# Do not edit this file - Generated by Perlito 7.0
use v5;
use utf8;
use strict;
use warnings;
no warnings ('redefine', 'once', 'void', 'uninitialized', 'misc', 'recursion');
use Perlito::Perl5::Runtime;
use Perlito::Perl5::Prelude;
our $MATCH = Perlito::Match->new();
{
package GLOBAL;
    sub new { shift; bless { @_ }, "GLOBAL" }

    # use v6 
;
    {
    package CompUnit;
        sub new { shift; bless { @_ }, "CompUnit" }
        sub attributes { $_[0]->{attributes} };
        sub methods { $_[0]->{methods} };
        sub emit_parrot {
            my $self = $_[0];
            ((my  $a) = (defined $self->{body} ? $self->{body} : ($self->{body} ||= bless([], 'ARRAY'))));
            (my  $item);
            ((my  $s) = ('.namespace [ ' . chr(34) . $self->{name} . chr(34) . ' ] ' . (chr(10)) . '.sub _ :main :anon' . (chr(10)) . '.end' . (chr(10)) . (chr(10)) . '.sub ' . chr(34) . '_class_vars_' . chr(34) . ' :anon' . (chr(10))));
            for my $item ( @{($a)} ) {
                if (((Main::isa($item, 'Decl')) && (($item->decl() ne 'has')))) {
                    ($s = ($s . $item->emit_parrot()))
                }
            };
            ($s = ($s . '.end' . (chr(10)) . (chr(10))));
            for my $item ( @{($a)} ) {
                if ((Main::isa($item, 'Sub') || Main::isa($item, 'Method'))) {
                    ($s = ($s . $item->emit_parrot()))
                }
            };
            for my $item ( @{($a)} ) {
                if (((Main::isa($item, 'Decl')) && (($item->decl() eq 'has')))) {
                    ((my  $name) = ($item->var())->name());
                    ($s = ($s . '.sub ' . chr(34) . $name . chr(34) . ' :method' . (chr(10)) . '  .param pmc val      :optional' . (chr(10)) . '  .param int has_val  :opt_flag' . (chr(10)) . '  unless has_val goto ifelse' . (chr(10)) . '  setattribute self, ' . chr(34) . $name . chr(34) . ', val' . (chr(10)) . '  goto ifend' . (chr(10)) . 'ifelse:' . (chr(10)) . '  val ' . chr(61) . ' getattribute self, ' . chr(34) . $name . chr(34) . (chr(10)) . 'ifend:' . (chr(10)) . '  .return(val)' . (chr(10)) . '.end' . (chr(10)) . (chr(10))))
                }
            };
            ($s = ($s . '.sub _ :anon :load :init :outer(' . chr(34) . '_class_vars_' . chr(34) . ')' . (chr(10)) . '  .local pmc self' . (chr(10)) . '  newclass self, ' . chr(34) . $self->{name} . chr(34) . (chr(10))));
            for my $item ( @{($a)} ) {
                if (((Main::isa($item, 'Decl')) && (($item->decl() eq 'has')))) {
                    ($s = ($s . $item->emit_parrot()))
                };
                if (((Main::isa($item, 'Decl') || Main::isa($item, 'Sub')) || Main::isa($item, 'Method'))) {

                }
                else {
                    ($s = ($s . $item->emit_parrot()))
                }
            };
            ($s = ($s . '.end' . (chr(10)) . (chr(10))));
            return scalar ($s)
        }
    }

;
    {
    package Val::Int;
        sub new { shift; bless { @_ }, "Val::Int" }
        sub emit_parrot {
            my $self = $_[0];
            ('  ' . chr(36) . 'P0 ' . chr(61) . ' new .Integer' . (chr(10)) . '  ' . chr(36) . 'P0 ' . chr(61) . ' ' . $self->{int} . (chr(10)))
        }
    }

;
    {
    package Val::Bit;
        sub new { shift; bless { @_ }, "Val::Bit" }
        sub emit_parrot {
            my $self = $_[0];
            ('  ' . chr(36) . 'P0 ' . chr(61) . ' new ' . chr(34) . 'Integer' . chr(34) . (chr(10)) . '  ' . chr(36) . 'P0 ' . chr(61) . ' ' . $self->{bit} . (chr(10)))
        }
    }

;
    {
    package Val::Num;
        sub new { shift; bless { @_ }, "Val::Num" }
        sub emit_parrot {
            my $self = $_[0];
            ('  ' . chr(36) . 'P0 ' . chr(61) . ' new ' . chr(34) . 'Float' . chr(34) . (chr(10)) . '  ' . chr(36) . 'P0 ' . chr(61) . ' ' . $self->{num} . (chr(10)))
        }
    }

;
    {
    package Val::Buf;
        sub new { shift; bless { @_ }, "Val::Buf" }
        sub emit_parrot {
            my $self = $_[0];
            ('  ' . chr(36) . 'P0 ' . chr(61) . ' new ' . chr(34) . 'String' . chr(34) . (chr(10)) . '  ' . chr(36) . 'P0 ' . chr(61) . ' ' . chr(34) . $self->{buf} . chr(34) . (chr(10)))
        }
    }

;
    {
    package Lit::Array;
        sub new { shift; bless { @_ }, "Lit::Array" }
        sub emit_parrot {
            my $self = $_[0];
            ((my  $a) = (defined $self->{array1} ? $self->{array1} : ($self->{array1} ||= bless([], 'ARRAY'))));
            (my  $item);
            ((my  $s) = ('  save ' . chr(36) . 'P1' . (chr(10)) . '  ' . chr(36) . 'P1 ' . chr(61) . ' new .ResizablePMCArray' . (chr(10))));
            for my $item ( @{($a)} ) {
                ($s = ($s . $item->emit_parrot()));
                ($s = ($s . '  push ' . chr(36) . 'P1, ' . chr(36) . 'P0' . (chr(10))))
            };
            ((my  $s) = ($s . '  ' . chr(36) . 'P0 ' . chr(61) . ' ' . chr(36) . 'P1' . (chr(10)) . '  restore ' . chr(36) . 'P1' . (chr(10))));
            return scalar ($s)
        }
    }

;
    {
    package Lit::Hash;
        sub new { shift; bless { @_ }, "Lit::Hash" }
        sub emit_parrot {
            my $self = $_[0];
            ((my  $a) = (defined $self->{hash1} ? $self->{hash1} : ($self->{hash1} ||= bless([], 'ARRAY'))));
            (my  $item);
            ((my  $s) = ('  save ' . chr(36) . 'P1' . (chr(10)) . '  save ' . chr(36) . 'P2' . (chr(10)) . '  ' . chr(36) . 'P1 ' . chr(61) . ' new .Hash' . (chr(10))));
            for my $item ( @{($a)} ) {
                ($s = ($s . ($item->[0])->emit_parrot()));
                ($s = ($s . '  ' . chr(36) . 'P2 ' . chr(61) . ' ' . chr(36) . 'P0' . (chr(10))));
                ($s = ($s . ($item->[1])->emit_parrot()));
                ($s = ($s . '  set ' . chr(36) . 'P1[' . chr(36) . 'P2], ' . chr(36) . 'P0' . (chr(10))))
            };
            ((my  $s) = ($s . '  ' . chr(36) . 'P0 ' . chr(61) . ' ' . chr(36) . 'P1' . (chr(10)) . '  restore ' . chr(36) . 'P2' . (chr(10)) . '  restore ' . chr(36) . 'P1' . (chr(10))));
            return scalar ($s)
        }
    }

;
    {
    package Index;
        sub new { shift; bless { @_ }, "Index" }
        sub emit_parrot {
            my $self = $_[0];
            ((my  $s) = ('  save ' . chr(36) . 'P1' . (chr(10))));
            ($s = ($s . $self->{obj}->emit_parrot()));
            ($s = ($s . '  ' . chr(36) . 'P1 ' . chr(61) . ' ' . chr(36) . 'P0' . (chr(10))));
            ($s = ($s . $self->{index_exp}->emit_parrot()));
            ($s = ($s . '  ' . chr(36) . 'P0 ' . chr(61) . ' ' . chr(36) . 'P1[' . chr(36) . 'P0]' . (chr(10))));
            ((my  $s) = ($s . '  restore ' . chr(36) . 'P1' . (chr(10))));
            return scalar ($s)
        }
    }

;
    {
    package Lookup;
        sub new { shift; bless { @_ }, "Lookup" }
        sub emit_parrot {
            my $self = $_[0];
            ((my  $s) = ('  save ' . chr(36) . 'P1' . (chr(10))));
            ($s = ($s . $self->{obj}->emit_parrot()));
            ($s = ($s . '  ' . chr(36) . 'P1 ' . chr(61) . ' ' . chr(36) . 'P0' . (chr(10))));
            ($s = ($s . $self->{index_exp}->emit_parrot()));
            ($s = ($s . '  ' . chr(36) . 'P0 ' . chr(61) . ' ' . chr(36) . 'P1[' . chr(36) . 'P0]' . (chr(10))));
            ((my  $s) = ($s . '  restore ' . chr(36) . 'P1' . (chr(10))));
            return scalar ($s)
        }
    }

;
    {
    package Var;
        sub new { shift; bless { @_ }, "Var" }
        sub emit_parrot {
            my $self = $_[0];
            ((($self->{twigil} eq '.')) ? (('  ' . chr(36) . 'P0 ' . chr(61) . ' getattribute self, ' . chr(39) . $self->{name} . chr(39) . (chr(10)))) : (('  ' . chr(36) . 'P0 ' . chr(61) . ' ' . $self->full_name() . ' ' . (chr(10)))))
        };
        sub full_name {
            my $self = $_[0];
            ((my  $table) = do {
    (my  $Hash_a = bless {}, 'HASH');
    ($Hash_a->{chr(36)} = 'scalar_');
    ($Hash_a->{chr(64)} = 'list_');
    ($Hash_a->{chr(37)} = 'hash_');
    ($Hash_a->{chr(38)} = 'code_');
    $Hash_a
});
            ((($self->{twigil} eq '.')) ? ($self->{name}) : (((($self->{name} eq chr(47))) ? (($table->{$self->{sigil}} . 'MATCH')) : (($table->{$self->{sigil}} . $self->{name})))))
        }
    }

;
    {
    package Bind;
        sub new { shift; bless { @_ }, "Bind" }
        sub parameters { $_[0]->{parameters} };
        sub arguments { $_[0]->{arguments} };
        sub emit_parrot {
            my $self = $_[0];
            if (Main::isa($self->{parameters}, 'Var')) {
                return scalar (($self->{arguments}->emit_parrot() . '  ' . $self->{parameters}->full_name() . ' ' . chr(61) . ' ' . chr(36) . 'P0' . (chr(10))))
            };
            if (Main::isa($self->{parameters}, 'Decl')) {
                return scalar (($self->{arguments}->emit_parrot() . '  .local pmc ' . (($self->{parameters})->var())->full_name() . (chr(10)) . '  ' . (($self->{parameters})->var())->full_name() . ' ' . chr(61) . ' ' . chr(36) . 'P0' . (chr(10)) . '  .lex ' . chr(39) . (($self->{parameters})->var())->full_name() . chr(39) . ', ' . chr(36) . 'P0' . (chr(10))))
            };
            if (Main::isa($self->{parameters}, 'Lookup')) {
                ((my  $param) = $self->{parameters});
                ((my  $obj) = $param->obj());
                ((my  $index) = $param->index_exp());
                return scalar (($self->{arguments}->emit_parrot() . '  save ' . chr(36) . 'P2' . (chr(10)) . '  ' . chr(36) . 'P2 ' . chr(61) . ' ' . chr(36) . 'P0' . (chr(10)) . '  save ' . chr(36) . 'P1' . (chr(10)) . $obj->emit_parrot() . '  ' . chr(36) . 'P1 ' . chr(61) . ' ' . chr(36) . 'P0' . (chr(10)) . $index->emit_parrot() . '  ' . chr(36) . 'P1[' . chr(36) . 'P0] ' . chr(61) . ' ' . chr(36) . 'P2' . (chr(10)) . '  restore ' . chr(36) . 'P1' . (chr(10)) . '  restore ' . chr(36) . 'P2' . (chr(10))))
            };
            if (Main::isa($self->{parameters}, 'Index')) {
                ((my  $param) = $self->{parameters});
                ((my  $obj) = $param->obj());
                ((my  $index) = $param->index_exp());
                return scalar (($self->{arguments}->emit_parrot() . '  save ' . chr(36) . 'P2' . (chr(10)) . '  ' . chr(36) . 'P2 ' . chr(61) . ' ' . chr(36) . 'P0' . (chr(10)) . '  save ' . chr(36) . 'P1' . (chr(10)) . $obj->emit_parrot() . '  ' . chr(36) . 'P1 ' . chr(61) . ' ' . chr(36) . 'P0' . (chr(10)) . $index->emit_parrot() . '  ' . chr(36) . 'P1[' . chr(36) . 'P0] ' . chr(61) . ' ' . chr(36) . 'P2' . (chr(10)) . '  restore ' . chr(36) . 'P1' . (chr(10)) . '  restore ' . chr(36) . 'P2' . (chr(10))))
            };
            die(('Not implemented binding: ' . $self->{parameters} . (chr(10)) . $self->{parameters}->emit_parrot()))
        }
    }

;
    {
    package Proto;
        sub new { shift; bless { @_ }, "Proto" }
        sub emit_parrot {
            my $self = $_[0];
            ('  ' . chr(36) . 'P0 ' . chr(61) . ' ' . $self->{name} . (chr(10)))
        }
    }

;
    {
    package Call;
        sub new { shift; bless { @_ }, "Call" }
        sub emit_parrot {
            my $self = $_[0];
            if (((((($self->{method} eq 'perl')) || (($self->{method} eq 'yaml'))) || (($self->{method} eq 'say'))) || (($self->{method} eq 'join')))) {
                if (($self->{hyper})) {
                    return scalar (('[ map ' . chr(123) . ' Main::' . $self->{method} . '( ' . chr(36) . '_, ' . ', ' . Main::join(([ map { $_->emit_parrot() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), '') . ')' . ' ' . chr(125) . ' ' . chr(64) . chr(123) . ' ' . $self->{invocant}->emit_parrot() . ' ' . chr(125) . ' ]'))
                }
                else {
                    return scalar (('Main::' . $self->{method} . '(' . $self->{invocant}->emit_parrot() . ', ' . Main::join(([ map { $_->emit_parrot() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), '') . ')'))
                }
            };
            ((my  $meth) = $self->{method});
            if (($meth eq 'postcircumfix:<( )>')) {
                ($meth = '')
            };
            ((my  $call) = ('->' . $meth . '(' . Main::join(([ map { $_->emit_parrot() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), '') . ')'));
            if (($self->{hyper})) {
                return scalar (('[ map ' . chr(123) . ' ' . chr(36) . '_' . $call . ' ' . chr(125) . ' ' . chr(64) . chr(123) . ' ' . $self->{invocant}->emit_parrot() . ' ' . chr(125) . ' ]'))
            };
            ((my  $List_args = bless [], 'ARRAY') = (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))));
            ((my  $str) = '');
            ((my  $ii) = 10);
            for my $arg ( @{$List_args} ) {
                ($str = ($str . '  save ' . chr(36) . 'P' . $ii . (chr(10))));
                ($ii = ($ii + 1))
            };
            ((my  $i) = 10);
            for my $arg ( @{$List_args} ) {
                ($str = ($str . $arg->emit_parrot() . '  ' . chr(36) . 'P' . $i . ' ' . chr(61) . ' ' . chr(36) . 'P0' . (chr(10))));
                ($i = ($i + 1))
            };
            ($str = ($str . $self->{invocant}->emit_parrot() . '  ' . chr(36) . 'P0 ' . chr(61) . ' ' . chr(36) . 'P0.' . $meth . '('));
            ($i = 0);
            (my  $List_p = bless [], 'ARRAY');
            for my $arg ( @{$List_args} ) {
                ($List_p->[$i] = (chr(36) . 'P' . (($i + 10))));
                ($i = ($i + 1))
            };
            ($str = ($str . Main::join($List_p, ', ') . ')' . (chr(10))));
            for my $arg ( @{$List_args} ) {
                ($ii = ($ii - 1));
                ($str = ($str . '  restore ' . chr(36) . 'P' . $ii . (chr(10))))
            };
            return scalar ($str)
        }
    }

;
    {
    package Apply;
        sub new { shift; bless { @_ }, "Apply" }
        ((my  $label) = 100);
        sub emit_parrot {
            my $self = $_[0];
            ((my  $code) = $self->{code});
            if (($code eq 'die')) {
                return scalar (('  ' . chr(36) . 'P0 ' . chr(61) . ' new .Exception' . (chr(10)) . '  ' . chr(36) . 'P0[' . chr(34) . '_message' . chr(34) . '] ' . chr(61) . ' ' . chr(34) . 'something broke' . chr(34) . (chr(10)) . '  throw ' . chr(36) . 'P0' . (chr(10))))
            };
            if (($code eq 'say')) {
                return scalar ((Main::join(([ map { $_->emit_parrot() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ('  print ' . chr(36) . 'P0' . (chr(10)))) . '  print ' . chr(36) . 'P0' . (chr(10)) . '  print ' . chr(34) . chr(92) . 'n' . chr(34) . (chr(10))))
            };
            if (($code eq 'print')) {
                return scalar ((Main::join(([ map { $_->emit_parrot() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ('  print ' . chr(36) . 'P0' . (chr(10)))) . '  print ' . chr(36) . 'P0' . (chr(10))))
            };
            if (($code eq 'array')) {
                return scalar (('  ' . chr(35) . ' TODO - array() is no-op' . (chr(10))))
            };
            if (($code eq 'prefix:<' . chr(126) . '>')) {
                return scalar ((((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0])->emit_parrot() . '  ' . chr(36) . 'S0 ' . chr(61) . ' ' . chr(36) . 'P0' . (chr(10)) . '  ' . chr(36) . 'P0 ' . chr(61) . ' ' . chr(36) . 'S0' . (chr(10))))
            };
            if (($code eq 'prefix:<' . chr(33) . '>')) {
                return scalar ((If->new(('cond' => (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0]), ('body' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, Val::Bit->new(('bit' => 0)) );
    $List_a
}), ('otherwise' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, Val::Bit->new(('bit' => 1)) );
    $List_a
})))->emit_parrot())
            };
            if (($code eq 'prefix:<' . chr(63) . '>')) {
                return scalar ((If->new(('cond' => (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0]), ('body' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, Val::Bit->new(('bit' => 1)) );
    $List_a
}), ('otherwise' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, Val::Bit->new(('bit' => 0)) );
    $List_a
})))->emit_parrot())
            };
            if (($code eq 'prefix:<' . chr(36) . '>')) {
                return scalar (('  ' . chr(35) . ' TODO - prefix:<' . chr(36) . '> is no-op' . (chr(10))))
            };
            if (($code eq 'prefix:<' . chr(64) . '>')) {
                return scalar (('  ' . chr(35) . ' TODO - prefix:<' . chr(64) . '> is no-op' . (chr(10))))
            };
            if (($code eq 'prefix:<' . chr(37) . '>')) {
                return scalar (('  ' . chr(35) . ' TODO - prefix:<' . chr(37) . '> is no-op' . (chr(10))))
            };
            if (($code eq 'infix:<' . chr(126) . '>')) {
                return scalar ((((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0])->emit_parrot() . '  ' . chr(36) . 'S0 ' . chr(61) . ' ' . chr(36) . 'P0' . (chr(10)) . '  save ' . chr(36) . 'S0' . (chr(10)) . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[1])->emit_parrot() . '  ' . chr(36) . 'S1 ' . chr(61) . ' ' . chr(36) . 'P0' . (chr(10)) . '  restore ' . chr(36) . 'S0' . (chr(10)) . '  ' . chr(36) . 'S0 ' . chr(61) . ' concat ' . chr(36) . 'S0, ' . chr(36) . 'S1' . (chr(10)) . '  ' . chr(36) . 'P0 ' . chr(61) . ' ' . chr(36) . 'S0' . (chr(10))))
            };
            if (($code eq 'infix:<+>')) {
                return scalar (('  save ' . chr(36) . 'P1' . (chr(10)) . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0])->emit_parrot() . '  ' . chr(36) . 'P1 ' . chr(61) . ' ' . chr(36) . 'P0' . (chr(10)) . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[1])->emit_parrot() . '  ' . chr(36) . 'P0 ' . chr(61) . ' ' . chr(36) . 'P1 + ' . chr(36) . 'P0' . (chr(10)) . '  restore ' . chr(36) . 'P1' . (chr(10))))
            };
            if (($code eq 'infix:<->')) {
                return scalar (('  save ' . chr(36) . 'P1' . (chr(10)) . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0])->emit_parrot() . '  ' . chr(36) . 'P1 ' . chr(61) . ' ' . chr(36) . 'P0' . (chr(10)) . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[1])->emit_parrot() . '  ' . chr(36) . 'P0 ' . chr(61) . ' ' . chr(36) . 'P1 - ' . chr(36) . 'P0' . (chr(10)) . '  restore ' . chr(36) . 'P1' . (chr(10))))
            };
            if (($code eq 'infix:<' . chr(38) . chr(38) . '>')) {
                return scalar ((If->new(('cond' => (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0]), ('body' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[1] );
    $List_a
}), ('otherwise' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
})))->emit_parrot())
            };
            if (($code eq 'infix:<' . chr(124) . chr(124) . '>')) {
                return scalar ((If->new(('cond' => (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0]), ('body' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
}), ('otherwise' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[1] );
    $List_a
})))->emit_parrot())
            };
            if (($code eq 'infix:<eq>')) {
                ($label = ($label + 1));
                ((my  $id) = $label);
                return scalar ((((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0])->emit_parrot() . '  ' . chr(36) . 'S0 ' . chr(61) . ' ' . chr(36) . 'P0' . (chr(10)) . '  save ' . chr(36) . 'S0' . (chr(10)) . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[1])->emit_parrot() . '  ' . chr(36) . 'S1 ' . chr(61) . ' ' . chr(36) . 'P0' . (chr(10)) . '  restore ' . chr(36) . 'S0' . (chr(10)) . '  if ' . chr(36) . 'S0 ' . chr(61) . chr(61) . ' ' . chr(36) . 'S1 goto eq' . $id . (chr(10)) . '  ' . chr(36) . 'P0 ' . chr(61) . ' 0' . (chr(10)) . '  goto eq_end' . $id . (chr(10)) . 'eq' . $id . ':' . (chr(10)) . '  ' . chr(36) . 'P0 ' . chr(61) . ' 1' . (chr(10)) . 'eq_end' . $id . ':' . (chr(10))))
            };
            if (($code eq 'infix:<ne>')) {
                ($label = ($label + 1));
                ((my  $id) = $label);
                return scalar ((((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0])->emit_parrot() . '  ' . chr(36) . 'S0 ' . chr(61) . ' ' . chr(36) . 'P0' . (chr(10)) . '  save ' . chr(36) . 'S0' . (chr(10)) . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[1])->emit_parrot() . '  ' . chr(36) . 'S1 ' . chr(61) . ' ' . chr(36) . 'P0' . (chr(10)) . '  restore ' . chr(36) . 'S0' . (chr(10)) . '  if ' . chr(36) . 'S0 ' . chr(61) . chr(61) . ' ' . chr(36) . 'S1 goto eq' . $id . (chr(10)) . '  ' . chr(36) . 'P0 ' . chr(61) . ' 1' . (chr(10)) . '  goto eq_end' . $id . (chr(10)) . 'eq' . $id . ':' . (chr(10)) . '  ' . chr(36) . 'P0 ' . chr(61) . ' 0' . (chr(10)) . 'eq_end' . $id . ':' . (chr(10))))
            };
            if (($code eq 'infix:<' . chr(61) . chr(61) . '>')) {
                ($label = ($label + 1));
                ((my  $id) = $label);
                return scalar (('  save ' . chr(36) . 'P1' . (chr(10)) . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0])->emit_parrot() . '  ' . chr(36) . 'P1 ' . chr(61) . ' ' . chr(36) . 'P0' . (chr(10)) . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[1])->emit_parrot() . '  if ' . chr(36) . 'P0 ' . chr(61) . chr(61) . ' ' . chr(36) . 'P1 goto eq' . $id . (chr(10)) . '  ' . chr(36) . 'P0 ' . chr(61) . ' 0' . (chr(10)) . '  goto eq_end' . $id . (chr(10)) . 'eq' . $id . ':' . (chr(10)) . '  ' . chr(36) . 'P0 ' . chr(61) . ' 1' . (chr(10)) . 'eq_end' . $id . ':' . (chr(10)) . '  restore ' . chr(36) . 'P1' . (chr(10))))
            };
            if (($code eq 'infix:<' . chr(33) . chr(61) . '>')) {
                ($label = ($label + 1));
                ((my  $id) = $label);
                return scalar (('  save ' . chr(36) . 'P1' . (chr(10)) . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0])->emit_parrot() . '  ' . chr(36) . 'P1 ' . chr(61) . ' ' . chr(36) . 'P0' . (chr(10)) . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[1])->emit_parrot() . '  if ' . chr(36) . 'P0 ' . chr(61) . chr(61) . ' ' . chr(36) . 'P1 goto eq' . $id . (chr(10)) . '  ' . chr(36) . 'P0 ' . chr(61) . ' 1' . (chr(10)) . '  goto eq_end' . $id . (chr(10)) . 'eq' . $id . ':' . (chr(10)) . '  ' . chr(36) . 'P0 ' . chr(61) . ' 0' . (chr(10)) . 'eq_end' . $id . ':' . (chr(10)) . '  restore ' . chr(36) . 'P1' . (chr(10))))
            };
            if (($code eq 'ternary:<' . chr(63) . chr(63) . ' ' . chr(33) . chr(33) . '>')) {
                return scalar ((If->new(('cond' => (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0]), ('body' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[1] );
    $List_a
}), ('otherwise' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[2] );
    $List_a
})))->emit_parrot())
            };
            if (($code eq 'defined')) {
                return scalar ((((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0])->emit_parrot() . '  ' . chr(36) . 'I0 ' . chr(61) . ' defined ' . chr(36) . 'P0' . (chr(10)) . '  ' . chr(36) . 'P0 ' . chr(61) . ' ' . chr(36) . 'I0' . (chr(10))))
            };
            if (($code eq 'substr')) {
                return scalar ((((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0])->emit_parrot() . '  ' . chr(36) . 'S0 ' . chr(61) . ' ' . chr(36) . 'P0' . (chr(10)) . '  save ' . chr(36) . 'S0' . (chr(10)) . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[1])->emit_parrot() . '  ' . chr(36) . 'I0 ' . chr(61) . ' ' . chr(36) . 'P0' . (chr(10)) . '  save ' . chr(36) . 'I0' . (chr(10)) . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[2])->emit_parrot() . '  ' . chr(36) . 'I1 ' . chr(61) . ' ' . chr(36) . 'P0' . (chr(10)) . '  restore ' . chr(36) . 'I0' . (chr(10)) . '  restore ' . chr(36) . 'S0' . (chr(10)) . '  ' . chr(36) . 'S0 ' . chr(61) . ' substr ' . chr(36) . 'S0, ' . chr(36) . 'I0, ' . chr(36) . 'I1' . (chr(10)) . '  ' . chr(36) . 'P0 ' . chr(61) . ' ' . chr(36) . 'S0' . (chr(10))))
            };
            ((my  $List_args = bless [], 'ARRAY') = (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))));
            ((my  $str) = '');
            ((my  $ii) = 10);
            (my  $arg);
            for my $arg ( @{$List_args} ) {
                ($str = ($str . '  save ' . chr(36) . 'P' . $ii . (chr(10))));
                ($ii = ($ii + 1))
            };
            ((my  $i) = 10);
            for my $arg ( @{$List_args} ) {
                ($str = ($str . $arg->emit_parrot() . '  ' . chr(36) . 'P' . $i . ' ' . chr(61) . ' ' . chr(36) . 'P0' . (chr(10))));
                ($i = ($i + 1))
            };
            ($str = ($str . '  ' . chr(36) . 'P0 ' . chr(61) . ' ' . $self->{code} . '('));
            ($i = 0);
            (my  $List_p = bless [], 'ARRAY');
            for my $arg ( @{$List_args} ) {
                ($List_p->[$i] = (chr(36) . 'P' . (($i + 10))));
                ($i = ($i + 1))
            };
            ($str = ($str . Main::join($List_p, ', ') . ')' . (chr(10))));
            for my $arg ( @{$List_args} ) {
                ($ii = ($ii - 1));
                ($str = ($str . '  restore ' . chr(36) . 'P' . $ii . (chr(10))))
            };
            return scalar ($str)
        }
    }

;
    {
    package Return;
        sub new { shift; bless { @_ }, "Return" }
        sub emit_parrot {
            my $self = $_[0];
            ($self->{result}->emit_parrot() . '  .return( ' . chr(36) . 'P0 )' . (chr(10)))
        }
    }

;
    {
    package If;
        sub new { shift; bless { @_ }, "If" }
        ((my  $label) = 100);
        sub emit_parrot {
            my $self = $_[0];
            ($label = ($label + 1));
            ((my  $id) = $label);
            return scalar (($self->{cond}->emit_parrot() . '  unless ' . chr(36) . 'P0 goto ifelse' . $id . (chr(10)) . Main::join(([ map { $_->emit_parrot() } @{( (defined $self->{body} ? $self->{body} : ($self->{body} ||= bless([], 'ARRAY'))) )} ]), '') . '  goto ifend' . $id . (chr(10)) . 'ifelse' . $id . ':' . (chr(10)) . Main::join(([ map { $_->emit_parrot() } @{( (defined $self->{otherwise} ? $self->{otherwise} : ($self->{otherwise} ||= bless([], 'ARRAY'))) )} ]), '') . 'ifend' . $id . ':' . (chr(10))))
        }
    }

;
    {
    package For;
        sub new { shift; bless { @_ }, "For" }
        ((my  $label) = 100);
        sub emit_parrot {
            my $self = $_[0];
            ((my  $cond) = $self->{cond});
            ($label = ($label + 1));
            ((my  $id) = $label);
            if ((Main::isa($cond, 'Var') && ($cond->sigil() ne chr(64)))) {
                ($cond = Lit::Array->new(('array1' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, $cond );
    $List_a
})))
            };
            return scalar (('' . $cond->emit_parrot() . '  save ' . chr(36) . 'P1' . (chr(10)) . '  save ' . chr(36) . 'P2' . (chr(10)) . '  ' . chr(36) . 'P1 ' . chr(61) . ' new .Iterator, ' . chr(36) . 'P0' . (chr(10)) . ' test_iter' . $id . ':' . (chr(10)) . '  unless ' . chr(36) . 'P1 goto iter_done' . $id . (chr(10)) . '  ' . chr(36) . 'P2 ' . chr(61) . ' shift ' . chr(36) . 'P1' . (chr(10)) . '  store_lex ' . chr(39) . $self->{topic}->full_name() . chr(39) . ', ' . chr(36) . 'P2' . (chr(10)) . Main::join(([ map { $_->emit_parrot() } @{( (defined $self->{body} ? $self->{body} : ($self->{body} ||= bless([], 'ARRAY'))) )} ]), '') . '  goto test_iter' . $id . (chr(10)) . ' iter_done' . $id . ':' . (chr(10)) . '  restore ' . chr(36) . 'P2' . (chr(10)) . '  restore ' . chr(36) . 'P1' . (chr(10)) . ''))
        }
    }

;
    {
    package Decl;
        sub new { shift; bless { @_ }, "Decl" }
        sub emit_parrot {
            my $self = $_[0];
            ((my  $decl) = $self->{decl});
            ((my  $name) = $self->{var}->name());
            ((($decl eq 'has')) ? (('  addattribute self, ' . chr(34) . $name . chr(34) . (chr(10)))) : (('  .local pmc ' . ($self->{var})->full_name() . ' ' . (chr(10)) . '  .lex ' . chr(39) . ($self->{var})->full_name() . chr(39) . ', ' . ($self->{var})->full_name() . ' ' . (chr(10)))))
        }
    }

;
    {
    package Sig;
        sub new { shift; bless { @_ }, "Sig" }
        sub emit_parrot {
            my $self = $_[0];
            ' print ' . chr(39) . 'Signature - TODO' . chr(39) . chr(59) . ' die ' . chr(39) . 'Signature - TODO' . chr(39) . chr(59) . ' '
        }
    }

;
    {
    package Method;
        sub new { shift; bless { @_ }, "Method" }
        sub emit_parrot {
            my $self = $_[0];
            ((my  $sig) = $self->{sig});
            ((my  $invocant) = $sig->invocant());
            ((my  $pos) = $sig->positional());
            ((my  $str) = '');
            ((my  $i) = 0);
            (my  $field);
            for my $field ( @{($pos)} ) {
                ($str = ($str . '  ' . chr(36) . 'P0 ' . chr(61) . ' params[' . $i . ']' . (chr(10)) . '  .lex ' . chr(39) . $field->full_name() . chr(39) . ', ' . chr(36) . 'P0' . (chr(10))));
                ($i = ($i + 1))
            };
            return scalar (('.sub ' . chr(34) . $self->{name} . chr(34) . ' :method :outer(' . chr(34) . '_class_vars_' . chr(34) . ')' . (chr(10)) . '  .param pmc params  :slurpy' . (chr(10)) . '  .lex ' . chr(39) . $invocant->full_name() . chr(39) . ', self' . (chr(10)) . $str . Main::join(([ map { $_->emit_parrot() } @{( (defined $self->{block} ? $self->{block} : ($self->{block} ||= bless([], 'ARRAY'))) )} ]), '') . '.end' . (chr(10)) . (chr(10))))
        }
    }

;
    {
    package Sub;
        sub new { shift; bless { @_ }, "Sub" }
        sub emit_parrot {
            my $self = $_[0];
            ((my  $sig) = $self->{sig});
            ((my  $invocant) = $sig->invocant());
            ((my  $pos) = $sig->positional());
            ((my  $str) = '');
            ((my  $i) = 0);
            (my  $field);
            for my $field ( @{($pos)} ) {
                ($str = ($str . '  ' . chr(36) . 'P0 ' . chr(61) . ' params[' . $i . ']' . (chr(10)) . '  .lex ' . chr(39) . $field->full_name() . chr(39) . ', ' . chr(36) . 'P0' . (chr(10))));
                ($i = ($i + 1))
            };
            return scalar (('.sub ' . chr(34) . $self->{name} . chr(34) . ' :outer(' . chr(34) . '_class_vars_' . chr(34) . ')' . (chr(10)) . '  .param pmc params  :slurpy' . (chr(10)) . $str . Main::join(([ map { $_->emit_parrot() } @{( (defined $self->{block} ? $self->{block} : ($self->{block} ||= bless([], 'ARRAY'))) )} ]), '') . '.end' . (chr(10)) . (chr(10))))
        }
    }

;
    {
    package Do;
        sub new { shift; bless { @_ }, "Do" }
        sub emit_parrot {
            my $self = $_[0];
            Main::join(([ map { $_->emit_parrot() } @{( (defined $self->{block} ? $self->{block} : ($self->{block} ||= bless([], 'ARRAY'))) )} ]), '')
        }
    }

;
    {
    package Use;
        sub new { shift; bless { @_ }, "Use" }
        sub emit_parrot {
            my $self = $_[0];
            ('  .include ' . chr(34) . $self->{mod} . chr(34) . (chr(10)))
        }
    }


}

1;
