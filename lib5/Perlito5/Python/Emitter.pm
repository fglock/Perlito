# Do not edit this file - Generated by Perlito5 7.0
use v5;
use utf8;
use strict;
use warnings;
no warnings ('redefine', 'once', 'void', 'uninitialized', 'misc', 'recursion');
use Perlito5::Perl5::Runtime;
use Perlito5::Perl5::Prelude;
our $MATCH = Perlito5::Match->new();
{
package GLOBAL;
    sub new { shift; bless { @_ }, "GLOBAL" }

    # use v6 
;
    use Perlito5::AST;
    {
    package Python;
        sub new { shift; bless { @_ }, "Python" }
        sub tab {
            my $level = $_[0];
            (('    ') x $level)
        };
        ((my  $Hash_safe_char = bless {}, 'HASH') = do {
    (my  $Hash_a = bless {}, 'HASH');
    ($Hash_a->{'_'} = 1);
    ($Hash_a->{','} = 1);
    ($Hash_a->{'.'} = 1);
    ($Hash_a->{':'} = 1);
    ($Hash_a->{'-'} = 1);
    ($Hash_a->{'+'} = 1);
    ($Hash_a->{'*'} = 1);
    ($Hash_a->{' '} = 1);
    ($Hash_a->{'('} = 1);
    ($Hash_a->{')'} = 1);
    ($Hash_a->{'<'} = 1);
    ($Hash_a->{'>'} = 1);
    ($Hash_a->{'['} = 1);
    ($Hash_a->{']'} = 1);
    $Hash_a
});
        sub escape_string {
            my $s = $_[0];
            (my  $List_out = bless [], 'ARRAY');
            ((my  $tmp) = '');
            if (($s eq '')) {
                return scalar (('u' . chr(39) . chr(39)))
            };
            for my $i ( @{(bless [0 .. (Main::chars($s, ) - 1)], 'ARRAY')} ) {
                ((my  $c) = substr($s, $i, 1));
                if (((((((($c ge 'a')) && (($c le 'z')))) || (((($c ge 'A')) && (($c le 'Z'))))) || (((($c ge '0')) && (($c le '9'))))) || exists($Hash_safe_char->{$c}))) {
                    ($tmp = ($tmp . $c))
                }
                else {
                    if (($tmp ne '')) {
                        push( @{$List_out}, ('u' . chr(39) . $tmp . chr(39)) )
                    };
                    push( @{$List_out}, ('unichr(' . do {
    ord($c)
} . ')') );
                    ($tmp = '')
                }
            };
            if (($tmp ne '')) {
                push( @{$List_out}, ('u' . chr(39) . $tmp . chr(39)) )
            };
            return scalar (Main::join($List_out, ' + '))
        }
    }

;
    {
    package Perlito5::Python::AnonSub;
        sub new { shift; bless { @_ }, "Perlito5::Python::AnonSub" }
        sub name { $_[0]->{name} };
        sub sig { $_[0]->{sig} };
        sub block { $_[0]->{block} };
        sub handles_return_exception { $_[0]->{handles_return_exception} };
        sub emit_python {
            my $self = $_[0];
            $self->emit_python_indented(0)
        };
        sub emit_python_indented {
            my $self = $_[0];
            my $level = $_[1];
            ((my  $sig) = $self->{sig});
            ((my  $pos) = $sig->positional());
            ((my  $args) = do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
});
            for my $field ( @{($pos)} ) {
                push( @{$args}, $field->emit_python_name() )
            };
            ((my  $block) = Perlito5::Python::LexicalBlock->new(('block' => (defined $self->{block} ? $self->{block} : ($self->{block} ||= bless([], 'ARRAY')))), ('needs_return' => 1)));
            (my  $List_s = bless [], 'ARRAY');
            push( @{$List_s}, (Python::tab($level) . ('def f_') . $self->{name} . ('(') . Main::join($args, (', ')) . ('):')) );
            if ($self->{handles_return_exception}) {
                push( @{$List_s}, (Python::tab(($level + 1)) . ('try:')) );
                push( @{$List_s}, $block->emit_python_indented(($level + 2)) );
                push( @{$List_s}, (Python::tab(($level + 1)) . ('except mp6_Return, r:')) );
                push( @{$List_s}, (Python::tab(($level + 2)) . ('return r.value')) )
            }
            else {
                push( @{$List_s}, $block->emit_python_indented(($level + 1)) )
            };
            return scalar (Main::join($List_s, (chr(10))))
        }
    }

;
    {
    package Perlito5::Python::LexicalBlock;
        sub new { shift; bless { @_ }, "Perlito5::Python::LexicalBlock" }
        sub block { $_[0]->{block} };
        sub needs_return { $_[0]->{needs_return} };
        sub top_level { $_[0]->{top_level} };
        (my  $ident);
        (my  $List_anon_block = bless [], 'ARRAY');
        sub push_stmt_python {
            my $block = $_[0];
            push( @{$List_anon_block}, $block )
        };
        sub get_ident_python {
            ($ident = ($ident + 1));
            return scalar ($ident)
        };
        sub has_my_decl {
            my $self = $_[0];
            for my $decl ( @{(defined $self->{block} ? $self->{block} : ($self->{block} ||= bless([], 'ARRAY')))} ) {
                if ((Main::isa($decl, 'Decl') && (($decl->decl() eq 'my')))) {
                    return scalar (1)
                };
                if ((((Main::isa($decl, 'Apply') && ($decl->code() eq 'infix:<' . chr(61) . '>')) && Main::isa($decl->arguments()->[0], 'Decl')) && ($decl->arguments()->[0]->decl() eq 'my'))) {
                    return scalar (1)
                }
            };
            return scalar (0)
        };
        sub emit_python {
            my $self = $_[0];
            $self->emit_python_indented(0)
        };
        sub emit_python_indented {
            my $self = $_[0];
            my $level = $_[1];
            (my  $List_block = bless [], 'ARRAY');
            for ( @{(defined $self->{block} ? $self->{block} : ($self->{block} ||= bless([], 'ARRAY')))} ) {
                if (defined($_)) {
                    push( @{$List_block}, $_ )
                }
            };
            if (!(($List_block))) {
                push( @{$List_block}, Apply->new(('code' => 'Mu')) )
            };
            (my  $List_s = bless [], 'ARRAY');
            (my  $List_tmp = bless [], 'ARRAY');
            for my $stmt ( @{$List_anon_block} ) {
                push( @{$List_tmp}, $stmt )
            };
            ((my  $has_decl) = do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
});
            ((my  $block) = do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
});
            for my $decl ( @{$List_block} ) {
                if ((Main::isa($decl, 'Decl') && (($decl->decl() eq 'has')))) {
                    push( @{$has_decl}, $decl )
                }
                else {
                    if ((((Main::isa($decl, 'Apply') && ($decl->code() eq 'infix:<' . chr(61) . '>')) && Main::isa($decl->arguments()->[0], 'Decl')) && ($decl->arguments()->[0]->decl() eq 'has'))) {
                        push( @{$has_decl}, $decl )
                    }
                    else {
                        push( @{(($block))}, $decl )
                    }
                }
            };
            if ((($has_decl))) {
                for my $decl ( @{(($has_decl))} ) {
                    if ((Main::isa($decl, 'Decl') && (($decl->decl() eq 'has')))) {
                        ((my  $label) = ('_anon_' . Perlito5::Python::LexicalBlock::get_ident_python()));
                        push( @{$List_s}, (Python::tab($level) . 'def f_' . $label . '(v_self):') );
                        push( @{$List_s}, (Python::tab(($level + 1)) . 'return v_self.v_' . ($decl->var())->name()) );
                        push( @{$List_s}, (Python::tab($level) . ('self.__dict__.update(' . chr(123) . chr(39) . 'f_') . $decl->var()->name() . (chr(39) . ':f_') . $label . (chr(125) . ')')) )
                    };
                    if ((((Main::isa($decl, 'Apply') && ($decl->code() eq 'infix:<' . chr(61) . '>')) && Main::isa($decl->arguments()->[0], 'Decl')) && ($decl->arguments()->[0]->decl() eq 'has'))) {
                        ((my  $label) = ('_anon_' . Perlito5::Python::LexicalBlock::get_ident_python()));
                        push( @{$List_s}, (Python::tab($level) . 'def f_' . $label . '(v_self):') );
                        push( @{$List_s}, (Python::tab(($level + 1)) . 'return v_self.v_' . $decl->arguments()->[0]->var()->name()) );
                        push( @{$List_s}, (Python::tab($level) . ('self.__dict__.update(' . chr(123) . chr(39) . 'f_') . $decl->arguments()->[0]->var()->name() . (chr(39) . ':f_') . $label . (chr(125) . ')')) )
                    }
                }
            };
            for my $decl ( @{(($block))} ) {
                if ((Main::isa($decl, 'Decl') && (($decl->decl() eq 'my')))) {
                    push( @{$List_s}, (Python::tab($level) . ($decl->var())->emit_python_name() . ' ' . chr(61) . ' ' . $decl->emit_python_init() . '') )
                }
                else {
                    if ((((Main::isa($decl, 'Apply') && ($decl->code() eq 'infix:<' . chr(61) . '>')) && Main::isa($decl->arguments()->[0], 'Decl')) && ($decl->arguments()->[0]->decl() eq 'my'))) {
                        push( @{$List_s}, (Python::tab($level) . $decl->arguments()->[0]->var()->emit_python_name() . ' ' . chr(61) . ' ' . $decl->arguments()->[0]->emit_python_init() . '') )
                    }
                }
            };
            (my  $last_statement);
            if ($self->{needs_return}) {
                ($last_statement = pop( @{(($block))} ))
            };
            for my $stmt ( @{(($block))} ) {
                ($List_anon_block = do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
});
                ((my  $s2) = $stmt->emit_python_indented($level));
                for my $stmt ( @{$List_anon_block} ) {
                    push( @{$List_s}, $stmt->emit_python_indented($level) )
                };
                push( @{$List_s}, $s2 )
            };
            if (($self->{needs_return} && $last_statement)) {
                ($List_anon_block = do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
});
                (my  $s2);
                if (Main::isa($last_statement, 'If')) {
                    ((my  $cond) = $last_statement->cond());
                    ((my  $has_otherwise) = ($last_statement->otherwise() ? 1 : 0));
                    ($s2 = (Python::tab($level) . 'if mp6_to_bool(' . $cond->emit_python() . ('):' . chr(10))));
                    ((my  $body_block) = Perlito5::Python::LexicalBlock->new(('block' => ($last_statement->body()->stmts())), ('needs_return' => 1)));
                    if ($body_block->has_my_decl()) {
                        ($body_block = Do->new(('block' => ($last_statement->body()))));
                        ($s2 = ($s2 . Python::tab(($level + 1)) . 'return ' . $body_block->emit_python()))
                    }
                    else {
                        ($s2 = ($s2 . $body_block->emit_python_indented(($level + 1))))
                    };
                    if (($has_otherwise)) {
                        ($s2 = ($s2 . (chr(10)) . Python::tab($level) . ('else:' . chr(10))));
                        ((my  $otherwise_block) = Perlito5::Python::LexicalBlock->new(('block' => ($last_statement->otherwise()->stmts())), ('needs_return' => 1)));
                        if ($otherwise_block->has_my_decl()) {
                            ($otherwise_block = Do->new(('block' => ($last_statement->otherwise()))));
                            ($s2 = ($s2 . Python::tab(($level + 1)) . 'return ' . $otherwise_block->emit_python()))
                        }
                        else {
                            ($s2 = ($s2 . $otherwise_block->emit_python_indented(($level + 1))))
                        }
                    }
                }
                else {
                    if ((Main::isa($last_statement, 'Apply') && ($last_statement->code() eq 'infix:<' . chr(61) . '>'))) {
                        ($s2 = $last_statement->emit_python_indented($level));
                        ($s2 = ($s2 . (chr(10)) . Python::tab($level) . ('return ') . $last_statement->arguments()->[0]->emit_python()))
                    }
                    else {
                        if (((Main::isa($last_statement, 'Apply') && ($last_statement->code() eq 'return')) || Main::isa($last_statement, 'For'))) {
                            ($s2 = $last_statement->emit_python_indented($level))
                        }
                        else {
                            ($s2 = (Python::tab($level) . ('return ') . $last_statement->emit_python()))
                        }
                    }
                };
                for my $stmt ( @{$List_anon_block} ) {
                    push( @{$List_s}, $stmt->emit_python_indented($level) )
                };
                push( @{$List_s}, $s2 )
            };
            ($List_anon_block = $List_tmp);
            return scalar (Main::join($List_s, (chr(10))))
        }
    }

;
    {
    package CompUnit;
        sub new { shift; bless { @_ }, "CompUnit" }
        sub attributes { $_[0]->{attributes} };
        sub methods { $_[0]->{methods} };
        sub emit_python {
            my $self = $_[0];
            $self->emit_python_indented(0)
        };
        sub emit_python_indented {
            my $self = $_[0];
            my $level = $_[1];
            (my  $List_s = bless [], 'ARRAY');
            ((my  $block) = Perlito5::Python::LexicalBlock->new(('block' => (defined $self->{body} ? $self->{body} : ($self->{body} ||= bless([], 'ARRAY'))))));
            ((my  $label) = ('_anon_' . Perlito5::Python::LexicalBlock::get_ident_python()));
            ((my  $name) = Main::to_go_namespace($self->{name}));
            for my $decl ( @{(defined $self->{body} ? $self->{body} : ($self->{body} ||= bless([], 'ARRAY')))} ) {
                if (Main::isa($decl, 'Use')) {
                    if (($decl->mod() ne 'v6')) {
                        push( @{$List_s}, (Python::tab($level) . 'import ' . Main::to_go_namespace($decl->mod())) )
                    }
                }
            };
            push( @{$List_s}, (Python::tab($level) . 'try:') );
            push( @{$List_s}, (Python::tab(($level + 1)) . 'type(' . $name . (')')) );
            push( @{$List_s}, (Python::tab($level) . 'except NameError:') );
            push( @{$List_s}, (Python::tab(($level + 1)) . 'class ' . $name . (':')) );
            push( @{$List_s}, (Python::tab(($level + 2)) . ('def __init__(self, **arg):')) );
            push( @{$List_s}, (Python::tab(($level + 3)) . ('for k in arg:')) );
            push( @{$List_s}, (Python::tab(($level + 4)) . ('self.__dict__[k] ' . chr(61) . ' mp6_Scalar()')) );
            push( @{$List_s}, (Python::tab(($level + 4)) . ('self.__dict__[k].f_set(arg[k])')) );
            push( @{$List_s}, (Python::tab(($level + 2)) . ('def f__setattr__(self, k, v):')) );
            push( @{$List_s}, (Python::tab(($level + 3)) . ('return self.__dict__[k].f_set(v)')) );
            push( @{$List_s}, (Python::tab(($level + 2)) . ('def f_isa(self, name):')) );
            push( @{$List_s}, (Python::tab(($level + 3)) . ('return name ' . chr(61) . chr(61) . ' u' . chr(39)) . $self->{name} . (chr(39))) );
            push( @{$List_s}, (Python::tab(($level + 2)) . ('def f_bool(self):')) );
            push( @{$List_s}, (Python::tab(($level + 3)) . ('return 1')) );
            push( @{$List_s}, (Python::tab(($level + 2)) . ('def __getattr__(self, attr):')) );
            push( @{$List_s}, (Python::tab(($level + 3)) . ('if attr[0:2] ' . chr(61) . chr(61) . ' u' . chr(39) . 'v_' . chr(39) . ':')) );
            push( @{$List_s}, (Python::tab(($level + 4)) . ('self.__dict__[attr] ' . chr(61) . ' mp6_Scalar()')) );
            push( @{$List_s}, (Python::tab(($level + 4)) . ('return self.__dict__[attr]')) );
            push( @{$List_s}, (Python::tab(($level + 3)) . ('raise AttributeError(attr)')) );
            push( @{$List_s}, (Python::tab(($level + 1)) . $name . ('_proto ' . chr(61) . ' ') . $name . ('()')) );
            push( @{$List_s}, (Python::tab(($level + 1)) . ('__builtin__.') . $name . (' ' . chr(61) . ' ') . $name . '') );
            push( @{$List_s}, (Python::tab(($level + 1)) . ('__builtin__.') . $name . ('_proto ' . chr(61) . ' ') . $name . ('_proto')) );
            if (($name eq 'GLOBAL')) {
                push( @{$List_s}, (Python::tab($level) . 'self ' . chr(61) . ' ' . $name) );
                push( @{$List_s}, $block->emit_python_indented($level) )
            }
            else {
                push( @{$List_s}, (Python::tab($level) . 'def ' . $label . ('():')) );
                push( @{$List_s}, (Python::tab(($level + 1)) . 'self ' . chr(61) . ' ' . $name) );
                push( @{$List_s}, $block->emit_python_indented(($level + 1)) );
                push( @{$List_s}, (Python::tab($level) . $label . ('()')) )
            };
            return scalar (Main::join($List_s, (chr(10))))
        }
    }

;
    {
    package Val::Int;
        sub new { shift; bless { @_ }, "Val::Int" }
        sub emit_python {
            my $self = $_[0];
            $self->{int}
        };
        sub emit_python_indented {
            my $self = $_[0];
            my $level = $_[1];
            (Python::tab($level) . $self->{int})
        }
    }

;
    {
    package Val::Bit;
        sub new { shift; bless { @_ }, "Val::Bit" }
        sub emit_python {
            my $self = $_[0];
            $self->{bit}
        };
        sub emit_python_indented {
            my $self = $_[0];
            my $level = $_[1];
            (Python::tab($level) . $self->{bit})
        }
    }

;
    {
    package Val::Num;
        sub new { shift; bless { @_ }, "Val::Num" }
        sub emit_python {
            my $self = $_[0];
            $self->{num}
        };
        sub emit_python_indented {
            my $self = $_[0];
            my $level = $_[1];
            (Python::tab($level) . $self->{num})
        }
    }

;
    {
    package Val::Buf;
        sub new { shift; bless { @_ }, "Val::Buf" }
        sub emit_python {
            my $self = $_[0];
            $self->emit_python_indented(0)
        };
        sub emit_python_indented {
            my $self = $_[0];
            my $level = $_[1];
            (Python::tab($level) . Python::escape_string($self->{buf}))
        }
    }

;
    {
    package Lit::Block;
        sub new { shift; bless { @_ }, "Lit::Block" }
        sub emit_python {
            my $self = $_[0];
            $self->emit_python_indented(0)
        };
        sub emit_python_indented {
            my $self = $_[0];
            my $level = $_[1];
            ((my  $label) = ('_anon_' . Perlito5::Python::LexicalBlock::get_ident_python()));
            ((my  $anon_var) = ($self->{sig} || Var->new(('name' => '_'), ('namespace' => ''), ('sigil' => chr(36)), ('twigil' => ''))));
            ((my  $anon_sig) = Sig->new(('invocant' => undef()), ('positional' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, $anon_var );
    $List_a
}), ('named' => do {
    (my  $Hash_a = bless {}, 'HASH');
    $Hash_a
})));
            Perlito5::Python::LexicalBlock::push_stmt_python(Perlito5::Python::AnonSub->new(('name' => $label), ('block' => (defined $self->{stmts} ? $self->{stmts} : ($self->{stmts} ||= bless([], 'ARRAY')))), ('sig' => $anon_sig), ('handles_return_exception' => 0)));
            return scalar ((Python::tab($level) . ('f_') . $label . ''))
        }
    }

;
    {
    package Lit::Array;
        sub new { shift; bless { @_ }, "Lit::Array" }
        sub emit_python {
            my $self = $_[0];
            $self->emit_python_indented(0)
        };
        sub emit_python_indented {
            my $self = $_[0];
            my $level = $_[1];
            ((my  $ast) = $self->expand_interpolation());
            return scalar ($ast->emit_python_indented($level))
        }
    }

;
    {
    package Lit::Hash;
        sub new { shift; bless { @_ }, "Lit::Hash" }
        sub emit_python {
            my $self = $_[0];
            $self->emit_python_indented(0)
        };
        sub emit_python_indented {
            my $self = $_[0];
            my $level = $_[1];
            ((my  $ast) = $self->expand_interpolation());
            return scalar ($ast->emit_python_indented($level))
        }
    }

;
    {
    package Index;
        sub new { shift; bless { @_ }, "Index" }
        sub emit_python {
            my $self = $_[0];
            $self->emit_python_indented(0)
        };
        sub emit_python_indented {
            my $self = $_[0];
            my $level = $_[1];
            (Python::tab($level) . $self->{obj}->emit_python() . '.f_index(' . $self->{index_exp}->emit_python() . ')')
        }
    }

;
    {
    package Lookup;
        sub new { shift; bless { @_ }, "Lookup" }
        sub emit_python {
            my $self = $_[0];
            $self->emit_python_indented(0)
        };
        sub emit_python_indented {
            my $self = $_[0];
            my $level = $_[1];
            (Python::tab($level) . $self->{obj}->emit_python() . '.f_lookup(' . $self->{index_exp}->emit_python() . ')')
        }
    }

;
    {
    package Var;
        sub new { shift; bless { @_ }, "Var" }
        ((my  $table) = do {
    (my  $Hash_a = bless {}, 'HASH');
    ($Hash_a->{chr(36)} = 'v_');
    ($Hash_a->{chr(64)} = 'List_');
    ($Hash_a->{chr(37)} = 'Hash_');
    ($Hash_a->{chr(38)} = 'Code_');
    $Hash_a
});
        sub emit_python {
            my $self = $_[0];
            $self->emit_python_indented(0)
        };
        sub emit_python_indented {
            my $self = $_[0];
            my $level = $_[1];
            return scalar ((Python::tab($level) . (((($self->{twigil} eq '.')) ? (('v_self.v_' . $self->{name} . '')) : (((($self->{name} eq chr(47))) ? (($table->{$self->{sigil}} . 'MATCH')) : (($table->{$self->{sigil}} . $self->{name} . ''))))))))
        };
        sub emit_python_name {
            my $self = $_[0];
            return scalar ((((($self->{twigil} eq '.')) ? (('v_self.v_' . $self->{name})) : (((($self->{name} eq chr(47))) ? (($table->{$self->{sigil}} . 'MATCH')) : (($table->{$self->{sigil}} . $self->{name})))))))
        }
    }

;
    {
    package Proto;
        sub new { shift; bless { @_ }, "Proto" }
        sub emit_python {
            my $self = $_[0];
            $self->emit_python_indented(0)
        };
        sub emit_python_indented {
            my $self = $_[0];
            my $level = $_[1];
            if (($self->{name} eq 'self')) {
                return scalar ((Python::tab($level) . 'v_self'))
            };
            (Python::tab($level) . Main::to_go_namespace($self->{name}) . '_proto')
        }
    }

;
    {
    package Call;
        sub new { shift; bless { @_ }, "Call" }
        ((my  $Hash_method_python = bless {}, 'HASH') = do {
    (my  $Hash_a = bless {}, 'HASH');
    ($Hash_a->{'id'} = 'id');
    ($Hash_a->{'yaml'} = 'yaml');
    ($Hash_a->{'join'} = 'join');
    ($Hash_a->{'split'} = 'split');
    ($Hash_a->{'isa'} = 'isa');
    ($Hash_a->{'say'} = 'say');
    $Hash_a
});
        sub emit_python {
            my $self = $_[0];
            $self->emit_python_indented(0)
        };
        sub emit_python_indented {
            my $self = $_[0];
            my $level = $_[1];
            ((my  $invocant) = $self->{invocant}->emit_python());
            if (($self->{method} eq 'new')) {
                (my  $List_str = bless [], 'ARRAY');
                for my $field ( @{(defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))} ) {
                    if ((Main::isa($field, 'Apply') && ($field->code() eq 'infix:<' . chr(61) . '>>'))) {
                        push( @{$List_str}, ('v_' . $field->arguments()->[0]->buf() . chr(61) . $field->arguments()->[1]->emit_python()) )
                    }
                    else {
                        die('Error in constructor, field: ', Main::perl($field, ))
                    }
                };
                return scalar ((Python::tab($level) . '__builtin__.' . Main::to_go_namespace($self->{invocant}->name()) . '(' . Main::join($List_str, ', ') . ')'))
            };
            if (exists($Hash_method_python->{$self->{method}})) {
                if (($self->{hyper})) {
                    return scalar ((Python::tab($level) . 'f_map(' . $invocant . ', lambda x: Main.' . $self->{method} . '(x, ' . Main::join(([ map { $_->emit_python() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ', ') . '))'))
                }
                else {
                    return scalar ((Python::tab($level) . ('f_') . $self->{method} . '(' . $invocant . ', ' . Main::join(([ map { $_->emit_python() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ', ') . ')'))
                }
            };
            ((my  $meth) = $self->{method});
            if (($meth eq 'postcircumfix:<( )>')) {
                return scalar ((Python::tab($level) . $invocant . '(' . Main::join(([ map { $_->emit_python() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ', ') . ')'))
            };
            if (((($meth eq 'values')) || (($meth eq 'keys')))) {
                return scalar ((Python::tab($level) . $invocant . '.' . $meth . '(' . Main::join(([ map { $_->emit_python() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ', ') . ')'))
            };
            if (($meth eq 'chars')) {
                return scalar ((Python::tab($level) . ('len(') . $invocant . (')')))
            };
            ((my  $call) = ('f_' . $meth . '(' . Main::join(([ map { $_->emit_python() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ', ') . ')'));
            if (($self->{hyper})) {
                return scalar ((Python::tab($level) . 'f_map(' . $invocant . ', lambda x: x.' . $call . ')'))
            }
            else {
                return scalar ((Python::tab($level) . $invocant . '.' . $call))
            }
        }
    }

;
    {
    package Apply;
        sub new { shift; bless { @_ }, "Apply" }
        sub emit_python_indented {
            my $self = $_[0];
            my $level = $_[1];
            (Python::tab($level) . $self->emit_python())
        };
        sub emit_python {
            my $self = $_[0];
            ((my  $apply) = $self->op_assign());
            if ($apply) {
                return scalar ($apply->emit_python())
            };
            ((my  $code) = $self->{code});
            if (Main::isa(((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0]), 'Apply')) {
                ((my  $args2) = (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0]->arguments());
                if ((Main::isa(($args2->[0]), 'Apply') && ((($args2->[0]->code() eq 'infix:<or>') || ($args2->[0]->code() eq 'infix:<' . chr(124) . chr(124) . '>'))))) {
                    ($args2->[0] = Do->new(('block' => $args2->[0])))
                }
            };
            if (Main::isa(((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0]), 'Apply')) {
                ((my  $args2) = (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0]->arguments());
                if ((Main::isa(($args2->[1]), 'Apply') && ($args2->[1]->code() ne 'infix:<' . chr(61) . '>>'))) {
                    ($args2->[1] = Do->new(('block' => $args2->[1])))
                }
            };
            if (Main::isa(((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[1]), 'Apply')) {
                ((my  $args2) = (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[1]->arguments());
                if ((Main::isa(($args2->[1]), 'Apply') && ($args2->[1]->code() ne 'infix:<' . chr(61) . '>>'))) {
                    ($args2->[1] = Do->new(('block' => $args2->[1])))
                }
            };
            if (Main::isa($code, 'Str')) {

            }
            else {
                return scalar (('(' . $self->{code}->emit_python() . ').(' . Main::join(([ map { $_->emit_python() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ', ') . ')'))
            };
            if (($code eq 'self')) {
                return scalar ('v_self')
            };
            if (($code eq 'Mu')) {
                return scalar ('mp6_Mu()')
            };
            if (($code eq 'make')) {
                return scalar (('v_MATCH.f__setattr__(' . chr(39) . 'v_capture' . chr(39) . ', ' . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0])->emit_python() . ')'))
            };
            if (($code eq 'False')) {
                return scalar ('False')
            };
            if (($code eq 'True')) {
                return scalar ('True')
            };
            if (($code eq 'array')) {
                return scalar (('[' . Main::join(([ map { $_->emit_python() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ' ') . ']'))
            };
            if (($code eq 'Int')) {
                return scalar (('mp6_to_num(' . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0])->emit_python() . ')'))
            };
            if (($code eq 'Num')) {
                return scalar (('mp6_to_num(' . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0])->emit_python() . ')'))
            };
            if (($code eq 'prefix:<' . chr(126) . '>')) {
                return scalar (('unicode(' . Main::join(([ map { $_->emit_python() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ' ') . ')'))
            };
            if (($code eq 'prefix:<' . chr(33) . '>')) {
                return scalar (('not mp6_to_bool(' . Main::join(([ map { $_->emit_python() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ' ') . ')'))
            };
            if (($code eq 'prefix:<' . chr(63) . '>')) {
                return scalar (('not (not mp6_to_bool(' . Main::join(([ map { $_->emit_python() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ' ') . '))'))
            };
            if (($code eq 'prefix:<' . chr(36) . '>')) {
                return scalar (('mp6_to_scalar(' . Main::join(([ map { $_->emit_python() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ' ') . ')'))
            };
            if (($code eq 'prefix:<' . chr(64) . '>')) {
                return scalar (('(' . Main::join(([ map { $_->emit_python() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ' ') . ')'))
            };
            if (($code eq 'prefix:<' . chr(37) . '>')) {
                return scalar ((chr(37) . chr(123) . Main::join(([ map { $_->emit_python() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ' ') . chr(125)))
            };
            if (($code eq 'infix:<x>')) {
                return scalar (('(unicode(' . (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0]->emit_python() . ')' . ' * mp6_to_num(' . (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[1]->emit_python() . '))'))
            };
            if (($code eq 'list:<' . chr(126) . '>')) {
                return scalar (('(unicode(' . Main::join(([ map { $_->emit_python() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ') + unicode(') . '))'))
            };
            if (($code eq 'infix:<+>')) {
                return scalar (('(mp6_to_num(' . Main::join(([ map { $_->emit_python() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ') + mp6_to_num(') . '))'))
            };
            if (($code eq 'infix:<->')) {
                return scalar (('(' . Main::join(([ map { $_->emit_python() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ' - ') . ')'))
            };
            if (($code eq 'infix:<*>')) {
                return scalar (('(' . Main::join(([ map { $_->emit_python() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ' * ') . ')'))
            };
            if (($code eq 'infix:<' . chr(47) . '>')) {
                return scalar (('(' . Main::join(([ map { $_->emit_python() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ' ' . chr(47) . ' ') . ')'))
            };
            if ((($code eq 'infix:<' . chr(38) . chr(38) . '>') || ($code eq 'infix:<and>'))) {
                return scalar (('mp6_and(' . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0])->emit_python() . ', lambda: ' . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[1])->emit_python() . ')'))
            };
            if ((($code eq 'infix:<' . chr(124) . chr(124) . '>') || ($code eq 'infix:<or>'))) {
                return scalar (('mp6_or(' . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0])->emit_python() . ', lambda: ' . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[1])->emit_python() . ')'))
            };
            if (($code eq 'infix:<' . chr(47) . chr(47) . '>')) {
                return scalar (('mp6_defined_or(' . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0])->emit_python() . ', lambda: ' . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[1])->emit_python() . ')'))
            };
            if (($code eq 'infix:<eq>')) {
                return scalar (('(unicode(' . Main::join(([ map { $_->emit_python() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ') ' . chr(61) . chr(61) . ' unicode(') . '))'))
            };
            if (($code eq 'infix:<ne>')) {
                return scalar (('(unicode(' . Main::join(([ map { $_->emit_python() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ') ' . chr(33) . chr(61) . ' unicode(') . '))'))
            };
            if (($code eq 'infix:<ge>')) {
                return scalar (('(unicode(' . Main::join(([ map { $_->emit_python() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ') >' . chr(61) . ' unicode(') . '))'))
            };
            if (($code eq 'infix:<le>')) {
                return scalar (('(unicode(' . Main::join(([ map { $_->emit_python() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ') <' . chr(61) . ' unicode(') . '))'))
            };
            if (($code eq 'infix:<' . chr(61) . chr(61) . '>')) {
                return scalar (('(mp6_to_num(' . Main::join(([ map { $_->emit_python() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ') ' . chr(61) . chr(61) . ' mp6_to_num(') . '))'))
            };
            if (($code eq 'infix:<' . chr(33) . chr(61) . '>')) {
                return scalar (('(mp6_to_num(' . Main::join(([ map { $_->emit_python() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ') ' . chr(33) . chr(61) . ' mp6_to_num(') . '))'))
            };
            if (($code eq 'infix:<<>')) {
                return scalar (('(mp6_to_num(' . Main::join(([ map { $_->emit_python() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ') < mp6_to_num(') . '))'))
            };
            if (($code eq 'infix:<>>')) {
                return scalar (('(mp6_to_num(' . Main::join(([ map { $_->emit_python() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ') > mp6_to_num(') . '))'))
            };
            if (($code eq 'infix:<<' . chr(61) . '>')) {
                return scalar (('(mp6_to_num(' . Main::join(([ map { $_->emit_python() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ') <' . chr(61) . ' mp6_to_num(') . '))'))
            };
            if (($code eq 'infix:<>' . chr(61) . '>')) {
                return scalar (('(mp6_to_num(' . Main::join(([ map { $_->emit_python() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ') >' . chr(61) . ' mp6_to_num(') . '))'))
            };
            if (($code eq 'infix:<..>')) {
                return scalar (('mp6_Array(range(' . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0])->emit_python() . ', 1 + ' . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[1])->emit_python() . '))'))
            };
            if (($code eq 'infix:<' . chr(61) . chr(61) . chr(61) . '>')) {
                return scalar (('(f_id(' . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0])->emit_python() . ') ' . chr(61) . chr(61) . ' f_id(' . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[1])->emit_python() . '))'))
            };
            if (($code eq 'exists')) {
                ((my  $arg) = (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0]);
                if (Main::isa($arg, 'Lookup')) {
                    return scalar (('(' . ($arg->obj())->emit_python() . ').has_key(' . ($arg->index_exp())->emit_python() . ')'))
                }
            };
            if (($code eq 'ternary:<' . chr(63) . chr(63) . ' ' . chr(33) . chr(33) . '>')) {
                ((my  $ast) = Do->new(('block' => If->new(('cond' => ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0])), ('body' => Lit::Block->new(('stmts' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[1] );
    $List_a
}))), ('otherwise' => Lit::Block->new(('stmts' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[2] );
    $List_a
})))))));
                return scalar ($ast->emit_python())
            };
            if (($code eq 'circumfix:<( )>')) {
                return scalar (('(' . Main::join(([ map { $_->emit_python() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ', ') . ')'))
            };
            if (($code eq 'infix:<' . chr(61) . '>')) {
                return scalar (emit_python_bind((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0], (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[1]))
            };
            if (($code eq 'return')) {
                return scalar (('raise mp6_Return(' . Main::join(([ map { $_->emit_python() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ', ') . ')'))
            };
            if (($code eq 'substr')) {
                return scalar ((((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0])->emit_python() . '[' . 'mp6_to_num(' . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[1])->emit_python() . ')' . ':' . ((defined((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[2]) ? ('mp6_to_num(' . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[1])->emit_python() . ') ' . '+ mp6_to_num(' . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[2])->emit_python() . ')') : '')) . ']'))
            };
            if (($code eq 'index')) {
                return scalar (('mp6_index(' . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0])->emit_python() . ', ' . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[1])->emit_python() . ')'))
            };
            if (($code eq 'defined')) {
                return scalar (('not f_isa(' . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0])->emit_python() . (',' . chr(39) . 'Mu' . chr(39) . ')')))
            };
            if (($code eq 'shift')) {
                return scalar ((((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0])->emit_python() . '.f_shift()'))
            };
            if (($code eq 'pop')) {
                return scalar ((((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0])->emit_python() . '.f_pop()'))
            };
            if (($code eq 'push')) {
                return scalar ((((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0])->emit_python() . '.f_push(' . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[1])->emit_python() . ')'))
            };
            if (($code eq 'unshift')) {
                return scalar ((((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[0])->emit_python() . '.f_unshift(' . ((defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY')))->[1])->emit_python() . ')'))
            };
            if ($self->{namespace}) {
                return scalar ((Main::to_go_namespace($self->{namespace}) . '_proto.f_' . $self->{code} . '(' . Main::join(([ map { $_->emit_python() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ', ') . ')'))
            };
            ('f_' . $self->{code} . '(' . Main::join(([ map { $_->emit_python() } @{( (defined $self->{arguments} ? $self->{arguments} : ($self->{arguments} ||= bless([], 'ARRAY'))) )} ]), ', ') . ')')
        };
        sub emit_python_indented {
            my $self = $_[0];
            my $level = $_[1];
            (Python::tab($level) . $self->emit_python())
        };
        sub emit_python_bind {
            my $parameters = $_[0];
            my $arguments = $_[1];
            if (Main::isa($parameters, 'Call')) {
                return scalar ((($parameters->invocant())->emit_python() . ('.f__setattr__(' . chr(39) . 'v_') . $parameters->method() . (chr(39) . ', ') . $arguments->emit_python() . (')')))
            };
            if (((Main::isa($parameters, 'Var') && ($parameters->sigil() eq chr(64))) || (Main::isa($parameters, 'Decl') && ($parameters->var()->sigil() eq chr(64))))) {
                ($arguments = Lit::Array->new(('array1' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, $arguments );
    $List_a
})))
            }
            else {
                if (((Main::isa($parameters, 'Var') && ($parameters->sigil() eq chr(37))) || (Main::isa($parameters, 'Decl') && ($parameters->var()->sigil() eq chr(37))))) {
                    ($arguments = Lit::Hash->new(('hash1' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, $arguments );
    $List_a
})))
                }
            };
            return scalar (($parameters->emit_python() . '.f_set(' . $arguments->emit_python() . ')'))
        }
    }

;
    {
    package If;
        sub new { shift; bless { @_ }, "If" }
        sub emit_python {
            my $self = $_[0];
            $self->emit_python_indented(0)
        };
        sub emit_python_indented {
            my $self = $_[0];
            my $level = $_[1];
            ((my  $has_body) = ((defined $self->{body} ? $self->{body} : ($self->{body} ||= bless([], 'ARRAY'))) ? 1 : 0));
            ((my  $has_otherwise) = ((defined $self->{otherwise} ? $self->{otherwise} : ($self->{otherwise} ||= bless([], 'ARRAY'))) ? 1 : 0));
            ((my  $body_block) = Perlito5::Python::LexicalBlock->new(('block' => (defined $self->{body} ? $self->{body} : ($self->{body} ||= bless([], 'ARRAY')))->stmts())));
            if ($body_block->has_my_decl()) {
                ($body_block = Do->new(('block' => (defined $self->{body} ? $self->{body} : ($self->{body} ||= bless([], 'ARRAY'))))))
            };
            ((my  $s) = (Python::tab($level) . 'if mp6_to_bool(' . $self->{cond}->emit_python() . ('):' . chr(10)) . $body_block->emit_python_indented(($level + 1))));
            if (($has_otherwise)) {
                ((my  $otherwise_block) = Perlito5::Python::LexicalBlock->new(('block' => (defined $self->{otherwise} ? $self->{otherwise} : ($self->{otherwise} ||= bless([], 'ARRAY')))->stmts())));
                if ($otherwise_block->has_my_decl()) {
                    ($otherwise_block = Do->new(('block' => (defined $self->{otherwise} ? $self->{otherwise} : ($self->{otherwise} ||= bless([], 'ARRAY'))))))
                };
                ($s = ($s . (chr(10)) . Python::tab($level) . ('else:' . chr(10)) . $otherwise_block->emit_python_indented(($level + 1))))
            };
            return scalar ($s)
        }
    }

;
    {
    package While;
        sub new { shift; bless { @_ }, "While" }
        sub emit_python {
            my $self = $_[0];
            $self->emit_python_indented(0)
        };
        sub emit_python_indented {
            my $self = $_[0];
            my $level = $_[1];
            ((my  $body_block) = Perlito5::Python::LexicalBlock->new(('block' => (defined $self->{body} ? $self->{body} : ($self->{body} ||= bless([], 'ARRAY')))->stmts())));
            if ($body_block->has_my_decl()) {
                ($body_block = Do->new(('block' => (defined $self->{body} ? $self->{body} : ($self->{body} ||= bless([], 'ARRAY'))))))
            };
            if (($self->{init} && $self->{continue})) {
                die(('not implemented (While)'))
            };
            (Python::tab($level) . 'while mp6_to_bool(' . $self->{cond}->emit_python() . ('):' . chr(10)) . $body_block->emit_python_indented(($level + 1)))
        }
    }

;
    {
    package For;
        sub new { shift; bless { @_ }, "For" }
        sub emit_python {
            my $self = $_[0];
            $self->emit_python_indented(0)
        };
        sub emit_python_indented {
            my $self = $_[0];
            my $level = $_[1];
            ((my  $body_block) = Perlito5::Python::LexicalBlock->new(('block' => (defined $self->{body} ? $self->{body} : ($self->{body} ||= bless([], 'ARRAY')))->stmts())));
            ((my  $sig) = 'v__');
            if ($self->{body}->sig()) {
                ($sig = $self->{body}->sig()->emit_python_name())
            };
            if ($body_block->has_my_decl()) {
                ((my  $label) = ('_anon_' . Perlito5::Python::LexicalBlock::get_ident_python()));
                ((my  $anon_var) = ($self->{body}->sig() || Var->new(('name' => '_'), ('namespace' => ''), ('sigil' => chr(36)), ('twigil' => ''))));
                ((my  $anon_sig) = Sig->new(('invocant' => undef()), ('positional' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, $anon_var );
    $List_a
}), ('named' => do {
    (my  $Hash_a = bless {}, 'HASH');
    $Hash_a
})));
                Perlito5::Python::LexicalBlock::push_stmt_python(Perlito5::Python::AnonSub->new(('name' => $label), ('block' => (defined $self->{body} ? $self->{body} : ($self->{body} ||= bless([], 'ARRAY')))->stmts()), ('sig' => $anon_sig), ('handles_return_exception' => 0)));
                return scalar ((Python::tab($level) . 'for ' . $sig . (' in ') . $self->{cond}->emit_python() . (':' . chr(10)) . Python::tab(($level + 1)) . ('f_') . $label . ('(') . $sig . (')')))
            };
            (Python::tab($level) . 'for ' . $sig . (' in ') . $self->{cond}->emit_python() . (':' . chr(10)) . $body_block->emit_python_indented(($level + 1)))
        }
    }

;
    {
    package Decl;
        sub new { shift; bless { @_ }, "Decl" }
        sub emit_python {
            my $self = $_[0];
            $self->emit_python_indented(0)
        };
        sub emit_python_indented {
            my $self = $_[0];
            my $level = $_[1];
            ((my  $decl) = $self->{decl});
            ((my  $name) = $self->{var}->name());
            (Python::tab($level) . (((($decl eq 'has')) ? ('') : $self->{var}->emit_python())))
        };
        sub emit_python_init {
            my $self = $_[0];
            if ((($self->{var})->sigil() eq chr(37))) {
                return scalar ('mp6_Hash(' . chr(123) . chr(125) . ')')
            }
            else {
                if ((($self->{var})->sigil() eq chr(64))) {
                    return scalar ('mp6_Array([])')
                }
                else {
                    return scalar ('mp6_Scalar()')
                }
            };
            return scalar ('')
        }
    }

;
    {
    package Method;
        sub new { shift; bless { @_ }, "Method" }
        sub emit_python {
            my $self = $_[0];
            $self->emit_python_indented(0)
        };
        sub emit_python_indented {
            my $self = $_[0];
            my $level = $_[1];
            ((my  $sig) = $self->{sig});
            ((my  $invocant) = $sig->invocant());
            ((my  $pos) = $sig->positional());
            ((my  $args) = do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
});
            ((my  $default_args) = do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
});
            ((my  $meth_args) = do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
});
            push( @{$meth_args}, $invocant->emit_python_name() );
            for my $field ( @{($pos)} ) {
                ((my  $arg) = $field->emit_python_name());
                push( @{$args}, $arg );
                push( @{$default_args}, ($arg . chr(61) . 'mp6_Scalar()') );
                push( @{$meth_args}, ($arg . chr(61) . 'mp6_Scalar()') )
            };
            ((my  $label) = ('_anon_' . Perlito5::Python::LexicalBlock::get_ident_python()));
            ((my  $block) = Perlito5::Python::LexicalBlock->new(('block' => (defined $self->{block} ? $self->{block} : ($self->{block} ||= bless([], 'ARRAY')))), ('needs_return' => 1)));
            (my  $List_s = bless [], 'ARRAY');
            push( @{$List_s}, (Python::tab($level) . 'def f_' . $label . ('(') . Main::join($meth_args, (', ')) . ('):')) );
            push( @{$List_s}, (Python::tab(($level + 1)) . ('try:')) );
            push( @{$List_s}, $block->emit_python_indented(($level + 2)) );
            push( @{$List_s}, (Python::tab(($level + 1)) . ('except mp6_Return, r:')) );
            push( @{$List_s}, (Python::tab(($level + 2)) . ('return r.value')) );
            push( @{$List_s}, (Python::tab($level) . ('self.__dict__.update(' . chr(123) . chr(39) . 'f_') . $self->{name} . (chr(39) . ':f_') . $label . (chr(125) . ')')) );
            return scalar (Main::join($List_s, (chr(10))))
        }
    }

;
    {
    package Sub;
        sub new { shift; bless { @_ }, "Sub" }
        sub emit_python {
            my $self = $_[0];
            $self->emit_python_indented(0)
        };
        sub emit_python_indented {
            my $self = $_[0];
            my $level = $_[1];
            ((my  $label) = ('_anon_' . Perlito5::Python::LexicalBlock::get_ident_python()));
            if ((($self->{name} eq ''))) {
                Perlito5::Python::LexicalBlock::push_stmt_python(Perlito5::Python::AnonSub->new(('name' => $label), ('block' => (defined $self->{block} ? $self->{block} : ($self->{block} ||= bless([], 'ARRAY')))), ('sig' => $self->{sig}), ('handles_return_exception' => 1)));
                return scalar ((Python::tab($level) . 'f_' . $label))
            };
            ((my  $sig) = $self->{sig});
            ((my  $pos) = $sig->positional());
            ((my  $args) = do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
});
            ((my  $default_args) = do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
});
            ((my  $meth_args) = do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    push( @{$List_a}, 'self' );
    $List_a
});
            for my $field ( @{($pos)} ) {
                ((my  $arg) = $field->emit_python_name());
                push( @{$args}, $arg );
                push( @{$default_args}, ($arg . chr(61) . 'mp6_Scalar()') );
                push( @{$meth_args}, ($arg . chr(61) . 'mp6_Scalar()') )
            };
            ((my  $block) = Perlito5::Python::LexicalBlock->new(('block' => (defined $self->{block} ? $self->{block} : ($self->{block} ||= bless([], 'ARRAY')))), ('needs_return' => 1)));
            ((my  $label2) = ('_anon_' . Perlito5::Python::LexicalBlock::get_ident_python()));
            (my  $List_s = bless [], 'ARRAY');
            push( @{$List_s}, (Python::tab($level) . ('def f_') . $self->{name} . ('(') . Main::join($default_args, (', ')) . ('):')) );
            push( @{$List_s}, (Python::tab(($level + 1)) . ('try:')) );
            push( @{$List_s}, $block->emit_python_indented(($level + 2)) );
            push( @{$List_s}, (Python::tab(($level + 1)) . ('except mp6_Return, r:')) );
            push( @{$List_s}, (Python::tab(($level + 2)) . ('return r.value')) );
            push( @{$List_s}, (Python::tab($level) . ('global ') . $label2) );
            push( @{$List_s}, (Python::tab($level) . $label2 . (' ' . chr(61) . ' f_') . $self->{name}) );
            push( @{$List_s}, (Python::tab($level) . ('def f_') . $label . ('(') . Main::join($meth_args, (', ')) . ('):')) );
            push( @{$List_s}, (Python::tab(($level + 1)) . ('return ') . $label2 . ('(') . Main::join($args, (', ')) . (')')) );
            push( @{$List_s}, (Python::tab($level) . ('self.__dict__.update(' . chr(123) . chr(39) . 'f_') . $self->{name} . (chr(39) . ':f_') . $label . (chr(125) . ')')) );
            return scalar (Main::join($List_s, (chr(10))))
        }
    }

;
    {
    package Do;
        sub new { shift; bless { @_ }, "Do" }
        sub emit_python {
            my $self = $_[0];
            $self->emit_python_indented(0)
        };
        sub emit_python_indented {
            my $self = $_[0];
            my $level = $_[1];
            ((my  $label) = ('_anon_' . Perlito5::Python::LexicalBlock::get_ident_python()));
            ((my  $block) = $self->simplify()->block());
            Perlito5::Python::LexicalBlock::push_stmt_python(Perlito5::Python::AnonSub->new(('name' => $label), ('block' => $block), ('sig' => Sig->new(('invocant' => undef()), ('positional' => do {
    (my  $List_a = bless [], 'ARRAY');
    (my  $List_v = bless [], 'ARRAY');
    $List_a
}), ('named' => do {
    (my  $Hash_a = bless {}, 'HASH');
    $Hash_a
}))), ('handles_return_exception' => 0)));
            return scalar ((Python::tab($level) . ('f_') . $label . ('()')))
        }
    }

;
    {
    package Use;
        sub new { shift; bless { @_ }, "Use" }
        sub emit_python {
            my $self = $_[0];
            $self->emit_python_indented(0)
        };
        sub emit_python_indented {
            my $self = $_[0];
            my $level = $_[1];
            return scalar ('')
        }
    }


}

1;
