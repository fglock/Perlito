# Do not edit this file - Generated by Perlito5 9.0

package Perlito5::IO;

sub slurp {
    my $source_filename = shift;
    open FILE, $source_filename
      or die "Cannot read $source_filename\n";
    local $/ = undef;
    $source = <FILE>;
    close FILE;
    return $source;
}

use v5.10;
package main;
undef();
package Perlito5;
package main;
undef();
package Perlito5::Match;
sub Perlito5::Match::flat {
    my $self = $_[0];
    (defined($self->{'capture'}) ? $self->{'capture'} : substr($self->{'str'}, $self->{'from'}, (($self->{'to'} - $self->{'from'}))))
};
1;

;

# use Perlito5::Match
;
package main;
undef();
package Perlito5::Rul;
sub Perlito5::Rul::new {
    my $class = shift();
    bless({@_}, $class)
};
sub Perlito5::Rul::constant {
    my $str = shift();
    my $len = length($str);
    if (($str eq chr(92))) {
        $str = chr(92) . chr(92)
    };
    if (($str eq chr(39))) {
        $str = chr(92) . chr(39)
    };
    if ($len) {
        ('( ' . chr(39) . $str . chr(39) . ' eq substr( $str, $MATCH->{to}, ' . $len . ') ' . '&& ( $MATCH->{to} = ' . $len . ' + $MATCH->{to} )' . ')')
    }
    else {
        return '1'
    }
};
package Perlito5::Rul::Quantifier;
sub Perlito5::Rul::Quantifier::new {
    my $class = shift();
    bless({@_}, $class)
};
sub Perlito5::Rul::Quantifier::term {
    $_[0]->{'term'}
};
sub Perlito5::Rul::Quantifier::quant {
    $_[0]->{'quant'}
};
sub Perlito5::Rul::Quantifier::emit_perl5 {
    my $self = $_[0];
    if (($self->{'quant'} eq '')) {
        return $self->{'term'}->emit_perl5()
    };
    if (($self->{'quant'} eq '+')) {
        $self->{'term'}->set_captures_to_array();
        return ('(do { ' . 'my $last_match_null = 0; ' . 'my $m = $MATCH; ' . 'my $to = $MATCH->{to}; ' . 'my $count = 0; ' . 'while (' . $self->{'term'}->emit_perl5() . ' && ($last_match_null < 2)) ' . '{ ' . 'if ($to == $MATCH->{to}) { ' . '$last_match_null = $last_match_null + 1; ' . '} ' . 'else { ' . '$last_match_null = 0; ' . '}; ' . '$m = $MATCH; ' . '$to = $MATCH->{to}; ' . '$count = $count + 1; ' . '}; ' . '$MATCH = $m; ' . '$MATCH->{to} = $to; ' . '$count > 0; ' . '})')
    };
    if (($self->{'quant'} eq '*')) {
        $self->{'term'}->set_captures_to_array();
        return ('(do { ' . 'my $last_match_null = 0; ' . 'my $m = $MATCH; ' . 'my $to = $MATCH->{to}; ' . 'while (' . $self->{'term'}->emit_perl5() . ' && ($last_match_null < 2)) ' . '{ ' . 'if ($to == $MATCH->{to}) { ' . '$last_match_null = $last_match_null + 1; ' . '} ' . 'else { ' . '$last_match_null = 0; ' . '}; ' . '$m = $MATCH; ' . '$to = $MATCH->{to}; ' . '}; ' . '$MATCH = $m; ' . '$MATCH->{to} = $to; ' . '1 ' . '})')
    };
    if (($self->{'quant'} eq '?')) {
        $self->{'term'}->set_captures_to_array();
        return ('(do { ' . 'my $m = $MATCH; ' . 'if (!' . $self->{'term'}->emit_perl5() . ') ' . '{ ' . '$MATCH = $m; ' . '}; ' . '1 ' . '})')
    };
    die('Perlito5::Rul::Quantifier:  not implemented')
};
sub Perlito5::Rul::Quantifier::set_captures_to_array {
    my $self = $_[0];
    $self->{'term'}->set_captures_to_array()
};
package Perlito5::Rul::Or;
sub Perlito5::Rul::Or::new {
    my $class = shift();
    bless({@_}, $class)
};
sub Perlito5::Rul::Or::or_list {
    $_[0]->{'or_list'}
};
sub Perlito5::Rul::Or::emit_perl5 {
    my $self = $_[0];
    if ((scalar(@{$self->{'or_list'}}) == 1)) {
        return $self->{'or_list'}->[0]->emit_perl5()
    };
    ('(do { ' . 'my $pos1 = $MATCH->{to}; (do { ' . join('}) || (do { $MATCH->{to} = $pos1; ', map($_->emit_perl5(), @{$self->{'or_list'}})) . '}) })')
};
sub Perlito5::Rul::Or::set_captures_to_array {
    my $self = $_[0];
    map($_->set_captures_to_array(), @{$self->{'or_list'}})
};
package Perlito5::Rul::Concat;
sub Perlito5::Rul::Concat::new {
    my $class = shift();
    bless({@_}, $class)
};
sub Perlito5::Rul::Concat::concat {
    $_[0]->{'concat'}
};
sub Perlito5::Rul::Concat::emit_perl5 {
    my $self = $_[0];
    if ((scalar(@{$self->{'concat'}}) == 1)) {
        return $self->{'concat'}->[0]->emit_perl5()
    };
    ('(' . join(' && ', map($_->emit_perl5(), @{$self->{'concat'}})) . ')')
};
sub Perlito5::Rul::Concat::set_captures_to_array {
    my $self = $_[0];
    map($_->set_captures_to_array(), @{$self->{'concat'}})
};
package Perlito5::Rul::Subrule;
sub Perlito5::Rul::Subrule::new {
    my $class = shift();
    bless({@_}, $class)
};
sub Perlito5::Rul::Subrule::metasyntax {
    $_[0]->{'metasyntax'}
};
sub Perlito5::Rul::Subrule::captures {
    $_[0]->{'captures'}
};
sub Perlito5::Rul::Subrule::emit_perl5 {
    my $self = $_[0];
    my $s = $self->{'metasyntax'};
    ($s =~ s!\.!->!g);
    my $meth = (((1 + index($self->{'metasyntax'}, '.'))) ? $s : (('$grammar->' . $self->{'metasyntax'})));
    my $code;
    if (($self->{'captures'} == 1)) {
        $code = ('if ($m2) { $MATCH->{to} = $m2->{to}; $MATCH->{' . chr(39) . $self->{'metasyntax'} . chr(39) . '} = $m2; 1 } else { 0 }; ')
    }
    else {
        if (($self->{'captures'} > 1)) {
            $code = ('if ($m2) { ' . '$MATCH->{to} = $m2->{to}; ' . 'if (exists $MATCH->{' . chr(39) . $self->{'metasyntax'} . chr(39) . '}) { ' . 'push @{ $MATCH->{' . chr(39) . $self->{'metasyntax'} . chr(39) . '} }, $m2; ' . '} ' . 'else { ' . '$MATCH->{' . chr(39) . $self->{'metasyntax'} . chr(39) . '} = [ $m2 ]; ' . '}; ' . '1 ' . '} else { 0 }; ')
        }
        else {
            $code = 'if ($m2) { $MATCH->{to} = $m2->{to}; 1 } else { 0 }; '
        }
    };
    ('(do { ' . 'my $m2 = ' . $meth . '($str, $MATCH->{to}); ' . $code . '})')
};
sub Perlito5::Rul::Subrule::set_captures_to_array {
    my $self = $_[0];
    if (($self->{'captures'} > 0)) {
        $self->{'captures'} = ($self->{'captures'} + 1)
    }
};
package Perlito5::Rul::Constant;
sub Perlito5::Rul::Constant::new {
    my $class = shift();
    bless({@_}, $class)
};
sub Perlito5::Rul::Constant::constant {
    $_[0]->{'constant'}
};
sub Perlito5::Rul::Constant::emit_perl5 {
    my $self = $_[0];
    my $str = $self->{'constant'};
    Perlito5::Rul::constant($str)
};
sub Perlito5::Rul::Constant::set_captures_to_array {
    my $self = $_[0]
};
package Perlito5::Rul::Dot;
sub Perlito5::Rul::Dot::new {
    my $class = shift();
    bless({@_}, $class)
};
sub Perlito5::Rul::Dot::emit_perl5 {
    my $self = $_[0];
    ('( ' . chr(39) . chr(39) . ' ne substr( $str, $MATCH->{to}, 1 ) ' . '&& ($MATCH->{to} = 1 + $MATCH->{to})' . ')')
};
sub Perlito5::Rul::Dot::set_captures_to_array {
    my $self = $_[0]
};
package Perlito5::Rul::SpecialChar;
sub Perlito5::Rul::SpecialChar::new {
    my $class = shift();
    bless({@_}, $class)
};
sub Perlito5::Rul::SpecialChar::char {
    $_[0]->{'char'}
};
sub Perlito5::Rul::SpecialChar::emit_perl5 {
    my $self = $_[0];
    my $char = $self->{'char'};
    if (($char eq 'n')) {
        return Perlito5::Rul::Subrule->new('metasyntax', 'is_newline', 'captures', 0)->emit_perl5()
    };
    if (($char eq 'N')) {
        return Perlito5::Rul::Subrule->new('metasyntax', 'not_newline', 'captures', 0)->emit_perl5()
    };
    if (($char eq 'd')) {
        return Perlito5::Rul::Subrule->new('metasyntax', 'digit', 'captures', 0)->emit_perl5()
    };
    if (($char eq 's')) {
        return Perlito5::Rul::Subrule->new('metasyntax', 'space', 'captures', 0)->emit_perl5()
    };
    if (($char eq 't')) {
        return Perlito5::Rul::constant(chr(9))
    };
    return Perlito5::Rul::constant($char)
};
sub Perlito5::Rul::SpecialChar::set_captures_to_array {
    my $self = $_[0]
};
package Perlito5::Rul::Block;
sub Perlito5::Rul::Block::new {
    my $class = shift();
    bless({@_}, $class)
};
sub Perlito5::Rul::Block::closure {
    $_[0]->{'closure'}
};
sub Perlito5::Rul::Block::emit_perl5 {
    my $self = $_[0];
    ('(do { ' . '$MATCH->{str} = $str; ' . $self->{'closure'} . '; 1 })')
};
sub Perlito5::Rul::Block::set_captures_to_array {
    my $self = $_[0]
};
package Perlito5::Rul::Before;
sub Perlito5::Rul::Before::new {
    my $class = shift();
    bless({@_}, $class)
};
sub Perlito5::Rul::Before::rule_exp {
    $_[0]->{'rule_exp'}
};
sub Perlito5::Rul::Before::emit_perl5 {
    my $self = $_[0];
    ('(do { ' . 'my $tmp = $MATCH; ' . '$MATCH = { ' . chr(39) . 'str' . chr(39) . ' => $str, ' . chr(39) . 'from' . chr(39) . ' => $tmp->{to}, ' . chr(39) . 'to' . chr(39) . ' => $tmp->{to} }; ' . 'my $res = ' . $self->{'rule_exp'}->emit_perl5() . '; ' . '$MATCH = $res ? $tmp : 0; ' . '})')
};
sub Perlito5::Rul::Before::set_captures_to_array {
    my $self = $_[0]
};
package Perlito5::Rul::NotBefore;
sub Perlito5::Rul::NotBefore::new {
    my $class = shift();
    bless({@_}, $class)
};
sub Perlito5::Rul::NotBefore::rule_exp {
    $_[0]->{'rule_exp'}
};
sub Perlito5::Rul::NotBefore::emit_perl5 {
    my $self = $_[0];
    ('(do { ' . 'my $tmp = $MATCH; ' . '$MATCH = { ' . chr(39) . 'str' . chr(39) . ' => $str, ' . chr(39) . 'from' . chr(39) . ' => $tmp->{to}, ' . chr(39) . 'to' . chr(39) . ' => $tmp->{to} }; ' . 'my $res = ' . $self->{'rule_exp'}->emit_perl5() . '; ' . '$MATCH = $res ? 0 : $tmp; ' . '})')
};
sub Perlito5::Rul::NotBefore::set_captures_to_array {
    my $self = $_[0]
};
1;

;

# use Perlito5::Emitter::Token
;
package main;
package Perlito5::Grammar::Precedence;

# use feature
;
sub Perlito5::Grammar::Precedence::new {
    my $class = shift();
    bless({@_}, $class)
};
my $Operator = {};
my $Precedence = {};
my $PrefixPrecedence = {};
my $Assoc = {};
sub Perlito5::Grammar::Precedence::is_assoc_type {
    my $assoc_type = shift();
    my $op_name = shift();
    return $Assoc->{$assoc_type}->{$op_name}
};
sub Perlito5::Grammar::Precedence::is_fixity_type {
    my $fixity_type = shift();
    my $op_name = shift();
    return $Operator->{$fixity_type}->{$op_name}
};
sub Perlito5::Grammar::Precedence::is_term {
    my $token = shift();
    (((($token->[0] eq 'term')) || (($token->[0] eq 'postfix_or_term'))) || (($token->[0] eq 'postfix')))
};
sub Perlito5::Grammar::Precedence::is_num {
    (($_[0] ge '0') && ($_[0] le '9'))
};
sub Perlito5::Grammar::Precedence::is_ident_middle {
    my $c = shift();
    ((((($c ge 'a') && ($c le 'z'))) || ((($c ge '0') && ($c le '9')))) || (($c eq '_')))
};
my @Parsed_op_chars = (2, 1);
my %Parsed_op = ('?', sub {
            Perlito5::Grammar::Expression->term_ternary($_[0], $_[1])
        }, '(', sub {
            Perlito5::Grammar::Expression->term_paren($_[0], $_[1])
        }, '[', sub {
            Perlito5::Grammar::Expression->term_square($_[0], $_[1])
        }, '{', sub {
            Perlito5::Grammar::Expression->term_curly($_[0], $_[1])
        }, '->', sub {
            Perlito5::Grammar::Expression->term_arrow($_[0], $_[1])
        });
my @Term_chars;
my %Term;
sub Perlito5::Grammar::Precedence::add_term {
    my $name = shift();
    my $param = shift();
    $Term{$name} = $param;
    unshift(@Term_chars, (scalar(@Term_chars) + 1)) while (@Term_chars < length($name))
};
my $End_token;
my $End_token_chars;
my %Op;
my @Op_chars = (3, 2, 1);
sub Perlito5::Grammar::Precedence::op_parse {
    my $self = shift();
    my $str = shift();
    my $pos = shift();
    my $last_is_term = shift();
    for my  $len (@{$End_token_chars}) {
        my $term = substr($str, $pos, $len);
        if (exists($End_token->{$term})) {
            my $c1 = substr($str, (($pos + $len) - 1), 1);
            my $c2 = substr($str, ($pos + $len), 1);
            if ((!(((is_ident_middle($c1) && is_ident_middle($c2)))) && !(((($c1 eq '<') && ($c2 eq '<')))))) {
                return {'str', $str, 'from', $pos, 'to', $pos, 'capture', ['end', $term]}
            }
        }
    };
    if (!($last_is_term)) {
        for my  $len (@Term_chars) {
            my $term = substr($str, $pos, $len);
            if (exists($Term{$term})) {
                my $c1 = substr($str, (($pos + $len) - 1), 1);
                my $c2 = substr($str, ($pos + $len), 1);
                if (((is_num($c1) || !(is_ident_middle($c1))) || !(is_ident_middle($c2)))) {
                    my $m = $Term{$term}->($str, $pos);
                    return $m if $m
                }
            }
        }
    };
    for my  $len (@Parsed_op_chars) {
        my $op = substr($str, $pos, $len);
        if (exists($Parsed_op{$op})) {
            my $m = $Parsed_op{$op}->($str, $pos);
            return $m if $m
        }
    };
    for my  $len (@Op_chars) {
        my $op = substr($str, $pos, $len);
        if (exists($Op{$op})) {
            my $c1 = substr($str, (($pos + $len) - 1), 1);
            my $c2 = substr($str, ($pos + $len), 1);
            if ((!(((is_ident_middle($c1) && is_ident_middle($c2)))) && !(((($c1 eq '&') && ($c2 eq '&')))))) {
                if (((exists($Operator->{'infix'}->{$op}) && !(exists($Operator->{'prefix'}->{$op}))) && !($last_is_term))) {

                }
                else {
                    return {'str', $str, 'from', $pos, 'to', ($pos + $len), 'capture', ['op', $op]}
                }
            }
        }
    };
    return Perlito5::Grammar::Bareword->term_bareword($str, $pos)
};
sub Perlito5::Grammar::Precedence::add_op {
    my $fixity = shift();
    my $name = shift();
    my $precedence = shift();
    my $param = shift();
    if (!((defined($param)))) {
        $param = {}
    };
    my $assoc = ($param->{'assoc'} || 'left');
    $Operator->{$fixity}->{$name} = 1;
    $Precedence->{$name} = $precedence;
    $PrefixPrecedence->{$name} = $precedence if ($fixity eq 'prefix');
    $Assoc->{$assoc}->{$name} = 1;
    $Op{$name} = 1
};
my $prec = 100;
add_op('postfix', '.( )', $prec);
add_op('postfix', '.[ ]', $prec);
add_op('postfix', '.{ }', $prec);
add_op('postfix', '( )', $prec);
add_op('postfix', '[ ]', $prec);
add_op('postfix', 'funcall', $prec);
add_op('postfix', 'funcall_no_params', $prec);
add_op('postfix', 'methcall', $prec);
add_op('postfix', 'methcall_no_params', $prec);
add_op('postfix', 'block', $prec);
add_op('postfix', 'hash', $prec);
$prec = ($prec - 1);
add_op('prefix', '++', $prec);
add_op('prefix', '--', $prec);
add_op('postfix', '++', $prec);
add_op('postfix', '--', $prec);
$prec = ($prec - 1);
add_op('infix', '**', $prec, {'assoc', 'right'});
$prec = ($prec - 1);
add_op('prefix', chr(92), $prec);
add_op('prefix', '+', $prec);
add_op('prefix', '-', $prec);
add_op('prefix', '~', $prec);
add_op('prefix', '!', $prec);
$prec = ($prec - 1);
add_op('infix', '=~', $prec);
add_op('infix', '!~', $prec);
$prec = ($prec - 1);
add_op('infix', '*', $prec);
add_op('infix', '/', $prec);
add_op('infix', '%', $prec);
add_op('infix', 'x', $prec);
$prec = ($prec - 1);
add_op('infix', '+', $prec);
add_op('infix', '-', $prec);
add_op('infix', '.', $prec, {'assoc', 'list'});
$prec = ($prec - 1);
add_op('infix', '<<', $prec);
add_op('infix', '>>', $prec);
$prec = ($prec - 1);
add_op('prefix', $_, $prec) for ('-r', '-w', '-x', '-o', '-R', '-W', '-X', '-O', '-e', '-z', '-s', '-f', '-d', '-l', '-p', '-S', '-b', '-c', '-t', '-u', '-g', '-k', '-T', '-B', '-M', '-A', '-C');
$prec = ($prec - 1);
add_op('infix', 'lt', $prec, {'assoc', 'chain'});
add_op('infix', 'le', $prec, {'assoc', 'chain'});
add_op('infix', 'gt', $prec, {'assoc', 'chain'});
add_op('infix', 'ge', $prec, {'assoc', 'chain'});
add_op('infix', '<=', $prec, {'assoc', 'chain'});
add_op('infix', '>=', $prec, {'assoc', 'chain'});
add_op('infix', '<', $prec, {'assoc', 'chain'});
add_op('infix', '>', $prec, {'assoc', 'chain'});
$prec = ($prec - 1);
add_op('infix', '<=>', $prec);
add_op('infix', 'cmp', $prec);
add_op('infix', '==', $prec, {'assoc', 'chain'});
add_op('infix', '!=', $prec, {'assoc', 'chain'});
add_op('infix', 'ne', $prec, {'assoc', 'chain'});
add_op('infix', 'eq', $prec, {'assoc', 'chain'});
$prec = ($prec - 1);
add_op('infix', '&', $prec);
$prec = ($prec - 1);
add_op('infix', '|', $prec);
add_op('infix', '^', $prec);
$prec = ($prec - 1);
add_op('infix', '..', $prec);
add_op('infix', '...', $prec);
add_op('infix', '~~', $prec, {'assoc', 'chain'});
$prec = ($prec - 1);
add_op('infix', '&&', $prec);
$prec = ($prec - 1);
add_op('infix', '||', $prec);
add_op('infix', '//', $prec);
$prec = ($prec - 1);
add_op('ternary', '? :', $prec, {'assoc', 'right'});
$prec = ($prec - 1);
add_op('infix', '=', $prec, {'assoc', 'right'});
add_op('infix', '**=', $prec, {'assoc', 'right'});
add_op('infix', '+=', $prec, {'assoc', 'right'});
add_op('infix', '-=', $prec, {'assoc', 'right'});
add_op('infix', '*=', $prec, {'assoc', 'right'});
add_op('infix', '/=', $prec, {'assoc', 'right'});
add_op('infix', 'x=', $prec, {'assoc', 'right'});
add_op('infix', '|=', $prec, {'assoc', 'right'});
add_op('infix', '&=', $prec, {'assoc', 'right'});
add_op('infix', '.=', $prec, {'assoc', 'right'});
add_op('infix', '<<=', $prec, {'assoc', 'right'});
add_op('infix', '>>=', $prec, {'assoc', 'right'});
add_op('infix', '%=', $prec, {'assoc', 'right'});
add_op('infix', '||=', $prec, {'assoc', 'right'});
add_op('infix', '&&=', $prec, {'assoc', 'right'});
add_op('infix', '^=', $prec, {'assoc', 'right'});
add_op('infix', '//=', $prec, {'assoc', 'right'});
$prec = ($prec - 1);
add_op('infix', '=>', $prec);
$prec = ($prec - 1);
add_op('list', ',', $prec, {'assoc', 'list'});
$prec = ($prec - 1);
add_op('prefix', 'not', $prec);
$prec = ($prec - 1);
add_op('infix', 'and', $prec);
$prec = ($prec - 1);
add_op('infix', 'or', $prec);
add_op('infix', 'xor', $prec);
$prec = ($prec - 1);
add_op('infix', '*start*', $prec);
sub Perlito5::Grammar::Precedence::get_token_precedence {
    my $token = $_[0];
    if (($token->[0] eq 'prefix')) {
        return $PrefixPrecedence->{$token->[1]}
    };
    return $Precedence->{$token->[1]}
};
sub Perlito5::Grammar::Precedence::precedence_parse {
    my $self = shift();
    my $get_token = $self->{'get_token'};
    my $reduce = $self->{'reduce'};
    my $last_end_token = $End_token;
    my $last_end_token_chars = $End_token_chars;
    $End_token = $self->{'end_token'};
    $End_token_chars = $self->{'end_token_chars'};
    my $op_stack = [];
    my $num_stack = [];
    my $last = ['op', '*start*'];
    my $last_is_term = 0;
    my $token = $get_token->($last_is_term);
    if (($token->[0] eq 'space')) {
        $token = $get_token->($last_is_term)
    };
    for ( ; ((defined($token)) && (($token->[0] ne 'end'))); {

        } ) {
        my $token_is_term = is_term($token);
        if (((($token->[1] eq ',')) && (((($last->[1] eq '*start*')) || (($last->[1] eq ',')))))) {
            push(@{$num_stack}, ['term', undef()])
        };
        if (($Operator->{'prefix'}->{$token->[1]} && (((($last->[1] eq '*start*')) || !($last_is_term))))) {
            $token->[0] = 'prefix';
            unshift(@{$op_stack}, $token)
        }
        else {
            if (($Operator->{'postfix'}->{$token->[1]} && $last_is_term)) {
                my $pr = $Precedence->{$token->[1]};
                for ( ; (scalar(@{$op_stack}) && (($pr <= get_token_precedence($op_stack->[0])))); {

                    } ) {
                    $reduce->($op_stack, $num_stack)
                };
                if (($token->[0] ne 'postfix_or_term')) {
                    $token->[0] = 'postfix'
                };
                unshift(@{$op_stack}, $token);
                $token_is_term = 1
            }
            else {
                if ($token_is_term) {
                    if ($last_is_term) {
                        say('#      last:  ', Perlito5::Dumper::Dumper($last));
                        say('#      token: ', Perlito5::Dumper::Dumper($token));
                        die('Value tokens must be separated by an operator')
                    };
                    $token->[0] = 'term';
                    push(@{$num_stack}, $token)
                }
                else {
                    if ($Precedence->{$token->[1]}) {
                        my $pr = $Precedence->{$token->[1]};
                        if ($Assoc->{'right'}->{$token->[1]}) {
                            for ( ; (scalar(@{$op_stack}) && (($pr < get_token_precedence($op_stack->[0])))); {

                                } ) {
                                $reduce->($op_stack, $num_stack)
                            }
                        }
                        else {
                            for ( ; (scalar(@{$op_stack}) && (($pr <= get_token_precedence($op_stack->[0])))); {

                                } ) {
                                $reduce->($op_stack, $num_stack)
                            }
                        };
                        if ($Operator->{'ternary'}->{$token->[1]}) {
                            $token->[0] = 'ternary'
                        }
                        else {
                            $token->[0] = 'infix'
                        };
                        unshift(@{$op_stack}, $token)
                    }
                    else {
                        die('Unknown token: ' . chr(39), $token->[1], chr(39))
                    }
                }
            }
        };
        $last = $token;
        $last_is_term = $token_is_term;
        $token = $get_token->($last_is_term);
        if (($token->[0] eq 'space')) {
            $token = $get_token->($last_is_term)
        }
    };
    if ((defined($token) && (($token->[0] ne 'end')))) {
        die('Unexpected end token: ', $token)
    };
    for ( ; scalar(@{$op_stack}); {

        } ) {
        $reduce->($op_stack, $num_stack)
    };
    $End_token = $last_end_token;
    $End_token_chars = $last_end_token_chars;
    return $num_stack
};
1;

;
package main;
package Perlito5::Grammar::Bareword;

# use strict
;
sub Perlito5::Grammar::Bareword::the_object {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((do {
                    my $pos1 = $MATCH->{'to'};
                    ((((do {
                                    ((((do {
                                                    my $tmp = $MATCH;
                                                    $MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}};
                                                    my $res = ((('$' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))));
                                                    $MATCH = ($res ? $tmp : 0)
                                                })) && ((do {
                                                    my $m2 = Perlito5::Grammar::Sigil->term_sigil($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'Perlito5::Grammar::Sigil.term_sigil'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }))) && ((do {
                                                $MATCH->{'str'} = $str;
                                                $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Sigil.term_sigil'})->[1];
                                                1
                                            })))
                                })) || ((do {
                                    $MATCH->{'to'} = $pos1;
                                    ((((((('{' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                            my $m2 = Perlito5::Grammar::Expression->curly_parse($str, $MATCH->{'to'});
                                                            if ($m2) {
                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                $MATCH->{'Perlito5::Grammar::Expression.curly_parse'} = $m2;
                                                                1
                                                            }
                                                            else {
                                                                0
                                                            }
                                                        }))) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                    $MATCH->{'str'} = $str;
                                                    $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression.curly_parse'});
                                                    1
                                                }))))
                                }))) || ((do {
                                $MATCH->{'to'} = $pos1;
                                ((((do {
                                                my $m2 = Perlito5::Grammar::Print->typeglob($str, $MATCH->{'to'});
                                                if ($m2) {
                                                    $MATCH->{'to'} = $m2->{'to'};
                                                    $MATCH->{'Perlito5::Grammar::Print.typeglob'} = $m2;
                                                    1
                                                }
                                                else {
                                                    0
                                                }
                                            })) && ((do {
                                                $MATCH->{'str'} = $str;
                                                $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Print.typeglob'});
                                                1
                                            }))))
                            })))
                })));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Bareword::term_bareword {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $p = $pos;
    my $m_namespace = Perlito5::Grammar->optional_namespace_before_ident($str, $p);
    my $namespace = Perlito5::Match::flat($m_namespace);
    $p = $m_namespace->{'to'};
    my $m_name = Perlito5::Grammar->ident($str, $p);
    if (!($m_name)) {
        if ($namespace) {
            $m_namespace->{'capture'} = ['term', Perlito5::AST::Var->new('sigil', '::', 'name', '', 'namespace', $namespace)];
            return $m_namespace
        };
        return 
    };
    my $name = Perlito5::Match::flat($m_name);
    $p = $m_name->{'to'};
    if ((substr($str, $p, 2) eq '::')) {
        $m_name->{'to'} = ($p + 2);
        $m_name->{'capture'} = ['term', Perlito5::AST::Var->new('sigil', '::', 'name', '', 'namespace', ($namespace . '::' . $name))];
        return $m_name
    };
    my $full_name = $name;
    $full_name = ($namespace . '::' . $name) if $namespace;
    my $m = Perlito5::Grammar::Space->ws($str, $p);
    if ($m) {
        $p = $m->{'to'}
    };
    my $invocant;
    my $is_subroutine_name;
    my $effective_name = ((($namespace || $Perlito5::PKG_NAME)) . '::' . $name);
    if (exists($Perlito5::Grammar::Print::Print{$name})) {
        $invocant = undef()
    }
    else {
        if ((exists($Perlito5::PROTO->{$effective_name}) || ((((!($namespace) || ($namespace eq 'CORE'))) && exists($Perlito5::CORE_PROTO->{('CORE::' . $name)}))))) {
            $is_subroutine_name = 1;
            $invocant = Perlito5::Grammar->full_ident($str, $p);
            my $package = Perlito5::Match::flat($invocant);
            if ($package) {
                $invocant->{'capture'} = Perlito5::AST::Var->new('sigil', '::', 'name', '', 'namespace', $package);
                if ((substr($str, $invocant->{'to'}, 2) eq '::')) {
                    $invocant->{'to'} = ($invocant->{'to'} + 2)
                }
                else {
                    if (!($Perlito5::PACKAGES->{$package})) {
                        $invocant = undef()
                    }
                }
            }
        }
        else {
            $invocant = Perlito5::Grammar::Bareword->the_object($str, $p)
        }
    };
    if ($invocant) {
        $p = $invocant->{'to'};
        my $arg = [];
        $m = Perlito5::Grammar::Space->ws($str, $p);
        $p = $m->{'to'} if $m;
        if ((substr($str, $p, 2) eq '->')) {

        }
        else {
            if ((substr($str, $p, 1) eq '(')) {
                my $m = Perlito5::Grammar::Expression->term_paren($str, $p);
                if ($m) {
                    $arg = $m->{'capture'}->[2];
                    $p = $m->{'to'};
                    $arg = Perlito5::Grammar::Expression::expand_list($arg)
                }
            }
            else {
                my $m = Perlito5::Grammar::Expression->list_parse($str, $p);
                if (($m->{'capture'} ne '*undef*')) {
                    $arg = Perlito5::Grammar::Expression::expand_list($m->{'capture'});
                    $p = $m->{'to'}
                }
            }
        };
        $m_name->{'capture'} = ['term', Perlito5::AST::Call->new('method', $full_name, 'invocant', Perlito5::Match::flat($invocant), 'arguments', $arg)];
        $m_name->{'to'} = $p;
        return $m_name
    };
    if ((substr($str, $p, 2) eq '=>')) {
        $m_name->{'capture'} = ['term', Perlito5::AST::Apply->new('code', $name, 'namespace', $namespace, 'arguments', [], 'bareword', 1)];
        $m_name->{'to'} = $p;
        return $m_name
    };
    if ((substr($str, $p, 2) eq '->')) {
        if ($is_subroutine_name) {
            $m_name->{'capture'} = ['term', Perlito5::AST::Apply->new('arguments', [], 'code', $name, 'namespace', $namespace)]
        }
        else {
            $m_name->{'capture'} = ['term', Perlito5::AST::Proto->new('name', $full_name)]
        };
        $m_name->{'to'} = $p;
        return $m_name
    };
    my $sig;
    if (exists($Perlito5::PROTO->{$effective_name})) {
        $sig = $Perlito5::PROTO->{$effective_name}
    }
    else {
        if ((((!($namespace) || ($namespace eq 'CORE'))) && exists($Perlito5::CORE_PROTO->{('CORE::' . $name)}))) {
            $effective_name = ('CORE::' . $name);
            $sig = $Perlito5::CORE_PROTO->{$effective_name}
        }
        else {
            $sig = undef()
        }
    };
    my $has_paren = 0;
    if (defined($sig)) {
        if ((substr($sig, 0, 1) eq ';')) {
            if ((substr($str, $p, 2) eq '//')) {
                $m_name->{'capture'} = ['term', Perlito5::AST::Apply->new('code', $name, 'namespace', $namespace, 'arguments', [], 'bareword', 1)];
                $m_name->{'to'} = $p;
                return $m_name
            }
        };
        if (($sig eq '')) {
            if ((substr($str, $p, 1) eq '(')) {
                ($p)++;
                $has_paren = 1;
                my $m = Perlito5::Grammar::Space->ws($str, $p);
                if ($m) {
                    $p = $m->{'to'}
                };
                if ((substr($str, $p, 1) ne ')')) {
                    die('syntax error near ', substr($str, $pos, 10))
                };
                ($p)++
            };
            $m_name->{'capture'} = ['term', Perlito5::AST::Apply->new('code', $name, 'namespace', $namespace, 'arguments', [], 'bareword', (($has_paren == 0)))];
            $m_name->{'to'} = $p;
            return $m_name
        };
        if (((($sig eq '_') || ($sig eq '$')) || ($sig eq ';$'))) {
            my $m;
            my $arg;
            if ((substr($str, $p, 1) eq '(')) {
                $m = Perlito5::Grammar::Expression->term_paren($str, $p);
                if (!($m)) {
                    return $m
                };
                $p = $m->{'to'};
                $has_paren = 1;
                $arg = $m->{'capture'}->[2];
                $arg = Perlito5::Grammar::Expression::expand_list($arg);
                my $v = shift(@{$arg});
                die(('Too many arguments for ' . $name)) if @{$arg};
                $arg = $v
            }
            else {
                $m = Perlito5::Grammar::Expression->argument_parse($str, $p);
                $arg = $m->{'capture'};
                if (($arg eq '*undef*')) {
                    $arg = undef()
                }
                else {
                    if (((ref($arg) eq 'Perlito5::AST::Apply') && ($arg->{'code'} eq 'circumfix:<( )>'))) {
                        my $v = shift(@{$arg->{'arguments'}});
                        die(('Too many arguments for ' . $name)) if @{$arg->{'arguments'}};
                        $arg = $v
                    }
                }
            };
            my @args;
            if (defined($arg)) {
                push(@args, $arg);
                $has_paren = 1
            }
            else {
                die(('Not enough arguments for ' . $name)) if ($sig eq '$');
                push(@args, Perlito5::AST::Var->new('namespace', '', 'name', '_', 'sigil', '$')) if ($sig eq '_')
            };
            $m->{'capture'} = ['term', Perlito5::AST::Apply->new('code', $name, 'namespace', $namespace, 'arguments', \@args, 'bareword', (($has_paren == 0)))];
            return $m
        };
        if (($sig eq '*')) {

        }
    };
    if ((substr($str, $p, 1) eq '(')) {
        $m = Perlito5::Grammar::Expression->term_paren($str, $p);
        if (!($m)) {
            return $m
        };
        my $arg = $m->{'capture'}->[2];
        $arg = Perlito5::Grammar::Expression::expand_list($arg);
        $m->{'capture'} = ['term', Perlito5::AST::Apply->new('code', $name, 'namespace', $namespace, 'arguments', $arg)];
        return $m
    };
    my $m_list = Perlito5::Grammar::Expression->list_parse($str, $p);
    my $list = $m_list->{'capture'};
    if (($list ne '*undef*')) {
        $m_name->{'capture'} = ['postfix_or_term', 'funcall', $namespace, $name, $list];
        $m_name->{'to'} = $m_list->{'to'};
        return $m_name
    };
    $m_name->{'capture'} = ['postfix_or_term', 'funcall_no_params', $namespace, $name];
    return $m_name
};
1;

;
package main;
undef();
package Perlito5::Grammar::Attribute;
sub Perlito5::Grammar::Attribute::opt_attribute {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my @attributes;
    my $ws = Perlito5::Grammar::Space->opt_ws($str, $pos);
    if ((substr($str, $ws->{'to'}, 1) ne ':')) {
        return {'to', $pos, 'capture', []}
    };
    $ws = Perlito5::Grammar::Space->opt_ws($str, ($ws->{'to'} + 1));
    my $p = $ws->{'to'};
    my $m = Perlito5::Grammar->ident($str, $p);
    die('syntax error') if !($m);
    my $to;
    for ( ; 1; {

        } ) {
        $to = $m->{'to'};
        my $delimiter = substr($str, $to, 1);
        if (($delimiter eq '(')) {
            my $params = Perlito5::Grammar::String->string_interpolation_parse($str, ($m->{'to'} + 1), '(', ')', 0);
            die('syntax error') if !($params);
            $to = $params->{'to'}
        };
        push(@attributes, substr($str, $p, ($to - $p)));
        $ws = Perlito5::Grammar::Space->opt_ws($str, $to);
        if ((substr($str, $ws->{'to'}, 1) eq ':')) {
            $ws = Perlito5::Grammar::Space->opt_ws($str, ($ws->{'to'} + 1))
        };
        $p = $ws->{'to'};
        $m = Perlito5::Grammar->ident($str, $p);
        return {'to', $to, 'capture', \@attributes} if !($m)
    }
};
1;

;
package main;
package Perlito5::Grammar::Expression;

# use Perlito5::Grammar::Precedence
;

# use Perlito5::Grammar::Bareword
;

# use Perlito5::Grammar::Attribute
;
Perlito5::Grammar::Precedence::add_term('.', sub {
        Perlito5::Grammar::Expression->term_digit($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('0', sub {
        Perlito5::Grammar::Expression->term_digit($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('1', sub {
        Perlito5::Grammar::Expression->term_digit($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('2', sub {
        Perlito5::Grammar::Expression->term_digit($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('3', sub {
        Perlito5::Grammar::Expression->term_digit($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('4', sub {
        Perlito5::Grammar::Expression->term_digit($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('5', sub {
        Perlito5::Grammar::Expression->term_digit($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('6', sub {
        Perlito5::Grammar::Expression->term_digit($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('7', sub {
        Perlito5::Grammar::Expression->term_digit($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('8', sub {
        Perlito5::Grammar::Expression->term_digit($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('9', sub {
        Perlito5::Grammar::Expression->term_digit($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('my', sub {
        Perlito5::Grammar::Expression->term_declarator($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('our', sub {
        Perlito5::Grammar::Expression->term_declarator($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('eval', sub {
        Perlito5::Grammar::Expression->term_eval($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('state', sub {
        Perlito5::Grammar::Expression->term_declarator($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('local', sub {
        Perlito5::Grammar::Expression->term_local($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('return', sub {
        Perlito5::Grammar::Expression->term_return($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('package', sub {
        Perlito5::Grammar::Expression->term_package($_[0], $_[1])
    });
sub Perlito5::Grammar::Expression::expand_list {
    my $param_list = shift();
    if (((ref($param_list) eq 'Perlito5::AST::Apply') && ($param_list->code() eq 'list:<,>'))) {
        my $args = [];
        for my  $v (@{$param_list->arguments()}) {
            if (defined($v)) {
                push(@{$args}, $v)
            }
        };
        return $args
    }
    else {
        if (($param_list eq '*undef*')) {
            return []
        }
        else {
            return [$param_list]
        }
    }
};
sub Perlito5::Grammar::Expression::block_or_hash {
    my $o = shift();
    if (defined($o->sig())) {
        return $o
    };
    my $stmts = $o->stmts();
    if ((!((defined($stmts))) || (scalar(@{$stmts}) == 0))) {
        return Perlito5::AST::Apply->new('code', 'circumfix:<{ }>', 'namespace', '', 'arguments', [])
    };
    if ((scalar(@{$stmts}) != 1)) {
        return $o
    };
    my $stmt = $stmts->[0];
    if ((ref($stmt) eq 'Perlito5::AST::Var')) {
        return Perlito5::AST::Apply->new('code', 'circumfix:<{ }>', 'namespace', '', 'arguments', [$stmt])
    };
    if ((ref($stmt) ne 'Perlito5::AST::Apply')) {
        return $o
    };
    if (($stmt->code() eq 'infix:<=>>')) {
        return Perlito5::AST::Apply->new('code', 'circumfix:<{ }>', 'namespace', '', 'arguments', [$stmt])
    };
    if (($stmt->code() ne 'list:<,>')) {
        return $o
    };
    return Perlito5::AST::Apply->new('code', 'circumfix:<{ }>', 'namespace', '', 'arguments', expand_list($stmt))
};
sub Perlito5::Grammar::Expression::pop_term {
    my $num_stack = shift();
    my $v = pop(@{$num_stack});
    if ((ref($v) eq 'ARRAY')) {
        if (($v->[1] eq 'methcall_no_params')) {
            $v = Perlito5::AST::Call->new('invocant', undef(), 'method', $v->[2], 'arguments', []);
            return $v
        };
        if (($v->[1] eq 'funcall_no_params')) {
            $v = Perlito5::AST::Apply->new('code', $v->[3], 'namespace', $v->[2], 'arguments', [], 'bareword', 1);
            return $v
        };
        if (($v->[1] eq 'methcall')) {
            my $param_list = expand_list(($v->[3]));
            $v = Perlito5::AST::Call->new('invocant', undef(), 'method', $v->[2], 'arguments', $param_list);
            return $v
        };
        if (($v->[1] eq 'funcall')) {
            my $param_list = expand_list(($v->[4]));
            $v = Perlito5::AST::Apply->new('code', $v->[3], 'arguments', $param_list, 'namespace', $v->[2]);
            return $v
        };
        if (($v->[1] eq '( )')) {
            my $param_list = expand_list($v->[2]);
            $v = Perlito5::AST::Apply->new('code', 'circumfix:<( )>', 'arguments', $param_list, 'namespace', '');
            return $v
        };
        if (($v->[1] eq '[ ]')) {
            my $param_list = expand_list($v->[2]);
            $v = Perlito5::AST::Apply->new('code', 'circumfix:<[ ]>', 'arguments', $param_list, 'namespace', '');
            return $v
        };
        if (($v->[1] eq 'block')) {
            $v = Perlito5::AST::Lit::Block->new('stmts', $v->[2], 'sig', $v->[3]);
            $v = block_or_hash($v);
            return $v
        };
        if (($v->[1] eq '.( )')) {
            $v = Perlito5::AST::Call->new('invocant', undef(), 'method', 'postcircumfix:<( )>', 'arguments', $v->[2]);
            return $v
        };
        if (($v->[1] eq '.[ ]')) {
            $v = Perlito5::AST::Index->new('obj', undef(), 'index_exp', $v->[2]);
            return $v
        };
        if (($v->[1] eq '.{ }')) {
            $v = Perlito5::AST::Lookup->new('obj', undef(), 'index_exp', $v->[2]);
            return $v
        };
        return $v->[1]
    };
    return $v
};
sub Perlito5::Grammar::Expression::reduce_postfix {
    my $op = shift();
    my $value = shift();
    my $v = $op;
    if (($v->[1] eq 'methcall_no_params')) {
        $v = Perlito5::AST::Call->new('invocant', $value, 'method', $v->[2], 'arguments', []);
        return $v
    };
    if (($v->[1] eq 'funcall_no_params')) {
        die('unexpected function call')
    };
    if (($v->[1] eq 'methcall')) {
        my $param_list = expand_list($v->[3]);
        $v = Perlito5::AST::Call->new('invocant', $value, 'method', $v->[2], 'arguments', $param_list);
        return $v
    };
    if (($v->[1] eq 'funcall')) {
        die('unexpected function call')
    };
    if (($v->[1] eq '( )')) {
        my $param_list = expand_list($v->[2]);
        if (((ref($value) eq 'Perlito5::AST::Apply') && !((defined($value->arguments()))))) {
            $value->{'arguments'} = $param_list;
            return $value
        };
        if (((ref($value) eq 'Perlito5::AST::Call') && !((defined($value->arguments()))))) {
            $value->{'arguments'} = $param_list;
            return $value
        };
        $v = Perlito5::AST::Call->new('invocant', $value, 'method', 'postcircumfix:<( )>', 'arguments', $param_list);
        return $v
    };
    if (($v->[1] eq '[ ]')) {
        $v = Perlito5::AST::Index->new('obj', $value, 'index_exp', $v->[2]);
        return $v
    };
    if (($v->[1] eq 'block')) {
        $v = Perlito5::AST::Lookup->new('obj', $value, 'index_exp', ($v->[2])->[0]);
        return $v
    };
    if (($v->[1] eq '.( )')) {
        my $param_list = expand_list($v->[2]);
        $v = Perlito5::AST::Call->new('invocant', $value, 'method', 'postcircumfix:<( )>', 'arguments', $param_list);
        return $v
    };
    if (($v->[1] eq '.[ ]')) {
        $v = Perlito5::AST::Call->new('invocant', $value, 'method', 'postcircumfix:<[ ]>', 'arguments', $v->[2]);
        return $v
    };
    if (($v->[1] eq '.{ }')) {
        $v = Perlito5::AST::Call->new('invocant', $value, 'method', 'postcircumfix:<{ }>', 'arguments', $v->[2]);
        return $v
    };
    push(@{$op}, $value);
    return $op
};
my $reduce_to_ast = sub {
        my $op_stack = shift();
        my $num_stack = shift();
        my $last_op = shift(@{$op_stack});
        if (($last_op->[0] eq 'prefix')) {
            push(@{$num_stack}, Perlito5::AST::Apply->new('namespace', '', 'code', ('prefix:<' . $last_op->[1] . '>'), 'arguments', [pop_term($num_stack)]))
        }
        else {
            if (($last_op->[0] eq 'postfix')) {
                push(@{$num_stack}, Perlito5::AST::Apply->new('namespace', '', 'code', ('postfix:<' . $last_op->[1] . '>'), 'arguments', [pop_term($num_stack)]))
            }
            else {
                if (($last_op->[0] eq 'postfix_or_term')) {
                    push(@{$num_stack}, reduce_postfix($last_op, pop_term($num_stack)))
                }
                else {
                    if (Perlito5::Grammar::Precedence::is_assoc_type('list', $last_op->[1])) {
                        my $arg;
                        if ((scalar(@{$num_stack}) < 2)) {
                            my $v2 = pop_term($num_stack);
                            if (((ref($v2) eq 'Perlito5::AST::Apply') && ($v2->code() eq (('list:<' . $last_op->[1] . '>'))))) {
                                push(@{$num_stack}, Perlito5::AST::Apply->new('namespace', $v2->namespace(), 'code', $v2->code(), 'arguments', [@{$v2->arguments()}, undef()]))
                            }
                            else {
                                push(@{$num_stack}, Perlito5::AST::Apply->new('namespace', '', 'code', ('list:<' . $last_op->[1] . '>'), 'arguments', [$v2, undef()]))
                            };
                            return 
                        }
                        else {
                            my $v2 = pop_term($num_stack);
                            $arg = [pop_term($num_stack), $v2]
                        };
                        if ((((ref($arg->[0]) eq 'Perlito5::AST::Apply') && ($last_op->[0] eq 'infix')) && (($arg->[0]->code() eq ('list:<' . $last_op->[1] . '>'))))) {
                            push(@{$num_stack}, Perlito5::AST::Apply->new('namespace', '', 'code', ($arg->[0])->code(), 'arguments', [@{($arg->[0])->arguments()}, $arg->[1]]));
                            return 
                        };
                        push(@{$num_stack}, Perlito5::AST::Apply->new('namespace', '', 'code', ('list:<' . $last_op->[1] . '>'), 'arguments', $arg))
                    }
                    else {
                        if (Perlito5::Grammar::Precedence::is_assoc_type('chain', $last_op->[1])) {
                            if ((scalar(@{$num_stack}) < 2)) {
                                die(('Missing value after operator ' . $last_op->[1]))
                            };
                            my $v2 = pop_term($num_stack);
                            my $arg = [pop_term($num_stack), $v2];
                            push(@{$num_stack}, Perlito5::AST::Apply->new('namespace', '', 'code', ('infix:<' . $last_op->[1] . '>'), 'arguments', $arg))
                        }
                        else {
                            if (($last_op->[0] eq 'ternary')) {
                                if ((scalar(@{$num_stack}) < 2)) {
                                    die('Missing value after ternary operator')
                                };
                                my $v2 = pop_term($num_stack);
                                push(@{$num_stack}, Perlito5::AST::Apply->new('namespace', '', 'code', ('ternary:<' . $last_op->[1] . '>'), 'arguments', [pop_term($num_stack), $last_op->[2], $v2]))
                            }
                            else {
                                if ((scalar(@{$num_stack}) < 2)) {
                                    die(('missing value after operator ' . chr(39) . $last_op->[1] . chr(39)))
                                };
                                my $v2 = pop_term($num_stack);
                                push(@{$num_stack}, Perlito5::AST::Apply->new('namespace', '', 'code', ('infix:<' . $last_op->[1] . '>'), 'arguments', [pop_term($num_stack), $v2]))
                            }
                        }
                    }
                }
            }
        }
    };
sub Perlito5::Grammar::Expression::term_arrow {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = ((((((('->' eq substr($str, $MATCH->{'to'}, 2)) && ($MATCH->{'to'} = (2 + $MATCH->{'to'})))) && ((do {
                                my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    1
                                }
                                else {
                                    0
                                }
                            }))) && ((do {
                            my $pos1 = $MATCH->{'to'};
                            ((((((do {
                                                    (((((('(' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                                        my $m2 = $grammar->paren_parse($str, $MATCH->{'to'});
                                                                        if ($m2) {
                                                                            $MATCH->{'to'} = $m2->{'to'};
                                                                            $MATCH->{'paren_parse'} = $m2;
                                                                            1
                                                                        }
                                                                        else {
                                                                            0
                                                                        }
                                                                    }))) && (((')' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                                $MATCH->{'str'} = $str;
                                                                $MATCH->{'capture'} = ['postfix_or_term', '.( )', Perlito5::Match::flat($MATCH->{'paren_parse'})];
                                                                1
                                                            })))
                                                })) || ((do {
                                                    $MATCH->{'to'} = $pos1;
                                                    ((((((('[' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                                            my $m2 = $grammar->square_parse($str, $MATCH->{'to'});
                                                                            if ($m2) {
                                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                                $MATCH->{'square_parse'} = $m2;
                                                                                1
                                                                            }
                                                                            else {
                                                                                0
                                                                            }
                                                                        }))) && (((']' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                                    $MATCH->{'str'} = $str;
                                                                    $MATCH->{'capture'} = ['postfix_or_term', '.[ ]', Perlito5::Match::flat($MATCH->{'square_parse'})];
                                                                    1
                                                                }))))
                                                }))) || ((do {
                                                $MATCH->{'to'} = $pos1;
                                                ((((((('{' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                                        my $m2 = $grammar->curly_parse($str, $MATCH->{'to'});
                                                                        if ($m2) {
                                                                            $MATCH->{'to'} = $m2->{'to'};
                                                                            $MATCH->{'curly_parse'} = $m2;
                                                                            1
                                                                        }
                                                                        else {
                                                                            0
                                                                        }
                                                                    }))) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                                $MATCH->{'str'} = $str;
                                                                $MATCH->{'capture'} = ['postfix_or_term', '.{ }', Perlito5::Match::flat($MATCH->{'curly_parse'})];
                                                                1
                                                            }))))
                                            }))) || ((do {
                                            $MATCH->{'to'} = $pos1;
                                            ((((((('$' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                                    my $m2 = Perlito5::Grammar->ident($str, $MATCH->{'to'});
                                                                    if ($m2) {
                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                        $MATCH->{'Perlito5::Grammar.ident'} = $m2;
                                                                        1
                                                                    }
                                                                    else {
                                                                        0
                                                                    }
                                                                }))) && ((do {
                                                                my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                if ($m2) {
                                                                    $MATCH->{'to'} = $m2->{'to'};
                                                                    1
                                                                }
                                                                else {
                                                                    0
                                                                }
                                                            }))) && ((do {
                                                            my $pos1 = $MATCH->{'to'};
                                                            (((do {
                                                                        (((((('(' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                                                            my $m2 = $grammar->paren_parse($str, $MATCH->{'to'});
                                                                                            if ($m2) {
                                                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                                                $MATCH->{'paren_parse'} = $m2;
                                                                                                1
                                                                                            }
                                                                                            else {
                                                                                                0
                                                                                            }
                                                                                        }))) && (((')' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                                                    $MATCH->{'str'} = $str;
                                                                                    $MATCH->{'capture'} = ['postfix_or_term', 'methcall', Perlito5::AST::Var->new('sigil', '$', 'namespace', '', 'name', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.ident'})), Perlito5::Match::flat($MATCH->{'paren_parse'})];
                                                                                    1
                                                                                })))
                                                                    })) || ((do {
                                                                        $MATCH->{'to'} = $pos1;
                                                                        ((do {
                                                                                $MATCH->{'str'} = $str;
                                                                                $MATCH->{'capture'} = ['postfix_or_term', 'methcall_no_params', Perlito5::AST::Var->new('sigil', '$', 'namespace', '', 'name', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.ident'}))];
                                                                                1
                                                                            }))
                                                                    })))
                                                        }))))
                                        }))) || ((do {
                                        $MATCH->{'to'} = $pos1;
                                        (((((do {
                                                            my $m2 = Perlito5::Grammar->full_ident($str, $MATCH->{'to'});
                                                            if ($m2) {
                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                $MATCH->{'Perlito5::Grammar.full_ident'} = $m2;
                                                                1
                                                            }
                                                            else {
                                                                0
                                                            }
                                                        })) && ((do {
                                                            my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                            if ($m2) {
                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                1
                                                            }
                                                            else {
                                                                0
                                                            }
                                                        }))) && ((do {
                                                        my $pos1 = $MATCH->{'to'};
                                                        (((do {
                                                                    (((((('(' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                                                        my $m2 = $grammar->paren_parse($str, $MATCH->{'to'});
                                                                                        if ($m2) {
                                                                                            $MATCH->{'to'} = $m2->{'to'};
                                                                                            $MATCH->{'paren_parse'} = $m2;
                                                                                            1
                                                                                        }
                                                                                        else {
                                                                                            0
                                                                                        }
                                                                                    }))) && (((')' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                                                $MATCH->{'str'} = $str;
                                                                                $MATCH->{'capture'} = ['postfix_or_term', 'methcall', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.full_ident'}), Perlito5::Match::flat($MATCH->{'paren_parse'})];
                                                                                1
                                                                            })))
                                                                })) || ((do {
                                                                    $MATCH->{'to'} = $pos1;
                                                                    ((do {
                                                                            $MATCH->{'str'} = $str;
                                                                            $MATCH->{'capture'} = ['postfix_or_term', 'methcall_no_params', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.full_ident'})];
                                                                            1
                                                                        }))
                                                                })))
                                                    }))))
                                    })))
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Expression::term_digit {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((do {
                    my $pos1 = $MATCH->{'to'};
                    (((do {
                                (((do {
                                            my $m2 = Perlito5::Grammar->val_num($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar.val_num'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        })) && ((do {
                                            $MATCH->{'str'} = $str;
                                            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.val_num'})];
                                            1
                                        })))
                            })) || ((do {
                                $MATCH->{'to'} = $pos1;
                                ((((do {
                                                my $m2 = Perlito5::Grammar->val_int($str, $MATCH->{'to'});
                                                if ($m2) {
                                                    $MATCH->{'to'} = $m2->{'to'};
                                                    $MATCH->{'Perlito5::Grammar.val_int'} = $m2;
                                                    1
                                                }
                                                else {
                                                    0
                                                }
                                            })) && ((do {
                                                $MATCH->{'str'} = $str;
                                                $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.val_int'})];
                                                1
                                            }))))
                            })))
                })));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Expression::term_ternary {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((((((('?' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                    my $m2 = $grammar->ternary5_parse($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'ternary5_parse'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }))) && (((':' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['op', '? :', Perlito5::Match::flat($MATCH->{'ternary5_parse'})];
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Expression::term_paren {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((((((('(' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                    my $m2 = $grammar->paren_parse($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'paren_parse'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }))) && (((')' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['postfix_or_term', '( )', Perlito5::Match::flat($MATCH->{'paren_parse'})];
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Expression::term_square {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((((((('[' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                    my $m2 = $grammar->square_parse($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'square_parse'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }))) && (((']' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['postfix_or_term', '[ ]', Perlito5::Match::flat($MATCH->{'square_parse'})];
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Expression::term_curly {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((((((((('{' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                            my $m = $MATCH;
                                            if (!(((do {
                                                            my $m2 = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'});
                                                            if ($m2) {
                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                1
                                                            }
                                                            else {
                                                                0
                                                            }
                                                        })))) {
                                                $MATCH = $m
                                            };
                                            1
                                        }))) && ((do {
                                        my $m2 = Perlito5::Grammar->exp_stmts($str, $MATCH->{'to'});
                                        if ($m2) {
                                            $MATCH->{'to'} = $m2->{'to'};
                                            $MATCH->{'Perlito5::Grammar.exp_stmts'} = $m2;
                                            1
                                        }
                                        else {
                                            0
                                        }
                                    }))) && ((do {
                                    my $m = $MATCH;
                                    if (!(((do {
                                                    my $m2 = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                })))) {
                                        $MATCH = $m
                                    };
                                    1
                                }))) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['postfix_or_term', 'block', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.exp_stmts'})];
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Expression::declarator {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((do {
                    my $pos1 = $MATCH->{'to'};
                    ((((do {
                                    (('my' eq substr($str, $MATCH->{'to'}, 2)) && ($MATCH->{'to'} = (2 + $MATCH->{'to'})))
                                })) || ((do {
                                    $MATCH->{'to'} = $pos1;
                                    ((('state' eq substr($str, $MATCH->{'to'}, 5)) && ($MATCH->{'to'} = (5 + $MATCH->{'to'}))))
                                }))) || ((do {
                                $MATCH->{'to'} = $pos1;
                                ((('our' eq substr($str, $MATCH->{'to'}, 3)) && ($MATCH->{'to'} = (3 + $MATCH->{'to'}))))
                            })))
                })));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Expression::term_declarator {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((((((((do {
                                            my $m2 = $grammar->declarator($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'declarator'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        })) && ((do {
                                            my $pos1 = $MATCH->{'to'};
                                            (((do {
                                                        (((do {
                                                                    my $m2 = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'});
                                                                    if ($m2) {
                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                        1
                                                                    }
                                                                    else {
                                                                        0
                                                                    }
                                                                })) && ((do {
                                                                    my $m2 = Perlito5::Grammar->opt_type($str, $MATCH->{'to'});
                                                                    if ($m2) {
                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                        $MATCH->{'Perlito5::Grammar.opt_type'} = $m2;
                                                                        1
                                                                    }
                                                                    else {
                                                                        0
                                                                    }
                                                                })))
                                                    })) || ((do {
                                                        $MATCH->{'to'} = $pos1;
                                                        1
                                                    })))
                                        }))) && ((do {
                                        my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                        if ($m2) {
                                            $MATCH->{'to'} = $m2->{'to'};
                                            1
                                        }
                                        else {
                                            0
                                        }
                                    }))) && ((do {
                                    my $m2 = Perlito5::Grammar->var_ident($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar.var_ident'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }))) && ((do {
                                my $m2 = Perlito5::Grammar::Attribute->opt_attribute($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    $MATCH->{'Perlito5::Grammar::Attribute.opt_attribute'} = $m2;
                                    1
                                }
                                else {
                                    0
                                }
                            }))) && ((do {
                            $MATCH->{'str'} = $str;
                            my $decl = Perlito5::Match::flat($MATCH->{'declarator'});
                            my $type = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.opt_type'});
                            die(('No such class ' . $type)) if ($type && !($Perlito5::PACKAGES->{$type}));
                            my $var = $MATCH->{'Perlito5::Grammar.var_ident'}->{'capture'};
                            $MATCH->{'capture'} = ['term', Perlito5::AST::Decl->new('decl', $decl, 'type', $type, 'var', $var, 'attributes', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Attribute.opt_attribute'}))];
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Expression::term_local {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((((((('local' eq substr($str, $MATCH->{'to'}, 5)) && ($MATCH->{'to'} = (5 + $MATCH->{'to'})))) && ((do {
                                    my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }))) && ((do {
                                my $m2 = Perlito5::Grammar->var_ident($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    $MATCH->{'Perlito5::Grammar.var_ident'} = $m2;
                                    1
                                }
                                else {
                                    0
                                }
                            }))) && ((do {
                            $MATCH->{'str'} = $str;
                            my $decl = 'local';
                            my $type = '';
                            $MATCH = Perlito5::Grammar::String->double_quoted_var_with_subscript($MATCH->{'Perlito5::Grammar.var_ident'});
                            my $var = $MATCH->{'capture'};
                            $MATCH->{'capture'} = ['term', Perlito5::AST::Decl->new('decl', $decl, 'type', $type, 'var', $var)];
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Expression::term_return {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((((((('return' eq substr($str, $MATCH->{'to'}, 6)) && ($MATCH->{'to'} = (6 + $MATCH->{'to'})))) && ((do {
                                    my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }))) && ((do {
                                my $m2 = $grammar->list_parse($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    $MATCH->{'list_parse'} = $m2;
                                    1
                                }
                                else {
                                    0
                                }
                            }))) && ((do {
                            $MATCH->{'str'} = $str;
                            my $args = Perlito5::Match::flat($MATCH->{'list_parse'});
                            $MATCH->{'capture'} = ['term', Perlito5::AST::Apply->new('code', 'return', 'arguments', (($args eq '*undef*') ? [] : [$args]), 'namespace', '')];
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Expression::term_package {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((((((('package' eq substr($str, $MATCH->{'to'}, 7)) && ($MATCH->{'to'} = (7 + $MATCH->{'to'})))) && ((do {
                                    my $m2 = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }))) && ((do {
                                my $m2 = Perlito5::Grammar->full_ident($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    $MATCH->{'Perlito5::Grammar.full_ident'} = $m2;
                                    1
                                }
                                else {
                                    0
                                }
                            }))) && ((do {
                            $MATCH->{'str'} = $str;
                            my $name = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.full_ident'});
                            $Perlito5::PACKAGES->{$name} = 1;
                            $Perlito5::PKG_NAME = $name;
                            $MATCH->{'capture'} = ['term', Perlito5::AST::Apply->new('code', 'package', 'arguments', [], 'namespace', $name)];
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Expression::term_eval {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = ((((((((('eval' eq substr($str, $MATCH->{'to'}, 4)) && ($MATCH->{'to'} = (4 + $MATCH->{'to'})))) && ((do {
                                        my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                        if ($m2) {
                                            $MATCH->{'to'} = $m2->{'to'};
                                            1
                                        }
                                        else {
                                            0
                                        }
                                    }))) && ((do {
                                    my $tmp = $MATCH;
                                    $MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}};
                                    my $res = ((('{' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))));
                                    $MATCH = ($res ? $tmp : 0)
                                }))) && ((do {
                                my $m2 = $grammar->term_curly($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    $MATCH->{'term_curly'} = $m2;
                                    1
                                }
                                else {
                                    0
                                }
                            }))) && ((do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['term', Perlito5::AST::Apply->new('code', 'eval', 'arguments', [Perlito5::AST::Do->new('block', Perlito5::AST::Lit::Block->new('stmts', Perlito5::Match::flat($MATCH->{'term_curly'})->[2]))], 'namespace', '')];
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
my $Argument_end_token = {':', 1, ']', 1, ')', 1, '}', 1, ';', 1, ',', 1, '<', 1, '>', 1, '=', 1, '|', 1, '^', 1, '?', 1, 'or', 1, 'if', 1, '=>', 1, 'lt', 1, 'le', 1, 'gt', 1, 'ge', 1, '<=', 1, '>=', 1, '==', 1, '!=', 1, 'ne', 1, 'eq', 1, '..', 1, '~~', 1, '&&', 1, '||', 1, '+=', 1, '-=', 1, '*=', 1, '/=', 1, 'x=', 1, '|=', 1, '&=', 1, '.=', 1, '^=', 1, '%=', 1, '//', 1, 'for', 1, 'and', 1, 'xor', 1, '...', 1, '<=>', 1, 'cmp', 1, '<<=', 1, '>>=', 1, '||=', 1, '&&=', 1, '//=', 1, '**=', 1, 'when', 1, 'while', 1, 'unless', 1, 'foreach', 1};
my $Argument_end_token_chars = [7, 6, 5, 4, 3, 2, 1];
my $List_end_token = {':', 1, ']', 1, ')', 1, '}', 1, ';', 1, 'or', 1, 'if', 1, 'for', 1, 'and', 1, 'xor', 1, 'else', 1, 'when', 1, 'while', 1, 'elsif', 1, 'unless', 1, 'foreach', 1};
my $List_end_token_chars = [7, 6, 5, 4, 3, 2, 1];
my $Expr_end_token = {']', 1, ')', 1, '}', 1, ';', 1, 'if', 1, 'for', 1, 'else', 1, 'when', 1, 'while', 1, 'elsif', 1, 'unless', 1, 'foreach', 1};
my $Expr_end_token_chars = [7, 6, 5, 4, 3, 2, 1];
sub Perlito5::Grammar::Expression::argument_parse {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $expr;
    my $last_pos = $pos;
    my $is_first_token = 1;
    my $lexer_stack = [];
    my $last_token_was_space = 1;
    my $get_token = sub {
            my $last_is_term = $_[0];
            my $v;
            if (scalar(@{$lexer_stack})) {
                $v = pop(@{$lexer_stack});
                if ((($is_first_token && (($v->[0] eq 'op'))) && !((Perlito5::Grammar::Precedence::is_fixity_type('prefix', $v->[1]))))) {
                    $v->[0] = 'end'
                }
            }
            else {
                my $m = Perlito5::Grammar::Precedence->op_parse($str, $last_pos, $last_is_term);
                if ($m) {
                    my $spc = Perlito5::Grammar::Space->ws($str, $m->{'to'});
                    if ($spc) {
                        $m->{'to'} = $spc->{'to'}
                    }
                };
                if (!($m)) {
                    return ['end', '*end*']
                };
                $v = $m->{'capture'};
                if ((($is_first_token && (($v->[0] eq 'op'))) && !((Perlito5::Grammar::Precedence::is_fixity_type('prefix', $v->[1]))))) {
                    $v->[0] = 'end'
                };
                if (($v->[0] ne 'end')) {
                    $last_pos = $m->{'to'}
                }
            };
            $last_token_was_space = (($v->[0] eq 'space'));
            $is_first_token = 0;
            return $v
        };
    my $prec = Perlito5::Grammar::Precedence->new('get_token', $get_token, 'reduce', $reduce_to_ast, 'end_token', $Argument_end_token, 'end_token_chars', $Argument_end_token_chars);
    my $res = $prec->precedence_parse();
    if ((scalar(@{$res}) == 0)) {
        return {'str', $str, 'from', $pos, 'to', $last_pos, 'capture', '*undef*'}
    };
    my $result = pop_term($res);
    return {'str', $str, 'from', $pos, 'to', $last_pos, 'capture', $result}
};
sub Perlito5::Grammar::Expression::list_parse {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $expr;
    my $last_pos = $pos;
    my $is_first_token = 1;
    my $lexer_stack = [];
    my $last_token_was_space = 1;
    my $get_token = sub {
            my $last_is_term = $_[0];
            my $v;
            if (scalar(@{$lexer_stack})) {
                $v = pop(@{$lexer_stack});
                if ((($is_first_token && (($v->[0] eq 'op'))) && !((Perlito5::Grammar::Precedence::is_fixity_type('prefix', $v->[1]))))) {
                    $v->[0] = 'end'
                }
            }
            else {
                my $m = Perlito5::Grammar::Precedence->op_parse($str, $last_pos, $last_is_term);
                if ($m) {
                    my $spc = Perlito5::Grammar::Space->ws($str, $m->{'to'});
                    if ($spc) {
                        $m->{'to'} = $spc->{'to'}
                    }
                };
                if (!($m)) {
                    return ['end', '*end*']
                };
                $v = $m->{'capture'};
                if ((($is_first_token && (($v->[0] eq 'op'))) && !((Perlito5::Grammar::Precedence::is_fixity_type('prefix', $v->[1]))))) {
                    $v->[0] = 'end'
                };
                if (($v->[0] ne 'end')) {
                    $last_pos = $m->{'to'}
                }
            };
            $last_token_was_space = (($v->[0] eq 'space'));
            $is_first_token = 0;
            return $v
        };
    my $prec = Perlito5::Grammar::Precedence->new('get_token', $get_token, 'reduce', $reduce_to_ast, 'end_token', $List_end_token, 'end_token_chars', $List_end_token_chars);
    my $res = $prec->precedence_parse();
    if ((scalar(@{$res}) == 0)) {
        return {'str', $str, 'from', $pos, 'to', $last_pos, 'capture', '*undef*'}
    };
    my $result = pop_term($res);
    return {'str', $str, 'from', $pos, 'to', $last_pos, 'capture', $result}
};
sub Perlito5::Grammar::Expression::circumfix_parse {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $delimiter = $_[3];
    my $expr;
    my $last_pos = $pos;
    my $get_token = sub {
            my $last_is_term = $_[0];
            my $m = Perlito5::Grammar::Precedence->op_parse($str, $last_pos, $last_is_term);
            if ($m) {
                my $spc = Perlito5::Grammar::Space->ws($str, $m->{'to'});
                if ($spc) {
                    $m->{'to'} = $spc->{'to'}
                }
            };
            if (!($m)) {
                die('Expected closing delimiter: ', $delimiter, ' near ', $last_pos)
            };
            my $v = $m->{'capture'};
            if (($v->[0] ne 'end')) {
                $last_pos = $m->{'to'}
            };
            return $v
        };
    my %delim_token;
    $delim_token{$delimiter} = 1;
    my $prec = Perlito5::Grammar::Precedence->new('get_token', $get_token, 'reduce', $reduce_to_ast, 'end_token', \%delim_token, 'end_token_chars', [length($delimiter)]);
    my $res = $prec->precedence_parse();
    $res = pop_term($res);
    if (!((defined($res)))) {
        $res = '*undef*'
    };
    return {'str', $str, 'from', $pos, 'to', $last_pos, 'capture', $res}
};
sub Perlito5::Grammar::Expression::ternary5_parse {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    return $self->circumfix_parse($str, $pos, ':')
};
sub Perlito5::Grammar::Expression::curly_parse {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    return $self->circumfix_parse($str, $pos, '}')
};
sub Perlito5::Grammar::Expression::square_parse {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    return $self->circumfix_parse($str, $pos, ']')
};
sub Perlito5::Grammar::Expression::paren_parse {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    return $self->circumfix_parse($str, $pos, ')')
};
sub Perlito5::Grammar::Expression::exp_parse {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $expr;
    my $last_pos = $pos;
    my $lexer_stack = [];
    my $get_token = sub {
            my $last_is_term = $_[0];
            my $v;
            if (scalar(@{$lexer_stack})) {
                $v = pop(@{$lexer_stack})
            }
            else {
                my $m = Perlito5::Grammar::Precedence->op_parse($str, $last_pos, $last_is_term);
                if ($m) {
                    my $spc = Perlito5::Grammar::Space->ws($str, $m->{'to'});
                    if ($spc) {
                        $m->{'to'} = $spc->{'to'}
                    }
                };
                if (!($m)) {
                    return ['end', '*end*']
                };
                $v = $m->{'capture'};
                if (($v->[0] ne 'end')) {
                    $last_pos = $m->{'to'}
                }
            };
            return $v
        };
    my $prec = Perlito5::Grammar::Precedence->new('get_token', $get_token, 'reduce', $reduce_to_ast, 'end_token', $Expr_end_token, 'end_token_chars', $Expr_end_token_chars);
    my $res = $prec->precedence_parse();
    if ((scalar(@{$res}) == 0)) {
        return 0
    };
    my $result = pop_term($res);
    return {'str', $str, 'from', $pos, 'to', $last_pos, 'capture', $result}
};
my @Statement_chars;
my %Statement;
sub Perlito5::Grammar::Expression::add_statement {
    my $name = shift();
    my $param = shift();
    $Statement{$name} = $param;
    unshift(@Statement_chars, (scalar(@Statement_chars) + 1)) while (@Statement_chars < length($name))
};
sub Perlito5::Grammar::Expression::exp_stmt {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    for my  $len (@Statement_chars) {
        my $term = substr($str, $pos, $len);
        if (exists($Statement{$term})) {
            my $m = $Statement{$term}->($str, $pos);
            return $m if $m
        }
    };
    return 0
};
my @Modifier_chars = (7, 6, 5, 4, 3, 2);
my %Modifier = ('if', 1, 'unless', 1, 'when', 1, 'for', 1, 'foreach', 1, 'while', 1, 'given', 1);
sub Perlito5::Grammar::Expression::statement_modifier {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $expression = $_[3];
    for my  $len (@Modifier_chars) {
        my $term = substr($str, $pos, $len);
        if (exists($Modifier{$term})) {
            my $m = $self->modifier($str, ($pos + $len), $term, $expression);
            return $m if $m
        }
    };
    return 0
};
sub Perlito5::Grammar::Expression::modifier {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $modifier = $_[3];
    my $expression = $_[4];
    my $modifier_exp = $self->exp_parse($str, $pos);
    if (!($modifier_exp)) {
        die('Expected expression after ' . chr(39), Perlito5::Match::flat($modifier), chr(39))
    };
    if (($modifier eq 'if')) {
        return {'str', $str, 'from', $pos, 'to', $modifier_exp->{'to'}, 'capture', Perlito5::AST::If->new('cond', Perlito5::Match::flat($modifier_exp), 'body', $expression)}
    };
    if (($modifier eq 'unless')) {
        return {'str', $str, 'from', $pos, 'to', $modifier_exp->{'to'}, 'capture', Perlito5::AST::If->new('cond', Perlito5::Match::flat($modifier_exp), 'otherwise', $expression)}
    };
    if (($modifier eq 'when')) {
        return {'str', $str, 'from', $pos, 'to', $modifier_exp->{'to'}, 'capture', Perlito5::AST::When->new('cond', Perlito5::Match::flat($modifier_exp), 'body', $expression)}
    };
    if (($modifier eq 'while')) {
        return {'str', $str, 'from', $pos, 'to', $modifier_exp->{'to'}, 'capture', Perlito5::AST::While->new('cond', Perlito5::Match::flat($modifier_exp), 'body', $expression)}
    };
    if ((($modifier eq 'for') || ($modifier eq 'foreach'))) {
        return {'str', $str, 'from', $pos, 'to', $modifier_exp->{'to'}, 'capture', Perlito5::AST::For->new('cond', Perlito5::Match::flat($modifier_exp), 'body', $expression)}
    };
    die(('Unexpected statement modifier ' . chr(39) . $modifier . chr(39)))
};
sub Perlito5::Grammar::Expression::statement_parse {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $res = $self->exp_stmt($str, $pos);
    if ($res) {
        return $res
    };
    $res = $self->exp_parse($str, $pos);
    if (!($res)) {
        return 
    };
    if ((((substr($str, $res->{'to'}, 1) eq ':') && $res->{'capture'}->isa('Perlito5::AST::Apply')) && $res->{'capture'}->{'bareword'})) {
        my $label = $res->{'capture'}->{'code'};
        my $ws = Perlito5::Grammar::Space->opt_ws($str, ($res->{'to'} + 1));
        my $stmt = $self->statement_parse($str, $ws->{'to'});
        if ($stmt) {
            $stmt->{'capture'}->{'label'} = $label;
            return $stmt
        };
        $res->{'to'} = $ws->{'to'};
        $res->{'capture'} = Perlito5::AST::Apply->new('arguments', [], 'code', 'undef', 'namespace', '', 'label', $label);
        return $res
    };
    my $modifier = $self->statement_modifier($str, $res->{'to'}, Perlito5::Match::flat($res));
    my $p = ($modifier ? $modifier->{'to'} : $res->{'to'});
    my $terminator = substr($str, $p, 1);
    die('Number or Bareword found where operator expected') if ((($terminator ne ';') && ($terminator ne '}')) && ($terminator ne ''));
    if (!($modifier)) {
        return $res
    };
    return $modifier
};
1;

;

# use Perlito5::Grammar::Expression
;
package main;
package Perlito5::Grammar;

# use strict
;

# use Perlito5::Grammar::Expression
;
Perlito5::Grammar::Expression::add_statement('if', sub {
        Perlito5::Grammar->if($_[0], $_[1])
    });
Perlito5::Grammar::Expression::add_statement('for', sub {
        Perlito5::Grammar->for($_[0], $_[1])
    });
Perlito5::Grammar::Expression::add_statement('foreach', sub {
        Perlito5::Grammar->for($_[0], $_[1])
    });
Perlito5::Grammar::Expression::add_statement('when', sub {
        Perlito5::Grammar->when($_[0], $_[1])
    });
Perlito5::Grammar::Expression::add_statement('while', sub {
        Perlito5::Grammar->while($_[0], $_[1])
    });
Perlito5::Grammar::Expression::add_statement('given', sub {
        Perlito5::Grammar->given($_[0], $_[1])
    });
Perlito5::Grammar::Expression::add_statement('unless', sub {
        Perlito5::Grammar->unless($_[0], $_[1])
    });
sub Perlito5::Grammar::unless {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((((((((('unless' eq substr($str, $MATCH->{'to'}, 6)) && ($MATCH->{'to'} = (6 + $MATCH->{'to'})))) && ((do {
                                            my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }))) && ((do {
                                        my $m2 = Perlito5::Grammar::Expression->term_paren($str, $MATCH->{'to'});
                                        if ($m2) {
                                            $MATCH->{'to'} = $m2->{'to'};
                                            $MATCH->{'Perlito5::Grammar::Expression.term_paren'} = $m2;
                                            1
                                        }
                                        else {
                                            0
                                        }
                                    }))) && ((do {
                                    my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }))) && ((do {
                                my $m2 = Perlito5::Grammar::Expression->term_curly($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    $MATCH->{'Perlito5::Grammar::Expression.term_curly'} = $m2;
                                    1
                                }
                                else {
                                    0
                                }
                            }))) && ((do {
                            my $pos1 = $MATCH->{'to'};
                            (((do {
                                        ((((((((((do {
                                                                                my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                                if ($m2) {
                                                                                    $MATCH->{'to'} = $m2->{'to'};
                                                                                    1
                                                                                }
                                                                                else {
                                                                                    0
                                                                                }
                                                                            })) && ((('else' eq substr($str, $MATCH->{'to'}, 4)) && ($MATCH->{'to'} = (4 + $MATCH->{'to'}))))) && ((do {
                                                                            my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                            if ($m2) {
                                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                                1
                                                                            }
                                                                            else {
                                                                                0
                                                                            }
                                                                        }))) && ((('{' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                                    my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                    if ($m2) {
                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                        1
                                                                    }
                                                                    else {
                                                                        0
                                                                    }
                                                                }))) && ((do {
                                                                my $m2 = Perlito5::Grammar->exp_stmts($str, $MATCH->{'to'});
                                                                if ($m2) {
                                                                    $MATCH->{'to'} = $m2->{'to'};
                                                                    $MATCH->{'Perlito5::Grammar.exp_stmts'} = $m2;
                                                                    1
                                                                }
                                                                else {
                                                                    0
                                                                }
                                                            }))) && ((do {
                                                            my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                            if ($m2) {
                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                1
                                                            }
                                                            else {
                                                                0
                                                            }
                                                        }))) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                    $MATCH->{'str'} = $str;
                                                    my $body = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression.term_curly'})->[2];
                                                    if (!(defined($body))) {
                                                        die('Missing code block in ' . chr(39) . 'if' . chr(39))
                                                    };
                                                    $MATCH->{'capture'} = Perlito5::AST::If->new('cond', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression.term_paren'})->[2], 'body', Perlito5::AST::Lit::Block->new('stmts', (Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.exp_stmts'}) || [])), 'otherwise', Perlito5::AST::Lit::Block->new('stmts', $body));
                                                    1
                                                })))
                                    })) || ((do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                                $MATCH->{'str'} = $str;
                                                my $body = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression.term_curly'})->[2];
                                                if (!(defined($body))) {
                                                    die('Missing code block in ' . chr(39) . 'unless' . chr(39))
                                                };
                                                $MATCH->{'capture'} = Perlito5::AST::If->new('cond', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression.term_paren'})->[2], 'body', Perlito5::AST::Lit::Block->new('stmts', []), 'otherwise', Perlito5::AST::Lit::Block->new('stmts', $body));
                                                1
                                            }))
                                    })))
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::if {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((((((((('if' eq substr($str, $MATCH->{'to'}, 2)) && ($MATCH->{'to'} = (2 + $MATCH->{'to'})))) && ((do {
                                            my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }))) && ((do {
                                        my $m2 = Perlito5::Grammar::Expression->term_paren($str, $MATCH->{'to'});
                                        if ($m2) {
                                            $MATCH->{'to'} = $m2->{'to'};
                                            $MATCH->{'Perlito5::Grammar::Expression.term_paren'} = $m2;
                                            1
                                        }
                                        else {
                                            0
                                        }
                                    }))) && ((do {
                                    my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }))) && ((do {
                                my $m2 = Perlito5::Grammar::Expression->term_curly($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    $MATCH->{'Perlito5::Grammar::Expression.term_curly'} = $m2;
                                    1
                                }
                                else {
                                    0
                                }
                            }))) && ((do {
                            my $pos1 = $MATCH->{'to'};
                            ((((do {
                                            ((((((((((do {
                                                                                    my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                                    if ($m2) {
                                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                                        1
                                                                                    }
                                                                                    else {
                                                                                        0
                                                                                    }
                                                                                })) && ((('else' eq substr($str, $MATCH->{'to'}, 4)) && ($MATCH->{'to'} = (4 + $MATCH->{'to'}))))) && ((do {
                                                                                my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                                if ($m2) {
                                                                                    $MATCH->{'to'} = $m2->{'to'};
                                                                                    1
                                                                                }
                                                                                else {
                                                                                    0
                                                                                }
                                                                            }))) && ((('{' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                                        my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                        if ($m2) {
                                                                            $MATCH->{'to'} = $m2->{'to'};
                                                                            1
                                                                        }
                                                                        else {
                                                                            0
                                                                        }
                                                                    }))) && ((do {
                                                                    my $m2 = Perlito5::Grammar->exp_stmts($str, $MATCH->{'to'});
                                                                    if ($m2) {
                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                        $MATCH->{'Perlito5::Grammar.exp_stmts'} = $m2;
                                                                        1
                                                                    }
                                                                    else {
                                                                        0
                                                                    }
                                                                }))) && ((do {
                                                                my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                if ($m2) {
                                                                    $MATCH->{'to'} = $m2->{'to'};
                                                                    1
                                                                }
                                                                else {
                                                                    0
                                                                }
                                                            }))) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                        $MATCH->{'str'} = $str;
                                                        my $body = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression.term_curly'})->[2];
                                                        if (!(defined($body))) {
                                                            die('Missing code block in ' . chr(39) . 'if' . chr(39))
                                                        };
                                                        $MATCH->{'capture'} = Perlito5::AST::If->new('cond', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression.term_paren'})->[2], 'body', Perlito5::AST::Lit::Block->new('stmts', $body), 'otherwise', Perlito5::AST::Lit::Block->new('stmts', (Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.exp_stmts'}) || [])));
                                                        1
                                                    })))
                                        })) || ((do {
                                            $MATCH->{'to'} = $pos1;
                                            ((((((do {
                                                                    my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                    if ($m2) {
                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                        1
                                                                    }
                                                                    else {
                                                                        0
                                                                    }
                                                                })) && ((('els' eq substr($str, $MATCH->{'to'}, 3)) && ($MATCH->{'to'} = (3 + $MATCH->{'to'}))))) && ((do {
                                                                my $m2 = $grammar->if($str, $MATCH->{'to'});
                                                                if ($m2) {
                                                                    $MATCH->{'to'} = $m2->{'to'};
                                                                    $MATCH->{'if'} = $m2;
                                                                    1
                                                                }
                                                                else {
                                                                    0
                                                                }
                                                            }))) && ((do {
                                                            $MATCH->{'str'} = $str;
                                                            my $body = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression.term_curly'})->[2];
                                                            if (!(defined($body))) {
                                                                die('Missing code block in ' . chr(39) . 'if' . chr(39))
                                                            };
                                                            $MATCH->{'capture'} = Perlito5::AST::If->new('cond', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression.term_paren'})->[2], 'body', Perlito5::AST::Lit::Block->new('stmts', $body), 'otherwise', Perlito5::AST::Lit::Block->new('stmts', [Perlito5::Match::flat($MATCH->{'if'})]));
                                                            1
                                                        }))))
                                        }))) || ((do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                                $MATCH->{'str'} = $str;
                                                my $body = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression.term_curly'})->[2];
                                                if (!(defined($body))) {
                                                    die('Missing code block in ' . chr(39) . 'if' . chr(39))
                                                };
                                                $MATCH->{'capture'} = Perlito5::AST::If->new('cond', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression.term_paren'})->[2], 'body', Perlito5::AST::Lit::Block->new('stmts', $body), 'otherwise', Perlito5::AST::Lit::Block->new('stmts', []));
                                                1
                                            }))
                                    })))
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::when {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((((((((('when' eq substr($str, $MATCH->{'to'}, 4)) && ($MATCH->{'to'} = (4 + $MATCH->{'to'})))) && ((do {
                                            my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }))) && ((do {
                                        my $m2 = Perlito5::Grammar::Expression->term_paren($str, $MATCH->{'to'});
                                        if ($m2) {
                                            $MATCH->{'to'} = $m2->{'to'};
                                            $MATCH->{'Perlito5::Grammar::Expression.term_paren'} = $m2;
                                            1
                                        }
                                        else {
                                            0
                                        }
                                    }))) && ((do {
                                    my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }))) && ((do {
                                my $m2 = Perlito5::Grammar::Expression->term_curly($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    $MATCH->{'Perlito5::Grammar::Expression.term_curly'} = $m2;
                                    1
                                }
                                else {
                                    0
                                }
                            }))) && ((do {
                            $MATCH->{'str'} = $str;
                            my $body = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression.term_curly'})->[2];
                            if (!(defined($body))) {
                                die('Missing code block in ' . chr(39) . 'when' . chr(39))
                            };
                            $MATCH->{'capture'} = Perlito5::AST::When->new('cond', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression.term_paren'})->[2], 'body', Perlito5::AST::Lit::Block->new('stmts', $body));
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::for {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = ((((((('for' eq substr($str, $MATCH->{'to'}, 3)) && ($MATCH->{'to'} = (3 + $MATCH->{'to'})))) && ((do {
                                my $m = $MATCH;
                                if (!(((('each' eq substr($str, $MATCH->{'to'}, 4)) && ($MATCH->{'to'} = (4 + $MATCH->{'to'})))))) {
                                    $MATCH = $m
                                };
                                1
                            }))) && ((do {
                            my $pos1 = $MATCH->{'to'};
                            (((do {
                                        ((((((((((((((((do {
                                                                                                        my $m2 = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'});
                                                                                                        if ($m2) {
                                                                                                            $MATCH->{'to'} = $m2->{'to'};
                                                                                                            1
                                                                                                        }
                                                                                                        else {
                                                                                                            0
                                                                                                        }
                                                                                                    })) && ((do {
                                                                                                        my $pos1 = $MATCH->{'to'};
                                                                                                        (((do {
                                                                                                                    (((do {
                                                                                                                                my $m2 = Perlito5::Grammar::Expression->term_declarator($str, $MATCH->{'to'});
                                                                                                                                if ($m2) {
                                                                                                                                    $MATCH->{'to'} = $m2->{'to'};
                                                                                                                                    $MATCH->{'Perlito5::Grammar::Expression.term_declarator'} = $m2;
                                                                                                                                    1
                                                                                                                                }
                                                                                                                                else {
                                                                                                                                    0
                                                                                                                                }
                                                                                                                            })) && ((do {
                                                                                                                                $MATCH->{'str'} = $str;
                                                                                                                                $MATCH->{'_tmp'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression.term_declarator'})->[1];
                                                                                                                                1
                                                                                                                            })))
                                                                                                                })) || ((do {
                                                                                                                    $MATCH->{'to'} = $pos1;
                                                                                                                    ((((do {
                                                                                                                                    my $m2 = Perlito5::Grammar->var_ident($str, $MATCH->{'to'});
                                                                                                                                    if ($m2) {
                                                                                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                                                                                        $MATCH->{'Perlito5::Grammar.var_ident'} = $m2;
                                                                                                                                        1
                                                                                                                                    }
                                                                                                                                    else {
                                                                                                                                        0
                                                                                                                                    }
                                                                                                                                })) && ((do {
                                                                                                                                    $MATCH->{'str'} = $str;
                                                                                                                                    $MATCH->{'_tmp'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.var_ident'});
                                                                                                                                    1
                                                                                                                                }))))
                                                                                                                })))
                                                                                                    }))) && ((do {
                                                                                                    my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                                                    if ($m2) {
                                                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                                                        1
                                                                                                    }
                                                                                                    else {
                                                                                                        0
                                                                                                    }
                                                                                                }))) && ((('(' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                                                            my $m2 = Perlito5::Grammar::Expression->paren_parse($str, $MATCH->{'to'});
                                                                                            if ($m2) {
                                                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                                                $MATCH->{'Perlito5::Grammar::Expression.paren_parse'} = $m2;
                                                                                                1
                                                                                            }
                                                                                            else {
                                                                                                0
                                                                                            }
                                                                                        }))) && (((')' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                                                    my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                                    if ($m2) {
                                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                                        1
                                                                                    }
                                                                                    else {
                                                                                        0
                                                                                    }
                                                                                }))) && ((('{' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                                            my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                            if ($m2) {
                                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                                1
                                                                            }
                                                                            else {
                                                                                0
                                                                            }
                                                                        }))) && ((do {
                                                                        my $m2 = Perlito5::Grammar->exp_stmts($str, $MATCH->{'to'});
                                                                        if ($m2) {
                                                                            $MATCH->{'to'} = $m2->{'to'};
                                                                            $MATCH->{'Perlito5::Grammar.exp_stmts'} = $m2;
                                                                            1
                                                                        }
                                                                        else {
                                                                            0
                                                                        }
                                                                    }))) && ((do {
                                                                    my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                    if ($m2) {
                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                        1
                                                                    }
                                                                    else {
                                                                        0
                                                                    }
                                                                }))) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                            my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                            if ($m2) {
                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                1
                                                            }
                                                            else {
                                                                0
                                                            }
                                                        }))) && ((do {
                                                        my $m2 = $grammar->opt_continue_block($str, $MATCH->{'to'});
                                                        if ($m2) {
                                                            $MATCH->{'to'} = $m2->{'to'};
                                                            $MATCH->{'opt_continue_block'} = $m2;
                                                            1
                                                        }
                                                        else {
                                                            0
                                                        }
                                                    }))) && ((do {
                                                    $MATCH->{'str'} = $str;
                                                    $MATCH->{'capture'} = Perlito5::AST::For->new('cond', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression.paren_parse'}), 'topic', undef(), 'body', Perlito5::AST::Lit::Block->new('stmts', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.exp_stmts'}), 'sig', $MATCH->{'_tmp'}), 'continue', $MATCH->{'opt_continue_block'}->{'capture'});
                                                    1
                                                })))
                                    })) || ((do {
                                        $MATCH->{'to'} = $pos1;
                                        ((((((((((((((((do {
                                                                                                        my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                                                        if ($m2) {
                                                                                                            $MATCH->{'to'} = $m2->{'to'};
                                                                                                            1
                                                                                                        }
                                                                                                        else {
                                                                                                            0
                                                                                                        }
                                                                                                    })) && ((('(' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                                                                    my $m2 = Perlito5::Grammar::Expression->exp_parse($str, $MATCH->{'to'});
                                                                                                    if ($m2) {
                                                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                                                        $MATCH->{'Perlito5::Grammar::Expression.exp_parse'} = $m2;
                                                                                                        1
                                                                                                    }
                                                                                                    else {
                                                                                                        0
                                                                                                    }
                                                                                                }))) && ((do {
                                                                                                my $pos1 = $MATCH->{'to'};
                                                                                                (((do {
                                                                                                            (((((((';' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                                                                                                    $MATCH->{'str'} = $str;
                                                                                                                                    $MATCH->{'c_style_for'} = 1;
                                                                                                                                    1
                                                                                                                                }))) && ((do {
                                                                                                                                my $pos1 = $MATCH->{'to'};
                                                                                                                                ((((do {
                                                                                                                                                my $m2 = Perlito5::Grammar->exp($str, $MATCH->{'to'});
                                                                                                                                                if ($m2) {
                                                                                                                                                    $MATCH->{'to'} = $m2->{'to'};
                                                                                                                                                    $MATCH->{'Perlito5::Grammar.exp'} = $m2;
                                                                                                                                                    1
                                                                                                                                                }
                                                                                                                                                else {
                                                                                                                                                    0
                                                                                                                                                }
                                                                                                                                            })) || ((do {
                                                                                                                                                $MATCH->{'to'} = $pos1;
                                                                                                                                                ()
                                                                                                                                            }))) || ((do {
                                                                                                                                            $MATCH->{'to'} = $pos1;
                                                                                                                                            ((do {
                                                                                                                                                    my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                                                                                                    if ($m2) {
                                                                                                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                                                                                                        1
                                                                                                                                                    }
                                                                                                                                                    else {
                                                                                                                                                        0
                                                                                                                                                    }
                                                                                                                                                }))
                                                                                                                                        })))
                                                                                                                            }))) && (((';' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                                                                                        my $pos1 = $MATCH->{'to'};
                                                                                                                        ((((do {
                                                                                                                                        my $m2 = Perlito5::Grammar->exp2($str, $MATCH->{'to'});
                                                                                                                                        if ($m2) {
                                                                                                                                            $MATCH->{'to'} = $m2->{'to'};
                                                                                                                                            $MATCH->{'Perlito5::Grammar.exp2'} = $m2;
                                                                                                                                            1
                                                                                                                                        }
                                                                                                                                        else {
                                                                                                                                            0
                                                                                                                                        }
                                                                                                                                    })) || ((do {
                                                                                                                                        $MATCH->{'to'} = $pos1;
                                                                                                                                        ()
                                                                                                                                    }))) || ((do {
                                                                                                                                    $MATCH->{'to'} = $pos1;
                                                                                                                                    ((do {
                                                                                                                                            my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                                                                                            if ($m2) {
                                                                                                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                                                                                                1
                                                                                                                                            }
                                                                                                                                            else {
                                                                                                                                                0
                                                                                                                                            }
                                                                                                                                        }))
                                                                                                                                })))
                                                                                                                    })))
                                                                                                        })) || ((do {
                                                                                                            $MATCH->{'to'} = $pos1;
                                                                                                            1
                                                                                                        })))
                                                                                            }))) && (((')' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                                                        my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                                        if ($m2) {
                                                                                            $MATCH->{'to'} = $m2->{'to'};
                                                                                            1
                                                                                        }
                                                                                        else {
                                                                                            0
                                                                                        }
                                                                                    }))) && ((('{' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                                                my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                                if ($m2) {
                                                                                    $MATCH->{'to'} = $m2->{'to'};
                                                                                    1
                                                                                }
                                                                                else {
                                                                                    0
                                                                                }
                                                                            }))) && ((do {
                                                                            my $m2 = Perlito5::Grammar->exp_stmts2($str, $MATCH->{'to'});
                                                                            if ($m2) {
                                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                                $MATCH->{'Perlito5::Grammar.exp_stmts2'} = $m2;
                                                                                1
                                                                            }
                                                                            else {
                                                                                0
                                                                            }
                                                                        }))) && ((do {
                                                                        my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                        if ($m2) {
                                                                            $MATCH->{'to'} = $m2->{'to'};
                                                                            1
                                                                        }
                                                                        else {
                                                                            0
                                                                        }
                                                                    }))) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                                my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                if ($m2) {
                                                                    $MATCH->{'to'} = $m2->{'to'};
                                                                    1
                                                                }
                                                                else {
                                                                    0
                                                                }
                                                            }))) && ((do {
                                                            my $m2 = $grammar->opt_continue_block($str, $MATCH->{'to'});
                                                            if ($m2) {
                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                $MATCH->{'opt_continue_block'} = $m2;
                                                                1
                                                            }
                                                            else {
                                                                0
                                                            }
                                                        }))) && ((do {
                                                        $MATCH->{'str'} = $str;
                                                        my $header;
                                                        if ($MATCH->{'c_style_for'}) {
                                                            $header = [$MATCH->{'Perlito5::Grammar::Expression.exp_parse'}->{'capture'}, $MATCH->{'Perlito5::Grammar.exp'}->{'capture'}, $MATCH->{'Perlito5::Grammar.exp2'}->{'capture'}]
                                                        }
                                                        else {
                                                            $header = $MATCH->{'Perlito5::Grammar::Expression.exp_parse'}->{'capture'}
                                                        };
                                                        $MATCH->{'capture'} = Perlito5::AST::For->new('cond', $header, 'topic', undef(), 'body', Perlito5::AST::Lit::Block->new('stmts', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.exp_stmts2'}), 'sig', undef()), 'continue', $MATCH->{'opt_continue_block'}->{'capture'});
                                                        1
                                                    }))))
                                    })))
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::while {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((((((((((((((((('while' eq substr($str, $MATCH->{'to'}, 5)) && ($MATCH->{'to'} = (5 + $MATCH->{'to'})))) && ((do {
                                                                            my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                            if ($m2) {
                                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                                1
                                                                            }
                                                                            else {
                                                                                0
                                                                            }
                                                                        }))) && ((('(' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                                    my $m2 = Perlito5::Grammar::Expression->paren_parse($str, $MATCH->{'to'});
                                                                    if ($m2) {
                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                        $MATCH->{'Perlito5::Grammar::Expression.paren_parse'} = $m2;
                                                                        1
                                                                    }
                                                                    else {
                                                                        0
                                                                    }
                                                                }))) && (((')' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                            my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                            if ($m2) {
                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                1
                                                            }
                                                            else {
                                                                0
                                                            }
                                                        }))) && ((('{' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                    my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }))) && ((do {
                                                my $m2 = Perlito5::Grammar->exp_stmts($str, $MATCH->{'to'});
                                                if ($m2) {
                                                    $MATCH->{'to'} = $m2->{'to'};
                                                    $MATCH->{'Perlito5::Grammar.exp_stmts'} = $m2;
                                                    1
                                                }
                                                else {
                                                    0
                                                }
                                            }))) && ((do {
                                            my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }))) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                    my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }))) && ((do {
                                my $m2 = $grammar->opt_continue_block($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    $MATCH->{'opt_continue_block'} = $m2;
                                    1
                                }
                                else {
                                    0
                                }
                            }))) && ((do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = Perlito5::AST::While->new('cond', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression.paren_parse'}), 'body', Perlito5::AST::Lit::Block->new('stmts', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.exp_stmts'}), 'sig', undef()), 'continue', $MATCH->{'opt_continue_block'}->{'capture'});
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::given {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = ((((((((((((((((('given' eq substr($str, $MATCH->{'to'}, 5)) && ($MATCH->{'to'} = (5 + $MATCH->{'to'})))) && ((do {
                                                                        my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                        if ($m2) {
                                                                            $MATCH->{'to'} = $m2->{'to'};
                                                                            1
                                                                        }
                                                                        else {
                                                                            0
                                                                        }
                                                                    }))) && ((('(' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                                my $m2 = Perlito5::Grammar::Expression->paren_parse($str, $MATCH->{'to'});
                                                                if ($m2) {
                                                                    $MATCH->{'to'} = $m2->{'to'};
                                                                    $MATCH->{'Perlito5::Grammar::Expression.paren_parse'} = $m2;
                                                                    1
                                                                }
                                                                else {
                                                                    0
                                                                }
                                                            }))) && (((')' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                        my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                        if ($m2) {
                                                            $MATCH->{'to'} = $m2->{'to'};
                                                            1
                                                        }
                                                        else {
                                                            0
                                                        }
                                                    }))) && ((('{' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                if ($m2) {
                                                    $MATCH->{'to'} = $m2->{'to'};
                                                    1
                                                }
                                                else {
                                                    0
                                                }
                                            }))) && ((do {
                                            my $m2 = Perlito5::Grammar->exp_stmts($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar.exp_stmts'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }))) && ((do {
                                        my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                        if ($m2) {
                                            $MATCH->{'to'} = $m2->{'to'};
                                            1
                                        }
                                        else {
                                            0
                                        }
                                    }))) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    1
                                }
                                else {
                                    0
                                }
                            }))) && ((do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = Perlito5::AST::Given->new('cond', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression.paren_parse'}), 'body', Perlito5::AST::Lit::Block->new('stmts', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.exp_stmts'}), 'sig', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.var_ident'})));
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::opt_continue_block {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((do {
                    my $pos1 = $MATCH->{'to'};
                    (((do {
                                (((((((((('continue' eq substr($str, $MATCH->{'to'}, 8)) && ($MATCH->{'to'} = (8 + $MATCH->{'to'})))) && ((do {
                                                                    my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                    if ($m2) {
                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                        1
                                                                    }
                                                                    else {
                                                                        0
                                                                    }
                                                                }))) && ((('{' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                            my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                            if ($m2) {
                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                1
                                                            }
                                                            else {
                                                                0
                                                            }
                                                        }))) && ((do {
                                                        my $m2 = Perlito5::Grammar->exp_stmts($str, $MATCH->{'to'});
                                                        if ($m2) {
                                                            $MATCH->{'to'} = $m2->{'to'};
                                                            $MATCH->{'Perlito5::Grammar.exp_stmts'} = $m2;
                                                            1
                                                        }
                                                        else {
                                                            0
                                                        }
                                                    }))) && ((do {
                                                    my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }))) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                            $MATCH->{'str'} = $str;
                                            $MATCH->{'capture'} = Perlito5::AST::Lit::Block->new('stmts', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.exp_stmts'}), 'sig', undef());
                                            1
                                        })))
                            })) || ((do {
                                $MATCH->{'to'} = $pos1;
                                ((do {
                                        $MATCH->{'str'} = $str;
                                        $MATCH->{'capture'} = Perlito5::AST::Lit::Block->new('stmts', [], 'sig', undef());
                                        1
                                    }))
                            })))
                })));
    ($tmp ? $MATCH : 0)
};

;

# use Perlito5::Grammar::Control
;
package main;
package Perlito5::Grammar::Regex;

# use Perlito5::Grammar::Precedence
;
sub Perlito5::Grammar::Regex::token {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((((((((do {
                                            my $m2 = Perlito5::Grammar->ident($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'Perlito5::Grammar.ident'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        })) && ((do {
                                            my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }))) && ((('{' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                    my $m2 = Perlito5::Grammar::Regex->rule($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::Regex.rule'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }))) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                            $MATCH->{'str'} = $str;
                            my $source = (Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.ident'}) . '{ ' . 'my $grammar = $_[0]; ' . 'my $str     = $_[1]; ' . 'my $pos     = $_[2]; ' . 'my $MATCH = { str => $str, from => $pos, to => $pos }; ' . 'my $tmp = ( ' . Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Regex.rule'})->emit_perl5() . '); ' . '$tmp ? $MATCH : 0; ' . '}');
                            my $ast = Perlito5::Grammar::Block->named_sub_def($source, 0);
                            $MATCH->{'capture'} = Perlito5::Match::flat($ast);
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Regex::term_token {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((((((('token' eq substr($str, $MATCH->{'to'}, 5)) && ($MATCH->{'to'} = (5 + $MATCH->{'to'})))) && ((do {
                                    my $m2 = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }))) && ((do {
                                my $m2 = $grammar->token($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    $MATCH->{'token'} = $m2;
                                    1
                                }
                                else {
                                    0
                                }
                            }))) && ((do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'token'})];
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
Perlito5::Grammar::Precedence::add_term('token', sub {
        Perlito5::Grammar::Regex->term_token($_[0], $_[1])
    });
sub Perlito5::Grammar::Regex::any {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((('' ne substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Regex::literal {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((do {
                    my $last_match_null = 0;
                    my $m = $MATCH;
                    my $to = $MATCH->{'to'};
                    for ( ; (((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (((do {
                                                ((((chr(92) eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((('' ne substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))))
                                            })) || ((do {
                                                $MATCH->{'to'} = $pos1;
                                                ((((do {
                                                                my $tmp = $MATCH;
                                                                $MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}};
                                                                my $res = (((chr(39) eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))));
                                                                $MATCH = ($res ? 0 : $tmp)
                                                            })) && ((('' ne substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
                                            })))
                                })) && (($last_match_null < 2))); {

                        } ) {
                        if (($to == $MATCH->{'to'})) {
                            $last_match_null = ($last_match_null + 1)
                        }
                        else {
                            $last_match_null = 0
                        };
                        $m = $MATCH;
                        $to = $MATCH->{'to'}
                    };
                    $MATCH = $m;
                    $MATCH->{'to'} = $to;
                    1
                })));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Regex::metasyntax_exp {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((do {
                    my $last_match_null = 0;
                    my $m = $MATCH;
                    my $to = $MATCH->{'to'};
                    my $count = 0;
                    for ( ; (((do {
                                    my $pos1 = $MATCH->{'to'};
                                    ((((((do {
                                                            ((((chr(92) eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((('' ne substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))))
                                                        })) || ((do {
                                                            $MATCH->{'to'} = $pos1;
                                                            ((((((chr(39) eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                                                my $m2 = $grammar->literal($str, $MATCH->{'to'});
                                                                                if ($m2) {
                                                                                    $MATCH->{'to'} = $m2->{'to'};
                                                                                    1
                                                                                }
                                                                                else {
                                                                                    0
                                                                                }
                                                                            }))) && (((chr(39) eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
                                                        }))) || ((do {
                                                        $MATCH->{'to'} = $pos1;
                                                        (((((('{' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                                            my $m2 = $grammar->string_code($str, $MATCH->{'to'});
                                                                            if ($m2) {
                                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                                1
                                                                            }
                                                                            else {
                                                                                0
                                                                            }
                                                                        }))) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
                                                    }))) || ((do {
                                                    $MATCH->{'to'} = $pos1;
                                                    (((((('<' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                                        my $m2 = $grammar->metasyntax_exp($str, $MATCH->{'to'});
                                                                        if ($m2) {
                                                                            $MATCH->{'to'} = $m2->{'to'};
                                                                            1
                                                                        }
                                                                        else {
                                                                            0
                                                                        }
                                                                    }))) && ((('>' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
                                                }))) || ((do {
                                                $MATCH->{'to'} = $pos1;
                                                ((((do {
                                                                my $tmp = $MATCH;
                                                                $MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}};
                                                                my $res = ((('>' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))));
                                                                $MATCH = ($res ? 0 : $tmp)
                                                            })) && ((('' ne substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
                                            })))
                                })) && (($last_match_null < 2))); {

                        } ) {
                        if (($to == $MATCH->{'to'})) {
                            $last_match_null = ($last_match_null + 1)
                        }
                        else {
                            $last_match_null = 0
                        };
                        $m = $MATCH;
                        $to = $MATCH->{'to'};
                        $count = ($count + 1)
                    };
                    $MATCH = $m;
                    $MATCH->{'to'} = $to;
                    ($count > 0)
                })));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Regex::string_code {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((do {
                    my $last_match_null = 0;
                    my $m = $MATCH;
                    my $to = $MATCH->{'to'};
                    my $count = 0;
                    for ( ; (((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (((((do {
                                                        ((((chr(92) eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((('' ne substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))))
                                                    })) || ((do {
                                                        $MATCH->{'to'} = $pos1;
                                                        ((((((chr(39) eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                                            my $m2 = $grammar->literal($str, $MATCH->{'to'});
                                                                            if ($m2) {
                                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                                1
                                                                            }
                                                                            else {
                                                                                0
                                                                            }
                                                                        }))) && (((chr(39) eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
                                                    }))) || ((do {
                                                    $MATCH->{'to'} = $pos1;
                                                    (((((('{' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                                        my $m2 = $grammar->string_code($str, $MATCH->{'to'});
                                                                        if ($m2) {
                                                                            $MATCH->{'to'} = $m2->{'to'};
                                                                            1
                                                                        }
                                                                        else {
                                                                            0
                                                                        }
                                                                    }))) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
                                                }))) || ((do {
                                                $MATCH->{'to'} = $pos1;
                                                ((((do {
                                                                my $tmp = $MATCH;
                                                                $MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}};
                                                                my $res = ((('}' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))));
                                                                $MATCH = ($res ? 0 : $tmp)
                                                            })) && ((('' ne substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
                                            })))
                                })) && (($last_match_null < 2))); {

                        } ) {
                        if (($to == $MATCH->{'to'})) {
                            $last_match_null = ($last_match_null + 1)
                        }
                        else {
                            $last_match_null = 0
                        };
                        $m = $MATCH;
                        $to = $MATCH->{'to'};
                        $count = ($count + 1)
                    };
                    $MATCH = $m;
                    $MATCH->{'to'} = $to;
                    ($count > 0)
                })));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Regex::parsed_code {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((((do {
                            my $m2 = $grammar->string_code($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        })) && ((do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = Perlito5::Match::flat($MATCH);
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Regex::rule_term {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((do {
                    my $pos1 = $MATCH->{'to'};
                    (((((((((do {
                                                        ((((((('<before' eq substr($str, $MATCH->{'to'}, 7)) && ($MATCH->{'to'} = (7 + $MATCH->{'to'})))) && ((do {
                                                                                my $m2 = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'});
                                                                                if ($m2) {
                                                                                    $MATCH->{'to'} = $m2->{'to'};
                                                                                    1
                                                                                }
                                                                                else {
                                                                                    0
                                                                                }
                                                                            }))) && ((do {
                                                                            my $m2 = $grammar->rule($str, $MATCH->{'to'});
                                                                            if ($m2) {
                                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                                $MATCH->{'rule'} = $m2;
                                                                                1
                                                                            }
                                                                            else {
                                                                                0
                                                                            }
                                                                        }))) && ((('>' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                                    $MATCH->{'str'} = $str;
                                                                    $MATCH->{'capture'} = Perlito5::Rul::Before->new('rule_exp', Perlito5::Match::flat($MATCH->{'rule'}));
                                                                    1
                                                                })))
                                                    })) || ((do {
                                                        $MATCH->{'to'} = $pos1;
                                                        (((((((('<!before' eq substr($str, $MATCH->{'to'}, 8)) && ($MATCH->{'to'} = (8 + $MATCH->{'to'})))) && ((do {
                                                                                    my $m2 = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'});
                                                                                    if ($m2) {
                                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                                        1
                                                                                    }
                                                                                    else {
                                                                                        0
                                                                                    }
                                                                                }))) && ((do {
                                                                                my $m2 = $grammar->rule($str, $MATCH->{'to'});
                                                                                if ($m2) {
                                                                                    $MATCH->{'to'} = $m2->{'to'};
                                                                                    $MATCH->{'rule'} = $m2;
                                                                                    1
                                                                                }
                                                                                else {
                                                                                    0
                                                                                }
                                                                            }))) && ((('>' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                                        $MATCH->{'str'} = $str;
                                                                        $MATCH->{'capture'} = Perlito5::Rul::NotBefore->new('rule_exp', Perlito5::Match::flat($MATCH->{'rule'}));
                                                                        1
                                                                    }))))
                                                    }))) || ((do {
                                                    $MATCH->{'to'} = $pos1;
                                                    (((((((chr(39) eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                                            my $m2 = $grammar->literal($str, $MATCH->{'to'});
                                                                            if ($m2) {
                                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                                $MATCH->{'literal'} = $m2;
                                                                                1
                                                                            }
                                                                            else {
                                                                                0
                                                                            }
                                                                        }))) && (((chr(39) eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                                    $MATCH->{'str'} = $str;
                                                                    $MATCH->{'capture'} = Perlito5::Rul::Constant->new('constant', Perlito5::Match::flat($MATCH->{'literal'}));
                                                                    1
                                                                }))))
                                                }))) || ((do {
                                                $MATCH->{'to'} = $pos1;
                                                ((((('<' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                                my $pos1 = $MATCH->{'to'};
                                                                (((do {
                                                                            (((((('.' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                                                                my $m2 = $grammar->metasyntax_exp($str, $MATCH->{'to'});
                                                                                                if ($m2) {
                                                                                                    $MATCH->{'to'} = $m2->{'to'};
                                                                                                    $MATCH->{'metasyntax_exp'} = $m2;
                                                                                                    1
                                                                                                }
                                                                                                else {
                                                                                                    0
                                                                                                }
                                                                                            }))) && ((('>' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                                                        $MATCH->{'str'} = $str;
                                                                                        $MATCH->{'capture'} = Perlito5::Rul::Subrule->new('metasyntax', Perlito5::Match::flat($MATCH->{'metasyntax_exp'}), 'captures', 0);
                                                                                        1
                                                                                    })))
                                                                        })) || ((do {
                                                                            $MATCH->{'to'} = $pos1;
                                                                            (((((do {
                                                                                                my $m2 = $grammar->metasyntax_exp($str, $MATCH->{'to'});
                                                                                                if ($m2) {
                                                                                                    $MATCH->{'to'} = $m2->{'to'};
                                                                                                    $MATCH->{'metasyntax_exp'} = $m2;
                                                                                                    1
                                                                                                }
                                                                                                else {
                                                                                                    0
                                                                                                }
                                                                                            })) && ((('>' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                                                            $MATCH->{'str'} = $str;
                                                                                            $MATCH->{'capture'} = Perlito5::Rul::Subrule->new('metasyntax', Perlito5::Match::flat($MATCH->{'metasyntax_exp'}), 'captures', 1);
                                                                                            1
                                                                                        }))))
                                                                        })))
                                                            }))))
                                            }))) || ((do {
                                            $MATCH->{'to'} = $pos1;
                                            ((((((('{' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                                    my $m2 = $grammar->parsed_code($str, $MATCH->{'to'});
                                                                    if ($m2) {
                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                        $MATCH->{'parsed_code'} = $m2;
                                                                        1
                                                                    }
                                                                    else {
                                                                        0
                                                                    }
                                                                }))) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                            $MATCH->{'str'} = $str;
                                                            $MATCH->{'capture'} = Perlito5::Rul::Block->new('closure', Perlito5::Match::flat($MATCH->{'parsed_code'}));
                                                            1
                                                        }))))
                                        }))) || ((do {
                                        $MATCH->{'to'} = $pos1;
                                        (((((chr(92) eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                        my $pos1 = $MATCH->{'to'};
                                                        ((((do {
                                                                        ((((((('c' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((('[' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                                                            my $m2 = Perlito5::Grammar->digits($str, $MATCH->{'to'});
                                                                                            if ($m2) {
                                                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                                                $MATCH->{'Perlito5::Grammar.digits'} = $m2;
                                                                                                1
                                                                                            }
                                                                                            else {
                                                                                                0
                                                                                            }
                                                                                        }))) && (((']' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                                                    $MATCH->{'str'} = $str;
                                                                                    $MATCH->{'capture'} = Perlito5::Rul::Constant->new('constant', chr(Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.digits'})));
                                                                                    1
                                                                                })))
                                                                    })) || ((do {
                                                                        $MATCH->{'to'} = $pos1;
                                                                        (((((('c' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                                                            my $m2 = Perlito5::Grammar->digits($str, $MATCH->{'to'});
                                                                                            if ($m2) {
                                                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                                                $MATCH->{'Perlito5::Grammar.digits'} = $m2;
                                                                                                1
                                                                                            }
                                                                                            else {
                                                                                                0
                                                                                            }
                                                                                        }))) && ((do {
                                                                                        $MATCH->{'str'} = $str;
                                                                                        $MATCH->{'capture'} = Perlito5::Rul::Constant->new('constant', chr(Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.digits'})));
                                                                                        1
                                                                                    }))))
                                                                    }))) || ((do {
                                                                    $MATCH->{'to'} = $pos1;
                                                                    ((((do {
                                                                                    my $m2 = $grammar->any($str, $MATCH->{'to'});
                                                                                    if ($m2) {
                                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                                        $MATCH->{'any'} = $m2;
                                                                                        1
                                                                                    }
                                                                                    else {
                                                                                        0
                                                                                    }
                                                                                })) && ((do {
                                                                                    $MATCH->{'str'} = $str;
                                                                                    $MATCH->{'capture'} = Perlito5::Rul::SpecialChar->new('char', Perlito5::Match::flat($MATCH->{'any'}));
                                                                                    1
                                                                                }))))
                                                                })))
                                                    }))))
                                    }))) || ((do {
                                    $MATCH->{'to'} = $pos1;
                                    ((((('.' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                    $MATCH->{'str'} = $str;
                                                    $MATCH->{'capture'} = Perlito5::Rul::Dot->new();
                                                    1
                                                }))))
                                }))) || ((do {
                                $MATCH->{'to'} = $pos1;
                                ((((((('[' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                        my $m2 = $grammar->rule($str, $MATCH->{'to'});
                                                        if ($m2) {
                                                            $MATCH->{'to'} = $m2->{'to'};
                                                            $MATCH->{'rule'} = $m2;
                                                            1
                                                        }
                                                        else {
                                                            0
                                                        }
                                                    }))) && (((']' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                $MATCH->{'str'} = $str;
                                                $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'rule'});
                                                1
                                            }))))
                            })))
                })));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Regex::quant_exp {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((do {
                    my $pos1 = $MATCH->{'to'};
                    ((((do {
                                    (('?' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))
                                })) || ((do {
                                    $MATCH->{'to'} = $pos1;
                                    ((('*' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
                                }))) || ((do {
                                $MATCH->{'to'} = $pos1;
                                ((('+' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
                            })))
                })));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Regex::quantifier {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((((((do {
                                    my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'Perlito5::Grammar::Space.opt_ws'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                })) && ((do {
                                    my $m2 = $grammar->rule_term($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'rule_term'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }))) && ((do {
                                my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    $MATCH->{'Perlito5::Grammar::Space.opt_ws'} = $m2;
                                    1
                                }
                                else {
                                    0
                                }
                            }))) && ((do {
                            my $pos1 = $MATCH->{'to'};
                            (((do {
                                        ((((do {
                                                        my $m2 = $grammar->quant_exp($str, $MATCH->{'to'});
                                                        if ($m2) {
                                                            $MATCH->{'to'} = $m2->{'to'};
                                                            $MATCH->{'quant_exp'} = $m2;
                                                            1
                                                        }
                                                        else {
                                                            0
                                                        }
                                                    })) && ((do {
                                                        my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                        if ($m2) {
                                                            $MATCH->{'to'} = $m2->{'to'};
                                                            $MATCH->{'Perlito5::Grammar::Space.opt_ws'} = $m2;
                                                            1
                                                        }
                                                        else {
                                                            0
                                                        }
                                                    }))) && ((do {
                                                    $MATCH->{'str'} = $str;
                                                    $MATCH->{'capture'} = Perlito5::Rul::Quantifier->new('term', Perlito5::Match::flat($MATCH->{'rule_term'}), 'quant', Perlito5::Match::flat($MATCH->{'quant_exp'}));
                                                    1
                                                })))
                                    })) || ((do {
                                        $MATCH->{'to'} = $pos1;
                                        ((do {
                                                $MATCH->{'str'} = $str;
                                                $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'rule_term'});
                                                1
                                            }))
                                    })))
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Regex::concat_list {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((do {
                    my $pos1 = $MATCH->{'to'};
                    (((do {
                                (((do {
                                            my $m2 = $grammar->quantifier($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'quantifier'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        })) && ((do {
                                            my $pos1 = $MATCH->{'to'};
                                            (((do {
                                                        (((do {
                                                                    my $m2 = $grammar->concat_list($str, $MATCH->{'to'});
                                                                    if ($m2) {
                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                        $MATCH->{'concat_list'} = $m2;
                                                                        1
                                                                    }
                                                                    else {
                                                                        0
                                                                    }
                                                                })) && ((do {
                                                                    $MATCH->{'str'} = $str;
                                                                    $MATCH->{'capture'} = [Perlito5::Match::flat($MATCH->{'quantifier'}), @{Perlito5::Match::flat($MATCH->{'concat_list'})}];
                                                                    1
                                                                })))
                                                    })) || ((do {
                                                        $MATCH->{'to'} = $pos1;
                                                        ((do {
                                                                $MATCH->{'str'} = $str;
                                                                $MATCH->{'capture'} = [Perlito5::Match::flat($MATCH->{'quantifier'})];
                                                                1
                                                            }))
                                                    })))
                                        })))
                            })) || ((do {
                                $MATCH->{'to'} = $pos1;
                                ((do {
                                        $MATCH->{'str'} = $str;
                                        $MATCH->{'capture'} = [];
                                        1
                                    }))
                            })))
                })));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Regex::concat_exp {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((((do {
                            my $m2 = $grammar->concat_list($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'concat_list'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        })) && ((do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = Perlito5::Rul::Concat->new('concat', Perlito5::Match::flat($MATCH->{'concat_list'}));
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Regex::or_list_exp {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((do {
                    my $pos1 = $MATCH->{'to'};
                    (((do {
                                (((do {
                                            my $m2 = $grammar->concat_exp($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                $MATCH->{'concat_exp'} = $m2;
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        })) && ((do {
                                            my $pos1 = $MATCH->{'to'};
                                            (((do {
                                                        ((((('|' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                                        my $m2 = $grammar->or_list_exp($str, $MATCH->{'to'});
                                                                        if ($m2) {
                                                                            $MATCH->{'to'} = $m2->{'to'};
                                                                            $MATCH->{'or_list_exp'} = $m2;
                                                                            1
                                                                        }
                                                                        else {
                                                                            0
                                                                        }
                                                                    }))) && ((do {
                                                                    $MATCH->{'str'} = $str;
                                                                    $MATCH->{'capture'} = [Perlito5::Match::flat($MATCH->{'concat_exp'}), @{Perlito5::Match::flat($MATCH->{'or_list_exp'})}];
                                                                    1
                                                                })))
                                                    })) || ((do {
                                                        $MATCH->{'to'} = $pos1;
                                                        ((do {
                                                                $MATCH->{'str'} = $str;
                                                                $MATCH->{'capture'} = [Perlito5::Match::flat($MATCH->{'concat_exp'})];
                                                                1
                                                            }))
                                                    })))
                                        })))
                            })) || ((do {
                                $MATCH->{'to'} = $pos1;
                                ((do {
                                        $MATCH->{'str'} = $str;
                                        $MATCH->{'capture'} = [];
                                        1
                                    }))
                            })))
                })));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Regex::rule {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = ((((((do {
                                my $pos1 = $MATCH->{'to'};
                                (((do {
                                            (((do {
                                                        my $m = $MATCH;
                                                        if (!(((do {
                                                                        my $m2 = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'});
                                                                        if ($m2) {
                                                                            $MATCH->{'to'} = $m2->{'to'};
                                                                            1
                                                                        }
                                                                        else {
                                                                            0
                                                                        }
                                                                    })))) {
                                                            $MATCH = $m
                                                        };
                                                        1
                                                    })) && ((('|' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))))
                                        })) || ((do {
                                            $MATCH->{'to'} = $pos1;
                                            1
                                        })))
                            })) && ((do {
                                my $m2 = $grammar->or_list_exp($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    $MATCH->{'or_list_exp'} = $m2;
                                    1
                                }
                                else {
                                    0
                                }
                            }))) && ((do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = Perlito5::Rul::Or->new('or_list', Perlito5::Match::flat($MATCH->{'or_list_exp'}));
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};

;

# use Perlito5::Grammar::Regex
;
package main;
undef();
package Perlito5::Grammar::String;

# use Perlito5::Grammar::Precedence
;
Perlito5::Grammar::Precedence::add_term(chr(39), sub {
        Perlito5::Grammar::String->term_q_quote($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('"', sub {
        Perlito5::Grammar::String->term_qq_quote($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('/', sub {
        Perlito5::Grammar::String->term_m_quote($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('<', sub {
        Perlito5::Grammar::String->term_glob($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('<<', sub {
        Perlito5::Grammar::String->here_doc_wanted($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('`', sub {
        Perlito5::Grammar::String->term_qx($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('m', sub {
        Perlito5::Grammar::String->term_m_quote($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('q', sub {
        Perlito5::Grammar::String->term_q_quote($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('qq', sub {
        Perlito5::Grammar::String->term_qq_quote($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('qw', sub {
        Perlito5::Grammar::String->term_qw_quote($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('qx', sub {
        Perlito5::Grammar::String->term_qx($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('qr', sub {
        Perlito5::Grammar::String->term_qr_quote($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('s', sub {
        Perlito5::Grammar::String->term_s_quote($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('tr', sub {
        Perlito5::Grammar::String->term_tr_quote($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('y', sub {
        Perlito5::Grammar::String->term_tr_quote($_[0], $_[1])
    });
sub Perlito5::Grammar::String::term_q_quote {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = ((((((do {
                                my $pos1 = $MATCH->{'to'};
                                (((do {
                                            (((('q' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                        my $pos1 = $MATCH->{'to'};
                                                        (((do {
                                                                    (('#' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))
                                                                })) || ((do {
                                                                    $MATCH->{'to'} = $pos1;
                                                                    (((((do {
                                                                                        my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                                        if ($m2) {
                                                                                            $MATCH->{'to'} = $m2->{'to'};
                                                                                            1
                                                                                        }
                                                                                        else {
                                                                                            0
                                                                                        }
                                                                                    })) && ((do {
                                                                                        my $tmp = $MATCH;
                                                                                        $MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}};
                                                                                        my $res = ((do {
                                                                                                    my $pos1 = $MATCH->{'to'};
                                                                                                    ((((do {
                                                                                                                    my $m2 = Perlito5::Grammar->word($str, $MATCH->{'to'});
                                                                                                                    if ($m2) {
                                                                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                                                                        1
                                                                                                                    }
                                                                                                                    else {
                                                                                                                        0
                                                                                                                    }
                                                                                                                })) || ((do {
                                                                                                                    $MATCH->{'to'} = $pos1;
                                                                                                                    ()
                                                                                                                }))) || ((do {
                                                                                                                $MATCH->{'to'} = $pos1;
                                                                                                                ((('=>' eq substr($str, $MATCH->{'to'}, 2)) && ($MATCH->{'to'} = (2 + $MATCH->{'to'}))))
                                                                                                            })))
                                                                                                }));
                                                                                        $MATCH = ($res ? 0 : $tmp)
                                                                                    }))) && ((('' ne substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
                                                                })))
                                                    })))
                                        })) || ((do {
                                            $MATCH->{'to'} = $pos1;
                                            (((chr(39) eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
                                        })))
                            })) && ((do {
                                my $m2 = $grammar->q_quote_parse($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    $MATCH->{'q_quote_parse'} = $m2;
                                    1
                                }
                                else {
                                    0
                                }
                            }))) && ((do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'q_quote_parse'})];
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::String::term_qq_quote {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = ((((((do {
                                my $pos1 = $MATCH->{'to'};
                                (((do {
                                            (((('qq' eq substr($str, $MATCH->{'to'}, 2)) && ($MATCH->{'to'} = (2 + $MATCH->{'to'})))) && ((do {
                                                        my $pos1 = $MATCH->{'to'};
                                                        (((do {
                                                                    (('#' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))
                                                                })) || ((do {
                                                                    $MATCH->{'to'} = $pos1;
                                                                    (((((do {
                                                                                        my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                                        if ($m2) {
                                                                                            $MATCH->{'to'} = $m2->{'to'};
                                                                                            1
                                                                                        }
                                                                                        else {
                                                                                            0
                                                                                        }
                                                                                    })) && ((do {
                                                                                        my $tmp = $MATCH;
                                                                                        $MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}};
                                                                                        my $res = ((do {
                                                                                                    my $pos1 = $MATCH->{'to'};
                                                                                                    ((((do {
                                                                                                                    my $m2 = Perlito5::Grammar->word($str, $MATCH->{'to'});
                                                                                                                    if ($m2) {
                                                                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                                                                        1
                                                                                                                    }
                                                                                                                    else {
                                                                                                                        0
                                                                                                                    }
                                                                                                                })) || ((do {
                                                                                                                    $MATCH->{'to'} = $pos1;
                                                                                                                    ()
                                                                                                                }))) || ((do {
                                                                                                                $MATCH->{'to'} = $pos1;
                                                                                                                ((('=>' eq substr($str, $MATCH->{'to'}, 2)) && ($MATCH->{'to'} = (2 + $MATCH->{'to'}))))
                                                                                                            })))
                                                                                                }));
                                                                                        $MATCH = ($res ? 0 : $tmp)
                                                                                    }))) && ((('' ne substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
                                                                })))
                                                    })))
                                        })) || ((do {
                                            $MATCH->{'to'} = $pos1;
                                            ((('"' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
                                        })))
                            })) && ((do {
                                my $m2 = $grammar->qq_quote_parse($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    $MATCH->{'qq_quote_parse'} = $m2;
                                    1
                                }
                                else {
                                    0
                                }
                            }))) && ((do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'qq_quote_parse'})];
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::String::term_qw_quote {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((((((('qw' eq substr($str, $MATCH->{'to'}, 2)) && ($MATCH->{'to'} = (2 + $MATCH->{'to'})))) && ((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (((do {
                                                (('#' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))
                                            })) || ((do {
                                                $MATCH->{'to'} = $pos1;
                                                (((((do {
                                                                    my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                    if ($m2) {
                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                        1
                                                                    }
                                                                    else {
                                                                        0
                                                                    }
                                                                })) && ((do {
                                                                    my $tmp = $MATCH;
                                                                    $MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}};
                                                                    my $res = ((do {
                                                                                my $pos1 = $MATCH->{'to'};
                                                                                ((((do {
                                                                                                my $m2 = Perlito5::Grammar->word($str, $MATCH->{'to'});
                                                                                                if ($m2) {
                                                                                                    $MATCH->{'to'} = $m2->{'to'};
                                                                                                    1
                                                                                                }
                                                                                                else {
                                                                                                    0
                                                                                                }
                                                                                            })) || ((do {
                                                                                                $MATCH->{'to'} = $pos1;
                                                                                                ()
                                                                                            }))) || ((do {
                                                                                            $MATCH->{'to'} = $pos1;
                                                                                            ((('=>' eq substr($str, $MATCH->{'to'}, 2)) && ($MATCH->{'to'} = (2 + $MATCH->{'to'}))))
                                                                                        })))
                                                                            }));
                                                                    $MATCH = ($res ? 0 : $tmp)
                                                                }))) && ((('' ne substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
                                            })))
                                }))) && ((do {
                                my $m2 = $grammar->qw_quote_parse($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    $MATCH->{'qw_quote_parse'} = $m2;
                                    1
                                }
                                else {
                                    0
                                }
                            }))) && ((do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'qw_quote_parse'})];
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::String::term_m_quote {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = ((((((do {
                                my $pos1 = $MATCH->{'to'};
                                (((do {
                                            (((('m' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                        my $pos1 = $MATCH->{'to'};
                                                        (((do {
                                                                    (('#' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))
                                                                })) || ((do {
                                                                    $MATCH->{'to'} = $pos1;
                                                                    (((((do {
                                                                                        my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                                        if ($m2) {
                                                                                            $MATCH->{'to'} = $m2->{'to'};
                                                                                            1
                                                                                        }
                                                                                        else {
                                                                                            0
                                                                                        }
                                                                                    })) && ((do {
                                                                                        my $tmp = $MATCH;
                                                                                        $MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}};
                                                                                        my $res = ((do {
                                                                                                    my $pos1 = $MATCH->{'to'};
                                                                                                    ((((do {
                                                                                                                    my $m2 = Perlito5::Grammar->word($str, $MATCH->{'to'});
                                                                                                                    if ($m2) {
                                                                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                                                                        1
                                                                                                                    }
                                                                                                                    else {
                                                                                                                        0
                                                                                                                    }
                                                                                                                })) || ((do {
                                                                                                                    $MATCH->{'to'} = $pos1;
                                                                                                                    ()
                                                                                                                }))) || ((do {
                                                                                                                $MATCH->{'to'} = $pos1;
                                                                                                                ((('=>' eq substr($str, $MATCH->{'to'}, 2)) && ($MATCH->{'to'} = (2 + $MATCH->{'to'}))))
                                                                                                            })))
                                                                                                }));
                                                                                        $MATCH = ($res ? 0 : $tmp)
                                                                                    }))) && ((('' ne substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
                                                                })))
                                                    })))
                                        })) || ((do {
                                            $MATCH->{'to'} = $pos1;
                                            ((('/' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
                                        })))
                            })) && ((do {
                                my $m2 = $grammar->m_quote_parse($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    $MATCH->{'m_quote_parse'} = $m2;
                                    1
                                }
                                else {
                                    0
                                }
                            }))) && ((do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'m_quote_parse'})];
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::String::term_s_quote {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((((((('s' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (((do {
                                                (('#' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))
                                            })) || ((do {
                                                $MATCH->{'to'} = $pos1;
                                                (((((do {
                                                                    my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                    if ($m2) {
                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                        1
                                                                    }
                                                                    else {
                                                                        0
                                                                    }
                                                                })) && ((do {
                                                                    my $tmp = $MATCH;
                                                                    $MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}};
                                                                    my $res = ((do {
                                                                                my $pos1 = $MATCH->{'to'};
                                                                                ((((do {
                                                                                                my $m2 = Perlito5::Grammar->word($str, $MATCH->{'to'});
                                                                                                if ($m2) {
                                                                                                    $MATCH->{'to'} = $m2->{'to'};
                                                                                                    1
                                                                                                }
                                                                                                else {
                                                                                                    0
                                                                                                }
                                                                                            })) || ((do {
                                                                                                $MATCH->{'to'} = $pos1;
                                                                                                ()
                                                                                            }))) || ((do {
                                                                                            $MATCH->{'to'} = $pos1;
                                                                                            ((('=>' eq substr($str, $MATCH->{'to'}, 2)) && ($MATCH->{'to'} = (2 + $MATCH->{'to'}))))
                                                                                        })))
                                                                            }));
                                                                    $MATCH = ($res ? 0 : $tmp)
                                                                }))) && ((('' ne substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
                                            })))
                                }))) && ((do {
                                my $m2 = $grammar->s_quote_parse($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    $MATCH->{'s_quote_parse'} = $m2;
                                    1
                                }
                                else {
                                    0
                                }
                            }))) && ((do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'s_quote_parse'})];
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::String::term_qx {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = ((((((do {
                                my $pos1 = $MATCH->{'to'};
                                (((do {
                                            (((('qx' eq substr($str, $MATCH->{'to'}, 2)) && ($MATCH->{'to'} = (2 + $MATCH->{'to'})))) && ((do {
                                                        my $pos1 = $MATCH->{'to'};
                                                        (((do {
                                                                    (('#' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))
                                                                })) || ((do {
                                                                    $MATCH->{'to'} = $pos1;
                                                                    (((((do {
                                                                                        my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                                        if ($m2) {
                                                                                            $MATCH->{'to'} = $m2->{'to'};
                                                                                            1
                                                                                        }
                                                                                        else {
                                                                                            0
                                                                                        }
                                                                                    })) && ((do {
                                                                                        my $tmp = $MATCH;
                                                                                        $MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}};
                                                                                        my $res = ((do {
                                                                                                    my $pos1 = $MATCH->{'to'};
                                                                                                    ((((do {
                                                                                                                    my $m2 = Perlito5::Grammar->word($str, $MATCH->{'to'});
                                                                                                                    if ($m2) {
                                                                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                                                                        1
                                                                                                                    }
                                                                                                                    else {
                                                                                                                        0
                                                                                                                    }
                                                                                                                })) || ((do {
                                                                                                                    $MATCH->{'to'} = $pos1;
                                                                                                                    ()
                                                                                                                }))) || ((do {
                                                                                                                $MATCH->{'to'} = $pos1;
                                                                                                                ((('=>' eq substr($str, $MATCH->{'to'}, 2)) && ($MATCH->{'to'} = (2 + $MATCH->{'to'}))))
                                                                                                            })))
                                                                                                }));
                                                                                        $MATCH = ($res ? 0 : $tmp)
                                                                                    }))) && ((('' ne substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
                                                                })))
                                                    })))
                                        })) || ((do {
                                            $MATCH->{'to'} = $pos1;
                                            ((('`' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
                                        })))
                            })) && ((do {
                                my $m2 = $grammar->qx_quote_parse($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    $MATCH->{'qx_quote_parse'} = $m2;
                                    1
                                }
                                else {
                                    0
                                }
                            }))) && ((do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'qx_quote_parse'})];
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::String::term_glob {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = ((((((('<' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                my $m2 = $grammar->glob_quote_parse($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    $MATCH->{'glob_quote_parse'} = $m2;
                                    1
                                }
                                else {
                                    0
                                }
                            }))) && ((do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'glob_quote_parse'})];
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::String::term_tr_quote {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((((((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (((do {
                                                (('tr' eq substr($str, $MATCH->{'to'}, 2)) && ($MATCH->{'to'} = (2 + $MATCH->{'to'})))
                                            })) || ((do {
                                                $MATCH->{'to'} = $pos1;
                                                ((('y' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
                                            })))
                                })) && ((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (((do {
                                                (('#' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))
                                            })) || ((do {
                                                $MATCH->{'to'} = $pos1;
                                                (((((do {
                                                                    my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                    if ($m2) {
                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                        1
                                                                    }
                                                                    else {
                                                                        0
                                                                    }
                                                                })) && ((do {
                                                                    my $tmp = $MATCH;
                                                                    $MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}};
                                                                    my $res = ((do {
                                                                                my $pos1 = $MATCH->{'to'};
                                                                                ((((do {
                                                                                                my $m2 = Perlito5::Grammar->word($str, $MATCH->{'to'});
                                                                                                if ($m2) {
                                                                                                    $MATCH->{'to'} = $m2->{'to'};
                                                                                                    1
                                                                                                }
                                                                                                else {
                                                                                                    0
                                                                                                }
                                                                                            })) || ((do {
                                                                                                $MATCH->{'to'} = $pos1;
                                                                                                ()
                                                                                            }))) || ((do {
                                                                                            $MATCH->{'to'} = $pos1;
                                                                                            ((('=>' eq substr($str, $MATCH->{'to'}, 2)) && ($MATCH->{'to'} = (2 + $MATCH->{'to'}))))
                                                                                        })))
                                                                            }));
                                                                    $MATCH = ($res ? 0 : $tmp)
                                                                }))) && ((('' ne substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
                                            })))
                                }))) && ((do {
                                my $m2 = $grammar->tr_quote_parse($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    $MATCH->{'tr_quote_parse'} = $m2;
                                    1
                                }
                                else {
                                    0
                                }
                            }))) && ((do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'tr_quote_parse'})];
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::String::term_qr_quote {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((((((('qr' eq substr($str, $MATCH->{'to'}, 2)) && ($MATCH->{'to'} = (2 + $MATCH->{'to'})))) && ((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (((do {
                                                (('#' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))
                                            })) || ((do {
                                                $MATCH->{'to'} = $pos1;
                                                (((((do {
                                                                    my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                    if ($m2) {
                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                        1
                                                                    }
                                                                    else {
                                                                        0
                                                                    }
                                                                })) && ((do {
                                                                    my $tmp = $MATCH;
                                                                    $MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}};
                                                                    my $res = ((do {
                                                                                my $pos1 = $MATCH->{'to'};
                                                                                ((((do {
                                                                                                my $m2 = Perlito5::Grammar->word($str, $MATCH->{'to'});
                                                                                                if ($m2) {
                                                                                                    $MATCH->{'to'} = $m2->{'to'};
                                                                                                    1
                                                                                                }
                                                                                                else {
                                                                                                    0
                                                                                                }
                                                                                            })) || ((do {
                                                                                                $MATCH->{'to'} = $pos1;
                                                                                                ()
                                                                                            }))) || ((do {
                                                                                            $MATCH->{'to'} = $pos1;
                                                                                            ((('=>' eq substr($str, $MATCH->{'to'}, 2)) && ($MATCH->{'to'} = (2 + $MATCH->{'to'}))))
                                                                                        })))
                                                                            }));
                                                                    $MATCH = ($res ? 0 : $tmp)
                                                                }))) && ((('' ne substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
                                            })))
                                }))) && ((do {
                                my $m2 = $grammar->qr_quote_parse($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    $MATCH->{'qr_quote_parse'} = $m2;
                                    1
                                }
                                else {
                                    0
                                }
                            }))) && ((do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'qr_quote_parse'})];
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
my %pair = ('{', '}', '(', ')', '[', ']', '<', '>');
my %escape_sequence = ('a', '7', 'b', '8', 'e', '27', 'f', '12', 'n', '10', 'r', '13', 't', '9');
my %hex = map(+(($_, 1)), ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'));
my %octal = map(+(($_, 1)), ('0', '1', '2', '3', '4', '5', '6', '7'));
sub Perlito5::Grammar::String::q_quote_parse {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $delimiter = substr($str, ($pos - 1), 1);
    my $open_delimiter = $delimiter;
    $delimiter = $pair{$delimiter} if exists($pair{$delimiter});
    return $self->string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 0)
};
sub Perlito5::Grammar::String::qq_quote_parse {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $delimiter = substr($str, ($pos - 1), 1);
    my $open_delimiter = $delimiter;
    $delimiter = $pair{$delimiter} if exists($pair{$delimiter});
    return $self->string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 1)
};
sub Perlito5::Grammar::String::qw_quote_parse {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $delimiter = substr($str, ($pos - 1), 1);
    my $open_delimiter = $delimiter;
    $delimiter = $pair{$delimiter} if exists($pair{$delimiter});
    my $m = $self->string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 0);
    if ($m) {
        $m->{'capture'} = Perlito5::AST::Apply->new('code', 'list:<,>', 'arguments', [map(Perlito5::AST::Val::Buf->new('buf', $_), split(' ', Perlito5::Match::flat($m)->{'buf'}))], 'namespace', '')
    };
    return $m
};
sub Perlito5::Grammar::String::m_quote_parse {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $delimiter = substr($str, ($pos - 1), 1);
    my $open_delimiter = $delimiter;
    my $closing_delimiter = $delimiter;
    $closing_delimiter = $pair{$delimiter} if exists($pair{$delimiter});
    my $part1 = $self->string_interpolation_parse($str, $pos, $open_delimiter, $closing_delimiter, 2);
    return $part1 unless $part1;
    my $str_regex = $part1->{'capture'};
    my $p = $part1->{'to'};
    my $modifiers = '';
    my $m = Perlito5::Grammar->ident($str, $p);
    if ($m) {
        $modifiers = Perlito5::Match::flat($m);
        $part1->{'to'} = $m->{'to'}
    };
    $part1->{'capture'} = Perlito5::AST::Apply->new('code', 'p5:m', 'arguments', [$str_regex, $modifiers], 'namespace', '');
    return $part1
};
sub Perlito5::Grammar::String::s_quote_parse {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $delimiter = substr($str, ($pos - 1), 1);
    my $open_delimiter = $delimiter;
    my $closing_delimiter = $delimiter;
    $closing_delimiter = $pair{$delimiter} if exists($pair{$delimiter});
    my $part1 = $self->string_interpolation_parse($str, $pos, $open_delimiter, $closing_delimiter, 1);
    return $part1 unless $part1;
    my $str_regex = Perlito5::AST::Val::Buf->new('buf', substr($str, $pos, (($part1->{'to'} - $pos) - 1)));
    my $part2;
    my $m;
    my $p = $part1->{'to'};
    if (exists($pair{$delimiter})) {
        $m = Perlito5::Grammar::Space->opt_ws($str, $p);
        $p = $m->{'to'};
        $delimiter = substr($str, $p, 1);
        my $open_delimiter = $delimiter;
        ($p)++;
        $closing_delimiter = $delimiter;
        $closing_delimiter = $pair{$delimiter} if exists($pair{$delimiter});
        $part2 = $self->string_interpolation_parse($str, $p, $open_delimiter, $closing_delimiter, 1);
        return $part2 unless $part2
    }
    else {
        $part2 = $self->string_interpolation_parse($str, $p, $open_delimiter, $closing_delimiter, 1);
        return $part2 unless $part2
    };
    $p = $part2->{'to'};
    my $modifiers = '';
    $m = Perlito5::Grammar->ident($str, $p);
    if ($m) {
        $modifiers = Perlito5::Match::flat($m);
        $part2->{'to'} = $m->{'to'}
    };
    $part2->{'capture'} = Perlito5::AST::Apply->new('code', 'p5:s', 'arguments', [$str_regex, Perlito5::Match::flat($part2), $modifiers], 'namespace', '');
    return $part2
};
sub Perlito5::Grammar::String::qr_quote_parse {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $delimiter = substr($str, ($pos - 1), 1);
    my $open_delimiter = $delimiter;
    my $closing_delimiter = $delimiter;
    $closing_delimiter = $pair{$delimiter} if exists($pair{$delimiter});
    my $part1 = $self->string_interpolation_parse($str, $pos, $open_delimiter, $closing_delimiter, 2);
    return $part1 unless $part1;
    my $str_regex = $part1->{'capture'};
    my $p = $part1->{'to'};
    my $modifiers = '';
    my $m = Perlito5::Grammar->ident($str, $p);
    if ($m) {
        $modifiers = Perlito5::Match::flat($m);
        $part1->{'to'} = $m->{'to'}
    };
    $part1->{'capture'} = Perlito5::AST::Apply->new('code', 'p5:qr', 'arguments', [$str_regex, $modifiers], 'namespace', '');
    return $part1
};
sub Perlito5::Grammar::String::qx_quote_parse {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $delimiter = substr($str, ($pos - 1), 1);
    my $open_delimiter = $delimiter;
    $delimiter = $pair{$delimiter} if exists($pair{$delimiter});
    my $m = $self->string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 0);
    if ($m) {
        $m->{'capture'} = Perlito5::AST::Apply->new('code', 'qx', 'arguments', [Perlito5::Match::flat($m)], 'namespace', '')
    };
    return $m
};
sub Perlito5::Grammar::String::glob_quote_parse {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $delimiter = substr($str, ($pos - 1), 1);
    my $open_delimiter = $delimiter;
    $delimiter = $pair{$delimiter} if exists($pair{$delimiter});
    my $m = $self->string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 0);
    if ($m) {
        $m->{'capture'} = Perlito5::AST::Apply->new('code', 'glob', 'arguments', [Perlito5::Match::flat($m)], 'namespace', '')
    };
    return $m
};
sub Perlito5::Grammar::String::tr_quote_parse {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $delimiter = substr($str, ($pos - 1), 1);
    my $open_delimiter = $delimiter;
    my $closing_delimiter = $delimiter;
    $closing_delimiter = $pair{$delimiter} if exists($pair{$delimiter});
    my $part1 = $self->string_interpolation_parse($str, $pos, $open_delimiter, $closing_delimiter, 1);
    return $part1 unless $part1;
    my $str_regex = Perlito5::AST::Val::Buf->new('buf', substr($str, $pos, (($part1->{'to'} - $pos) - 1)));
    my $part2;
    my $m;
    my $p = $part1->{'to'};
    if (exists($pair{$delimiter})) {
        $m = Perlito5::Grammar::Space->opt_ws($str, $p);
        $p = $m->{'to'};
        $delimiter = substr($str, $p, 1);
        my $open_delimiter = $delimiter;
        ($p)++;
        $closing_delimiter = $delimiter;
        $closing_delimiter = $pair{$delimiter} if exists($pair{$delimiter});
        $part2 = $self->string_interpolation_parse($str, $p, $open_delimiter, $closing_delimiter, 1);
        return $part2 unless $part2
    }
    else {
        $part2 = $self->string_interpolation_parse($str, $p, $open_delimiter, $closing_delimiter, 1);
        return $part2 unless $part2
    };
    $p = $part2->{'to'};
    my $modifiers = '';
    $m = Perlito5::Grammar->ident($str, $p);
    if ($m) {
        $modifiers = Perlito5::Match::flat($m);
        $part2->{'to'} = $m->{'to'}
    };
    $part2->{'capture'} = Perlito5::AST::Apply->new('code', 'p5:tr', 'arguments', [$str_regex, Perlito5::Match::flat($part2), $modifiers], 'namespace', '');
    return $part2
};
sub Perlito5::Grammar::String::string_interpolation_parse {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $open_delimiter = $_[3];
    my $delimiter = $_[4];
    my $interpolate = $_[5];
    my $p = $pos;
    my $balanced = ($open_delimiter && exists($pair{$open_delimiter}));
    my @args;
    my $buf = '';
    for ( ; (($p < length($str)) && (substr($str, $p, length($delimiter)) ne $delimiter)); {

        } ) {
        my $c = substr($str, $p, 1);
        my $c2 = substr($str, ($p + 1), 1);
        my $m;
        my $more = '';
        if ((($balanced && ($c eq chr(92))) && ((($c2 eq $open_delimiter) || ($c2 eq $delimiter))))) {
            ($p)++;
            $c = $c2
        }
        else {
            if (($balanced && ($c eq $open_delimiter))) {
                $buf = ($buf . $c);
                ($p)++;
                $m = $self->string_interpolation_parse($str, $p, $open_delimiter, $delimiter, $interpolate);
                $more = $delimiter
            }
            else {
                if (($interpolate && ((($c eq '$') || ($c eq '@'))))) {
                    $m = Perlito5::Grammar::String->double_quoted_var($str, $p, $delimiter, $interpolate)
                }
                else {
                    if (($c eq chr(92))) {
                        if (($interpolate == 2)) {
                            $m = {'str', $str, 'from', $p, 'to', ($p + 2), 'capture', Perlito5::AST::Val::Buf->new('buf', substr($str, $p, 2))}
                        }
                        else {
                            if (($interpolate == 1)) {
                                $m = Perlito5::Grammar::String->double_quoted_unescape($str, $p)
                            }
                            else {
                                $m = (($c2 eq chr(92)) ? {'str', $str, 'from', $p, 'to', ($p + 2), 'capture', Perlito5::AST::Val::Buf->new('buf', chr(92))} : (($c2 eq chr(39)) ? {'str', $str, 'from', $p, 'to', ($p + 2), 'capture', Perlito5::AST::Val::Buf->new('buf', chr(39))} : 0))
                            }
                        }
                    }
                }
            }
        };
        if ($m) {
            my $obj = Perlito5::Match::flat($m);
            if ((ref($obj) eq 'Perlito5::AST::Val::Buf')) {
                $buf = ($buf . $obj->{'buf'});
                $obj = undef()
            };
            if ($obj) {
                if (length($buf)) {
                    push(@args, Perlito5::AST::Val::Buf->new('buf', $buf));
                    $buf = ''
                };
                push(@args, $obj)
            };
            $p = $m->{'to'};
            $buf = ($buf . $more)
        }
        else {
            ($p)++;
            if ((($c eq chr(10)) || ($c eq chr(13)))) {
                my $m = $self->here_doc($str, $p);
                if (($p != $m->{'to'})) {
                    $p = $m->{'to'}
                }
                else {
                    $buf = ($buf . $c)
                }
            }
            else {
                $buf = ($buf . $c)
            }
        }
    };
    if (length($buf)) {
        push(@args, Perlito5::AST::Val::Buf->new('buf', $buf))
    };
    die(('Can' . chr(39) . 't find string terminator ' . chr(39) . $delimiter . chr(39) . ' anywhere before EOF')) if (substr($str, $p, length($delimiter)) ne $delimiter);
    $p = ($p + length($delimiter));
    my $ast;
    if (!(@args)) {
        $ast = Perlito5::AST::Val::Buf->new('buf', '')
    }
    else {
        if ((@args == 1)) {
            $ast = $args[0]
        }
        else {
            $ast = Perlito5::AST::Apply->new('namespace', '', 'code', 'list:<.>', 'arguments', \@args)
        }
    };
    return {'str', $str, 'from', $pos, 'to', $p, 'capture', $ast}
};
my @Here_doc;
sub Perlito5::Grammar::String::here_doc_wanted {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $delimiter;
    my $type = 'double_quote';
    my $p = $pos;
    if ((substr($str, $p, 2) eq '<<')) {
        $p = ($p + 2);
        my $quote = substr($str, $p, 1);
        if ((($quote eq chr(39)) || ($quote eq '"'))) {
            $p = ($p + 1);
            my $m = $self->string_interpolation_parse($str, $p, $quote, $quote, 0);
            if ($m) {
                $p = $m->{'to'};
                $delimiter = Perlito5::Match::flat($m)->{'buf'};
                $type = (($quote eq chr(39)) ? 'single_quote' : 'double_quote')
            }
        }
        else {
            $p = ($p + 1) if ($quote eq chr(92));
            my $m = Perlito5::Grammar->ident($str, $p);
            if ($m) {
                $p = $m->{'to'};
                $delimiter = Perlito5::Match::flat($m);
                $type = (($quote eq chr(92)) ? 'single_quote' : 'double_quote')
            }
            else {
                die('Use of bare << to mean <<"" is deprecated')
            }
        }
    };
    if (!(defined($delimiter))) {
        return 0
    };
    my $placeholder = Perlito5::AST::Apply->new('code', 'list:<.>', 'namespace', '', 'arguments', [Perlito5::AST::Apply->new('code', 'list:<.>', 'namespace', '', 'arguments', [])]);
    push(@Here_doc, [$type, $placeholder->{'arguments'}->[0]->{'arguments'}, $delimiter]);
    return {'str', $str, 'from', $pos, 'to', $p, 'capture', ['term', $placeholder]}
};
sub Perlito5::Grammar::String::newline {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((do {
                    my $pos1 = $MATCH->{'to'};
                    (((do {
                                ((((chr(10) eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                            my $m = $MATCH;
                                            if (!((((chr(13) eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) {
                                                $MATCH = $m
                                            };
                                            1
                                        })))
                            })) || ((do {
                                $MATCH->{'to'} = $pos1;
                                (((((chr(13) eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                my $m = $MATCH;
                                                if (!((((chr(10) eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) {
                                                    $MATCH = $m
                                                };
                                                1
                                            }))))
                            })))
                })));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::String::here_doc {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    if (!(@Here_doc)) {
        return {'str', $str, 'from', $pos, 'to', $pos}
    };
    my $p = $pos;
    my $here = shift(@Here_doc);
    my $type = $here->[0];
    my $result = $here->[1];
    my $delimiter = $here->[2];
    if (($type eq 'single_quote')) {
        for ( ; ($p < length($str)); {

            } ) {
            if ((substr($str, $p, length($delimiter)) eq $delimiter)) {
                push(@{$result}, Perlito5::AST::Val::Buf->new('buf', substr($str, $pos, ($p - $pos))));
                $p = ($p + length($delimiter));
                my $m = $self->newline($str, $p);
                if ((($p >= length($str)) || $m)) {
                    $p = $m->{'to'} if $m;
                    return {'str', $str, 'from', $pos, 'to', ($p - 1)}
                }
            };
            for ( ; (($p < length($str)) && (((substr($str, $p, 1) ne chr(10)) && (substr($str, $p, 1) ne chr(13))))); {

                } ) {
                ($p)++
            };
            for ( ; (($p < length($str)) && (((substr($str, $p, 1) eq chr(10)) || (substr($str, $p, 1) eq chr(13))))); {

                } ) {
                ($p)++
            }
        }
    }
    else {
        my $m;
        if ((substr($str, $p, length($delimiter)) eq $delimiter)) {
            $p = ($p + length($delimiter));
            $m = $self->newline($str, $p);
            if ((($p >= length($str)) || $m)) {
                push(@{$result}, Perlito5::AST::Val::Buf->new('buf', ''));
                $p = $m->{'to'} if $m;
                return {'str', $str, 'from', $pos, 'to', $p}
            }
        };
        $m = $self->string_interpolation_parse($str, $pos, '', (chr(10) . $delimiter . chr(10)), 1);
        if ($m) {
            push(@{$result}, Perlito5::Match::flat($m));
            push(@{$result}, Perlito5::AST::Val::Buf->new('buf', chr(10)));
            $m->{'to'} = ($m->{'to'} - 1);
            return $m
        }
    };
    die(('Can' . chr(39) . 't find string terminator "' . $delimiter . '" anywhere before EOF'))
};
sub Perlito5::Grammar::String::double_quoted_unescape {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $c2 = substr($str, ($pos + 1), 1);
    my $m;
    if (exists($escape_sequence{$c2})) {
        $m = {'str', $str, 'from', $pos, 'to', ($pos + 2), 'capture', Perlito5::AST::Val::Buf->new('buf', chr($escape_sequence{$c2}))}
    }
    else {
        if (($c2 eq 'c')) {
            my $c3 = ((ord(substr($str, ($pos + 2), 1)) - ord('A')) + 1);
            $c3 = (128 + $c3) if ($c3 < 0);
            $m = {'str', $str, 'from', $pos, 'to', ($pos + 3), 'capture', Perlito5::AST::Val::Buf->new('buf', chr($c3))}
        }
        else {
            if (($c2 eq 'x')) {
                if ((substr($str, ($pos + 2), 1) eq '{')) {
                    my $p = ($pos + 3);
                    ($p)++ while (($p < length($str)) && (substr($str, $p, 1) ne '}'));
                    my $tmp = oct(('0x' . substr($str, ($pos + 3), ($p - $pos))));
                    $m = {'str', $str, 'from', $pos, 'to', ($p + 1), 'capture', Perlito5::AST::Apply->new('arguments', [Perlito5::AST::Val::Int->new('int', $tmp)], 'code', 'chr')}
                }
                else {
                    my $p = ($pos + 2);
                    ($p)++ if $hex{uc(substr($str, $p, 1))};
                    ($p)++ if $hex{uc(substr($str, $p, 1))};
                    my $tmp = oct(('0x' . substr($str, ($pos + 2), ($p - $pos))));
                    $m = {'str', $str, 'from', $pos, 'to', $p, 'capture', Perlito5::AST::Apply->new('arguments', [Perlito5::AST::Val::Int->new('int', $tmp)], 'code', 'chr')}
                }
            }
            else {
                if (exists($octal{$c2})) {
                    my $p = ($pos + 2);
                    ($p)++ if $octal{substr($str, $p, 1)};
                    ($p)++ if $octal{substr($str, $p, 1)};
                    my $tmp = oct(substr($str, ($pos + 1), ($p - $pos)));
                    $m = {'str', $str, 'from', $pos, 'to', $p, 'capture', Perlito5::AST::Apply->new('arguments', [Perlito5::AST::Val::Int->new('int', $tmp)], 'code', 'chr')}
                }
                else {
                    $m = {'str', $str, 'from', $pos, 'to', ($pos + 2), 'capture', Perlito5::AST::Val::Buf->new('buf', $c2)}
                }
            }
        }
    };
    return $m
};
sub Perlito5::Grammar::String::double_quoted_var_with_subscript {
    my $self = $_[0];
    my $m_var = $_[1];
    my $interpolate = $_[2];
    my $str = $m_var->{'str'};
    my $pos = $m_var->{'to'};
    my $p = $pos;
    my $m_index;
    if ((substr($str, $p, 3) eq '->[')) {
        $p = ($p + 3);
        $m_index = Perlito5::Grammar::Expression->list_parse($str, $p);
        die('syntax error') unless $m_index;
        my $exp = $m_index->{'capture'};
        $p = $m_index->{'to'};
        die('syntax error') if (($exp eq '*undef*') || (substr($str, $p, 1) ne ']'));
        ($p)++;
        $m_index->{'capture'} = Perlito5::AST::Call->new('method', 'postcircumfix:<[ ]>', 'invocant', $m_var->{'capture'}, 'arguments', $exp);
        $m_index->{'to'} = $p;
        return $self->double_quoted_var_with_subscript($m_index, $interpolate)
    };
    if ((substr($str, $p, 3) eq '->{')) {
        $pos = ($pos + 2);
        $m_index = Perlito5::Grammar::Expression->term_curly($str, $pos);
        die('syntax error') unless $m_index;
        $m_index->{'capture'} = Perlito5::AST::Call->new('method', 'postcircumfix:<{ }>', 'invocant', $m_var->{'capture'}, 'arguments', Perlito5::Match::flat($m_index)->[2]->[0]);
        return $self->double_quoted_var_with_subscript($m_index, $interpolate)
    };
    if ((substr($str, $p, 1) eq '[')) {
        if (($interpolate == 2)) {
            my $m = ((Perlito5::Grammar::Expression->term_digit($str, ($p + 1)) || (((substr($str, ($p + 1), 1) eq '-') && Perlito5::Grammar::Expression->term_digit($str, ($p + 2))))) || Perlito5::Grammar::Sigil->term_sigil($str, ($p + 1)));
            return $m_var unless $m;
            return $m_var unless (substr($str, $m->{'to'}, 1) eq ']')
        };
        ($p)++;
        $m_index = Perlito5::Grammar::Expression->list_parse($str, $p);
        if ($m_index) {
            my $exp = $m_index->{'capture'};
            $p = $m_index->{'to'};
            if ((($exp ne '*undef*') && (substr($str, $p, 1) eq ']'))) {
                ($p)++;
                $m_index->{'capture'} = Perlito5::AST::Index->new('obj', $m_var->{'capture'}, 'index_exp', $exp);
                $m_index->{'to'} = $p;
                return $self->double_quoted_var_with_subscript($m_index, $interpolate)
            }
        }
    };
    $m_index = Perlito5::Grammar::Expression->term_curly($str, $pos);
    if ($m_index) {
        $m_index->{'capture'} = Perlito5::AST::Lookup->new('obj', $m_var->{'capture'}, 'index_exp', Perlito5::Match::flat($m_index)->[2]->[0]);
        return $self->double_quoted_var_with_subscript($m_index, $interpolate)
    };
    return $m_var
};
sub Perlito5::Grammar::String::double_quoted_var {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $delimiter = $_[3];
    my $interpolate = $_[4];
    my $c = substr($str, $pos, 1);
    if ((($c eq '$') && (substr($str, ($pos + 1), 1) eq '{'))) {
        my $m = Perlito5::Grammar::Sigil->term_sigil($str, $pos);
        return $m unless $m;
        my $var = Perlito5::Match::flat($m)->[1];
        $m->{'capture'} = $var;
        return $m
    }
    else {
        if ((($c eq '$') && (substr($str, ($pos + 1), length($delimiter)) ne $delimiter))) {
            my $m = Perlito5::Grammar::Sigil->term_sigil($str, $pos);
            return $m unless $m;
            $m->{'capture'} = $m->{'capture'}->[1];
            return $self->double_quoted_var_with_subscript($m, $interpolate)
        }
        else {
            if ((($c eq '@') && (substr($str, ($pos + 1), length($delimiter)) ne $delimiter))) {
                my $m = Perlito5::Grammar::Sigil->term_sigil($str, $pos);
                return $m unless $m;
                $m->{'capture'} = $m->{'capture'}->[1];
                $m = $self->double_quoted_var_with_subscript($m, $interpolate);
                $m->{'capture'} = Perlito5::AST::Apply->new('code', 'join', 'arguments', [Perlito5::AST::Val::Buf->new('buf', ' '), $m->{'capture'}], 'namespace', '');
                return $m
            }
        }
    };
    return 0
};
1;

;
package main;
undef();
package Perlito5::Grammar::Sigil;

# use Perlito5::Grammar::Precedence
;
Perlito5::Grammar::Precedence::add_term('$', sub {
        Perlito5::Grammar::Sigil->term_sigil($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('@', sub {
        Perlito5::Grammar::Sigil->term_sigil($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('%', sub {
        Perlito5::Grammar::Sigil->term_sigil($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('&', sub {
        Perlito5::Grammar::Sigil->term_sigil($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('*', sub {
        Perlito5::Grammar::Sigil->term_sigil($_[0], $_[1])
    });
my %special_var = ('$_', '', '$&', '', '$`', '', '$' . chr(39), '', '$+', '', '@+', '', '%+', '', '$.', '', '$/', '', '$|', '', '$,', '', '$' . chr(92), '', '$"', '', '$;', '', '$%', '', '$=', '', '$-', '', '@-', '', '%-', '', '$~', '', '$^', '', '$:', '', '$?', '', '$!', '', '%!', '', '$@', '', '$$', '', '$<', '', '$>', '', '$(', '', '$)', '', '$[', '', '$]', 'main', '@_', '', '*_', '', '*&', '', '*`', '', '*' . chr(39), '', '*+', '', '*.', '', '*/', '', '*|', '', '*,', '', '*' . chr(92), '', '*"', '', '*;', '', '*%', '', '*=', '', '*-', '', '*~', '', '*^', '', '*:', '', '*?', '', '*!', '', '*@', '', '*$', '', '*<', '', '*>', '', '*(', '', '*)', '', '*[', '', '*]', '', '*_', '', '**', '', '*#', '', '$#+', '', '$#-', '', '$#_', '');
sub Perlito5::Grammar::Sigil::term_special_var {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $len = 0;
    my $s = substr($str, $pos, 3);
    if (($s eq '$#[')) {
        $len = 2
    }
    else {
        if (exists($special_var{$s})) {
            $len = 3
        }
        else {
            $s = substr($str, $pos, 2);
            if (exists($special_var{$s})) {
                $len = 2
            }
        }
    };
    if ($len) {
        my $c0 = substr($str, (($pos + $len) - 1), 1);
        my $c1 = substr($str, ($pos + $len), 1);
        if (((((((($c0 eq '$') || ($c0 eq '@')) || ($c0 eq '%')) || ($c0 eq '*')) || ($c0 eq '&'))) && ((((((((($c1 eq '$') || ($c1 eq '@')) || ($c1 eq '%')) || ($c1 eq '*')) || ($c1 eq '&')) || ((($c1 ge 'a') && ($c1 le 'z')))) || ((($c1 ge 'A') && ($c1 le 'Z')))) || ((($c1 ge '0') && ($c1 le '9'))))))) {

        }
        else {
            return {'str', $str, 'from', $pos, 'to', ($pos + $len), 'capture', ['term', Perlito5::AST::Var->new('sigil', substr($s, 0, ($len - 1)), 'namespace', $special_var{$s}, 'name', substr($s, ($len - 1), 1))]}
        }
    };
    return 0
};
my %sigil = ('$', 1, '%', 1, '@', 1, '&', 1, '*', 1);
sub Perlito5::Grammar::Sigil::term_sigil {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $c1 = substr($str, $pos, 1);
    return  unless exists($sigil{$c1});
    my $p = ($pos + 1);
    my $sigil = $c1;
    if ((substr($str, $pos, 2) eq '$#')) {
        $sigil = '$#';
        ($p)++
    };
    my $m = Perlito5::Grammar::Space->opt_ws($str, $p);
    $p = $m->{'to'};
    $c1 = substr($str, $p, 1);
    my $q = ($p + 1);
    if (($c1 eq '{')) {
        my $p = $q;
        $m = Perlito5::Grammar::Space->opt_ws($str, $p);
        $p = $m->{'to'};
        $m = Perlito5::Grammar->optional_namespace_before_ident($str, $p);
        if ($m) {
            my $namespace = Perlito5::Match::flat($m);
            my $pos = $m->{'to'};
            my $n = Perlito5::Grammar->var_name($str, $m->{'to'});
            my $name;
            if ($n) {
                $name = Perlito5::Match::flat($n);
                $pos = $n->{'to'}
            };
            if (($namespace || $name)) {
                my $spc = Perlito5::Grammar::Space->opt_ws($str, $pos);
                $m->{'capture'} = Perlito5::AST::Var->new('sigil', $sigil, 'namespace', $namespace, 'name', $name);
                $m->{'to'} = $spc->{'to'};
                $m = Perlito5::Grammar::String->double_quoted_var_with_subscript($m);
                $m->{'capture'} = ['term', $m->{'capture'}];
                $spc = Perlito5::Grammar::Space->opt_ws($str, $m->{'to'});
                my $p = $spc->{'to'};
                if ((substr($str, $p, 1) eq '}')) {
                    $m->{'to'} = ($p + 1);
                    return $m
                }
            }
        };
        my $caret = Perlito5::Grammar->caret_char($str, $p);
        if ($caret) {
            my $p = $caret->{'to'};
            my $name = Perlito5::Match::flat($caret);
            $m = Perlito5::Grammar->var_name($str, $p);
            if ($m) {
                $name = ($name . Perlito5::Match::flat($m));
                $p = $m->{'to'}
            };
            if ((substr($str, $p, 1) eq '}')) {
                $caret->{'capture'} = ['term', Perlito5::AST::Apply->new('arguments', [Perlito5::AST::Val::Buf->new('buf', $name)], 'code', ('prefix:<' . $sigil . '>'), 'namespace', '')];
                $caret->{'to'} = ($p + 1);
                return $caret
            }
        };
        $m = Perlito5::Grammar::Expression->curly_parse($str, $p);
        if ($m) {
            my $p = $m->{'to'};
            if ((substr($str, $p, 1) eq '}')) {
                $m->{'to'} = ($m->{'to'} + 1);
                $m->{'capture'} = ['term', Perlito5::AST::Apply->new('arguments', [$m->{'capture'}], 'code', ('prefix:<' . $sigil . '>'), 'namespace', '')];
                return $m
            }
        }
    };
    my $caret = Perlito5::Grammar->caret_char($str, $p);
    if ($caret) {
        my $name = Perlito5::Match::flat($caret);
        $caret->{'capture'} = ['term', Perlito5::AST::Apply->new('arguments', [Perlito5::AST::Val::Buf->new('buf', $name)], 'code', ('prefix:<' . $sigil . '>'), 'namespace', '')];
        return $caret
    };
    if (($c1 eq '$')) {
        $m = $self->term_sigil($str, $p);
        if ($m) {
            $m->{'capture'} = ['term', Perlito5::AST::Apply->new('arguments', [$m->{'capture'}->[1]], 'code', ('prefix:<' . $sigil . '>'), 'namespace', '')];
            return $m
        }
    };
    $m = Perlito5::Grammar->optional_namespace_before_ident($str, $p);
    if ($m) {
        my $namespace = Perlito5::Match::flat($m);
        my $n = Perlito5::Grammar->var_name($str, $m->{'to'});
        if ($n) {
            $n->{'capture'} = ['term', Perlito5::AST::Var->new('sigil', $sigil, 'namespace', $namespace, 'name', Perlito5::Match::flat($n))];
            return $n
        };
        if ($namespace) {
            $m->{'capture'} = ['term', Perlito5::AST::Var->new('sigil', $sigil, 'namespace', $namespace, 'name', undef())];
            return $m
        }
    };
    return $self->term_special_var($str, $pos)
};
1;

;
package main;
package Perlito5::Grammar::Use;

# use Perlito5::Grammar::Precedence
;

# use Perlito5::Grammar
;

# use strict
;
Perlito5::Grammar::Precedence::add_term('no', sub {
        Perlito5::Grammar::Use->term_use($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('use', sub {
        Perlito5::Grammar::Use->term_use($_[0], $_[1])
    });
my %Perlito_internal_module = ('strict', 'Perlito5::strict', 'warnings', 'Perlito5::warnings', 'utf8', 'Perlito5::utf8', 'bytes', 'Perlito5::bytes', 'encoding', 'Perlito5::encoding', 'Carp', 'Perlito5::Carp');
sub Perlito5::Grammar::Use::use_decl {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((do {
                    my $pos1 = $MATCH->{'to'};
                    (((do {
                                (('use' eq substr($str, $MATCH->{'to'}, 3)) && ($MATCH->{'to'} = (3 + $MATCH->{'to'})))
                            })) || ((do {
                                $MATCH->{'to'} = $pos1;
                                ((('no' eq substr($str, $MATCH->{'to'}, 2)) && ($MATCH->{'to'} = (2 + $MATCH->{'to'}))))
                            })))
                })));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Use::term_use {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = ((((((do {
                                my $m2 = $grammar->use_decl($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    $MATCH->{'use_decl'} = $m2;
                                    1
                                }
                                else {
                                    0
                                }
                            })) && ((do {
                                my $m2 = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    1
                                }
                                else {
                                    0
                                }
                            }))) && ((do {
                            my $pos1 = $MATCH->{'to'};
                            (((do {
                                        (((do {
                                                    my $m2 = Perlito5::Grammar->val_version($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'Perlito5::Grammar.val_version'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                })) && ((do {
                                                    $MATCH->{'str'} = $str;
                                                    $MATCH->{'capture'} = ['term', Perlito5::AST::Apply->new('code', 'undef', 'namespace', '', 'arguments', [])];
                                                    1
                                                })))
                                    })) || ((do {
                                        $MATCH->{'to'} = $pos1;
                                        ((((((do {
                                                                my $m2 = Perlito5::Grammar->full_ident($str, $MATCH->{'to'});
                                                                if ($m2) {
                                                                    $MATCH->{'to'} = $m2->{'to'};
                                                                    $MATCH->{'Perlito5::Grammar.full_ident'} = $m2;
                                                                    1
                                                                }
                                                                else {
                                                                    0
                                                                }
                                                            })) && ((do {
                                                                my $m = $MATCH;
                                                                if (!(((((('-' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                                                        my $m2 = Perlito5::Grammar->ident($str, $MATCH->{'to'});
                                                                                        if ($m2) {
                                                                                            $MATCH->{'to'} = $m2->{'to'};
                                                                                            if (exists($MATCH->{'Perlito5::Grammar.ident'})) {
                                                                                                push(@{$MATCH->{'Perlito5::Grammar.ident'}}, $m2)
                                                                                            }
                                                                                            else {
                                                                                                $MATCH->{'Perlito5::Grammar.ident'} = [$m2]
                                                                                            };
                                                                                            1
                                                                                        }
                                                                                        else {
                                                                                            0
                                                                                        }
                                                                                    })))))) {
                                                                    $MATCH = $m
                                                                };
                                                                1
                                                            }))) && ((do {
                                                            my $m2 = Perlito5::Grammar::Expression->list_parse($str, $MATCH->{'to'});
                                                            if ($m2) {
                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                $MATCH->{'Perlito5::Grammar::Expression.list_parse'} = $m2;
                                                                1
                                                            }
                                                            else {
                                                                0
                                                            }
                                                        }))) && ((do {
                                                        $MATCH->{'str'} = $str;
                                                        my $list = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression.list_parse'});
                                                        if (($list eq '*undef*')) {
                                                            $list = undef()
                                                        }
                                                        else {
                                                            my $m = $MATCH->{'Perlito5::Grammar::Expression.list_parse'};
                                                            my $list_code = substr($str, $m->{'from'}, ($m->{'to'} - $m->{'from'}));
                                                            my @list = eval $list_code;
                                                            $list = \@list
                                                        };
                                                        my $full_ident = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.full_ident'});
                                                        $Perlito5::PACKAGES->{$full_ident} = 1;
                                                        my $ast = Perlito5::AST::Use->new('code', Perlito5::Match::flat($MATCH->{'use_decl'}), 'mod', $full_ident, 'arguments', $list);
                                                        parse_time_eval($ast);
                                                        $MATCH->{'capture'} = ['term', $ast];
                                                        1
                                                    }))))
                                    })))
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Use::parse_time_eval {
    my $self = shift();
    my $module_name = $self->mod();
    my $use_or_not = $self->code();
    my $arguments = $self->{'arguments'};
    my $skip_import = (defined($arguments) && (@{$arguments} == 0));
    $arguments = [] unless defined($arguments);
    if (($module_name eq 'feature')) {

    }
    else {
        if ($Perlito5::EXPAND_USE) {
            $module_name = $Perlito_internal_module{$module_name} if exists($Perlito_internal_module{$module_name});
            my $filename = modulename_to_filename($module_name);
            Perlito5::Grammar::Use::require($filename);
            if (!($skip_import)) {
                if (($use_or_not eq 'use')) {
                    if (defined(&{($module_name . '::import')})) {
                        unshift(@{$Perlito5::CALLER}, [$Perlito5::PKG_NAME]);
                        $module_name->import(@{$arguments});
                        shift(@{$Perlito5::CALLER})
                    }
                }
                else {
                    if (($use_or_not eq 'no')) {
                        if (defined(&{($module_name . '::unimport')})) {
                            unshift(@{$Perlito5::CALLER}, [$Perlito5::PKG_NAME]);
                            $module_name->unimport(@{$arguments});
                            shift(@{$Perlito5::CALLER})
                        }
                    }
                }
            }
        }
    }
};
sub Perlito5::Grammar::Use::emit_time_eval {
    my $self = shift();
    if (($self->mod() eq 'strict')) {
        if (($self->code() eq 'use')) {
            Perlito5::strict->import()
        }
        else {
            if (($self->code() eq 'no')) {
                Perlito5::strict->unimport()
            }
        }
    }
};
sub Perlito5::Grammar::Use::modulename_to_filename {
    my $s = shift();
    ($s =~ s!::!/!g);
    return ($s . '.pm')
};
sub Perlito5::Grammar::Use::filename_lookup {
    my $filename = shift();
    if (exists($INC{$filename})) {
        return 'done' if $INC{$filename};
        die('Compilation failed in require')
    };
    for my  $prefix ((@INC, '.')) {
        my $realfilename = ($prefix . '/' . $filename);
        if (-f($realfilename)) {
            $INC{$filename} = $realfilename;
            return 'todo'
        }
    };
    die(('Can' . chr(39) . 't locate ' . $filename . ' in @INC ' . '(@INC contains ' . join(' ', @INC) . ').'))
};
sub Perlito5::Grammar::Use::expand_use {
    my $comp_units = shift();
    my $stmt = shift();
    my $module_name = $stmt->mod();
    return  if ((($module_name eq 'strict') || ($module_name eq 'warnings')) || ($module_name eq 'feature'));
    $module_name = $Perlito_internal_module{$module_name} if exists($Perlito_internal_module{$module_name});
    my $filename = modulename_to_filename($module_name);
    return  if (filename_lookup($filename) eq 'done');
    my $realfilename = $INC{$filename};
    my $source = Perlito5::IO::slurp($realfilename);
    my $m = Perlito5::Grammar->exp_stmts($source, 0);
    die('Syntax Error near ', $m->{'to'}) if ($m->{'to'} != length($source));
    push(@{$comp_units}, @{add_comp_unit([Perlito5::AST::CompUnit->new('name', 'main', 'body', Perlito5::Match::flat($m))])})
};
sub Perlito5::Grammar::Use::add_comp_unit {
    my $parse = shift();
    my $comp_units = [];
    for my  $comp_unit (@{$parse}) {
        if (defined($comp_unit)) {
            if ($comp_unit->isa('Perlito5::AST::Use')) {
                expand_use($comp_units, $comp_unit)
            }
            else {
                if ($comp_unit->isa('Perlito5::AST::CompUnit')) {
                    for my  $stmt (@{$comp_unit->body()}) {
                        if ($stmt->isa('Perlito5::AST::Use')) {
                            expand_use($comp_units, $stmt)
                        }
                    }
                }
            };
            push(@{$comp_units}, $comp_unit)
        }
    };
    return $comp_units
};
sub Perlito5::Grammar::Use::require {
    my $filename = shift();
    my $is_bareword = shift();
    if ($is_bareword) {
        $Perlito5::PACKAGES->{$filename} = 1;
        $filename = modulename_to_filename($filename)
    };
    return  if (filename_lookup($filename) eq 'done');
    my $result = eval Perlito5::IO::slurp($INC{$filename});
    if (${'@'}) {
        $INC{$filename} = undef();
        die(${'@'})
    }
    else {
        if (!($result)) {
            delete($INC{$filename});
            warn(${'@'}) if ${'@'};
            die(($filename . ' did not return true value'))
        }
        else {
            return $result
        }
    }
};
1;

;
package main;
package Perlito5::Grammar::Block;

# use Perlito5::Grammar::Expression
;

# use strict
;
our %Named_block = ('BEGIN', 1, 'UNITCHECK', 1, 'CHECK', 1, 'INIT', 1, 'END', 1);
Perlito5::Grammar::Precedence::add_term('do', sub {
        Perlito5::Grammar::Block->term_do($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('sub', sub {
        Perlito5::Grammar::Block->term_anon_sub($_[0], $_[1])
    });
Perlito5::Grammar::Expression::add_statement('{', sub {
        Perlito5::Grammar::Block->term_block($_[0], $_[1])
    });
Perlito5::Grammar::Expression::add_statement('sub', sub {
        Perlito5::Grammar::Block->named_sub($_[0], $_[1])
    });
Perlito5::Grammar::Expression::add_statement($_, sub {
            Perlito5::Grammar::Block->term_block($_[0], $_[1])
        }) for keys(%Named_block);
sub Perlito5::Grammar::Block::term_block {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $p = $pos;
    my $block_name;
    my $m_name = Perlito5::Grammar->ident($str, $p);
    if ($m_name) {
        $p = $m_name->{'to'};
        $block_name = Perlito5::Match::flat($m_name)
    };
    my $ws = Perlito5::Grammar::Space->ws($str, $p);
    if ($ws) {
        $p = $ws->{'to'}
    };
    if ((substr($str, $p, 1) eq '{')) {
        my $m = Perlito5::Grammar::Expression->term_curly($str, $p);
        if ($m) {
            my $block_start = $p;
            $p = $m->{'to'};
            $ws = Perlito5::Grammar::Space->ws($str, $p);
            if ($ws) {
                $p = $ws->{'to'}
            };
            my $continue = Perlito5::AST::Lit::Block->new('stmts', []);
            my $has_continue = 0;
            if ((!($block_name) && (substr($str, $p, 8) eq 'continue'))) {
                $p = ($p + 8);
                $ws = Perlito5::Grammar::Space->ws($str, $p);
                if ($ws) {
                    $p = $ws->{'to'}
                };
                my $cont = Perlito5::Grammar::Expression->term_curly($str, $p);
                die('syntax error') unless $cont;
                warn('continue!');
                $continue->{'stmts'} = $cont->{'capture'}->[2];
                $has_continue = 1;
                $m->{'to'} = $cont->{'to'}
            };
            my $v = Perlito5::Match::flat($m);
            $v = Perlito5::AST::Lit::Block->new('stmts', $v->[2], 'sig', $v->[3]);
            $v = Perlito5::Grammar::Expression::block_or_hash($v) unless ($has_continue || $block_name);
            if ((ref($v) eq 'Perlito5::AST::Lit::Block')) {
                if (($block_name eq 'BEGIN')) {
                    eval substr($str, $block_start, ($m->{'to'} - $block_start));
                    $m->{'capture'} = Perlito5::AST::Apply->new('code', 'undef', 'namespace', '', 'arguments', [])
                }
                else {
                    $v->{'name'} = $block_name;
                    $m->{'capture'} = $v;
                    $m->{'capture'}->{'continue'} = $continue
                };
                return $m
            }
        }
    };
    return 0
};
sub Perlito5::Grammar::Block::named_sub_def {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((((((((((do {
                                                    my $m2 = Perlito5::Grammar->optional_namespace_before_ident($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'Perlito5::Grammar.optional_namespace_before_ident'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                })) && ((do {
                                                    my $m2 = Perlito5::Grammar->ident($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'Perlito5::Grammar.ident'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }))) && ((do {
                                                my $m2 = Perlito5::Grammar::Block->prototype($str, $MATCH->{'to'});
                                                if ($m2) {
                                                    $MATCH->{'to'} = $m2->{'to'};
                                                    $MATCH->{'Perlito5::Grammar::Block.prototype'} = $m2;
                                                    1
                                                }
                                                else {
                                                    0
                                                }
                                            }))) && ((do {
                                            my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }))) && ((do {
                                        my $m2 = Perlito5::Grammar::Attribute->opt_attribute($str, $MATCH->{'to'});
                                        if ($m2) {
                                            $MATCH->{'to'} = $m2->{'to'};
                                            $MATCH->{'Perlito5::Grammar::Attribute.opt_attribute'} = $m2;
                                            1
                                        }
                                        else {
                                            0
                                        }
                                    }))) && ((do {
                                    my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }))) && ((do {
                                my $pos1 = $MATCH->{'to'};
                                ((((do {
                                                (((((((('{' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                                            my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                            if ($m2) {
                                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                                1
                                                                            }
                                                                            else {
                                                                                0
                                                                            }
                                                                        }))) && ((do {
                                                                        my $m2 = Perlito5::Grammar->exp_stmts($str, $MATCH->{'to'});
                                                                        if ($m2) {
                                                                            $MATCH->{'to'} = $m2->{'to'};
                                                                            $MATCH->{'Perlito5::Grammar.exp_stmts'} = $m2;
                                                                            1
                                                                        }
                                                                        else {
                                                                            0
                                                                        }
                                                                    }))) && ((do {
                                                                    my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                    if ($m2) {
                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                        1
                                                                    }
                                                                    else {
                                                                        0
                                                                    }
                                                                }))) && ((do {
                                                                my $pos1 = $MATCH->{'to'};
                                                                (((do {
                                                                            (('}' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))
                                                                        })) || ((do {
                                                                            $MATCH->{'to'} = $pos1;
                                                                            ((do {
                                                                                    $MATCH->{'str'} = $str;
                                                                                    die('Syntax Error in sub ' . chr(39), Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.ident'}), chr(39));
                                                                                    1
                                                                                }))
                                                                        })))
                                                            }))) && ((do {
                                                            $MATCH->{'str'} = $str;
                                                            $MATCH->{'_tmp'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.exp_stmts'});
                                                            1
                                                        })))
                                            })) || ((do {
                                                $MATCH->{'to'} = $pos1;
                                                ((((do {
                                                                my $m2 = Perlito5::Grammar::Expression->statement_parse($str, $MATCH->{'to'});
                                                                if ($m2) {
                                                                    $MATCH->{'to'} = $m2->{'to'};
                                                                    1
                                                                }
                                                                else {
                                                                    0
                                                                }
                                                            })) && ((do {
                                                                $MATCH->{'str'} = $str;
                                                                die('Illegal declaration of subroutine ' . chr(39), Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.ident'}), chr(39));
                                                                1
                                                            }))))
                                            }))) || ((do {
                                            $MATCH->{'to'} = $pos1;
                                            ((do {
                                                    $MATCH->{'str'} = $str;
                                                    $MATCH->{'_tmp'} = undef();
                                                    1
                                                }))
                                        })))
                            }))) && ((do {
                            $MATCH->{'str'} = $str;
                            my $name = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.ident'});
                            my $sig = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Block.prototype'});
                            $sig = undef() if ($sig eq '*undef*');
                            my $namespace = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.optional_namespace_before_ident'});
                            if ($name) {
                                if (!($namespace)) {
                                    $namespace = (($name eq '_') ? 'main' : $Perlito5::PKG_NAME)
                                };
                                my $full_name = ($namespace . '::' . $name);
                                $Perlito5::PROTO->{$full_name} = $sig
                            };
                            $MATCH->{'capture'} = Perlito5::AST::Sub->new('name', $name, 'namespace', $namespace, 'sig', $sig, 'block', $MATCH->{'_tmp'}, 'attributes', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Attribute.opt_attribute'}));
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Block::named_sub {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    return  unless (substr($str, $pos, 3) eq 'sub');
    my $ws = Perlito5::Grammar::Space->ws($str, ($pos + 3));
    return  unless $ws;
    my $p = $ws->{'to'};
    my $m_name = Perlito5::Grammar->ident($str, $p);
    return  unless $m_name;
    my $block_name = Perlito5::Match::flat($m_name);
    if (exists($Named_block{$block_name})) {
        return Perlito5::Grammar::Block->term_block($str, $p)
    };
    return Perlito5::Grammar::Block->named_sub_def($str, $p)
};
sub Perlito5::Grammar::Block::term_anon_sub {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((((((('sub' eq substr($str, $MATCH->{'to'}, 3)) && ($MATCH->{'to'} = (3 + $MATCH->{'to'})))) && ((do {
                                    my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }))) && ((do {
                                my $m2 = Perlito5::Grammar::Block->anon_sub_def($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    $MATCH->{'Perlito5::Grammar::Block.anon_sub_def'} = $m2;
                                    1
                                }
                                else {
                                    0
                                }
                            }))) && ((do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Block.anon_sub_def'})];
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Block::term_do {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = ((((((((('do' eq substr($str, $MATCH->{'to'}, 2)) && ($MATCH->{'to'} = (2 + $MATCH->{'to'})))) && ((do {
                                        my $m2 = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'});
                                        if ($m2) {
                                            $MATCH->{'to'} = $m2->{'to'};
                                            1
                                        }
                                        else {
                                            0
                                        }
                                    }))) && ((do {
                                    my $tmp = $MATCH;
                                    $MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}};
                                    my $res = ((('{' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))));
                                    $MATCH = ($res ? $tmp : 0)
                                }))) && ((do {
                                my $m2 = Perlito5::Grammar::Expression->statement_parse($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    $MATCH->{'Perlito5::Grammar::Expression.statement_parse'} = $m2;
                                    1
                                }
                                else {
                                    0
                                }
                            }))) && ((do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = ['term', Perlito5::AST::Do->new('block', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression.statement_parse'}))];
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Block::args_sig {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((do {
                    my $last_match_null = 0;
                    my $m = $MATCH;
                    my $to = $MATCH->{'to'};
                    for ( ; (((do {
                                    my $pos1 = $MATCH->{'to'};
                                    (((((((((((do {
                                                                                ((';' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))
                                                                            })) || ((do {
                                                                                $MATCH->{'to'} = $pos1;
                                                                                (((chr(92) eq substr($str, $MATCH->{'to'}, 2)) && ($MATCH->{'to'} = (2 + $MATCH->{'to'}))))
                                                                            }))) || ((do {
                                                                            $MATCH->{'to'} = $pos1;
                                                                            ((('[' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
                                                                        }))) || ((do {
                                                                        $MATCH->{'to'} = $pos1;
                                                                        (((']' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
                                                                    }))) || ((do {
                                                                    $MATCH->{'to'} = $pos1;
                                                                    ((('*' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
                                                                }))) || ((do {
                                                                $MATCH->{'to'} = $pos1;
                                                                ((('+' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
                                                            }))) || ((do {
                                                            $MATCH->{'to'} = $pos1;
                                                            ((('@' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
                                                        }))) || ((do {
                                                        $MATCH->{'to'} = $pos1;
                                                        ((('%' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
                                                    }))) || ((do {
                                                    $MATCH->{'to'} = $pos1;
                                                    ((('$' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
                                                }))) || ((do {
                                                $MATCH->{'to'} = $pos1;
                                                ((('&' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
                                            })))
                                })) && (($last_match_null < 2))); {

                        } ) {
                        if (($to == $MATCH->{'to'})) {
                            $last_match_null = ($last_match_null + 1)
                        }
                        else {
                            $last_match_null = 0
                        };
                        $m = $MATCH;
                        $to = $MATCH->{'to'}
                    };
                    $MATCH = $m;
                    $MATCH->{'to'} = $to;
                    1
                })));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Block::prototype {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((do {
                    my $pos1 = $MATCH->{'to'};
                    (((do {
                                ((((((((do {
                                                                my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                if ($m2) {
                                                                    $MATCH->{'to'} = $m2->{'to'};
                                                                    1
                                                                }
                                                                else {
                                                                    0
                                                                }
                                                            })) && ((('(' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                            my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                            if ($m2) {
                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                1
                                                            }
                                                            else {
                                                                0
                                                            }
                                                        }))) && ((do {
                                                        my $m2 = $grammar->args_sig($str, $MATCH->{'to'});
                                                        if ($m2) {
                                                            $MATCH->{'to'} = $m2->{'to'};
                                                            $MATCH->{'args_sig'} = $m2;
                                                            1
                                                        }
                                                        else {
                                                            0
                                                        }
                                                    }))) && ((do {
                                                    my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }))) && (((')' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                            $MATCH->{'str'} = $str;
                                            $MATCH->{'capture'} = ('' . Perlito5::Match::flat($MATCH->{'args_sig'}));
                                            1
                                        })))
                            })) || ((do {
                                $MATCH->{'to'} = $pos1;
                                ((do {
                                        $MATCH->{'str'} = $str;
                                        $MATCH->{'capture'} = '*undef*';
                                        1
                                    }))
                            })))
                })));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Block::anon_sub_def {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((((((((((((do {
                                                            my $m2 = $grammar->prototype($str, $MATCH->{'to'});
                                                            if ($m2) {
                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                $MATCH->{'prototype'} = $m2;
                                                                1
                                                            }
                                                            else {
                                                                0
                                                            }
                                                        })) && ((do {
                                                            my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                            if ($m2) {
                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                1
                                                            }
                                                            else {
                                                                0
                                                            }
                                                        }))) && ((do {
                                                        my $m2 = Perlito5::Grammar::Attribute->opt_attribute($str, $MATCH->{'to'});
                                                        if ($m2) {
                                                            $MATCH->{'to'} = $m2->{'to'};
                                                            $MATCH->{'Perlito5::Grammar::Attribute.opt_attribute'} = $m2;
                                                            1
                                                        }
                                                        else {
                                                            0
                                                        }
                                                    }))) && ((do {
                                                    my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }))) && ((('{' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                            my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        }))) && ((do {
                                        my $m2 = Perlito5::Grammar->exp_stmts($str, $MATCH->{'to'});
                                        if ($m2) {
                                            $MATCH->{'to'} = $m2->{'to'};
                                            $MATCH->{'Perlito5::Grammar.exp_stmts'} = $m2;
                                            1
                                        }
                                        else {
                                            0
                                        }
                                    }))) && ((do {
                                    my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }))) && ((do {
                                my $pos1 = $MATCH->{'to'};
                                (((do {
                                            (('}' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))
                                        })) || ((do {
                                            $MATCH->{'to'} = $pos1;
                                            ((do {
                                                    $MATCH->{'str'} = $str;
                                                    die('Syntax Error in anon sub');
                                                    1
                                                }))
                                        })))
                            }))) && ((do {
                            $MATCH->{'str'} = $str;
                            my $sig = Perlito5::Match::flat($MATCH->{'prototype'});
                            $sig = undef() if ($sig eq '*undef*');
                            $MATCH->{'capture'} = Perlito5::AST::Sub->new('name', undef(), 'namespace', undef(), 'sig', $sig, 'block', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.exp_stmts'}), 'attributes', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Attribute.opt_attribute'}));
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
1;

;
package main;
package Perlito5::Grammar::Space;

# use Perlito5::Grammar::Precedence
;
my %space = ('#', sub {
            my $m = Perlito5::Grammar::Space->to_eol($_[0], $_[1]);
            $m->{'to'}
        }, chr(9), sub {
            $_[1]
        }, chr(10), sub {
            my $str = $_[0];
            my $pos = $_[1];
            ($pos)++ if (substr($str, $pos, 1) eq chr(13));
            my $m = Perlito5::Grammar::Space->start_of_line($_[0], $pos);
            $m->{'to'}
        }, chr(12), sub {
            $_[1]
        }, chr(13), sub {
            my $str = $_[0];
            my $pos = $_[1];
            ($pos)++ if (substr($str, $pos, 1) eq chr(10));
            my $m = Perlito5::Grammar::Space->start_of_line($_[0], $pos);
            $m->{'to'}
        }, chr(32), sub {
            $_[1]
        });
sub Perlito5::Grammar::Space::term_space {
    my $str = $_[0];
    my $pos = $_[1];
    my $p = $pos;
    for ( ; exists($space{substr($str, $p, 1)}); {

        } ) {
        $p = $space{substr($str, $p, 1)}->($str, ($p + 1))
    };
    return term_end($str, $p) if ((substr($str, $p, 7) eq '__END__') || (substr($str, $p, 8) eq '__DATA__'));
    return {'str', $str, 'from', $pos, 'to', $p, 'capture', ['space', ' ']}
};
sub Perlito5::Grammar::Space::term_end {
    my $str = $_[0];
    my $p = $_[1];
    my $is_data = 0;
    if (((substr($str, $_[1], 7) eq '__END__') && ($Perlito5::PKG_NAME eq 'main'))) {
        $p = ($p + 7);
        $is_data = 1
    }
    else {
        if ((substr($str, $_[1], 8) eq '__DATA__')) {
            $p = ($p + 8);
            $is_data = 1
        }
    };
    my $m = Perlito5::Grammar::Space->to_eol($str, $p);
    $p = $m->{'to'};
    if ((substr($str, $p, 1) eq chr(10))) {
        ($p)++;
        ($p)++ if (substr($str, $p, 1) eq chr(13))
    }
    else {
        if ((substr($str, $p, 1) eq chr(13))) {
            ($p)++;
            ($p)++ if (substr($str, $p, 1) eq chr(10))
        }
    };
    if ($is_data) {
        $Perlito5::DATA_SECTION{$Perlito5::PKG_NAME} = substr($_[0], $p)
    };
    return {'str', $str, 'from', $_[1], 'to', length($_[0]), 'capture', ['space', ' ']}
};
Perlito5::Grammar::Precedence::add_term('#', \&term_space);
Perlito5::Grammar::Precedence::add_term(chr(9), \&term_space);
Perlito5::Grammar::Precedence::add_term(chr(10), \&term_space);
Perlito5::Grammar::Precedence::add_term(chr(12), \&term_space);
Perlito5::Grammar::Precedence::add_term(chr(13), \&term_space);
Perlito5::Grammar::Precedence::add_term(chr(32), \&term_space);
Perlito5::Grammar::Precedence::add_term('__END__', \&term_end);
Perlito5::Grammar::Precedence::add_term('__DATA__', \&term_end);
sub Perlito5::Grammar::Space::to_eol {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((do {
                    my $last_match_null = 0;
                    my $m = $MATCH;
                    my $to = $MATCH->{'to'};
                    for ( ; (((((do {
                                            my $tmp = $MATCH;
                                            $MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}};
                                            my $res = ((do {
                                                        my $pos1 = $MATCH->{'to'};
                                                        (((do {
                                                                    ((chr(10) eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))
                                                                })) || ((do {
                                                                    $MATCH->{'to'} = $pos1;
                                                                    (((chr(13) eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
                                                                })))
                                                    }));
                                            $MATCH = ($res ? 0 : $tmp)
                                        })) && ((('' ne substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && (($last_match_null < 2))); {

                        } ) {
                        if (($to == $MATCH->{'to'})) {
                            $last_match_null = ($last_match_null + 1)
                        }
                        else {
                            $last_match_null = 0
                        };
                        $m = $MATCH;
                        $to = $MATCH->{'to'}
                    };
                    $MATCH = $m;
                    $MATCH->{'to'} = $to;
                    1
                })));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Space::pod_pod_begin {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((do {
                    my $pos1 = $MATCH->{'to'};
                    (((do {
                                ((((do {
                                                my $pos1 = $MATCH->{'to'};
                                                (((do {
                                                            ((chr(10) eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))
                                                        })) || ((do {
                                                            $MATCH->{'to'} = $pos1;
                                                            (((chr(13) eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
                                                        })))
                                            })) && ((('=cut' eq substr($str, $MATCH->{'to'}, 4)) && ($MATCH->{'to'} = (4 + $MATCH->{'to'}))))) && ((do {
                                            my $m2 = $grammar->to_eol($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        })))
                            })) || ((do {
                                $MATCH->{'to'} = $pos1;
                                (((((('' ne substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                    my $m2 = $grammar->to_eol($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }))) && ((do {
                                                my $m2 = $grammar->pod_pod_begin($str, $MATCH->{'to'});
                                                if ($m2) {
                                                    $MATCH->{'to'} = $m2->{'to'};
                                                    1
                                                }
                                                else {
                                                    0
                                                }
                                            }))))
                            })))
                })));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Space::pod_begin {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((do {
                    my $pos1 = $MATCH->{'to'};
                    (((do {
                                ((((do {
                                                my $pos1 = $MATCH->{'to'};
                                                (((do {
                                                            ((chr(10) eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))
                                                        })) || ((do {
                                                            $MATCH->{'to'} = $pos1;
                                                            (((chr(13) eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
                                                        })))
                                            })) && ((('=end' eq substr($str, $MATCH->{'to'}, 4)) && ($MATCH->{'to'} = (4 + $MATCH->{'to'}))))) && ((do {
                                            my $m2 = $grammar->to_eol($str, $MATCH->{'to'});
                                            if ($m2) {
                                                $MATCH->{'to'} = $m2->{'to'};
                                                1
                                            }
                                            else {
                                                0
                                            }
                                        })))
                            })) || ((do {
                                $MATCH->{'to'} = $pos1;
                                (((((('' ne substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                    my $m2 = $grammar->to_eol($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                }))) && ((do {
                                                my $m2 = $grammar->pod_begin($str, $MATCH->{'to'});
                                                if ($m2) {
                                                    $MATCH->{'to'} = $m2->{'to'};
                                                    1
                                                }
                                                else {
                                                    0
                                                }
                                            }))))
                            })))
                })));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Space::start_of_line {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((((do {
                            my $m2 = Perlito5::Grammar::String->here_doc($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        })) && ((do {
                            my $pos1 = $MATCH->{'to'};
                            ((((do {
                                            (((('=' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                        my $pos1 = $MATCH->{'to'};
                                                        (((((do {
                                                                            (((('pod' eq substr($str, $MATCH->{'to'}, 3)) && ($MATCH->{'to'} = (3 + $MATCH->{'to'})))) && ((do {
                                                                                        my $m2 = $grammar->pod_pod_begin($str, $MATCH->{'to'});
                                                                                        if ($m2) {
                                                                                            $MATCH->{'to'} = $m2->{'to'};
                                                                                            1
                                                                                        }
                                                                                        else {
                                                                                            0
                                                                                        }
                                                                                    })))
                                                                        })) || ((do {
                                                                            $MATCH->{'to'} = $pos1;
                                                                            ((((('head' eq substr($str, $MATCH->{'to'}, 4)) && ($MATCH->{'to'} = (4 + $MATCH->{'to'})))) && ((do {
                                                                                            my $m2 = $grammar->pod_pod_begin($str, $MATCH->{'to'});
                                                                                            if ($m2) {
                                                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                                                1
                                                                                            }
                                                                                            else {
                                                                                                0
                                                                                            }
                                                                                        }))))
                                                                        }))) || ((do {
                                                                        $MATCH->{'to'} = $pos1;
                                                                        ((((('begin' eq substr($str, $MATCH->{'to'}, 5)) && ($MATCH->{'to'} = (5 + $MATCH->{'to'})))) && ((do {
                                                                                        my $m2 = $grammar->pod_begin($str, $MATCH->{'to'});
                                                                                        if ($m2) {
                                                                                            $MATCH->{'to'} = $m2->{'to'};
                                                                                            1
                                                                                        }
                                                                                        else {
                                                                                            0
                                                                                        }
                                                                                    }))))
                                                                    }))) || ((do {
                                                                    $MATCH->{'to'} = $pos1;
                                                                    ((((('for' eq substr($str, $MATCH->{'to'}, 3)) && ($MATCH->{'to'} = (3 + $MATCH->{'to'})))) && ((do {
                                                                                    my $m2 = $grammar->pod_begin($str, $MATCH->{'to'});
                                                                                    if ($m2) {
                                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                                        1
                                                                                    }
                                                                                    else {
                                                                                        0
                                                                                    }
                                                                                }))))
                                                                })))
                                                    })))
                                        })) || ((do {
                                            $MATCH->{'to'} = $pos1;
                                            ((((((((((('#' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                                                    my $last_match_null = 0;
                                                                                    my $m = $MATCH;
                                                                                    my $to = $MATCH->{'to'};
                                                                                    for ( ; (((do {
                                                                                                    my $pos1 = $MATCH->{'to'};
                                                                                                    (((do {
                                                                                                                ((' ' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))
                                                                                                            })) || ((do {
                                                                                                                $MATCH->{'to'} = $pos1;
                                                                                                                (((chr(9) eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
                                                                                                            })))
                                                                                                })) && (($last_match_null < 2))); {

                                                                                        } ) {
                                                                                        if (($to == $MATCH->{'to'})) {
                                                                                            $last_match_null = ($last_match_null + 1)
                                                                                        }
                                                                                        else {
                                                                                            $last_match_null = 0
                                                                                        };
                                                                                        $m = $MATCH;
                                                                                        $to = $MATCH->{'to'}
                                                                                    };
                                                                                    $MATCH = $m;
                                                                                    $MATCH->{'to'} = $to;
                                                                                    1
                                                                                }))) && ((('line' eq substr($str, $MATCH->{'to'}, 4)) && ($MATCH->{'to'} = (4 + $MATCH->{'to'}))))) && ((do {
                                                                            my $last_match_null = 0;
                                                                            my $m = $MATCH;
                                                                            my $to = $MATCH->{'to'};
                                                                            my $count = 0;
                                                                            for ( ; (((do {
                                                                                            my $pos1 = $MATCH->{'to'};
                                                                                            (((do {
                                                                                                        ((' ' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))
                                                                                                    })) || ((do {
                                                                                                        $MATCH->{'to'} = $pos1;
                                                                                                        (((chr(9) eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
                                                                                                    })))
                                                                                        })) && (($last_match_null < 2))); {

                                                                                } ) {
                                                                                if (($to == $MATCH->{'to'})) {
                                                                                    $last_match_null = ($last_match_null + 1)
                                                                                }
                                                                                else {
                                                                                    $last_match_null = 0
                                                                                };
                                                                                $m = $MATCH;
                                                                                $to = $MATCH->{'to'};
                                                                                $count = ($count + 1)
                                                                            };
                                                                            $MATCH = $m;
                                                                            $MATCH->{'to'} = $to;
                                                                            ($count > 0)
                                                                        }))) && ((do {
                                                                        my $m2 = Perlito5::Grammar->digits($str, $MATCH->{'to'});
                                                                        if ($m2) {
                                                                            $MATCH->{'to'} = $m2->{'to'};
                                                                            $MATCH->{'Perlito5::Grammar.digits'} = $m2;
                                                                            1
                                                                        }
                                                                        else {
                                                                            0
                                                                        }
                                                                    }))) && ((do {
                                                                    my $last_match_null = 0;
                                                                    my $m = $MATCH;
                                                                    my $to = $MATCH->{'to'};
                                                                    for ( ; (((do {
                                                                                    my $pos1 = $MATCH->{'to'};
                                                                                    (((do {
                                                                                                ((' ' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))
                                                                                            })) || ((do {
                                                                                                $MATCH->{'to'} = $pos1;
                                                                                                (((chr(9) eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
                                                                                            })))
                                                                                })) && (($last_match_null < 2))); {

                                                                        } ) {
                                                                        if (($to == $MATCH->{'to'})) {
                                                                            $last_match_null = ($last_match_null + 1)
                                                                        }
                                                                        else {
                                                                            $last_match_null = 0
                                                                        };
                                                                        $m = $MATCH;
                                                                        $to = $MATCH->{'to'}
                                                                    };
                                                                    $MATCH = $m;
                                                                    $MATCH->{'to'} = $to;
                                                                    1
                                                                }))) && ((do {
                                                                my $m2 = $grammar->to_eol($str, $MATCH->{'to'});
                                                                if ($m2) {
                                                                    $MATCH->{'to'} = $m2->{'to'};
                                                                    1
                                                                }
                                                                else {
                                                                    0
                                                                }
                                                            }))) && ((do {
                                                            $MATCH->{'str'} = $str;
                                                            $Perlito5::LINE_NUMBER = (0 + Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.digits'}));
                                                            1
                                                        }))))
                                        }))) || ((do {
                                        $MATCH->{'to'} = $pos1;
                                        1
                                    })))
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Space::ws {
    my $self = shift();
    my $str = shift();
    my $pos = shift();
    my $p = $pos;
    for ( ; exists($space{substr($str, $p, 1)}); {

        } ) {
        $p = $space{substr($str, $p, 1)}->($str, ($p + 1))
    };
    return term_end($str, $p) if ((substr($str, $p, 7) eq '__END__') || (substr($str, $p, 8) eq '__DATA__'));
    if (($p == $pos)) {
        return 0
    };
    return {'str', $str, 'from', $pos, 'to', $p}
};
sub Perlito5::Grammar::Space::opt_ws {
    my $self = shift();
    my $str = shift();
    my $pos = shift();
    my $p = $pos;
    for ( ; exists($space{substr($str, $p, 1)}); {

        } ) {
        $p = $space{substr($str, $p, 1)}->($str, ($p + 1))
    };
    return term_end($str, $p) if ((substr($str, $p, 7) eq '__END__') || (substr($str, $p, 8) eq '__DATA__'));
    return {'str', $str, 'from', $pos, 'to', $p}
};
1;

;
package main;
package Perlito5::Grammar::Print;

# use strict
;
our %Print = ('print', 1, 'printf', 1, 'say', 1, 'exec', 1, 'system', 1);
Perlito5::Grammar::Precedence::add_term('print', sub {
        Perlito5::Grammar::Print->term_print($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('printf', sub {
        Perlito5::Grammar::Print->term_print($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('say', sub {
        Perlito5::Grammar::Print->term_print($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('exec', sub {
        Perlito5::Grammar::Print->term_print($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('system', sub {
        Perlito5::Grammar::Print->term_print($_[0], $_[1])
    });
sub Perlito5::Grammar::Print::print_decl {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((do {
                    my $pos1 = $MATCH->{'to'};
                    ((((((do {
                                            (('print' eq substr($str, $MATCH->{'to'}, 5)) && ($MATCH->{'to'} = (5 + $MATCH->{'to'})))
                                        })) || ((do {
                                            $MATCH->{'to'} = $pos1;
                                            ((('printf' eq substr($str, $MATCH->{'to'}, 6)) && ($MATCH->{'to'} = (6 + $MATCH->{'to'}))))
                                        }))) || ((do {
                                        $MATCH->{'to'} = $pos1;
                                        ((('say' eq substr($str, $MATCH->{'to'}, 3)) && ($MATCH->{'to'} = (3 + $MATCH->{'to'}))))
                                    }))) || ((do {
                                    $MATCH->{'to'} = $pos1;
                                    ((('exec' eq substr($str, $MATCH->{'to'}, 4)) && ($MATCH->{'to'} = (4 + $MATCH->{'to'}))))
                                }))) || ((do {
                                $MATCH->{'to'} = $pos1;
                                ((('system' eq substr($str, $MATCH->{'to'}, 6)) && ($MATCH->{'to'} = (6 + $MATCH->{'to'}))))
                            })))
                })));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Print::the_object {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((((do {
                            my $pos1 = $MATCH->{'to'};
                            ((((do {
                                            (((((do {
                                                                my $tmp = $MATCH;
                                                                $MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}};
                                                                my $res = ((('$' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))));
                                                                $MATCH = ($res ? $tmp : 0)
                                                            })) && ((do {
                                                                my $m2 = Perlito5::Grammar::Sigil->term_sigil($str, $MATCH->{'to'});
                                                                if ($m2) {
                                                                    $MATCH->{'to'} = $m2->{'to'};
                                                                    $MATCH->{'Perlito5::Grammar::Sigil.term_sigil'} = $m2;
                                                                    1
                                                                }
                                                                else {
                                                                    0
                                                                }
                                                            }))) && ((do {
                                                            my $tmp = $MATCH;
                                                            $MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}};
                                                            my $res = ((('+' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))));
                                                            $MATCH = ($res ? 0 : $tmp)
                                                        }))) && ((do {
                                                        $MATCH->{'str'} = $str;
                                                        $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Sigil.term_sigil'})->[1];
                                                        1
                                                    })))
                                        })) || ((do {
                                            $MATCH->{'to'} = $pos1;
                                            (((((do {
                                                                my $tmp = $MATCH;
                                                                $MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}};
                                                                my $res = ((('{' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))));
                                                                $MATCH = ($res ? $tmp : 0)
                                                            })) && ((do {
                                                                my $m2 = Perlito5::Grammar::Expression->term_curly($str, $MATCH->{'to'});
                                                                if ($m2) {
                                                                    $MATCH->{'to'} = $m2->{'to'};
                                                                    $MATCH->{'Perlito5::Grammar::Expression.term_curly'} = $m2;
                                                                    1
                                                                }
                                                                else {
                                                                    0
                                                                }
                                                            }))) && ((do {
                                                            $MATCH->{'str'} = $str;
                                                            $MATCH->{'capture'} = Perlito5::AST::Lit::Block->new('stmts', $MATCH->{'Perlito5::Grammar::Expression.term_curly'}->{'capture'}->[2]);
                                                            1
                                                        }))))
                                        }))) || ((do {
                                        $MATCH->{'to'} = $pos1;
                                        (((((do {
                                                            my $m2 = $grammar->typeglob($str, $MATCH->{'to'});
                                                            if ($m2) {
                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                $MATCH->{'typeglob'} = $m2;
                                                                1
                                                            }
                                                            else {
                                                                0
                                                            }
                                                        })) && ((do {
                                                            my $tmp = $MATCH;
                                                            $MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}};
                                                            my $res = ((('(' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))));
                                                            $MATCH = ($res ? 0 : $tmp)
                                                        }))) && ((do {
                                                        $MATCH->{'str'} = $str;
                                                        $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'typeglob'});
                                                        1
                                                    }))))
                                    })))
                        })) && ((do {
                            $MATCH->{'str'} = $str;
                            my $pos = $MATCH->{'to'};
                            my $m = Perlito5::Grammar::Space->ws($MATCH->{'str'}, $pos);
                            $pos = $m->{'to'} if $m;
                            my $s = substr($MATCH->{'str'}, $pos, 1);
                            my $s2 = substr($MATCH->{'str'}, $pos, 2);
                            if (((((($s eq ',') || ($s eq '?')) || ($s2 eq '->')) || ($s eq '[')) || ($s eq '{'))) {
                                return 
                            };
                            if (($s eq '+')) {
                                my $m = Perlito5::Grammar::Space->ws($MATCH->{'str'}, ($pos + 1));
                                if ($m) {
                                    return 
                                }
                            }
                            else {
                                my $m = Perlito5::Grammar::Precedence->op_parse($MATCH->{'str'}, $pos, 1);
                                my $next_op = ($m ? Perlito5::Match::flat($m)->[1] : '');
                                my $is_infix = Perlito5::Grammar::Precedence::is_fixity_type('infix', $next_op);
                                return  if $is_infix
                            };
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Print::typeglob {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $p = $pos;
    my $m_namespace = Perlito5::Grammar->optional_namespace_before_ident($str, $p);
    my $namespace = Perlito5::Match::flat($m_namespace);
    $p = $m_namespace->{'to'};
    my $m_name = Perlito5::Grammar->ident($str, $p);
    if (!($m_name)) {
        if ($namespace) {
            $m_namespace->{'capture'} = Perlito5::AST::Var->new('sigil', '::', 'name', '', 'namespace', $namespace);
            return $m_namespace
        };
        return 
    };
    my $name = Perlito5::Match::flat($m_name);
    $p = $m_name->{'to'};
    if ((substr($str, $p, 2) eq '::')) {
        $m_name->{'to'} = ($p + 2);
        $m_name->{'capture'} = Perlito5::AST::Var->new('sigil', '::', 'name', '', 'namespace', ($namespace . '::' . $name));
        return $m_name
    };
    my $effective_name = ((($namespace || $Perlito5::PKG_NAME)) . '::' . $name);
    if (exists($Perlito5::PROTO->{$effective_name})) {
        return 
    };
    if ((((!($namespace) || ($namespace eq 'CORE'))) && exists($Perlito5::CORE_PROTO->{('CORE::' . $name)}))) {
        return 
    };
    my $full_name = $name;
    $full_name = ($namespace . '::' . $name) if $namespace;
    $m_name->{'capture'} = Perlito5::AST::Var->new('sigil', '::', 'name', '', 'namespace', $full_name);
    return $m_name
};
sub Perlito5::Grammar::Print::print_ast {
    my($decl, $the_object, $expr) = @_;
    Perlito5::AST::Apply->new('namespace', '', 'code', $decl, 'special_arg', $the_object, 'arguments', $expr)
};
sub Perlito5::Grammar::Print::term_print {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = ((((((do {
                                my $m2 = $grammar->print_decl($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    $MATCH->{'print_decl'} = $m2;
                                    1
                                }
                                else {
                                    0
                                }
                            })) && ((do {
                                my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    1
                                }
                                else {
                                    0
                                }
                            }))) && ((do {
                            my $pos1 = $MATCH->{'to'};
                            (((do {
                                        (((((((('(' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                                    my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                    if ($m2) {
                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                        1
                                                                    }
                                                                    else {
                                                                        0
                                                                    }
                                                                }))) && ((do {
                                                                my $m2 = $grammar->the_object($str, $MATCH->{'to'});
                                                                if ($m2) {
                                                                    $MATCH->{'to'} = $m2->{'to'};
                                                                    $MATCH->{'the_object'} = $m2;
                                                                    1
                                                                }
                                                                else {
                                                                    0
                                                                }
                                                            }))) && ((do {
                                                            my $m2 = Perlito5::Grammar::Expression->list_parse($str, $MATCH->{'to'});
                                                            if ($m2) {
                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                $MATCH->{'Perlito5::Grammar::Expression.list_parse'} = $m2;
                                                                1
                                                            }
                                                            else {
                                                                0
                                                            }
                                                        }))) && (((')' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                    $MATCH->{'str'} = $str;
                                                    my $list = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression.list_parse'});
                                                    return  if !(ref($list));
                                                    $MATCH->{'capture'} = ['term', print_ast(Perlito5::Match::flat($MATCH->{'print_decl'}), Perlito5::Match::flat($MATCH->{'the_object'}), Perlito5::Grammar::Expression::expand_list($list))];
                                                    1
                                                })))
                                    })) || ((do {
                                        $MATCH->{'to'} = $pos1;
                                        (((((do {
                                                            my $m2 = $grammar->the_object($str, $MATCH->{'to'});
                                                            if ($m2) {
                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                $MATCH->{'the_object'} = $m2;
                                                                1
                                                            }
                                                            else {
                                                                0
                                                            }
                                                        })) && ((do {
                                                            my $m2 = Perlito5::Grammar::Expression->list_parse($str, $MATCH->{'to'});
                                                            if ($m2) {
                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                $MATCH->{'Perlito5::Grammar::Expression.list_parse'} = $m2;
                                                                1
                                                            }
                                                            else {
                                                                0
                                                            }
                                                        }))) && ((do {
                                                        $MATCH->{'str'} = $str;
                                                        my $list = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression.list_parse'});
                                                        return  if !(ref($list));
                                                        $MATCH->{'capture'} = ['term', print_ast(Perlito5::Match::flat($MATCH->{'print_decl'}), Perlito5::Match::flat($MATCH->{'the_object'}), Perlito5::Grammar::Expression::expand_list($list))];
                                                        1
                                                    }))))
                                    })))
                        })))));
    ($tmp ? $MATCH : 0)
};
1;

;
package main;
package Perlito5::Grammar::Map;

# use strict
;
Perlito5::Grammar::Precedence::add_term('map', sub {
        Perlito5::Grammar::Map->term_map_or_grep($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('grep', sub {
        Perlito5::Grammar::Map->term_map_or_grep($_[0], $_[1])
    });
Perlito5::Grammar::Precedence::add_term('sort', sub {
        Perlito5::Grammar::Map->term_sort($_[0], $_[1])
    });
sub Perlito5::Grammar::Map::map_or_grep {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((do {
                    my $pos1 = $MATCH->{'to'};
                    (((do {
                                (('map' eq substr($str, $MATCH->{'to'}, 3)) && ($MATCH->{'to'} = (3 + $MATCH->{'to'})))
                            })) || ((do {
                                $MATCH->{'to'} = $pos1;
                                ((('grep' eq substr($str, $MATCH->{'to'}, 4)) && ($MATCH->{'to'} = (4 + $MATCH->{'to'}))))
                            })))
                })));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Map::term_map_or_grep {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = ((((((do {
                                my $m2 = $grammar->map_or_grep($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    $MATCH->{'map_or_grep'} = $m2;
                                    1
                                }
                                else {
                                    0
                                }
                            })) && ((do {
                                my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    1
                                }
                                else {
                                    0
                                }
                            }))) && ((do {
                            my $pos1 = $MATCH->{'to'};
                            (((do {
                                        ((((do {
                                                        my $m2 = Perlito5::Grammar::Expression->term_curly($str, $MATCH->{'to'});
                                                        if ($m2) {
                                                            $MATCH->{'to'} = $m2->{'to'};
                                                            $MATCH->{'Perlito5::Grammar::Expression.term_curly'} = $m2;
                                                            1
                                                        }
                                                        else {
                                                            0
                                                        }
                                                    })) && ((do {
                                                        my $m2 = Perlito5::Grammar::Expression->list_parse($str, $MATCH->{'to'});
                                                        if ($m2) {
                                                            $MATCH->{'to'} = $m2->{'to'};
                                                            $MATCH->{'Perlito5::Grammar::Expression.list_parse'} = $m2;
                                                            1
                                                        }
                                                        else {
                                                            0
                                                        }
                                                    }))) && ((do {
                                                    $MATCH->{'str'} = $str;
                                                    $MATCH->{'capture'} = ['term', Perlito5::AST::Apply->new('code', Perlito5::Match::flat($MATCH->{'map_or_grep'}), 'special_arg', Perlito5::AST::Lit::Block->new('stmts', $MATCH->{'Perlito5::Grammar::Expression.term_curly'}->{'capture'}->[2]), 'arguments', Perlito5::Grammar::Expression::expand_list($MATCH->{'Perlito5::Grammar::Expression.list_parse'}->{'capture'}), 'namespace', '')];
                                                    1
                                                })))
                                    })) || ((do {
                                        $MATCH->{'to'} = $pos1;
                                        ((((((((('(' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                                        my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                        if ($m2) {
                                                                            $MATCH->{'to'} = $m2->{'to'};
                                                                            1
                                                                        }
                                                                        else {
                                                                            0
                                                                        }
                                                                    }))) && ((do {
                                                                    my $m2 = Perlito5::Grammar::Expression->term_curly($str, $MATCH->{'to'});
                                                                    if ($m2) {
                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                        $MATCH->{'Perlito5::Grammar::Expression.term_curly'} = $m2;
                                                                        1
                                                                    }
                                                                    else {
                                                                        0
                                                                    }
                                                                }))) && ((do {
                                                                my $m2 = Perlito5::Grammar::Expression->list_parse($str, $MATCH->{'to'});
                                                                if ($m2) {
                                                                    $MATCH->{'to'} = $m2->{'to'};
                                                                    $MATCH->{'Perlito5::Grammar::Expression.list_parse'} = $m2;
                                                                    1
                                                                }
                                                                else {
                                                                    0
                                                                }
                                                            }))) && (((')' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                        $MATCH->{'str'} = $str;
                                                        $MATCH->{'capture'} = ['term', Perlito5::AST::Apply->new('code', Perlito5::Match::flat($MATCH->{'map_or_grep'}), 'special_arg', Perlito5::AST::Lit::Block->new('stmts', $MATCH->{'Perlito5::Grammar::Expression.term_curly'}->{'capture'}->[2]), 'arguments', Perlito5::Grammar::Expression::expand_list($MATCH->{'Perlito5::Grammar::Expression.list_parse'}->{'capture'}), 'namespace', '')];
                                                        1
                                                    }))))
                                    })))
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Map::term_sort {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = ((((((('sort' eq substr($str, $MATCH->{'to'}, 4)) && ($MATCH->{'to'} = (4 + $MATCH->{'to'})))) && ((do {
                                my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    1
                                }
                                else {
                                    0
                                }
                            }))) && ((do {
                            my $pos1 = $MATCH->{'to'};
                            (((do {
                                        ((((do {
                                                        my $pos1 = $MATCH->{'to'};
                                                        ((((do {
                                                                        (((do {
                                                                                    my $m2 = Perlito5::Grammar::Expression->term_curly($str, $MATCH->{'to'});
                                                                                    if ($m2) {
                                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                                        $MATCH->{'Perlito5::Grammar::Expression.term_curly'} = $m2;
                                                                                        1
                                                                                    }
                                                                                    else {
                                                                                        0
                                                                                    }
                                                                                })) && ((do {
                                                                                    $MATCH->{'str'} = $str;
                                                                                    $MATCH->{'_tmp'} = Perlito5::AST::Lit::Block->new('stmts', $MATCH->{'Perlito5::Grammar::Expression.term_curly'}->{'capture'}->[2]);
                                                                                    1
                                                                                })))
                                                                    })) || ((do {
                                                                        $MATCH->{'to'} = $pos1;
                                                                        ((((do {
                                                                                        my $m2 = Perlito5::Grammar->full_ident($str, $MATCH->{'to'});
                                                                                        if ($m2) {
                                                                                            $MATCH->{'to'} = $m2->{'to'};
                                                                                            $MATCH->{'Perlito5::Grammar.full_ident'} = $m2;
                                                                                            1
                                                                                        }
                                                                                        else {
                                                                                            0
                                                                                        }
                                                                                    })) && ((do {
                                                                                        $MATCH->{'str'} = $str;
                                                                                        my $name = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.full_ident'});
                                                                                        return  if ($Perlito5::CORE_PROTO->{$name} || $Perlito5::CORE_PROTO->{('CORE::' . $name)});
                                                                                        $MATCH->{'_tmp'} = $name;
                                                                                        1
                                                                                    }))))
                                                                    }))) || ((do {
                                                                    $MATCH->{'to'} = $pos1;
                                                                    (((((do {
                                                                                        my $tmp = $MATCH;
                                                                                        $MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}};
                                                                                        my $res = ((('$' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))));
                                                                                        $MATCH = ($res ? $tmp : 0)
                                                                                    })) && ((do {
                                                                                        my $m2 = Perlito5::Grammar::Sigil->term_sigil($str, $MATCH->{'to'});
                                                                                        if ($m2) {
                                                                                            $MATCH->{'to'} = $m2->{'to'};
                                                                                            $MATCH->{'Perlito5::Grammar::Sigil.term_sigil'} = $m2;
                                                                                            1
                                                                                        }
                                                                                        else {
                                                                                            0
                                                                                        }
                                                                                    }))) && ((do {
                                                                                    $MATCH->{'str'} = $str;
                                                                                    my $var = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Sigil.term_sigil'})->[1];
                                                                                    return  if (ref($var) ne 'Perlito5::AST::Var');
                                                                                    $MATCH->{'_tmp'} = $var;
                                                                                    1
                                                                                }))))
                                                                })))
                                                    })) && ((do {
                                                        my $m2 = Perlito5::Grammar::Expression->list_parse($str, $MATCH->{'to'});
                                                        if ($m2) {
                                                            $MATCH->{'to'} = $m2->{'to'};
                                                            $MATCH->{'Perlito5::Grammar::Expression.list_parse'} = $m2;
                                                            1
                                                        }
                                                        else {
                                                            0
                                                        }
                                                    }))) && ((do {
                                                    $MATCH->{'str'} = $str;
                                                    $MATCH->{'capture'} = ['term', Perlito5::AST::Apply->new('code', 'sort', 'special_arg', $MATCH->{'_tmp'}, 'arguments', Perlito5::Grammar::Expression::expand_list($MATCH->{'Perlito5::Grammar::Expression.list_parse'}->{'capture'}), 'namespace', '')];
                                                    1
                                                })))
                                    })) || ((do {
                                        $MATCH->{'to'} = $pos1;
                                        ((((((((('(' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                                        my $m2 = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'});
                                                                        if ($m2) {
                                                                            $MATCH->{'to'} = $m2->{'to'};
                                                                            1
                                                                        }
                                                                        else {
                                                                            0
                                                                        }
                                                                    }))) && ((do {
                                                                    my $pos1 = $MATCH->{'to'};
                                                                    ((((do {
                                                                                    ((((do {
                                                                                                    my $m2 = Perlito5::Grammar->full_ident($str, $MATCH->{'to'});
                                                                                                    if ($m2) {
                                                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                                                        $MATCH->{'Perlito5::Grammar.full_ident'} = $m2;
                                                                                                        1
                                                                                                    }
                                                                                                    else {
                                                                                                        0
                                                                                                    }
                                                                                                })) && ((do {
                                                                                                    my $m2 = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'});
                                                                                                    if ($m2) {
                                                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                                                        1
                                                                                                    }
                                                                                                    else {
                                                                                                        0
                                                                                                    }
                                                                                                }))) && ((do {
                                                                                                $MATCH->{'str'} = $str;
                                                                                                my $name = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.full_ident'});
                                                                                                return  if ($Perlito5::CORE_PROTO->{$name} || $Perlito5::CORE_PROTO->{('CORE::' . $name)});
                                                                                                $MATCH->{'_tmp'} = $name;
                                                                                                1
                                                                                            })))
                                                                                })) || ((do {
                                                                                    $MATCH->{'to'} = $pos1;
                                                                                    ((((do {
                                                                                                    my $m2 = Perlito5::Grammar::Expression->term_curly($str, $MATCH->{'to'});
                                                                                                    if ($m2) {
                                                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                                                        $MATCH->{'Perlito5::Grammar::Expression.term_curly'} = $m2;
                                                                                                        1
                                                                                                    }
                                                                                                    else {
                                                                                                        0
                                                                                                    }
                                                                                                })) && ((do {
                                                                                                    $MATCH->{'str'} = $str;
                                                                                                    $MATCH->{'_tmp'} = Perlito5::AST::Lit::Block->new('stmts', $MATCH->{'Perlito5::Grammar::Expression.term_curly'}->{'capture'}->[2]);
                                                                                                    1
                                                                                                }))))
                                                                                }))) || ((do {
                                                                                $MATCH->{'to'} = $pos1;
                                                                                (((((do {
                                                                                                    my $tmp = $MATCH;
                                                                                                    $MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}};
                                                                                                    my $res = ((('$' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))));
                                                                                                    $MATCH = ($res ? $tmp : 0)
                                                                                                })) && ((do {
                                                                                                    my $m2 = Perlito5::Grammar::Sigil->term_sigil($str, $MATCH->{'to'});
                                                                                                    if ($m2) {
                                                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                                                        $MATCH->{'Perlito5::Grammar::Sigil.term_sigil'} = $m2;
                                                                                                        1
                                                                                                    }
                                                                                                    else {
                                                                                                        0
                                                                                                    }
                                                                                                }))) && ((do {
                                                                                                $MATCH->{'str'} = $str;
                                                                                                my $var = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Sigil.term_sigil'})->[1];
                                                                                                return  if (ref($var) ne 'Perlito5::AST::Var');
                                                                                                $MATCH->{'_tmp'} = $var;
                                                                                                1
                                                                                            }))))
                                                                            })))
                                                                }))) && ((do {
                                                                my $m2 = Perlito5::Grammar::Expression->list_parse($str, $MATCH->{'to'});
                                                                if ($m2) {
                                                                    $MATCH->{'to'} = $m2->{'to'};
                                                                    $MATCH->{'Perlito5::Grammar::Expression.list_parse'} = $m2;
                                                                    1
                                                                }
                                                                else {
                                                                    0
                                                                }
                                                            }))) && (((')' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
                                                        $MATCH->{'str'} = $str;
                                                        $MATCH->{'capture'} = ['term', Perlito5::AST::Apply->new('code', 'sort', 'special_arg', $MATCH->{'_tmp'}, 'arguments', Perlito5::Grammar::Expression::expand_list($MATCH->{'Perlito5::Grammar::Expression.list_parse'}->{'capture'}), 'namespace', '')];
                                                        1
                                                    }))))
                                    })))
                        })))));
    ($tmp ? $MATCH : 0)
};
1;

;
package main;
package Perlito5::Grammar;

# use Perlito5::Grammar::Expression
;

# use Perlito5::Grammar::Control
;

# use Perlito5::Grammar::String
;

# use Perlito5::Grammar::Sigil
;

# use Perlito5::Grammar::Use
;

# use Perlito5::Grammar::Block
;

# use Perlito5::Grammar::Space
;

# use Perlito5::Grammar::Print
;

# use Perlito5::Grammar::Map
;

# use Perlito5::Grammar::Attribute
;
sub Perlito5::Grammar::word {
    ((substr($_[1], $_[2], 1) =~ m!\w!) ? {'str', $_[1], 'from', $_[2], 'to', ($_[2] + 1)} : 0)
};
sub Perlito5::Grammar::digit {
    ((substr($_[1], $_[2], 1) =~ m!\d!) ? {'str', $_[1], 'from', $_[2], 'to', ($_[2] + 1)} : 0)
};
sub Perlito5::Grammar::ident {
    return  if ((substr($_[1], $_[2], 1) !~ m!\w!) || (substr($_[1], $_[2], 1) =~ m!\d!));
    my $m = {'str', $_[1], 'from', $_[2], 'to', ($_[2] + 1)};
    ($m->{'to'})++ while (substr($_[1], $m->{'to'}, 1) =~ m!\w!);
    $m
};
sub Perlito5::Grammar::caret_char {
    my $c = substr($_[1], $_[2], 1);
    my $pos = $_[2];
    if (($c eq '^')) {
        ($pos)++;
        $c = substr($_[1], $pos, 1);
        return 0 if (($c lt 'A') || ($c gt 'Z'));
        $c = chr(((ord($c) - ord('A')) + 1))
    }
    else {
        if (Perlito5::Grammar::Space->ws($_[1], $pos)) {
            return 0
        }
    };
    return 0 if (($c lt chr(1)) || ($c gt chr(26)));
    return {'str', $_[1], 'from', $_[2], 'to', ($pos + 1), 'capture', $c}
};
sub Perlito5::Grammar::full_ident {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((((do {
                            my $m2 = $grammar->ident($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {
                                0
                            }
                        })) && ((do {
                            my $last_match_null = 0;
                            my $m = $MATCH;
                            my $to = $MATCH->{'to'};
                            for ( ; (((((('::' eq substr($str, $MATCH->{'to'}, 2)) && ($MATCH->{'to'} = (2 + $MATCH->{'to'})))) && ((do {
                                                    my $m2 = $grammar->ident($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                })))) && (($last_match_null < 2))); {

                                } ) {
                                if (($to == $MATCH->{'to'})) {
                                    $last_match_null = ($last_match_null + 1)
                                }
                                else {
                                    $last_match_null = 0
                                };
                                $m = $MATCH;
                                $to = $MATCH->{'to'}
                            };
                            $MATCH = $m;
                            $MATCH->{'to'} = $to;
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::namespace_before_ident {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = ((((((do {
                                my $m2 = $grammar->ident($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    1
                                }
                                else {
                                    0
                                }
                            })) && ((do {
                                my $tmp = $MATCH;
                                $MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}};
                                my $res = ((('::' eq substr($str, $MATCH->{'to'}, 2)) && ($MATCH->{'to'} = (2 + $MATCH->{'to'}))));
                                $MATCH = ($res ? $tmp : 0)
                            }))) && ((do {
                            my $last_match_null = 0;
                            my $m = $MATCH;
                            my $to = $MATCH->{'to'};
                            for ( ; ((((((('::' eq substr($str, $MATCH->{'to'}, 2)) && ($MATCH->{'to'} = (2 + $MATCH->{'to'})))) && ((do {
                                                        my $m2 = $grammar->ident($str, $MATCH->{'to'});
                                                        if ($m2) {
                                                            $MATCH->{'to'} = $m2->{'to'};
                                                            1
                                                        }
                                                        else {
                                                            0
                                                        }
                                                    }))) && ((do {
                                                    my $tmp = $MATCH;
                                                    $MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}};
                                                    my $res = ((('::' eq substr($str, $MATCH->{'to'}, 2)) && ($MATCH->{'to'} = (2 + $MATCH->{'to'}))));
                                                    $MATCH = ($res ? $tmp : 0)
                                                })))) && (($last_match_null < 2))); {

                                } ) {
                                if (($to == $MATCH->{'to'})) {
                                    $last_match_null = ($last_match_null + 1)
                                }
                                else {
                                    $last_match_null = 0
                                };
                                $m = $MATCH;
                                $to = $MATCH->{'to'}
                            };
                            $MATCH = $m;
                            $MATCH->{'to'} = $to;
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::optional_namespace_before_ident {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((do {
                    my $pos1 = $MATCH->{'to'};
                    ((((do {
                                    ((((do {
                                                    my $m2 = $grammar->namespace_before_ident($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        $MATCH->{'namespace_before_ident'} = $m2;
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                })) && ((do {
                                                    my $last_match_null = 0;
                                                    my $m = $MATCH;
                                                    my $to = $MATCH->{'to'};
                                                    for ( ; (((('::' eq substr($str, $MATCH->{'to'}, 2)) && ($MATCH->{'to'} = (2 + $MATCH->{'to'})))) && (($last_match_null < 2))); {

                                                        } ) {
                                                        if (($to == $MATCH->{'to'})) {
                                                            $last_match_null = ($last_match_null + 1)
                                                        }
                                                        else {
                                                            $last_match_null = 0
                                                        };
                                                        $m = $MATCH;
                                                        $to = $MATCH->{'to'}
                                                    };
                                                    $MATCH = $m;
                                                    $MATCH->{'to'} = $to;
                                                    1
                                                }))) && ((do {
                                                $MATCH->{'str'} = $str;
                                                $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'namespace_before_ident'});
                                                1
                                            })))
                                })) || ((do {
                                    $MATCH->{'to'} = $pos1;
                                    (((((('::' eq substr($str, $MATCH->{'to'}, 2)) && ($MATCH->{'to'} = (2 + $MATCH->{'to'})))) && ((do {
                                                        my $m2 = $grammar->optional_namespace_before_ident($str, $MATCH->{'to'});
                                                        if ($m2) {
                                                            $MATCH->{'to'} = $m2->{'to'};
                                                            $MATCH->{'optional_namespace_before_ident'} = $m2;
                                                            1
                                                        }
                                                        else {
                                                            0
                                                        }
                                                    }))) && ((do {
                                                    $MATCH->{'str'} = $str;
                                                    my $name = Perlito5::Match::flat($MATCH->{'optional_namespace_before_ident'});
                                                    $MATCH->{'capture'} = 'main';
                                                    $MATCH->{'capture'} = ($MATCH->{'capture'} . ('::' . $name)) if ($name ne '');
                                                    1
                                                }))))
                                }))) || ((do {
                                $MATCH->{'to'} = $pos1;
                                ((1 && ((do {
                                                $MATCH->{'str'} = $str;
                                                $MATCH->{'capture'} = '';
                                                1
                                            }))))
                            })))
                })));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::exp_stmts2 {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((((do {
                            my $m2 = $grammar->exp_stmts($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'exp_stmts'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        })) && ((do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'exp_stmts'});
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::exp {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((((do {
                            my $m2 = Perlito5::Grammar::Expression->exp_parse($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::Expression.exp_parse'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        })) && ((do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression.exp_parse'});
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::exp2 {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((((do {
                            my $m2 = Perlito5::Grammar::Expression->exp_parse($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::Expression.exp_parse'} = $m2;
                                1
                            }
                            else {
                                0
                            }
                        })) && ((do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression.exp_parse'});
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::opt_type {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((do {
                    my $pos1 = $MATCH->{'to'};
                    (((do {
                                ((((do {
                                                my $m = $MATCH;
                                                if (!(((('::' eq substr($str, $MATCH->{'to'}, 2)) && ($MATCH->{'to'} = (2 + $MATCH->{'to'})))))) {
                                                    $MATCH = $m
                                                };
                                                1
                                            })) && ((do {
                                                my $m2 = $grammar->full_ident($str, $MATCH->{'to'});
                                                if ($m2) {
                                                    $MATCH->{'to'} = $m2->{'to'};
                                                    $MATCH->{'full_ident'} = $m2;
                                                    1
                                                }
                                                else {
                                                    0
                                                }
                                            }))) && ((do {
                                            $MATCH->{'str'} = $str;
                                            $MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'full_ident'});
                                            1
                                        })))
                            })) || ((do {
                                $MATCH->{'to'} = $pos1;
                                ((1 && ((do {
                                                $MATCH->{'str'} = $str;
                                                $MATCH->{'capture'} = '';
                                                1
                                            }))))
                            })))
                })));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::var_sigil {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((do {
                    my $pos1 = $MATCH->{'to'};
                    ((((((do {
                                            (('$' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))
                                        })) || ((do {
                                            $MATCH->{'to'} = $pos1;
                                            ((('%' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
                                        }))) || ((do {
                                        $MATCH->{'to'} = $pos1;
                                        ((('@' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
                                    }))) || ((do {
                                    $MATCH->{'to'} = $pos1;
                                    ((('&' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
                                }))) || ((do {
                                $MATCH->{'to'} = $pos1;
                                ((('*' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
                            })))
                })));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::var_name {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((do {
                    my $pos1 = $MATCH->{'to'};
                    (((do {
                                my $m2 = $grammar->full_ident($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    $MATCH->{'full_ident'} = $m2;
                                    1
                                }
                                else {
                                    0
                                }
                            })) || ((do {
                                $MATCH->{'to'} = $pos1;
                                ((do {
                                        my $m2 = $grammar->digit($str, $MATCH->{'to'});
                                        if ($m2) {
                                            $MATCH->{'to'} = $m2->{'to'};
                                            $MATCH->{'digit'} = $m2;
                                            1
                                        }
                                        else {
                                            0
                                        }
                                    }))
                            })))
                })));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::var_ident {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((((((do {
                                    my $m2 = $grammar->var_sigil($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'var_sigil'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                })) && ((do {
                                    my $m2 = $grammar->optional_namespace_before_ident($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        $MATCH->{'optional_namespace_before_ident'} = $m2;
                                        1
                                    }
                                    else {
                                        0
                                    }
                                }))) && ((do {
                                my $m2 = $grammar->var_name($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    $MATCH->{'var_name'} = $m2;
                                    1
                                }
                                else {
                                    0
                                }
                            }))) && ((do {
                            $MATCH->{'str'} = $str;
                            $MATCH->{'capture'} = Perlito5::AST::Var->new('sigil', Perlito5::Match::flat($MATCH->{'var_sigil'}), 'namespace', Perlito5::Match::flat($MATCH->{'optional_namespace_before_ident'}), 'name', Perlito5::Match::flat($MATCH->{'var_name'}));
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::exponent {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = ((((((do {
                                my $pos1 = $MATCH->{'to'};
                                (((do {
                                            (('e' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))
                                        })) || ((do {
                                            $MATCH->{'to'} = $pos1;
                                            ((('E' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
                                        })))
                            })) && ((do {
                                my $pos1 = $MATCH->{'to'};
                                ((((do {
                                                (('+' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))
                                            })) || ((do {
                                                $MATCH->{'to'} = $pos1;
                                                ((('-' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
                                            }))) || ((do {
                                            $MATCH->{'to'} = $pos1;
                                            1
                                        })))
                            }))) && ((do {
                            my $last_match_null = 0;
                            my $m = $MATCH;
                            my $to = $MATCH->{'to'};
                            my $count = 0;
                            for ( ; (((do {
                                            my $pos1 = $MATCH->{'to'};
                                            (((do {
                                                        (('_' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))
                                                    })) || ((do {
                                                        $MATCH->{'to'} = $pos1;
                                                        ((do {
                                                                my $m2 = $grammar->digit($str, $MATCH->{'to'});
                                                                if ($m2) {
                                                                    $MATCH->{'to'} = $m2->{'to'};
                                                                    1
                                                                }
                                                                else {
                                                                    0
                                                                }
                                                            }))
                                                    })))
                                        })) && (($last_match_null < 2))); {

                                } ) {
                                if (($to == $MATCH->{'to'})) {
                                    $last_match_null = ($last_match_null + 1)
                                }
                                else {
                                    $last_match_null = 0
                                };
                                $m = $MATCH;
                                $to = $MATCH->{'to'};
                                $count = ($count + 1)
                            };
                            $MATCH = $m;
                            $MATCH->{'to'} = $to;
                            ($count > 0)
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::val_num {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((((do {
                            my $pos1 = $MATCH->{'to'};
                            (((do {
                                        (((((('.' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                            my $m2 = $grammar->digit($str, $MATCH->{'to'});
                                                            if ($m2) {
                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                1
                                                            }
                                                            else {
                                                                0
                                                            }
                                                        }))) && ((do {
                                                        my $last_match_null = 0;
                                                        my $m = $MATCH;
                                                        my $to = $MATCH->{'to'};
                                                        for ( ; (((do {
                                                                        my $pos1 = $MATCH->{'to'};
                                                                        (((do {
                                                                                    (('_' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))
                                                                                })) || ((do {
                                                                                    $MATCH->{'to'} = $pos1;
                                                                                    ((do {
                                                                                            my $m2 = $grammar->digit($str, $MATCH->{'to'});
                                                                                            if ($m2) {
                                                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                                                1
                                                                                            }
                                                                                            else {
                                                                                                0
                                                                                            }
                                                                                        }))
                                                                                })))
                                                                    })) && (($last_match_null < 2))); {

                                                            } ) {
                                                            if (($to == $MATCH->{'to'})) {
                                                                $last_match_null = ($last_match_null + 1)
                                                            }
                                                            else {
                                                                $last_match_null = 0
                                                            };
                                                            $m = $MATCH;
                                                            $to = $MATCH->{'to'}
                                                        };
                                                        $MATCH = $m;
                                                        $MATCH->{'to'} = $to;
                                                        1
                                                    }))) && ((do {
                                                    my $m = $MATCH;
                                                    if (!(((do {
                                                                    my $m2 = $grammar->exponent($str, $MATCH->{'to'});
                                                                    if ($m2) {
                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                        1
                                                                    }
                                                                    else {
                                                                        0
                                                                    }
                                                                })))) {
                                                        $MATCH = $m
                                                    };
                                                    1
                                                })))
                                    })) || ((do {
                                        $MATCH->{'to'} = $pos1;
                                        (((((do {
                                                            my $m2 = $grammar->digit($str, $MATCH->{'to'});
                                                            if ($m2) {
                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                1
                                                            }
                                                            else {
                                                                0
                                                            }
                                                        })) && ((do {
                                                            my $last_match_null = 0;
                                                            my $m = $MATCH;
                                                            my $to = $MATCH->{'to'};
                                                            for ( ; (((do {
                                                                            my $pos1 = $MATCH->{'to'};
                                                                            (((do {
                                                                                        (('_' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))
                                                                                    })) || ((do {
                                                                                        $MATCH->{'to'} = $pos1;
                                                                                        ((do {
                                                                                                my $m2 = $grammar->digit($str, $MATCH->{'to'});
                                                                                                if ($m2) {
                                                                                                    $MATCH->{'to'} = $m2->{'to'};
                                                                                                    1
                                                                                                }
                                                                                                else {
                                                                                                    0
                                                                                                }
                                                                                            }))
                                                                                    })))
                                                                        })) && (($last_match_null < 2))); {

                                                                } ) {
                                                                if (($to == $MATCH->{'to'})) {
                                                                    $last_match_null = ($last_match_null + 1)
                                                                }
                                                                else {
                                                                    $last_match_null = 0
                                                                };
                                                                $m = $MATCH;
                                                                $to = $MATCH->{'to'}
                                                            };
                                                            $MATCH = $m;
                                                            $MATCH->{'to'} = $to;
                                                            1
                                                        }))) && ((do {
                                                        my $pos1 = $MATCH->{'to'};
                                                        (((do {
                                                                    my $m2 = $grammar->exponent($str, $MATCH->{'to'});
                                                                    if ($m2) {
                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                        1
                                                                    }
                                                                    else {
                                                                        0
                                                                    }
                                                                })) || ((do {
                                                                    $MATCH->{'to'} = $pos1;
                                                                    ((((((('.' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                                                            my $tmp = $MATCH;
                                                                                            $MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}};
                                                                                            my $res = ((('.' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))));
                                                                                            $MATCH = ($res ? 0 : $tmp)
                                                                                        }))) && ((do {
                                                                                        my $last_match_null = 0;
                                                                                        my $m = $MATCH;
                                                                                        my $to = $MATCH->{'to'};
                                                                                        for ( ; (((do {
                                                                                                        my $pos1 = $MATCH->{'to'};
                                                                                                        (((do {
                                                                                                                    (('_' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))
                                                                                                                })) || ((do {
                                                                                                                    $MATCH->{'to'} = $pos1;
                                                                                                                    ((do {
                                                                                                                            my $m2 = $grammar->digit($str, $MATCH->{'to'});
                                                                                                                            if ($m2) {
                                                                                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                                                                                1
                                                                                                                            }
                                                                                                                            else {
                                                                                                                                0
                                                                                                                            }
                                                                                                                        }))
                                                                                                                })))
                                                                                                    })) && (($last_match_null < 2))); {

                                                                                            } ) {
                                                                                            if (($to == $MATCH->{'to'})) {
                                                                                                $last_match_null = ($last_match_null + 1)
                                                                                            }
                                                                                            else {
                                                                                                $last_match_null = 0
                                                                                            };
                                                                                            $m = $MATCH;
                                                                                            $to = $MATCH->{'to'}
                                                                                        };
                                                                                        $MATCH = $m;
                                                                                        $MATCH->{'to'} = $to;
                                                                                        1
                                                                                    }))) && ((do {
                                                                                    my $m = $MATCH;
                                                                                    if (!(((do {
                                                                                                    my $m2 = $grammar->exponent($str, $MATCH->{'to'});
                                                                                                    if ($m2) {
                                                                                                        $MATCH->{'to'} = $m2->{'to'};
                                                                                                        1
                                                                                                    }
                                                                                                    else {
                                                                                                        0
                                                                                                    }
                                                                                                })))) {
                                                                                        $MATCH = $m
                                                                                    };
                                                                                    1
                                                                                }))))
                                                                })))
                                                    }))))
                                    })))
                        })) && ((do {
                            $MATCH->{'str'} = $str;
                            my $s = Perlito5::Match::flat($MATCH);
                            ($s =~ s!_!!g);
                            $MATCH->{'capture'} = Perlito5::AST::Val::Num->new('num', $s);
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::digits {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((do {
                    my $last_match_null = 0;
                    my $m = $MATCH;
                    my $to = $MATCH->{'to'};
                    my $count = 0;
                    for ( ; (((do {
                                    my $m2 = $grammar->digit($str, $MATCH->{'to'});
                                    if ($m2) {
                                        $MATCH->{'to'} = $m2->{'to'};
                                        1
                                    }
                                    else {
                                        0
                                    }
                                })) && (($last_match_null < 2))); {

                        } ) {
                        if (($to == $MATCH->{'to'})) {
                            $last_match_null = ($last_match_null + 1)
                        }
                        else {
                            $last_match_null = 0
                        };
                        $m = $MATCH;
                        $to = $MATCH->{'to'};
                        $count = ($count + 1)
                    };
                    $MATCH = $m;
                    $MATCH->{'to'} = $to;
                    ($count > 0)
                })));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::val_int {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = (((do {
                    my $pos1 = $MATCH->{'to'};
                    (((do {
                                (((do {
                                            my $pos1 = $MATCH->{'to'};
                                            ((((do {
                                                            ((((('0' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                                            my $pos1 = $MATCH->{'to'};
                                                                            (((do {
                                                                                        (('x' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))
                                                                                    })) || ((do {
                                                                                        $MATCH->{'to'} = $pos1;
                                                                                        ((('X' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
                                                                                    })))
                                                                        }))) && ((do {
                                                                        my $last_match_null = 0;
                                                                        my $m = $MATCH;
                                                                        my $to = $MATCH->{'to'};
                                                                        my $count = 0;
                                                                        for ( ; (((do {
                                                                                        my $m2 = $grammar->word($str, $MATCH->{'to'});
                                                                                        if ($m2) {
                                                                                            $MATCH->{'to'} = $m2->{'to'};
                                                                                            1
                                                                                        }
                                                                                        else {
                                                                                            0
                                                                                        }
                                                                                    })) && (($last_match_null < 2))); {

                                                                            } ) {
                                                                            if (($to == $MATCH->{'to'})) {
                                                                                $last_match_null = ($last_match_null + 1)
                                                                            }
                                                                            else {
                                                                                $last_match_null = 0
                                                                            };
                                                                            $m = $MATCH;
                                                                            $to = $MATCH->{'to'};
                                                                            $count = ($count + 1)
                                                                        };
                                                                        $MATCH = $m;
                                                                        $MATCH->{'to'} = $to;
                                                                        ($count > 0)
                                                                    })))
                                                        })) || ((do {
                                                            $MATCH->{'to'} = $pos1;
                                                            (((((('0' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                                                my $pos1 = $MATCH->{'to'};
                                                                                (((do {
                                                                                            (('b' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))
                                                                                        })) || ((do {
                                                                                            $MATCH->{'to'} = $pos1;
                                                                                            ((('B' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
                                                                                        })))
                                                                            }))) && ((do {
                                                                            my $last_match_null = 0;
                                                                            my $m = $MATCH;
                                                                            my $to = $MATCH->{'to'};
                                                                            my $count = 0;
                                                                            for ( ; (((do {
                                                                                            my $pos1 = $MATCH->{'to'};
                                                                                            ((((do {
                                                                                                            (('_' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))
                                                                                                        })) || ((do {
                                                                                                            $MATCH->{'to'} = $pos1;
                                                                                                            ((('0' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
                                                                                                        }))) || ((do {
                                                                                                        $MATCH->{'to'} = $pos1;
                                                                                                        ((('1' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
                                                                                                    })))
                                                                                        })) && (($last_match_null < 2))); {

                                                                                } ) {
                                                                                if (($to == $MATCH->{'to'})) {
                                                                                    $last_match_null = ($last_match_null + 1)
                                                                                }
                                                                                else {
                                                                                    $last_match_null = 0
                                                                                };
                                                                                $m = $MATCH;
                                                                                $to = $MATCH->{'to'};
                                                                                $count = ($count + 1)
                                                                            };
                                                                            $MATCH = $m;
                                                                            $MATCH->{'to'} = $to;
                                                                            ($count > 0)
                                                                        }))))
                                                        }))) || ((do {
                                                        $MATCH->{'to'} = $pos1;
                                                        ((((('0' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                                        my $last_match_null = 0;
                                                                        my $m = $MATCH;
                                                                        my $to = $MATCH->{'to'};
                                                                        my $count = 0;
                                                                        for ( ; (((do {
                                                                                        my $pos1 = $MATCH->{'to'};
                                                                                        (((do {
                                                                                                    (('_' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))
                                                                                                })) || ((do {
                                                                                                    $MATCH->{'to'} = $pos1;
                                                                                                    ((do {
                                                                                                            my $m2 = $grammar->digit($str, $MATCH->{'to'});
                                                                                                            if ($m2) {
                                                                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                                                                1
                                                                                                            }
                                                                                                            else {
                                                                                                                0
                                                                                                            }
                                                                                                        }))
                                                                                                })))
                                                                                    })) && (($last_match_null < 2))); {

                                                                            } ) {
                                                                            if (($to == $MATCH->{'to'})) {
                                                                                $last_match_null = ($last_match_null + 1)
                                                                            }
                                                                            else {
                                                                                $last_match_null = 0
                                                                            };
                                                                            $m = $MATCH;
                                                                            $to = $MATCH->{'to'};
                                                                            $count = ($count + 1)
                                                                        };
                                                                        $MATCH = $m;
                                                                        $MATCH->{'to'} = $to;
                                                                        ($count > 0)
                                                                    }))))
                                                    })))
                                        })) && ((do {
                                            $MATCH->{'str'} = $str;
                                            $MATCH->{'capture'} = Perlito5::AST::Val::Int->new('int', oct(lc(Perlito5::Match::flat($MATCH))));
                                            1
                                        })))
                            })) || ((do {
                                $MATCH->{'to'} = $pos1;
                                (((((do {
                                                    my $m2 = $grammar->digit($str, $MATCH->{'to'});
                                                    if ($m2) {
                                                        $MATCH->{'to'} = $m2->{'to'};
                                                        1
                                                    }
                                                    else {
                                                        0
                                                    }
                                                })) && ((do {
                                                    my $last_match_null = 0;
                                                    my $m = $MATCH;
                                                    my $to = $MATCH->{'to'};
                                                    for ( ; (((do {
                                                                    my $pos1 = $MATCH->{'to'};
                                                                    (((do {
                                                                                (('_' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))
                                                                            })) || ((do {
                                                                                $MATCH->{'to'} = $pos1;
                                                                                ((do {
                                                                                        my $m2 = $grammar->digit($str, $MATCH->{'to'});
                                                                                        if ($m2) {
                                                                                            $MATCH->{'to'} = $m2->{'to'};
                                                                                            1
                                                                                        }
                                                                                        else {
                                                                                            0
                                                                                        }
                                                                                    }))
                                                                            })))
                                                                })) && (($last_match_null < 2))); {

                                                        } ) {
                                                        if (($to == $MATCH->{'to'})) {
                                                            $last_match_null = ($last_match_null + 1)
                                                        }
                                                        else {
                                                            $last_match_null = 0
                                                        };
                                                        $m = $MATCH;
                                                        $to = $MATCH->{'to'}
                                                    };
                                                    $MATCH = $m;
                                                    $MATCH->{'to'} = $to;
                                                    1
                                                }))) && ((do {
                                                $MATCH->{'str'} = $str;
                                                my $s = Perlito5::Match::flat($MATCH);
                                                ($s =~ s!_!!g);
                                                $MATCH->{'capture'} = Perlito5::AST::Val::Int->new('int', $s);
                                                1
                                            }))))
                            })))
                })));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::val_version {
    my $grammar = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    my $MATCH = {'str', $str, 'from', $pos, 'to', $pos};
    my $tmp = ((((((do {
                                my $m = $MATCH;
                                if (!(((('v' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) {
                                    $MATCH = $m
                                };
                                1
                            })) && ((do {
                                my $m2 = $grammar->digits($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    1
                                }
                                else {
                                    0
                                }
                            }))) && ((do {
                            my $m = $MATCH;
                            if (!((((((('.' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                        my $m2 = $grammar->digits($str, $MATCH->{'to'});
                                                        if ($m2) {
                                                            $MATCH->{'to'} = $m2->{'to'};
                                                            1
                                                        }
                                                        else {
                                                            0
                                                        }
                                                    }))) && ((do {
                                                    my $m = $MATCH;
                                                    if (!(((((('.' eq substr($str, $MATCH->{'to'}, 1)) && ($MATCH->{'to'} = (1 + $MATCH->{'to'})))) && ((do {
                                                                            my $m2 = $grammar->digits($str, $MATCH->{'to'});
                                                                            if ($m2) {
                                                                                $MATCH->{'to'} = $m2->{'to'};
                                                                                1
                                                                            }
                                                                            else {
                                                                                0
                                                                            }
                                                                        })))))) {
                                                        $MATCH = $m
                                                    };
                                                    1
                                                })))))) {
                                $MATCH = $m
                            };
                            1
                        })))));
    ($tmp ? $MATCH : 0)
};
my @PKG;
sub Perlito5::Grammar::exp_stmts {
    my $self = $_[0];
    my $str = $_[1];
    my $pos = $_[2];
    push(@PKG, $Perlito5::PKG_NAME);
    my @stmts;
    my $m = Perlito5::Grammar::Space->opt_ws($str, $pos);
    $pos = $m->{'to'};
    for ( ; $m; {

        } ) {
        if ((substr($str, $pos, 1) eq ';')) {
            $m = Perlito5::Grammar::Space->opt_ws($str, ($pos + 1));
            $pos = $m->{'to'}
        }
        else {
            $m = Perlito5::Grammar::Expression->statement_parse($str, $pos);
            if ($m) {
                push(@stmts, $m->{'capture'});
                $pos = $m->{'to'};
                if ((substr($str, $pos, 1) eq ';')) {
                    $pos = ($pos + 1)
                };
                $m = Perlito5::Grammar::Space->opt_ws($str, $pos);
                $pos = $m->{'to'}
            }
        }
    };
    $Perlito5::PKG_NAME = pop(@PKG);
    return {'str', $str, 'to', $pos, 'capture', \@stmts}
};

;

# use Perlito5::Grammar
;
package main;
undef();
package Perlito5::AST::CompUnit;
sub Perlito5::AST::CompUnit::new {
    my $class = shift();
    bless({@_}, $class)
};
sub Perlito5::AST::CompUnit::name {
    $_[0]->{'name'}
};
sub Perlito5::AST::CompUnit::body {
    $_[0]->{'body'}
};
package Perlito5::AST::Val::Int;
sub Perlito5::AST::Val::Int::new {
    my $class = shift();
    bless({@_}, $class)
};
sub Perlito5::AST::Val::Int::int {
    $_[0]->{'int'}
};
package Perlito5::AST::Val::Num;
sub Perlito5::AST::Val::Num::new {
    my $class = shift();
    bless({@_}, $class)
};
sub Perlito5::AST::Val::Num::num {
    $_[0]->{'num'}
};
package Perlito5::AST::Val::Buf;
sub Perlito5::AST::Val::Buf::new {
    my $class = shift();
    bless({@_}, $class)
};
sub Perlito5::AST::Val::Buf::buf {
    $_[0]->{'buf'}
};
package Perlito5::AST::Lit::Block;
sub Perlito5::AST::Lit::Block::new {
    my $class = shift();
    bless({@_}, $class)
};
sub Perlito5::AST::Lit::Block::sig {
    $_[0]->{'sig'}
};
sub Perlito5::AST::Lit::Block::stmts {
    $_[0]->{'stmts'}
};
package Perlito5::AST::Index;
sub Perlito5::AST::Index::new {
    my $class = shift();
    bless({@_}, $class)
};
sub Perlito5::AST::Index::obj {
    $_[0]->{'obj'}
};
sub Perlito5::AST::Index::index_exp {
    $_[0]->{'index_exp'}
};
package Perlito5::AST::Lookup;
sub Perlito5::AST::Lookup::new {
    my $class = shift();
    bless({@_}, $class)
};
sub Perlito5::AST::Lookup::obj {
    $_[0]->{'obj'}
};
sub Perlito5::AST::Lookup::index_exp {
    $_[0]->{'index_exp'}
};
sub Perlito5::AST::Lookup::autoquote {
    my $self = shift();
    my $index = shift();
    if (($index->isa('Perlito5::AST::Apply') && $index->{'bareword'})) {
        my $full_name = ((($index->{'namespace'} ? ($index->{'namespace'} . '::') : '')) . $index->{'code'});
        if (!(exists($Perlito5::PROTO->{$full_name}))) {
            return Perlito5::AST::Val::Buf->new('buf', $full_name)
        }
    }
    else {
        if (($index->isa('Perlito5::AST::Apply') && ((($index->code() eq 'prefix:<->') || ($index->code() eq 'prefix:<+>'))))) {
            my $arg = $index->arguments()->[0];
            return Perlito5::AST::Apply->new('code', $index->code(), 'namespace', $index->namespace(), 'arguments', [$self->autoquote($arg)]) if $arg
        }
    };
    $index
};
package Perlito5::AST::Var;
sub Perlito5::AST::Var::new {
    my $class = shift();
    bless({@_}, $class)
};
sub Perlito5::AST::Var::sigil {
    $_[0]->{'sigil'}
};
sub Perlito5::AST::Var::namespace {
    $_[0]->{'namespace'}
};
sub Perlito5::AST::Var::name {
    $_[0]->{'name'}
};
sub Perlito5::AST::Var::plain_name {
    my $self = shift();
    if ($self->namespace()) {
        return ($self->namespace() . '::' . $self->name())
    };
    return $self->name()
};
package Perlito5::AST::Proto;
sub Perlito5::AST::Proto::new {
    my $class = shift();
    bless({@_}, $class)
};
sub Perlito5::AST::Proto::name {
    $_[0]->{'name'}
};
package Perlito5::AST::Call;
sub Perlito5::AST::Call::new {
    my $class = shift();
    bless({@_}, $class)
};
sub Perlito5::AST::Call::invocant {
    $_[0]->{'invocant'}
};
sub Perlito5::AST::Call::method {
    $_[0]->{'method'}
};
sub Perlito5::AST::Call::arguments {
    $_[0]->{'arguments'}
};
package Perlito5::AST::Apply;
sub Perlito5::AST::Apply::new {
    my $class = shift();
    bless({@_}, $class)
};
sub Perlito5::AST::Apply::code {
    $_[0]->{'code'}
};
sub Perlito5::AST::Apply::special_arg {
    $_[0]->{'special_arg'}
};
sub Perlito5::AST::Apply::arguments {
    $_[0]->{'arguments'}
};
sub Perlito5::AST::Apply::namespace {
    $_[0]->{'namespace'}
};
package Perlito5::AST::If;
sub Perlito5::AST::If::new {
    my $class = shift();
    bless({@_}, $class)
};
sub Perlito5::AST::If::cond {
    $_[0]->{'cond'}
};
sub Perlito5::AST::If::body {
    $_[0]->{'body'}
};
sub Perlito5::AST::If::otherwise {
    $_[0]->{'otherwise'}
};
package Perlito5::AST::When;
sub Perlito5::AST::When::new {
    my $class = shift();
    bless({@_}, $class)
};
sub Perlito5::AST::When::cond {
    $_[0]->{'cond'}
};
sub Perlito5::AST::When::body {
    $_[0]->{'body'}
};
package Perlito5::AST::While;
sub Perlito5::AST::While::new {
    my $class = shift();
    bless({@_}, $class)
};
sub Perlito5::AST::While::init {
    $_[0]->{'init'}
};
sub Perlito5::AST::While::cond {
    $_[0]->{'cond'}
};
sub Perlito5::AST::While::continue {
    $_[0]->{'continue'}
};
sub Perlito5::AST::While::body {
    $_[0]->{'body'}
};
package Perlito5::AST::For;
sub Perlito5::AST::For::new {
    my $class = shift();
    bless({@_}, $class)
};
sub Perlito5::AST::For::cond {
    $_[0]->{'cond'}
};
sub Perlito5::AST::For::continue {
    $_[0]->{'continue'}
};
sub Perlito5::AST::For::body {
    $_[0]->{'body'}
};
package Perlito5::AST::Given;
sub Perlito5::AST::Given::new {
    my $class = shift();
    bless({@_}, $class)
};
sub Perlito5::AST::Given::cond {
    $_[0]->{'cond'}
};
sub Perlito5::AST::Given::body {
    $_[0]->{'body'}
};
package Perlito5::AST::Decl;
sub Perlito5::AST::Decl::new {
    my $class = shift();
    bless({@_}, $class)
};
sub Perlito5::AST::Decl::decl {
    $_[0]->{'decl'}
};
sub Perlito5::AST::Decl::type {
    $_[0]->{'type'}
};
sub Perlito5::AST::Decl::var {
    $_[0]->{'var'}
};
sub Perlito5::AST::Decl::attributes {
    $_[0]->{'attributes'}
};
package Perlito5::AST::Sig;
sub Perlito5::AST::Sig::new {
    my $class = shift();
    bless({@_}, $class)
};
sub Perlito5::AST::Sig::positional {
    $_[0]->{'positional'}
};
package Perlito5::AST::Sub;
sub Perlito5::AST::Sub::new {
    my $class = shift();
    bless({@_}, $class)
};
sub Perlito5::AST::Sub::name {
    $_[0]->{'name'}
};
sub Perlito5::AST::Sub::sig {
    $_[0]->{'sig'}
};
sub Perlito5::AST::Sub::block {
    $_[0]->{'block'}
};
sub Perlito5::AST::Sub::attributes {
    $_[0]->{'attributes'}
};
package Perlito5::AST::Do;
sub Perlito5::AST::Do::new {
    my $class = shift();
    bless({@_}, $class)
};
sub Perlito5::AST::Do::block {
    $_[0]->{'block'}
};
package Perlito5::AST::Use;
sub Perlito5::AST::Use::new {
    my $class = shift();
    bless({@_}, $class)
};
sub Perlito5::AST::Use::mod {
    $_[0]->{'mod'}
};
sub Perlito5::AST::Use::code {
    $_[0]->{'code'}
};
1;

;
package main;
package Perlito5::Dumper;
sub Perlito5::Dumper::_identity {
    ($_[0] eq $_[1])
};
sub Perlito5::Dumper::Dumper {
    my $obj = $_[0];
    my $level = ($_[1] || 0);
    return 'undef' if !(defined($obj));
    my $ref = ref($obj);
    my $tab = join("", '    ' x $level);
    my $tab1 = ($tab . '    ');
    if (($ref eq 'ARRAY')) {
        return ('[' . chr(10) . join('', map(($tab1 . Dumper($_, ($level + 1)) . ',' . chr(10)), @{$obj})) . $tab . ']')
    }
    else {
        if (($ref eq 'HASH')) {
            return ('{' . chr(10) . join('', map(($tab1 . (chr(39) . $_ . chr(39) . ' => ') . Dumper($obj->{$_}, ($level + 1)) . ',' . chr(10)), sort(keys(%{$obj})))) . $tab . '}')
        }
        else {
            if (($ref eq 'SCALAR')) {
                return (chr(92) . Dumper(${$obj}))
            }
            else {
                if ($ref) {
                    return ('bless({' . chr(10) . join('', map(($tab1 . (chr(39) . $_ . chr(39) . ' => ') . Dumper($obj->{$_}, ($level + 1)) . ',' . chr(10)), sort(keys(%{$obj})))) . $tab . ('}, ' . chr(39) . $ref . chr(39) . ')'))
                }
            }
        }
    };
    return escape_string($obj)
};
my %safe_char = (' ', 1, '!', 1, '"', 1, '#', 1, '$', 1, '%', 1, '&', 1, '(', 1, ')', 1, '*', 1, '+', 1, ',', 1, '-', 1, '.', 1, '/', 1, ':', 1, ';', 1, '<', 1, '=', 1, '>', 1, '?', 1, '@', 1, '[', 1, ']', 1, '^', 1, '_', 1, '`', 1, '{', 1, '|', 1, '}', 1, '~', 1);
sub Perlito5::Dumper::escape_string {
    my $s = shift();
    my @out;
    my $tmp = '';
    return chr(39) . chr(39) if ($s eq '');
    for my  $i ((0 .. (length($s) - 1))) {
        my $c = substr($s, $i, 1);
        if ((((((($c ge 'a') && ($c le 'z'))) || ((($c ge 'A') && ($c le 'Z')))) || ((($c ge '0') && ($c le '9')))) || exists($safe_char{$c}))) {
            $tmp = ($tmp . $c)
        }
        else {
            push(@out, (chr(39) . $tmp . chr(39))) if ($tmp ne '');
            push(@out, ('chr(' . ord($c) . ')'));
            $tmp = ''
        }
    };
    push(@out, (chr(39) . $tmp . chr(39))) if ($tmp ne '');
    return join(' . ', @out)
};
1;

;
package main;
undef();

# use Perlito5::AST
;

# use Perlito5::Dumper
;

# use strict
;
package Perlito5::Javascript2;
{
    my $label_count = 100;
    my %label;
    sub Perlito5::Javascript2::pkg {
        ('p5pkg["' . $Perlito5::PKG_NAME . '"]')
    };
    sub Perlito5::Javascript2::pkg_new_var {
        $label{$Perlito5::PKG_NAME} = ('p5' . ($label_count)++)
    };
    sub Perlito5::Javascript2::get_label {
        ($label_count)++
    };
    sub Perlito5::Javascript2::tab {
        my $level = shift();
        join("", chr(9) x $level)
    };
    our %op_prefix_js_str = ('prefix:<-A>', 'p5atime', 'prefix:<-C>', 'p5ctime', 'prefix:<-M>', 'p5mtime', 'prefix:<-d>', 'p5is_directory', 'prefix:<-e>', 'p5file_exists', 'prefix:<-f>', 'p5is_file', 'prefix:<-s>', 'p5size');
    our %op_infix_js_str = ('infix:<eq>', ' == ', 'infix:<ne>', ' != ', 'infix:<le>', ' <= ', 'infix:<ge>', ' >= ', 'infix:<lt>', ' < ', 'infix:<gt>', ' > ');
    our %op_infix_js_num = ('infix:<==>', ' == ', 'infix:<!=>', ' != ', 'infix:<+>', ' + ', 'infix:<->', ' - ', 'infix:<*>', ' * ', 'infix:</>', ' / ', 'infix:<>>', ' > ', 'infix:<<>', ' < ', 'infix:<>=>', ' >= ', 'infix:<<=>', ' <= ', 'infix:<&>', ' & ', 'infix:<|>', ' | ', 'infix:<^>', ' ^ ', 'infix:<>>>', ' >>> ');
    our %op_to_bool = map(+(($_, 1)), ('prefix:<!>', 'infix:<!=>', 'infix:<==>', 'infix:<<=>', 'infix:<>=>', 'infix:<>>', 'infix:<<>', 'infix:<eq>', 'infix:<ne>', 'infix:<ge>', 'infix:<le>', 'infix:<gt>', 'infix:<lt>', 'prefix:<not>', 'exists', 'defined'));
    our %op_to_str = map(+(($_, 1)), ('substr', 'join', 'list:<.>', 'chr'));
    our %op_to_num = map(+(($_, 1)), ('length', 'index', 'ord', 'oct', 'infix:<->', 'infix:<+>', 'infix:<*>', 'infix:</>', 'infix:<%>', 'infix:<**>'));
    my %safe_char = (' ', 1, '!', 1, '"', 1, '#', 1, '$', 1, '%', 1, '&', 1, '(', 1, ')', 1, '*', 1, '+', 1, ',', 1, '-', 1, '.', 1, '/', 1, ':', 1, ';', 1, '<', 1, '=', 1, '>', 1, '?', 1, '@', 1, '[', 1, ']', 1, '^', 1, '_', 1, '`', 1, '{', 1, '|', 1, '}', 1, '~', 1);
    sub Perlito5::Javascript2::escape_string {
        my $s = shift();
        my @out;
        my $tmp = '';
        return chr(39) . chr(39) if ($s eq '');
        for my  $i ((0 .. (length($s) - 1))) {
            my $c = substr($s, $i, 1);
            if ((((((($c ge 'a') && ($c le 'z'))) || ((($c ge 'A') && ($c le 'Z')))) || ((($c ge '0') && ($c le '9')))) || exists($safe_char{$c}))) {
                $tmp = ($tmp . $c)
            }
            else {
                push(@out, (chr(39) . $tmp . chr(39))) if ($tmp ne '');
                push(@out, ('String.fromCharCode(' . ord($c) . ')'));
                $tmp = ''
            }
        };
        push(@out, (chr(39) . $tmp . chr(39))) if ($tmp ne '');
        return join(' + ', @out)
    };
    sub Perlito5::Javascript2::to_str {
        my $cond = shift();
        my $level = shift();
        my $wantarray = 'scalar';
        if (((($cond->isa('Perlito5::AST::Apply') && ($cond->code() eq 'circumfix:<( )>')) && $cond->{'arguments'}) && @{$cond->{'arguments'}})) {
            return to_str($cond->{'arguments'}->[0], $level)
        };
        if ((($cond->isa('Perlito5::AST::Val::Buf')) || (($cond->isa('Perlito5::AST::Apply') && exists($op_to_str{$cond->code()}))))) {
            return $cond->emit_javascript2($level, $wantarray)
        }
        else {
            return ('p5str(' . $cond->emit_javascript2($level, $wantarray) . ')')
        }
    };
    sub Perlito5::Javascript2::to_num {
        my $cond = shift();
        my $level = shift();
        my $wantarray = 'scalar';
        if ((($cond->isa('Perlito5::AST::Val::Int') || $cond->isa('Perlito5::AST::Val::Num')) || (($cond->isa('Perlito5::AST::Apply') && exists($op_to_num{$cond->code()}))))) {
            return $cond->emit_javascript2($level, $wantarray)
        }
        else {
            return ('p5num(' . $cond->emit_javascript2($level, $wantarray) . ')')
        }
    };
    sub Perlito5::Javascript2::to_bool {
        my $cond = shift();
        my $level = shift();
        my $wantarray = 'scalar';
        if (((($cond->isa('Perlito5::AST::Apply') && ($cond->code() eq 'circumfix:<( )>')) && $cond->{'arguments'}) && @{$cond->{'arguments'}})) {
            return to_bool($cond->{'arguments'}->[0], $level)
        };
        if (($cond->isa('Perlito5::AST::Apply') && ((($cond->code() eq 'infix:<&&>') || ($cond->code() eq 'infix:<and>'))))) {
            return ('(' . to_bool($cond->{'arguments'}->[0], $level) . ' && ' . to_bool($cond->{'arguments'}->[1], $level) . ')')
        };
        if (($cond->isa('Perlito5::AST::Apply') && ((($cond->code() eq 'infix:<||>') || ($cond->code() eq 'infix:<or>'))))) {
            return ('(' . to_bool($cond->{'arguments'}->[0], $level) . ' || ' . to_bool($cond->{'arguments'}->[1], $level) . ')')
        };
        if (((($cond->isa('Perlito5::AST::Val::Int')) || ($cond->isa('Perlito5::AST::Val::Num'))) || (($cond->isa('Perlito5::AST::Apply') && exists($op_to_bool{$cond->code()}))))) {
            return $cond->emit_javascript2($level, $wantarray)
        }
        else {
            return ('p5bool(' . $cond->emit_javascript2($level, $wantarray) . ')')
        }
    };
    sub Perlito5::Javascript2::is_scalar {
        (((((!($_[0]->isa('Perlito5::AST::Val::Int')) && !($_[0]->isa('Perlito5::AST::Val::Num'))) && !($_[0]->isa('Perlito5::AST::Val::Buf'))) && !($_[0]->isa('Perlito5::AST::Sub'))) && !((($_[0]->isa('Perlito5::AST::Var') && ($_[0]->{'sigil'} eq '$'))))) && !((($_[0]->isa('Perlito5::AST::Apply') && ((((exists($op_to_str{$_[0]->{'code'}}) || exists($op_to_num{$_[0]->{'code'}})) || exists($op_to_bool{$_[0]->{'code'}})) || ($_[0]->{'code'} eq 'prefix:<' . chr(92) . '>')))))))
    };
    sub Perlito5::Javascript2::to_list {
        my $items = to_list_preprocess($_[0]);
        my $level = $_[1];
        my $literal_type = ($_[2] || 'array');
        my $wantarray = 'list';
        my $interpolate = 0;
        for (@{$items}) {
            $interpolate = 1 if is_scalar($_)
        };
        if (($literal_type eq 'hash')) {
            if (!($interpolate)) {
                my @out;
                my $printable = 1;
                my @in = @{$items};
                for ( ; @in; {

                    } ) {
                    my $k = shift(@in);
                    my $v = shift(@in);
                    $k = $k->emit_javascript2($level, 0);
                    $printable = 0 if ($k =~ m![ \[]!);
                    $v = ($v ? $v->emit_javascript2($level, 0) : 'null');
                    push(@out, ($k . ' : ' . $v))
                };
                return ('{' . join(', ', @out) . '}') if $printable
            };
            return ('p5a_to_h(' . to_list($items, $level, 'array') . ')')
        };
        ($interpolate ? (('p5list_to_a(' . join(', ', map($_->emit_javascript2($level, $wantarray), @{$items})) . ')')) : (('[' . join(', ', map($_->emit_javascript2($level, $wantarray), @{$items})) . ']')))
    };
    sub Perlito5::Javascript2::to_list_preprocess {
        my @items;
        for my  $item (@{$_[0]}) {
            if (($item->isa('Perlito5::AST::Apply') && (((($item->code() eq 'circumfix:<( )>') || ($item->code() eq 'list:<,>')) || ($item->code() eq 'infix:<=>>'))))) {
                if (($item->isa('Perlito5::AST::Apply') && ($item->code() eq 'infix:<=>>'))) {
                    $item->{'arguments'}->[0] = Perlito5::AST::Lookup->autoquote($item->{'arguments'}->[0])
                };
                for my  $arg (@{to_list_preprocess($item->arguments())}) {
                    push(@items, $arg)
                }
            }
            else {
                push(@items, $item)
            }
        };
        return \@items
    };
    sub Perlito5::Javascript2::to_scalar {
        my $items = to_scalar_preprocess($_[0]);
        my $level = $_[1];
        my $wantarray = 'scalar';
        (@{$items} ? ('(' . join(', ', map($_->emit_javascript2($level, $wantarray), @{$items})) . ')') : 'null')
    };
    sub Perlito5::Javascript2::to_scalar_preprocess {
        my @items;
        for my  $item (@{$_[0]}) {
            if (($item->isa('Perlito5::AST::Apply') && ((($item->code() eq 'list:<,>') || ($item->code() eq 'infix:<=>>'))))) {
                if (($item->isa('Perlito5::AST::Apply') && ($item->code() eq 'infix:<=>>'))) {
                    $item->{'arguments'}->[0] = Perlito5::AST::Lookup->autoquote($item->{'arguments'}->[0])
                };
                for my  $arg (@{to_scalar_preprocess($item->arguments())}) {
                    push(@items, $arg)
                }
            }
            else {
                push(@items, $item)
            }
        };
        return \@items
    };
    sub Perlito5::Javascript2::to_runtime_context {
        my $items = to_scalar_preprocess($_[0]);
        my $level = $_[1];
        my $wantarray = 'runtime';
        return $items->[0]->emit_javascript2($level, $wantarray) if ((@{$items} == 1) && is_scalar($items->[0]));
        ('p5context(' . '[' . join(', ', map($_->emit_javascript2($level, $wantarray), @{$items})) . ']' . ', p5want)')
    };
    sub Perlito5::Javascript2::autoquote {
        my $index = shift();
        my $level = shift();
        $index = Perlito5::AST::Lookup->autoquote($index);
        return to_str($index, $level)
    };
    sub Perlito5::Javascript2::emit_javascript2_autovivify {
        my $obj = shift();
        my $level = shift();
        my $type = shift();
        if ((($obj->isa('Perlito5::AST::Index') || $obj->isa('Perlito5::AST::Lookup')) || $obj->isa('Perlito5::AST::Call'))) {
            return $obj->emit_javascript2($level, 0, $type)
        };
        ('(' . $obj->emit_javascript2($level) . ' || (' . $obj->emit_javascript2($level) . ' = ' . ((($type eq 'array') ? 'new p5ArrayRef([])' : (($type eq 'hash') ? 'new p5HashRef({})' : 'new p5ScalarRef(null)'))) . ')' . ')')
    };
    sub Perlito5::Javascript2::emit_function_javascript2 {
        my $level = shift();
        my $wantarray = shift();
        my $argument = shift();
        if (($argument->isa('Perlito5::AST::Apply') && ($argument->code() eq 'return'))) {
            return ('function () { ' . $argument->emit_javascript2($level, $wantarray) . ' }')
        };
        return ('function () { return ' . $argument->emit_javascript2($level, $wantarray) . ' }')
    }
};
package Perlito5::Javascript2::LexicalBlock;
{
    sub Perlito5::Javascript2::LexicalBlock::new {
        my $class = shift();
        bless({@_}, $class)
    };
    sub Perlito5::Javascript2::LexicalBlock::block {
        $_[0]->{'block'}
    };
    sub Perlito5::Javascript2::LexicalBlock::needs_return {
        $_[0]->{'needs_return'}
    };
    sub Perlito5::Javascript2::LexicalBlock::top_level {
        $_[0]->{'top_level'}
    };
    sub Perlito5::Javascript2::LexicalBlock::has_decl {
        my $self = $_[0];
        my $type = $_[1];
        for my  $decl (@{$self->{'block'}}) {
            if (defined($decl)) {
                if ((($decl->isa('Perlito5::AST::Decl') && ($decl->decl() eq $type)) || ($decl->isa('Perlito5::AST::Apply') && ($decl->code() eq $type)))) {
                    return 1
                };
                if (($decl->isa('Perlito5::AST::Apply') && ($decl->code() eq 'infix:<=>'))) {
                    my $var = $decl->arguments()->[0];
                    if ((($var->isa('Perlito5::AST::Decl') && ($var->decl() eq $type)) || ($decl->isa('Perlito5::AST::Apply') && ($decl->code() eq $type)))) {
                        return 1
                    }
                }
            }
        };
        return 0
    };
    sub Perlito5::Javascript2::LexicalBlock::emit_javascript2 {
        my $self = shift();
        my $level = shift();
        my $wantarray = shift();
        my $original_level = $level;
        my @block;
        for (@{$self->{'block'}}) {
            if (defined($_)) {
                push(@block, $_)
            }
        };
        if (!(@block)) {
            return 'null;'
        };
        my @str;
        my $has_local = $self->has_decl('local');
        my $create_context = ($self->{'create_context'} && $self->has_decl('my'));
        my $outer_pkg = $Perlito5::PKG_NAME;
        my $outer_throw = $Perlito5::THROW;
        unshift(@{$Perlito5::VAR}, {});
        $Perlito5::THROW = 0 if $self->{'top_level'};
        if (($self->{'top_level'} || $create_context)) {
            ($level)++
        };
        my $last_statement;
        if ($self->{'needs_return'}) {
            $last_statement = pop(@block)
        };
        for my  $decl (@block) {
            if (((ref($decl) eq 'Perlito5::AST::Apply') && ($decl->code() eq 'package'))) {
                $Perlito5::PKG_NAME = $decl->{'namespace'};
                $Perlito5::VAR->[0]->{'$_'} = {'decl', 'our', 'namespace', $Perlito5::PKG_NAME};
                $Perlito5::VAR->[0]->{'$a'} = {'decl', 'our', 'namespace', $Perlito5::PKG_NAME};
                $Perlito5::VAR->[0]->{'$b'} = {'decl', 'our', 'namespace', $Perlito5::PKG_NAME};
                $Perlito5::VAR->[0]->{'$AUTOLOAD'} = {'decl', 'our', 'namespace', $Perlito5::PKG_NAME}
            };
            if ($decl->isa('Perlito5::AST::Decl')) {
                push(@str, $decl->emit_javascript2_init())
            };
            if (($decl->isa('Perlito5::AST::Apply') && ($decl->code() eq 'my'))) {
                for (@{$decl->{'arguments'}}) {
                    if ($_->isa('Perlito5::AST::Var')) {
                        my $d = Perlito5::AST::Decl->new('decl', $decl->code(), 'var', $_);
                        push(@str, $d->emit_javascript2_init())
                    }
                }
            };
            if (($decl->isa('Perlito5::AST::Apply') && ($decl->code() eq 'infix:<=>'))) {
                my $arg = $decl->{'arguments'}->[0];
                if ($arg->isa('Perlito5::AST::Decl')) {
                    push(@str, $arg->emit_javascript2_init())
                };
                if (($arg->isa('Perlito5::AST::Apply') && ($arg->code() eq 'my'))) {
                    for (@{$arg->{'arguments'}}) {
                        if ($_->isa('Perlito5::AST::Var')) {
                            my $d = Perlito5::AST::Decl->new('decl', $arg->code(), 'var', $_);
                            push(@str, $d->emit_javascript2_init())
                        }
                    }
                }
            };
            if (!((($decl->isa('Perlito5::AST::Decl') && ($decl->decl() eq 'my'))))) {
                push(@str, ($decl->emit_javascript2($level, 'void') . ';'))
            }
        };
        if (($self->{'needs_return'} && $last_statement)) {
            if ($last_statement->isa('Perlito5::AST::Decl')) {
                push(@str, $last_statement->emit_javascript2_init())
            };
            if (($last_statement->isa('Perlito5::AST::Apply') && ($last_statement->code() eq 'infix:<=>'))) {
                if ($last_statement->{'arguments'}->[0]->isa('Perlito5::AST::Decl')) {
                    push(@str, $last_statement->{'arguments'}->[0]->emit_javascript2_init())
                }
            };
            if (((($last_statement->isa('Perlito5::AST::Apply') && ($last_statement->code() eq 'return')) && $self->{'top_level'}) && @{$last_statement->{'arguments'}})) {
                $last_statement = $last_statement->{'arguments'}->[0]
            };
            if ((((((($last_statement->isa('Perlito5::AST::For') || $last_statement->isa('Perlito5::AST::While')) || $last_statement->isa('Perlito5::AST::If')) || $last_statement->isa('Perlito5::AST::Lit::Block')) || $last_statement->isa('Perlito5::AST::Use')) || ($last_statement->isa('Perlito5::AST::Apply') && ($last_statement->code() eq 'goto'))) || ($last_statement->isa('Perlito5::AST::Apply') && ($last_statement->code() eq 'return')))) {
                push(@str, $last_statement->emit_javascript2($level, 'runtime'))
            }
            else {
                if ($has_local) {
                    push(@str, ('return p5cleanup_local(local_idx, (' . Perlito5::Javascript2::to_runtime_context([$last_statement], $level) . '));'))
                }
                else {
                    push(@str, ('return (' . Perlito5::Javascript2::to_runtime_context([$last_statement], $level) . ');'))
                }
            }
        };
        if ($has_local) {
            unshift(@str, 'var local_idx = p5LOCAL.length;');
            push(@str, 'p5cleanup_local(local_idx, null);')
        };
        my $out;
        if (($self->{'top_level'} && $Perlito5::THROW)) {
            $level = $original_level;
            my $tab = (chr(10) . Perlito5::Javascript2::tab(($level + 1)));
            $out = ('try {' . $tab . join($tab, @str) . chr(10) . Perlito5::Javascript2::tab($level) . '}' . chr(10) . Perlito5::Javascript2::tab($level) . 'catch(err) {' . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . 'if ( err instanceof Error ) {' . chr(10) . Perlito5::Javascript2::tab(($level + 2)) . 'throw(err);' . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . '}' . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . 'else {' . chr(10) . Perlito5::Javascript2::tab(($level + 2)) . (($has_local ? 'return p5cleanup_local(local_idx, err)' : 'return(err)')) . ';' . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . '}' . chr(10) . Perlito5::Javascript2::tab($level) . '}')
        }
        else {
            if ($create_context) {
                $level = $original_level;
                my $tab = (chr(10) . Perlito5::Javascript2::tab(($level + 1)));
                $out = ('(function () {' . $tab . join($tab, @str) . chr(10) . Perlito5::Javascript2::tab($level) . '})();')
            }
            else {
                $level = $original_level;
                my $tab = (chr(10) . Perlito5::Javascript2::tab($level));
                $out = join($tab, @str)
            }
        };
        $Perlito5::PKG_NAME = $outer_pkg;
        $Perlito5::THROW = $outer_throw if $self->{'top_level'};
        shift(@{$Perlito5::VAR});
        return $out
    }
};
package Perlito5::AST::CompUnit;
{
    sub Perlito5::AST::CompUnit::emit_javascript2 {
        my $self = $_[0];
        my $level = $_[1];
        my $str = ('(function () {' . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . Perlito5::Javascript2::LexicalBlock->new('block', $self->{'body'}, 'needs_return', 0)->emit_javascript2(($level + 1)) . chr(10) . Perlito5::Javascript2::tab($level) . '})()' . chr(10));
        return $str
    };
    sub Perlito5::AST::CompUnit::emit_javascript2_program {
        my $comp_units = shift();
        $Perlito5::PKG_NAME = 'main';
        my $str = ('' . 'var p5want;' . chr(10) . 'var ' . Perlito5::Javascript2::pkg_new_var() . ' = p5pkg[' . chr(39) . $Perlito5::PKG_NAME . chr(39) . '];' . chr(10));
        $Perlito5::VAR = [{'@_', {'decl', 'my'}, '$@', {'decl', 'our', 'namespace', 'main'}, '$|', {'decl', 'our', 'namespace', 'main'}, '$/', {'decl', 'our', 'namespace', 'main'}, '$"', {'decl', 'our', 'namespace', 'main'}, '$,', {'decl', 'our', 'namespace', 'main'}, '$!', {'decl', 'our', 'namespace', 'main'}, '$;', {'decl', 'our', 'namespace', 'main'}, '$?', {'decl', 'our', 'namespace', 'main'}, '$[', {'decl', 'our', 'namespace', 'main'}, '$^O', {'decl', 'our', 'namespace', 'main'}, '$^V', {'decl', 'our', 'namespace', 'main'}, '%ENV', {'decl', 'our', 'namespace', 'main'}, '%INC', {'decl', 'our', 'namespace', 'main'}, '@#', {'decl', 'our', 'namespace', 'main'}, '@ARGV', {'decl', 'our', 'namespace', 'main'}, '@INC', {'decl', 'our', 'namespace', 'main'}, '$_', {'decl', 'our', 'namespace', $Perlito5::PKG_NAME}, '$a', {'decl', 'our', 'namespace', $Perlito5::PKG_NAME}, '$b', {'decl', 'our', 'namespace', $Perlito5::PKG_NAME}, '$AUTOLOAD', {'decl', 'our', 'namespace', $Perlito5::PKG_NAME}}];
        for my  $comp_unit (@{$comp_units}) {
            $str = ($str . $comp_unit->emit_javascript2() . chr(10))
        };
        return $str
    }
};
package Perlito5::AST::Val::Int;
{
    sub Perlito5::AST::Val::Int::emit_javascript2 {
        my $self = shift();
        my $level = shift();
        $self->{'int'}
    }
};
package Perlito5::AST::Val::Num;
{
    sub Perlito5::AST::Val::Num::emit_javascript2 {
        my $self = shift();
        my $level = shift();
        $self->{'num'}
    }
};
package Perlito5::AST::Val::Buf;
{
    sub Perlito5::AST::Val::Buf::emit_javascript2 {
        my $self = shift();
        my $level = shift();
        Perlito5::Javascript2::escape_string($self->{'buf'})
    }
};
package Perlito5::AST::Lit::Block;
{
    sub Perlito5::AST::Lit::Block::emit_javascript2 {
        my $self = shift();
        my $level = shift();
        my $wantarray = shift();
        my $body;
        if (($wantarray eq 'runtime')) {
            $body = Perlito5::Javascript2::LexicalBlock->new('block', $self->{'stmts'}, 'needs_return', 1)
        }
        else {
            $body = Perlito5::Javascript2::LexicalBlock->new('block', $self->{'stmts'}, 'needs_return', 0, 'top_level', 0)
        };
        my $init = '';
        if (($self->{'name'} eq 'INIT')) {
            my $tmp = ('p5pkg.main._tmp' . Perlito5::Javascript2::get_label());
            $init = (Perlito5::Javascript2::tab(($level + 2)) . ('if (' . $tmp . ') { return }; ' . $tmp . ' = 1;' . chr(10)))
        };
        return ('p5for_lex(' . 'function () {' . chr(10) . $init . $body->emit_javascript2(($level + 2)) . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . '}, ' . '[0], ' . $self->emit_javascript2_continue($level) . ', ' . '"' . (($self->{'label'} || '')) . '"' . ')')
    };
    sub Perlito5::AST::Lit::Block::emit_javascript2_continue {
        my $self = shift();
        my $level = shift();
        if ((!($self->{'continue'}) || !(@{$self->{'continue'}->{'stmts'}}))) {
            return 'false'
        };
        return ('function () {' . chr(10) . (Perlito5::Javascript2::LexicalBlock->new('block', $self->{'continue'}->stmts(), 'needs_return', 0, 'top_level', 0))->emit_javascript2(($level + 2)) . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . '}')
    }
};
package Perlito5::AST::Index;
{
    sub Perlito5::AST::Index::emit_javascript2 {
        my $self = shift();
        my $level = shift();
        my $wantarray = shift();
        my $autovivification_type = shift();
        my $method = ($autovivification_type || 'p5aget');
        $method = 'p5aget_array' if ($autovivification_type eq 'array');
        $method = 'p5aget_hash' if ($autovivification_type eq 'hash');
        if (((($self->{'obj'}->isa('Perlito5::AST::Apply') && ($self->{'obj'}->{'code'} eq 'prefix:<@>'))) || (($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '@'))))) {
            return ('(function (a, v) { ' . 'var src=' . $self->{'obj'}->emit_javascript2($level) . '; ' . 'for (var i=0, l=v.length; ' . 'i<l; ++i)' . '{ ' . 'a.push(src.' . $method . '(v[i])) ' . '}; ' . 'return a ' . '})(' . '[], ' . Perlito5::Javascript2::to_list([$self->{'index_exp'}], $level) . ')')
        };
        return ($self->emit_javascript2_container($level) . '.' . $method . '(' . Perlito5::Javascript2::to_num($self->{'index_exp'}, $level) . ')')
    };
    sub Perlito5::AST::Index::emit_javascript2_set {
        my $self = shift();
        my $arguments = shift();
        my $level = shift();
        my $wantarray = shift();
        if (((($self->{'obj'}->isa('Perlito5::AST::Apply') && ($self->{'obj'}->{'code'} eq 'prefix:<@>'))) || (($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '@'))))) {
            return ('(function (a, v) {' . chr(10) . 'var src=' . Perlito5::Javascript2::to_list([$arguments], $level) . ';' . chr(10) . 'var out=' . Perlito5::Javascript2::emit_javascript2_autovivify($self->{'obj'}, $level, 'array') . ';' . chr(10) . 'var tmp' . ';' . chr(10) . 'for (var i=0, l=v.length; ' . 'i<l; ++i) {' . chr(10) . 'tmp = src.p5aget(i); ' . 'out.p5aset(v[i], tmp); ' . 'a.push(tmp) ' . '}; ' . 'return a ' . '})(' . '[], ' . Perlito5::Javascript2::to_list([$self->{'index_exp'}], $level) . ')')
        };
        return ($self->emit_javascript2_container($level) . '.p5aset(' . Perlito5::Javascript2::to_num($self->{'index_exp'}, ($level + 1)) . ', ' . Perlito5::Javascript2::to_scalar([$arguments], ($level + 1)) . ')')
    };
    sub Perlito5::AST::Index::emit_javascript2_set_list {
        my $self = shift();
        my $level = shift();
        my $list = shift();
        if (((($self->{'obj'}->isa('Perlito5::AST::Apply') && ($self->{'obj'}->{'code'} eq 'prefix:<@>'))) || (($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '@'))))) {
            return ('(function (a, v) {' . chr(10) . 'var out=' . Perlito5::Javascript2::emit_javascript2_autovivify($self->{'obj'}, $level, 'array') . ';' . chr(10) . 'var tmp' . ';' . chr(10) . 'for (var i=0, l=v.length; ' . 'i<l; ++i) {' . chr(10) . 'tmp = ' . $list . '.shift(); ' . 'out.p5aset(v[i], tmp); ' . 'a.push(tmp) ' . '}; ' . 'return a ' . '})(' . '[], ' . Perlito5::Javascript2::to_list([$self->{'index_exp'}], $level) . ')')
        };
        return ($self->emit_javascript2_container($level) . '.p5aset(' . Perlito5::Javascript2::to_num($self->{'index_exp'}, ($level + 1)) . ', ' . $list . '.shift()' . ')')
    };
    sub Perlito5::AST::Index::emit_javascript2_container {
        my $self = shift();
        my $level = shift();
        if (($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '$'))) {
            my $v = Perlito5::AST::Var->new('sigil', '@', 'namespace', $self->{'obj'}->namespace(), 'name', $self->{'obj'}->name());
            return $v->emit_javascript2($level)
        }
        else {
            if (($self->{'obj'}->isa('Perlito5::AST::Apply') && ($self->{'obj'}->{'code'} eq 'prefix:<$>'))) {
                return (Perlito5::Javascript2::emit_javascript2_autovivify($self->{'obj'}->{'arguments'}->[0], $level, 'array') . '._array_')
            }
            else {
                return (Perlito5::Javascript2::emit_javascript2_autovivify($self->{'obj'}, $level, 'array') . '._array_')
            }
        }
    }
};
package Perlito5::AST::Lookup;
{
    sub Perlito5::AST::Lookup::emit_javascript2 {
        my $self = shift();
        my $level = shift();
        my $wantarray = shift();
        my $autovivification_type = shift();
        my $method = ($autovivification_type || 'p5hget');
        $method = 'p5hget_array' if ($autovivification_type eq 'array');
        $method = 'p5hget_hash' if ($autovivification_type eq 'hash');
        if (((($self->{'obj'}->isa('Perlito5::AST::Apply') && ($self->{'obj'}->{'code'} eq 'prefix:<@>'))) || (($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '@'))))) {
            my $v;
            $v = Perlito5::AST::Var->new('sigil', '%', 'namespace', $self->{'obj'}->namespace(), 'name', $self->{'obj'}->name()) if $self->{'obj'}->isa('Perlito5::AST::Var');
            $v = Perlito5::AST::Apply->new('code', 'prefix:<%>', 'namespace', $self->{'obj'}->namespace(), 'arguments', $self->{'obj'}->arguments()) if $self->{'obj'}->isa('Perlito5::AST::Apply');
            return ('(function (a, v) { ' . 'var src=' . $v->emit_javascript2($level) . '; ' . 'for (var i=0, l=v.length; ' . 'i<l; ++i)' . '{ ' . 'a.push(src.p5hget(v[i])) ' . '}; ' . 'return a ' . '})(' . '[], ' . Perlito5::Javascript2::to_list([$self->{'index_exp'}], $level) . ')')
        };
        return ($self->emit_javascript2_container($level) . '.' . $method . '(' . Perlito5::Javascript2::autoquote($self->{'index_exp'}, $level) . ')')
    };
    sub Perlito5::AST::Lookup::emit_javascript2_set {
        my $self = shift();
        my $arguments = shift();
        my $level = shift();
        my $wantarray = shift();
        if (((($self->{'obj'}->isa('Perlito5::AST::Apply') && ($self->{'obj'}->{'code'} eq 'prefix:<@>'))) || (($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '@'))))) {
            my $v;
            $v = Perlito5::AST::Var->new('sigil', '%', 'namespace', $self->{'obj'}->namespace(), 'name', $self->{'obj'}->name()) if $self->{'obj'}->isa('Perlito5::AST::Var');
            $v = Perlito5::AST::Apply->new('code', 'prefix:<%>', 'namespace', $self->{'obj'}->namespace(), 'arguments', $self->{'obj'}->arguments()) if $self->{'obj'}->isa('Perlito5::AST::Apply');
            return ('(function (a, v) { ' . 'var src=' . Perlito5::Javascript2::to_list([$arguments], $level) . ';' . chr(10) . 'var out=' . $v->emit_javascript2($level) . ';' . chr(10) . 'var tmp' . ';' . chr(10) . 'for (var i=0, l=v.length; ' . 'i<l; ++i)' . '{ ' . 'tmp = src.p5hget(i); ' . 'out.p5hset(v[i], tmp); ' . 'a.push(tmp) ' . '}; ' . 'return a ' . '})(' . '[], ' . Perlito5::Javascript2::to_list([$self->{'index_exp'}], $level) . ')')
        };
        return ($self->emit_javascript2_container($level) . '.p5hset(' . Perlito5::Javascript2::autoquote($self->{'index_exp'}, $level) . ', ' . Perlito5::Javascript2::to_scalar([$arguments], ($level + 1)) . ')')
    };
    sub Perlito5::AST::Lookup::emit_javascript2_set_list {
        my $self = shift();
        my $level = shift();
        my $list = shift();
        if (((($self->{'obj'}->isa('Perlito5::AST::Apply') && ($self->{'obj'}->{'code'} eq 'prefix:<@>'))) || (($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '@'))))) {
            my $v;
            $v = Perlito5::AST::Var->new('sigil', '%', 'namespace', $self->{'obj'}->namespace(), 'name', $self->{'obj'}->name()) if $self->{'obj'}->isa('Perlito5::AST::Var');
            $v = Perlito5::AST::Apply->new('code', 'prefix:<%>', 'namespace', $self->{'obj'}->namespace(), 'arguments', $self->{'obj'}->arguments()) if $self->{'obj'}->isa('Perlito5::AST::Apply');
            return ('(function (a, v) { ' . 'var out=' . $v->emit_javascript2($level) . ';' . chr(10) . 'var tmp' . ';' . chr(10) . 'for (var i=0, l=v.length; ' . 'i<l; ++i)' . '{ ' . 'tmp = ' . $list . '.shift(); ' . 'out.p5hset(v[i], tmp); ' . 'a.push(tmp) ' . '}; ' . 'return a ' . '})(' . '[], ' . Perlito5::Javascript2::to_list([$self->{'index_exp'}], $level) . ')')
        };
        return ($self->emit_javascript2_container($level) . '.p5hset(' . Perlito5::Javascript2::autoquote($self->{'index_exp'}, $level) . ', ' . $list . '.shift()' . ')')
    };
    sub Perlito5::AST::Lookup::emit_javascript2_container {
        my $self = shift();
        my $level = shift();
        if (($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '$'))) {
            my $v = Perlito5::AST::Var->new('sigil', '%', 'namespace', $self->{'obj'}->namespace(), 'name', $self->{'obj'}->name());
            return $v->emit_javascript2($level)
        }
        else {
            if (($self->{'obj'}->isa('Perlito5::AST::Apply') && ($self->{'obj'}->{'code'} eq 'prefix:<$>'))) {
                return (Perlito5::Javascript2::emit_javascript2_autovivify($self->{'obj'}->{'arguments'}->[0], $level, 'hash') . '._hash_')
            }
            else {
                return (Perlito5::Javascript2::emit_javascript2_autovivify($self->{'obj'}, $level, 'hash') . '._hash_')
            }
        }
    }
};
package Perlito5::AST::Var;
{
    my $table = {'$', 'v_', '@', 'List_', '%', 'Hash_', '&', ''};
    sub Perlito5::AST::Var::emit_javascript2 {
        my $self = shift();
        my $level = shift();
        my $wantarray = shift();
        my $str_name = $self->{'name'};
        $str_name = chr(92) . chr(92) if ($str_name eq chr(92));
        $str_name = chr(92) . '"' if ($str_name eq '"');
        my $perl5_name = $self->perl5_name_javascript2();
        my $decl_type;
        my $decl = $self->perl5_get_decl_javascript2($perl5_name);
        if ($decl) {
            $decl_type = $decl->{'decl'}
        }
        else {
            if ((!($self->{'namespace'}) && ($self->{'sigil'} ne '*'))) {
                if ($Perlito5::STRICT) {
                    die(('Global symbol "' . $perl5_name . '" requires explicit package name'))
                };
                $decl_type = 'our';
                $self->{'namespace'} = $Perlito5::PKG_NAME;
                my $sigil = (($self->{'sigil'} eq '$#') ? '@' : $self->{'sigil'});
                my $s = ('p5pkg["' . $self->{'namespace'} . '"]["' . $table->{$sigil} . $str_name . '"]');
                if (($sigil eq '@')) {
                    $s = ($s . ' || (' . $s . ' = [])');
                    $s = ('p5pkg[' . $s . ', "' . $self->{'namespace'} . '"]["' . $table->{$sigil} . $str_name . '"]');
                    if ((($self->{'sigil'} eq '@') && ($wantarray eq 'scalar'))) {
                        $s = ($s . '.length')
                    }
                }
                else {
                    if (($sigil eq '%')) {
                        $s = ($s . ' || (' . $s . ' = {})');
                        $s = ('p5pkg[' . $s . ', "' . $self->{'namespace'} . '"]["' . $table->{$sigil} . $str_name . '"]')
                    }
                };
                if (($self->{'sigil'} eq '$#')) {
                    return ('(' . $s . '.length - 1)')
                };
                return $s
            }
        };
        if (($self->{'sigil'} eq '@')) {
            if (($wantarray eq 'scalar')) {
                return ($self->emit_javascript2($level, 'list') . '.length')
            };
            if (($wantarray eq 'runtime')) {
                return ('(p5want' . ' ? ' . $self->emit_javascript2($level, 'list') . ' : ' . $self->emit_javascript2($level, 'list') . '.length' . ')')
            }
        };
        if (($self->{'sigil'} eq '::')) {
            return Perlito5::Javascript2::escape_string($self->{'namespace'})
        };
        if (($self->{'sigil'} eq '&')) {
            return ('p5pkg["' . (($self->{'namespace'} || $Perlito5::PKG_NAME)) . '"]["' . $str_name . '"]([], ' . ((($wantarray eq 'list') ? '1' : (($wantarray eq 'scalar') ? '0' : (($wantarray eq 'void') ? 'null' : 'p5want')))) . ')')
        };
        if (($self->{'sigil'} eq '*')) {
            return ('p5pkg["' . (($self->{'namespace'} || $Perlito5::PKG_NAME)) . '"]["' . $str_name . '"]')
        };
        if (($decl_type eq 'our')) {
            my $sigil = (($self->{'sigil'} eq '$#') ? '@' : $self->{'sigil'});
            my $s = ('p5pkg["' . (($self->{'namespace'} || $decl->{'namespace'})) . '"]["' . $table->{$sigil} . $str_name . '"]');
            if (($self->{'sigil'} eq '$#')) {
                return ('(' . $s . '.length - 1)')
            };
            return $s
        };
        my $ns = '';
        if ($self->{'namespace'}) {
            $ns = ('p5make_package("' . $self->{'namespace'} . '")');
            if (($self->{'sigil'} eq '$#')) {
                return ('(' . $ns . '["' . $table->{'@'} . $str_name . '"].length - 1)')
            };
            return ($ns . '["' . $table->{$self->{'sigil'}} . $str_name . '"]')
        };
        if (($self->{'sigil'} eq '$#')) {
            return ('(' . $ns . $table->{'@'} . $str_name . '.length - 1)')
        };
        ($ns . $table->{$self->{'sigil'}} . $str_name)
    };
    sub Perlito5::AST::Var::emit_javascript2_set {
        my $self = shift();
        my $arguments = shift();
        my $level = shift();
        my $wantarray = shift();
        my $open = (($wantarray eq 'void') ? '' : '(');
        my $close = (($wantarray eq 'void') ? '' : ')');
        if (($self->sigil() eq '$')) {
            return ($open . $self->emit_javascript2() . ' = ' . Perlito5::Javascript2::to_scalar([$arguments], ($level + 1)) . $close)
        };
        if (($self->sigil() eq '@')) {
            return ($open . $self->emit_javascript2() . ' = ' . Perlito5::Javascript2::to_list([$arguments], ($level + 1)) . $close)
        };
        if (($self->sigil() eq '%')) {
            return ($open . $self->emit_javascript2() . ' = ' . Perlito5::Javascript2::to_list([$arguments], ($level + 1), 'hash') . $close)
        };
        if (($self->sigil() eq '*')) {
            return ('p5typeglob_set(' . '"' . (($self->{'namespace'} || $Perlito5::PKG_NAME)) . '", ' . '"' . $self->{'name'} . '", ' . Perlito5::Javascript2::to_scalar([$arguments], ($level + 1)) . ')')
        };
        die('don' . chr(39) . 't know how to assign to variable ', $self->sigil(), $self->name())
    };
    sub Perlito5::AST::Var::emit_javascript2_set_list {
        my $self = shift();
        my $level = shift();
        my $list = shift();
        if (($self->sigil() eq '$')) {
            return ($self->emit_javascript2() . ' = ' . $list . '.shift()')
        };
        if (($self->sigil() eq '@')) {
            return ($self->emit_javascript2() . ' = ' . $list . '; ' . $list . ' = []')
        };
        if (($self->sigil() eq '%')) {
            return ($self->emit_javascript2() . ' = p5a_to_h(' . $list . '); ' . $list . ' = []')
        };
        die('don' . chr(39) . 't know how to assign to variable ', $self->sigil(), $self->name())
    };
    sub Perlito5::AST::Var::perl5_name_javascript2 {
        my $self = shift();
        my $sigil = $self->{'sigil'};
        $sigil = '@' if ($sigil eq '$#');
        ($sigil . (($self->{'namespace'} ? ($self->{'namespace'} . '::') : '')) . $self->{'name'})
    };
    sub Perlito5::AST::Var::perl5_get_decl_javascript2 {
        my $self = shift();
        my $perl5_name = shift();
        return {'decl', 'our'} if (substr($perl5_name, 0, 1) eq '&');
        for (@{$Perlito5::VAR}) {
            return $_->{$perl5_name} if exists($_->{$perl5_name})
        };
        return undef()
    }
};
package Perlito5::AST::Decl;
{
    sub Perlito5::AST::Decl::emit_javascript2 {
        my $self = shift();
        my $level = shift();
        $self->{'var'}->emit_javascript2($level)
    };
    sub Perlito5::AST::Decl::emit_javascript2_init {
        my $self = shift();
        my $env = {'decl', $self->{'decl'}};
        my $perl5_name = $self->{'var'}->perl5_name_javascript2();
        if (($self->{'decl'} ne 'my')) {
            die(('No package name allowed for variable ' . $perl5_name . ' in "our"')) if (($self->{'decl'} eq 'our') && $self->{'var'}->{'namespace'});
            if (($self->{'var'}->{'namespace'} eq '')) {
                my $decl_namespace = '';
                my $decl = $self->{'var'}->perl5_get_decl_javascript2($perl5_name);
                if (((($self->{'decl'} eq 'local') && $decl) && ((($decl->{'decl'} eq 'our') || ($decl->{'decl'} eq 'local'))))) {
                    $decl_namespace = $decl->{'namespace'}
                };
                $env->{'namespace'} = ($decl_namespace || $Perlito5::PKG_NAME)
            }
        };
        $Perlito5::VAR->[0]->{$perl5_name} = $env;
        if (($self->{'decl'} eq 'my')) {
            my $str = ('var ' . $self->{'var'}->emit_javascript2());
            if (($self->{'var'}->sigil() eq '%')) {
                $str = ($str . ' = {};')
            }
            else {
                if (($self->{'var'}->sigil() eq '@')) {
                    $str = ($str . '= [];')
                }
                else {
                    $str = ($str . ';')
                }
            };
            return $str
        }
        else {
            if (($self->{'decl'} eq 'our')) {
                my $str = $self->{'var'}->emit_javascript2();
                if (($self->{'var'}->sigil() eq '%')) {
                    $str = ($str . ' = {};')
                }
                else {
                    if (($self->{'var'}->sigil() eq '@')) {
                        $str = ($str . '= [];')
                    }
                    else {
                        return ('// our ' . $str)
                    }
                };
                return ('if (typeof ' . $self->{'var'}->emit_javascript2() . ' == "undefined" ) { ' . $str . '};')
            }
            else {
                if (($self->{'decl'} eq 'local')) {
                    my $perl5_name = $self->{'var'}->perl5_name_javascript2();
                    my $decl_namespace = '';
                    my $decl = $self->{'var'}->perl5_get_decl_javascript2($perl5_name);
                    if (($decl && ((($decl->{'decl'} eq 'our') || ($decl->{'decl'} eq 'local'))))) {
                        $decl_namespace = $decl->{'namespace'}
                    };
                    my $ns = ('p5pkg["' . ((($self->{'var'}->{'namespace'} || $decl_namespace) || $Perlito5::PKG_NAME)) . '"]');
                    return ('p5set_local(' . $ns . ',' . Perlito5::Javascript2::escape_string($self->{'var'}->{'name'}) . ',' . Perlito5::Javascript2::escape_string($self->{'var'}->{'sigil'}) . '); ')
                }
                else {
                    if (($self->{'decl'} eq 'state')) {
                        return ('// state ' . $self->{'var'}->emit_javascript2())
                    }
                    else {
                        die(('not implemented: Perlito5::AST::Decl ' . chr(39) . $self->{'decl'} . chr(39)))
                    }
                }
            }
        }
    };
    sub Perlito5::AST::Decl::emit_javascript2_set {
        my $self = shift();
        my $arguments = shift();
        my $level = shift();
        my $wantarray = shift();
        $self->var()->emit_javascript2_set($arguments, $level, $wantarray)
    };
    sub Perlito5::AST::Decl::emit_javascript2_set_list {
        my $self = shift();
        my $level = shift();
        my $list = shift();
        $self->var()->emit_javascript2_set_list($level, $list)
    }
};
package Perlito5::AST::Proto;
{
    sub Perlito5::AST::Proto::emit_javascript2 {
        my $self = shift();
        my $level = shift();
        return Perlito5::Javascript2::pkg() if ($self->{'name'} eq '__PACKAGE__');
        ('p5pkg["' . $self->{'name'} . '"]')
    }
};
package Perlito5::AST::Call;
{
    sub Perlito5::AST::Call::emit_javascript2 {
        my $self = shift();
        my $level = shift();
        my $wantarray = shift();
        my $autovivification_type = shift();
        my $meth = $self->{'method'};
        if (($meth eq 'postcircumfix:<[ ]>')) {
            my $method = ($autovivification_type || 'p5aget');
            $method = 'p5aget_array' if ($autovivification_type eq 'array');
            $method = 'p5aget_hash' if ($autovivification_type eq 'hash');
            return (Perlito5::Javascript2::emit_javascript2_autovivify($self->{'invocant'}, $level, 'array') . '._array_.' . $method . '(' . Perlito5::Javascript2::to_num($self->{'arguments'}, ($level + 1)) . ')')
        };
        if (($meth eq 'postcircumfix:<{ }>')) {
            my $method = ($autovivification_type || 'p5hget');
            $method = 'p5hget_array' if ($autovivification_type eq 'array');
            $method = 'p5hget_hash' if ($autovivification_type eq 'hash');
            return (Perlito5::Javascript2::emit_javascript2_autovivify($self->{'invocant'}, $level, 'hash') . '._hash_.' . $method . '(' . Perlito5::Javascript2::autoquote($self->{'arguments'}, ($level + 1), 'list') . ')')
        };
        if (($meth eq 'postcircumfix:<( )>')) {
            my $invocant;
            if (((ref($self->{'invocant'}) eq 'Perlito5::AST::Apply') && ($self->{'invocant'}->{'code'} eq 'prefix:<&>'))) {
                my $arg = $self->{'invocant'}->{'arguments'}->[0];
                $invocant = ('p5code_lookup_by_name("' . $Perlito5::PKG_NAME . '", ' . $arg->emit_javascript2($level) . ')')
            }
            else {
                if (((ref($self->{'invocant'}) eq 'Perlito5::AST::Var') && ($self->{'invocant'}->{'sigil'} eq '&'))) {
                    $invocant = ('p5pkg["' . (($self->{'invocant'}->{'namespace'} || $Perlito5::PKG_NAME)) . '"]["' . $self->{'invocant'}->{'name'} . '"]')
                }
                else {
                    $invocant = $self->{'invocant'}->emit_javascript2($level, 'scalar')
                }
            };
            return ('(' . $invocant . ')(' . Perlito5::Javascript2::to_list($self->{'arguments'}) . ', ' . ((($wantarray eq 'list') ? '1' : (($wantarray eq 'scalar') ? '0' : (($wantarray eq 'void') ? 'null' : 'p5want')))) . ')')
        };
        my $invocant = $self->{'invocant'}->emit_javascript2($level, 'scalar');
        if ((ref($meth) eq 'Perlito5::AST::Var')) {
            $meth = $meth->emit_javascript2($level, 'scalar')
        }
        else {
            $meth = ('"' . $meth . '"')
        };
        return ('p5call(' . $invocant . ', ' . $meth . ', ' . Perlito5::Javascript2::to_list($self->{'arguments'}) . ', ' . ((($wantarray eq 'list') ? '1' : (($wantarray eq 'scalar') ? '0' : (($wantarray eq 'void') ? 'null' : 'p5want')))) . ')')
    };
    sub Perlito5::AST::Call::emit_javascript2_set {
        my $self = shift();
        my $arguments = shift();
        my $level = shift();
        my $wantarray = shift();
        if (($self->{'method'} eq 'postcircumfix:<[ ]>')) {
            return (Perlito5::Javascript2::emit_javascript2_autovivify($self->{'invocant'}, $level, 'array') . '._array_.p5aset(' . Perlito5::Javascript2::to_num($self->{'arguments'}, ($level + 1)) . ', ' . Perlito5::Javascript2::to_scalar([$arguments], ($level + 1)) . ')')
        };
        if (($self->{'method'} eq 'postcircumfix:<{ }>')) {
            return (Perlito5::Javascript2::emit_javascript2_autovivify($self->{'invocant'}, $level, 'hash') . '._hash_.p5hset(' . Perlito5::Javascript2::autoquote($self->{'arguments'}, ($level + 1), 'list') . ', ' . Perlito5::Javascript2::to_scalar([$arguments], ($level + 1)) . ')')
        };
        die('don' . chr(39) . 't know how to assign to method ', $self->{'method'})
    };
    sub Perlito5::AST::Call::emit_javascript2_set_list {
        my $self = shift();
        my $level = shift();
        my $list = shift();
        if (($self->{'method'} eq 'postcircumfix:<[ ]>')) {
            return (Perlito5::Javascript2::emit_javascript2_autovivify($self->{'invocant'}, $level, 'array') . '._array_.p5aset(' . Perlito5::Javascript2::to_num($self->{'arguments'}, ($level + 1)) . ', ' . $list . '.shift()' . ')')
        };
        if (($self->{'method'} eq 'postcircumfix:<{ }>')) {
            return (Perlito5::Javascript2::emit_javascript2_autovivify($self->{'invocant'}, $level, 'hash') . '._hash_.p5hset(' . Perlito5::Javascript2::autoquote($self->{'arguments'}, ($level + 1), 'list') . ', ' . $list . '.shift()' . ')')
        };
        die('don' . chr(39) . 't know how to assign to method ', $self->{'method'})
    }
};
package Perlito5::AST::Apply;
{
    sub Perlito5::AST::Apply::emit_regex_javascript2 {
        my $op = shift();
        my $var = shift();
        my $regex = shift();
        if ($regex->isa('Perlito5::AST::Var')) {
            $regex = {'code', 'p5:m', 'arguments', [$regex, '']}
        };
        my $str;
        my $code = $regex->{'code'};
        my $regex_args = $regex->{'arguments'};
        if (($code eq 'p5:s')) {
            $str = ($var->emit_javascript2() . ' = p5str(' . $var->emit_javascript2() . ').replace(/' . $regex_args->[0]->{'buf'} . '/' . $regex_args->[2] . ', ' . $regex_args->[1]->emit_javascript2() . ')')
        }
        else {
            if (($code eq 'p5:m')) {
                my $ast = $regex_args->[0];
                if ($ast->isa('Perlito5::AST::Val::Buf')) {
                    $str = ('(' . 'p5str(' . $var->emit_javascript2() . ')' . '.match(/' . $ast->{'buf'} . '/' . $regex_args->[1] . ')' . ' ? 1 : 0)')
                }
                else {
                    $str = ('(new RegExp(' . $ast->emit_javascript2() . ', ' . '"' . $regex_args->[1] . '"' . '))' . '.exec(' . 'p5str(' . $var->emit_javascript2() . ')' . ')')
                }
            }
            else {
                if (($code eq 'p5:tr')) {
                    $str = ('p5tr(' . $var->emit_javascript2() . ', ' . $regex_args->[0]->emit_javascript2() . ', ' . $regex_args->[1]->emit_javascript2() . ')')
                }
                else {
                    die(('Error: regex emitter - unknown operator ' . $code))
                }
            }
        };
        if (($op eq '=~')) {
            return $str
        };
        if (($op eq '!~')) {
            return ('!(' . $str . ')')
        };
        die('Error: regex emitter')
    };
    sub Perlito5::AST::Apply::emit_javascript2_set {
        my $self = shift();
        my $arguments = shift();
        my $level = shift();
        my $wantarray = shift();
        my $code = $self->{'code'};
        if (($code eq 'prefix:<$>')) {
            return ('p5scalar_deref_set(' . Perlito5::Javascript2::emit_javascript2_autovivify($self->{'arguments'}->[0], ($level + 1), 'scalar') . ', ' . Perlito5::Javascript2::to_scalar([$arguments], ($level + 1)) . ')')
        };
        if (($code eq 'prefix:<*>')) {
            return ('p5typeglob_deref_set(' . Perlito5::Javascript2::to_scalar($self->{'arguments'}, ($level + 1)) . ', ' . Perlito5::Javascript2::to_scalar([$arguments], ($level + 1)) . ')')
        };
        my $open = (($wantarray eq 'void') ? '' : '(');
        my $close = (($wantarray eq 'void') ? '' : ')');
        ($open . $self->emit_javascript2(($level + 1)) . ' = ' . $arguments->emit_javascript2(($level + 1)) . $close)
    };
    my %emit_js = ('infix:<=~>', sub {
                my $self = $_[0];
                emit_regex_javascript2('=~', $self->{'arguments'}->[0], $self->{'arguments'}->[1])
            }, 'infix:<!~>', sub {
                my $self = $_[0];
                emit_regex_javascript2('!~', $self->{'arguments'}->[0], $self->{'arguments'}->[1])
            }, 'p5:s', sub {
                my $self = $_[0];
                emit_regex_javascript2('=~', Perlito5::AST::Var->new('sigil', '$', 'namespace', '', 'name', '_'), $self)
            }, 'p5:m', sub {
                my $self = $_[0];
                emit_regex_javascript2('=~', Perlito5::AST::Var->new('sigil', '$', 'namespace', '', 'name', '_'), $self)
            }, 'p5:tr', sub {
                my $self = $_[0];
                emit_regex_javascript2('=~', Perlito5::AST::Var->new('sigil', '$', 'namespace', '', 'name', '_'), $self)
            }, '__PACKAGE__', sub {
                my $self = $_[0];
                ('"' . $Perlito5::PKG_NAME . '"')
            }, 'wantarray', sub {
                my $self = $_[0];
                'p5want'
            }, 'package', sub {
                my $self = $_[0];
                ('p5make_package("' . $self->{'namespace'} . '")')
            }, 'infix:<=>>', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                (Perlito5::AST::Lookup->autoquote($self->{'arguments'}->[0])->emit_javascript2($level) . ', ' . $self->{'arguments'}->[1]->emit_javascript2($level))
            }, 'infix:<cmp>', sub {
                my $self = $_[0];
                ('p5cmp(' . join(', ', map(Perlito5::Javascript2::to_str($_), @{$self->{'arguments'}})) . ')')
            }, 'infix:<<=>>', sub {
                my $self = $_[0];
                ('p5cmp(' . join(', ', map(Perlito5::Javascript2::to_num($_), @{$self->{'arguments'}})) . ')')
            }, 'infix:<**>', sub {
                my $self = $_[0];
                ('Math.pow(' . join(', ', map(Perlito5::Javascript2::to_num($_), @{$self->{'arguments'}})) . ')')
            }, 'infix:<<<>', sub {
                my $self = $_[0];
                ('p5shift_left(' . join(', ', map(Perlito5::Javascript2::to_num($_), @{$self->{'arguments'}})) . ')')
            }, 'infix:<%>', sub {
                my $self = $_[0];
                ('p5modulo(' . join(', ', map(Perlito5::Javascript2::to_num($_), @{$self->{'arguments'}})) . ')')
            }, 'prefix:<!>', sub {
                my $self = shift();
                my $level = shift();
                ('!( ' . Perlito5::Javascript2::to_bool($self->{'arguments'}->[0], $level) . ')')
            }, 'prefix:<not>', sub {
                my $self = shift();
                my $level = shift();
                ('!( ' . Perlito5::Javascript2::to_bool($self->{'arguments'}->[0], $level) . ')')
            }, 'prefix:<~>', sub {
                my $self = $_[0];
                ('p5complement( ' . Perlito5::Javascript2::to_num($self->{'arguments'}->[0]) . ')')
            }, 'prefix:<->', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                ('p5negative( ' . $self->{'arguments'}->[0]->emit_javascript2($level, 'scalar') . ')')
            }, 'prefix:<+>', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                ('(' . $self->{'arguments'}->[0]->emit_javascript2($level, $wantarray) . ')')
            }, 'require', sub {
                my $self = $_[0];
                my $level = $_[1];
                ('p5pkg["Perlito5::Grammar::Use"]["require"]([' . Perlito5::Javascript2::to_str($self->{'arguments'}->[0]) . ', ' . (($self->{'arguments'}->[0]->{'bareword'} ? 1 : 0)) . '])')
            }, 'prefix:<$>', sub {
                my $self = $_[0];
                my $level = $_[1];
                my $arg = $self->{'arguments'}->[0];
                return ('p5scalar_deref(' . Perlito5::Javascript2::emit_javascript2_autovivify($arg, $level, 'scalar') . ')')
            }, 'prefix:<@>', sub {
                my $self = $_[0];
                my $level = $_[1];
                my $arg = $self->{'arguments'}->[0];
                (Perlito5::Javascript2::emit_javascript2_autovivify($arg, $level, 'array') . '._array_')
            }, 'prefix:<$#>', sub {
                my $self = $_[0];
                my $level = $_[1];
                my $arg = $self->{'arguments'}->[0];
                ('(' . Perlito5::Javascript2::emit_javascript2_autovivify($arg, $level, 'array') . '._array_.length - 1)')
            }, 'prefix:<%>', sub {
                my $self = $_[0];
                my $level = $_[1];
                my $arg = $self->{'arguments'}->[0];
                (Perlito5::Javascript2::emit_javascript2_autovivify($arg, $level, 'hash') . '._hash_')
            }, 'prefix:<&>', sub {
                my $self = $_[0];
                my $level = $_[1];
                my $arg = $self->{'arguments'}->[0];
                ('p5code_lookup_by_name("' . $Perlito5::PKG_NAME . '", ' . $arg->emit_javascript2($level) . ')([])')
            }, 'circumfix:<[ ]>', sub {
                my $self = $_[0];
                my $level = $_[1];
                ('(new p5ArrayRef(' . Perlito5::Javascript2::to_list($self->{'arguments'}) . '))')
            }, 'circumfix:<{ }>', sub {
                my $self = $_[0];
                my $level = $_[1];
                ('(new p5HashRef(' . Perlito5::Javascript2::to_list($self->{'arguments'}, $level, 'hash') . '))')
            }, 'prefix:<' . chr(92) . '>', sub {
                my $self = $_[0];
                my $level = $_[1];
                my $arg = $self->{'arguments'}->[0];
                if ($arg->isa('Perlito5::AST::Apply')) {
                    if (($arg->{'code'} eq 'prefix:<&>')) {
                        return ('p5code_lookup_by_name("' . $Perlito5::PKG_NAME . '", ' . $arg->{'arguments'}->[0]->emit_javascript2($level) . ')')
                    }
                };
                if ($arg->isa('Perlito5::AST::Var')) {
                    if (($arg->sigil() eq '@')) {
                        return ('(new p5ArrayRef(' . $arg->emit_javascript2($level) . '))')
                    };
                    if (($arg->sigil() eq '%')) {
                        return ('(new p5HashRef(' . $arg->emit_javascript2($level) . '))')
                    };
                    if (($arg->sigil() eq '*')) {
                        return ('(new p5GlobRef(' . $arg->emit_javascript2($level) . '))')
                    };
                    if (($arg->sigil() eq '&')) {
                        if ($arg->{'namespace'}) {
                            return ('p5pkg["' . $arg->{'namespace'} . '"].' . $arg->{'name'})
                        }
                        else {
                            return (Perlito5::Javascript2::pkg() . '.' . $arg->{'name'})
                        }
                    }
                };
                return ('(new p5ScalarRef(' . $arg->emit_javascript2($level) . '))')
            }, 'postfix:<++>', sub {
                my $self = $_[0];
                my $level = $_[1];
                my $arg = $self->{'arguments'}->[0];
                if ((($arg->isa('Perlito5::AST::Index') || $arg->isa('Perlito5::AST::Lookup')) || $arg->isa('Perlito5::AST::Call'))) {
                    return $arg->emit_javascript2(($level + 1), 0, 'p5postincr')
                };
                if (($arg->isa('Perlito5::AST::Var') && ($arg->{'sigil'} eq '$'))) {
                    return ('(function (_tmp) { ' . $arg->emit_javascript2($level) . ' = p5incr_(_tmp); ' . 'return _tmp ' . '})(' . $arg->emit_javascript2($level) . ')')
                };
                ('(' . join(' ', map($_->emit_javascript2(), @{$self->{'arguments'}})) . ')++')
            }, 'postfix:<-->', sub {
                my $self = $_[0];
                my $level = $_[1];
                my $arg = $self->{'arguments'}->[0];
                if ((($arg->isa('Perlito5::AST::Index') || $arg->isa('Perlito5::AST::Lookup')) || $arg->isa('Perlito5::AST::Call'))) {
                    return $arg->emit_javascript2(($level + 1), 0, 'p5postdecr')
                };
                if (($arg->isa('Perlito5::AST::Var') && ($arg->{'sigil'} eq '$'))) {
                    return ('(function (_tmp) { ' . $arg->emit_javascript2($level) . ' = p5decr_(_tmp); ' . 'return _tmp ' . '})(' . $arg->emit_javascript2($level) . ')')
                };
                ('(' . join(' ', map($_->emit_javascript2(), @{$self->{'arguments'}})) . ')--')
            }, 'prefix:<++>', sub {
                my $self = $_[0];
                my $level = $_[1];
                my $arg = $self->{'arguments'}->[0];
                if ((($arg->isa('Perlito5::AST::Index') || $arg->isa('Perlito5::AST::Lookup')) || $arg->isa('Perlito5::AST::Call'))) {
                    return $arg->emit_javascript2(($level + 1), 0, 'p5incr')
                };
                if (($arg->isa('Perlito5::AST::Var') && ($arg->{'sigil'} eq '$'))) {
                    return ('(function (_tmp) { ' . $arg->emit_javascript2($level) . ' = p5incr_(_tmp); ' . 'return ' . $arg->emit_javascript2($level) . ' ' . '})(' . $arg->emit_javascript2($level) . ')')
                };
                ('++(' . join(' ', map($_->emit_javascript2(), @{$self->{'arguments'}})) . ')')
            }, 'prefix:<-->', sub {
                my $self = $_[0];
                my $level = $_[1];
                my $arg = $self->{'arguments'}->[0];
                if ((($arg->isa('Perlito5::AST::Index') || $arg->isa('Perlito5::AST::Lookup')) || $arg->isa('Perlito5::AST::Call'))) {
                    return $arg->emit_javascript2(($level + 1), 0, 'p5decr')
                };
                if (($arg->isa('Perlito5::AST::Var') && ($arg->{'sigil'} eq '$'))) {
                    return ('(function (_tmp) { ' . $arg->emit_javascript2($level) . ' = p5decr_(_tmp); ' . 'return ' . $arg->emit_javascript2($level) . ' ' . '})(' . $arg->emit_javascript2($level) . ')')
                };
                ('--(' . join(' ', map($_->emit_javascript2(), @{$self->{'arguments'}})) . ')')
            }, 'infix:<x>', sub {
                my $self = $_[0];
                ('p5str_replicate(' . join(', ', map($_->emit_javascript2(), @{$self->{'arguments'}})) . ')')
            }, 'list:<.>', sub {
                my $self = $_[0];
                ('(' . join(' + ', map(Perlito5::Javascript2::to_str($_), @{$self->{'arguments'}})) . ')')
            }, 'list:<,>', sub {
                my $self = $_[0];
                Perlito5::Javascript2::to_list($self->{'arguments'})
            }, 'infix:<..>', sub {
                my $self = $_[0];
                my $level = $_[1];
                ('(function (a) { ' . 'for (var i=' . $self->{'arguments'}->[0]->emit_javascript2() . ', l=' . $self->{'arguments'}->[1]->emit_javascript2() . '; ' . 'i<=l; ++i)' . '{ ' . 'a.push(i) ' . '}; ' . 'return a ' . '})([])')
            }, 'delete', sub {
                my $self = $_[0];
                my $level = $_[1];
                ('(delete ' . $self->{'arguments'}->[0]->emit_javascript2() . ')')
            }, 'scalar', sub {
                my $self = $_[0];
                my $level = $_[1];
                Perlito5::Javascript2::to_scalar($self->{'arguments'}, ($level + 1))
            }, 'ternary:<? :>', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                ('( ' . Perlito5::Javascript2::to_bool($self->{'arguments'}->[0]) . ' ? ' . ($self->{'arguments'}->[1])->emit_javascript2($level, $wantarray) . ' : ' . ($self->{'arguments'}->[2])->emit_javascript2($level, $wantarray) . ')')
            }, 'my', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                ('p5context(' . '[' . join(', ', map($_->emit_javascript2($level, $wantarray), @{$self->{'arguments'}})) . '], ' . ((($wantarray eq 'runtime') ? 'p5want' : (($wantarray eq 'list') ? 1 : 0))) . ')')
            }, 'local', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                ('p5context(' . '[' . join(', ', map($_->emit_javascript2($level, $wantarray), @{$self->{'arguments'}})) . '], ' . ((($wantarray eq 'runtime') ? 'p5want' : (($wantarray eq 'list') ? 1 : 0))) . ')')
            }, 'circumfix:<( )>', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                ('p5context(' . '[' . join(', ', map($_->emit_javascript2($level, $wantarray), @{$self->{'arguments'}})) . '], ' . ((($wantarray eq 'runtime') ? 'p5want' : (($wantarray eq 'list') ? 1 : 0))) . ')')
            }, 'infix:<=>', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                my $parameters = $self->{'arguments'}->[0];
                my $arguments = $self->{'arguments'}->[1];
                if (($parameters->isa('Perlito5::AST::Apply') && (((($parameters->code() eq 'my') || ($parameters->code() eq 'local')) || ($parameters->code() eq 'circumfix:<( )>'))))) {
                    my $tmp = ('tmp' . Perlito5::Javascript2::get_label());
                    my $tmp2 = ('tmp' . Perlito5::Javascript2::get_label());
                    return ('(function () {' . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . 'var ' . $tmp . ' = ' . Perlito5::Javascript2::to_list([$arguments], ($level + 1)) . ';' . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . 'var ' . $tmp2 . ' = ' . $tmp . '.slice(0);' . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . join((';' . chr(10) . Perlito5::Javascript2::tab(($level + 1))), (map($_->emit_javascript2_set_list(($level + 1), $tmp), @{$parameters->arguments()})), ('return ' . $tmp2)) . chr(10) . Perlito5::Javascript2::tab($level) . '})()')
                };
                return $parameters->emit_javascript2_set($arguments, ($level + 1), $wantarray)
            }, 'break', sub {
                my $self = shift();
                my $level = shift();
                $Perlito5::THROW = 1;
                'throw(new p5_error("break", ""))'
            }, 'next', sub {
                my $self = shift();
                my $level = shift();
                $Perlito5::THROW = 1;
                my $label = ($self->{'arguments'}->[0]->{'code'} || '');
                ('throw(new p5_error("next", "' . $label . '"))')
            }, 'last', sub {
                my $self = shift();
                my $level = shift();
                $Perlito5::THROW = 1;
                my $label = ($self->{'arguments'}->[0]->{'code'} || '');
                ('throw(new p5_error("last", "' . $label . '"))')
            }, 'redo', sub {
                my $self = shift();
                my $level = shift();
                $Perlito5::THROW = 1;
                my $label = ($self->{'arguments'}->[0]->{'code'} || '');
                ('throw(new p5_error("redo", "' . $label . '"))')
            }, 'return', sub {
                my $self = shift();
                my $level = shift();
                $Perlito5::THROW = 1;
                ('throw(' . Perlito5::Javascript2::to_runtime_context($self->{'arguments'}, $level) . ')')
            }, 'goto', sub {
                my $self = $_[0];
                $Perlito5::THROW = 1;
                ('throw((' . $self->{'arguments'}->[0]->emit_javascript2() . ')([List__, p5want]))')
            }, 'do', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                my $tmp_strict = $Perlito5::STRICT;
                $Perlito5::STRICT = 0;
                my $ast = Perlito5::AST::Apply->new('code', 'eval', 'namespace', '', 'arguments', [Perlito5::AST::Apply->new('code', 'slurp', 'namespace', 'Perlito5::IO', 'arguments', $self->{'arguments'})]);
                my $js = $ast->emit_javascript2($level);
                $Perlito5::STRICT = $tmp_strict;
                return $js
            }, 'eval', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                $Perlito5::THROW = 1;
                my $arg = $self->{'arguments'}->[0];
                my $eval;
                if ($arg->isa('Perlito5::AST::Do')) {
                    $eval = $arg->emit_javascript2(($level + 1), $wantarray)
                }
                else {
                    my $var_env_perl5 = Perlito5::Dumper::Dumper($Perlito5::VAR);
                    my $m = Perlito5::Grammar::Expression->term_square($var_env_perl5, 0);
                    $m = Perlito5::Grammar::Expression::expand_list(Perlito5::Match::flat($m)->[2]);
                    my $var_env_js = ('(new p5ArrayRef(' . Perlito5::Javascript2::to_list($m) . '))');
                    $eval = ('eval(p5pkg["Perlito5::Javascript2::Runtime"].perl5_to_js([' . Perlito5::Javascript2::to_str($arg) . ', ' . '"' . $Perlito5::PKG_NAME . '", ' . $var_env_js . ', ' . '"' . $wantarray . '"' . ']))')
                };
                ('(function (p5want) {' . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . 'var r;' . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . 'p5pkg["main"]["v_@"] = "";' . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . 'p5pkg["Perlito5"]["v_STRICT"] = ' . $Perlito5::STRICT . ';' . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . 'try {' . chr(10) . Perlito5::Javascript2::tab(($level + 2)) . 'r = ' . $eval . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . '}' . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . 'catch(err) {' . chr(10) . Perlito5::Javascript2::tab(($level + 2)) . 'if ( err instanceof p5_error || err instanceof Error ) {' . chr(10) . Perlito5::Javascript2::tab(($level + 3)) . 'p5pkg["main"]["v_@"] = err;' . chr(10) . Perlito5::Javascript2::tab(($level + 3)) . 'try {' . chr(10) . Perlito5::Javascript2::tab(($level + 4)) . 'p5pkg["main"]["v_@"] = p5pkg["main"]["v_@"] + "' . chr(92) . 'n" + err.stack;' . chr(10) . Perlito5::Javascript2::tab(($level + 3)) . '}' . chr(10) . Perlito5::Javascript2::tab(($level + 3)) . 'catch(err) { }' . chr(10) . Perlito5::Javascript2::tab(($level + 2)) . '}' . chr(10) . Perlito5::Javascript2::tab(($level + 2)) . 'else {' . chr(10) . Perlito5::Javascript2::tab(($level + 3)) . 'return(err);' . chr(10) . Perlito5::Javascript2::tab(($level + 2)) . '}' . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . '}' . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . 'return r;' . chr(10) . Perlito5::Javascript2::tab(($level + 0)) . '})(' . ((($wantarray eq 'list') ? '1' : (($wantarray eq 'scalar') ? '0' : (($wantarray eq 'void') ? 'null' : 'p5want')))) . ')')
            }, 'undef', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                if (($self->{'arguments'} && @{$self->{'arguments'}})) {
                    return ('(' . $self->{'arguments'}->[0]->emit_javascript2() . ' = null)')
                };
                return 'null'
            }, 'defined', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                my $arg = $self->{'arguments'}->[0];
                my $invocant;
                if (((ref($arg) eq 'Perlito5::AST::Apply') && ($arg->{'code'} eq 'prefix:<&>'))) {
                    my $arg2 = $arg->{'arguments'}->[0];
                    $invocant = ('p5code_lookup_by_name("' . $Perlito5::PKG_NAME . '", ' . $arg2->emit_javascript2($level) . ')')
                }
                else {
                    if (((ref($arg) eq 'Perlito5::AST::Var') && ($arg->{'sigil'} eq '&'))) {
                        $invocant = ('p5pkg["' . (($arg->{'namespace'} || $Perlito5::PKG_NAME)) . '"]["' . $arg->{'name'} . '"]')
                    }
                    else {
                        $invocant = $arg->emit_javascript2($level, 'scalar')
                    }
                };
                ('(' . $invocant . ' != null)')
            }, 'shift', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                if (($self->{'arguments'} && @{$self->{'arguments'}})) {
                    return ($self->{'arguments'}->[0]->emit_javascript2($level) . '.shift()')
                };
                return 'List__.shift()'
            }, 'pop', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                if (($self->{'arguments'} && @{$self->{'arguments'}})) {
                    return ($self->{'arguments'}->[0]->emit_javascript2($level) . '.pop()')
                };
                return 'List__.pop()'
            }, 'unshift', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                my @arguments = @{$self->{'arguments'}};
                my $v = shift(@arguments);
                return ($v->emit_javascript2($level) . '.p5unshift(' . Perlito5::Javascript2::to_list(\@arguments) . ')')
            }, 'push', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                my @arguments = @{$self->{'arguments'}};
                my $v = shift(@arguments);
                return ($v->emit_javascript2($level) . '.p5push(' . Perlito5::Javascript2::to_list(\@arguments) . ')')
            }, 'tie', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                my @arguments = @{$self->{'arguments'}};
                my $v = shift(@arguments);
                my $meth;
                if (($v->isa('Perlito5::AST::Var') && ($v->sigil() eq '%'))) {
                    $meth = 'hash'
                }
                else {
                    if (($v->isa('Perlito5::AST::Var') && ($v->sigil() eq '@'))) {
                        $meth = 'array'
                    }
                    else {
                        if (($v->isa('Perlito5::AST::Var') && ($v->sigil() eq '$'))) {
                            $meth = 'scalar'
                        }
                        else {
                            die('tie ' . chr(39), ref($v), chr(39) . ' not implemented')
                        }
                    }
                };
                return ('p5tie_' . $meth . '(' . $v->emit_javascript2($level) . ', ' . Perlito5::Javascript2::to_list(\@arguments) . ')')
            }, 'untie', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                my @arguments = @{$self->{'arguments'}};
                my $v = shift(@arguments);
                my $meth;
                if (($v->isa('Perlito5::AST::Var') && ($v->sigil() eq '%'))) {
                    $meth = 'hash'
                }
                else {
                    if (($v->isa('Perlito5::AST::Var') && ($v->sigil() eq '@'))) {
                        $meth = 'array'
                    }
                    else {
                        if (($v->isa('Perlito5::AST::Var') && ($v->sigil() eq '$'))) {
                            $meth = 'scalar'
                        }
                        else {
                            die('tie ' . chr(39), ref($v), chr(39) . ' not implemented')
                        }
                    }
                };
                return ('p5untie_' . $meth . '(' . $v->emit_javascript2($level) . ')')
            }, 'map', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                my @in = @{$self->{'arguments'}};
                my $fun;
                if ($self->{'special_arg'}) {
                    $fun = $self->{'special_arg'}
                }
                else {
                    $fun = shift(@in)
                };
                my $list = Perlito5::Javascript2::to_list(\@in);
                if ((ref($fun) eq 'Perlito5::AST::Lit::Block')) {
                    $fun = $fun->{'stmts'}
                }
                else {
                    $fun = [$fun]
                };
                ('p5map(' . Perlito5::Javascript2::pkg() . ', ' . 'function (p5want) {' . chr(10) . (Perlito5::Javascript2::LexicalBlock->new('block', $fun, 'needs_return', 1, 'top_level', 0))->emit_javascript2(($level + 1)) . chr(10) . Perlito5::Javascript2::tab($level) . '}, ' . $list . ')')
            }, 'grep', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                my @in = @{$self->{'arguments'}};
                my $fun;
                if ($self->{'special_arg'}) {
                    $fun = $self->{'special_arg'}
                }
                else {
                    $fun = shift(@in)
                };
                my $list = Perlito5::Javascript2::to_list(\@in);
                if ((ref($fun) eq 'Perlito5::AST::Lit::Block')) {
                    $fun = $fun->{'stmts'}
                }
                else {
                    $fun = [$fun]
                };
                ('p5grep(' . Perlito5::Javascript2::pkg() . ', ' . 'function (p5want) {' . chr(10) . (Perlito5::Javascript2::LexicalBlock->new('block', $fun, 'needs_return', 1, 'top_level', 0))->emit_javascript2(($level + 1)) . chr(10) . Perlito5::Javascript2::tab($level) . '}, ' . $list . ')')
            }, 'sort', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                my @in = @{$self->{'arguments'}};
                my $fun;
                my $list;
                if ($self->{'special_arg'}) {
                    $fun = $self->{'special_arg'}
                }
                else {
                    if ((ref($in[0]) eq 'Perlito5::AST::Lit::Block')) {
                        $fun = shift(@in)
                    }
                };
                if ((ref($fun) eq 'Perlito5::AST::Lit::Block')) {
                    $fun = ('function (p5want) {' . chr(10) . (Perlito5::Javascript2::LexicalBlock->new('block', $fun->{'stmts'}, 'needs_return', 1, 'top_level', 0))->emit_javascript2(($level + 1)) . chr(10) . Perlito5::Javascript2::tab($level) . '}')
                }
                else {
                    $fun = 'null'
                };
                $list = Perlito5::Javascript2::to_list(\@in);
                ('p5sort(' . Perlito5::Javascript2::pkg() . ', ' . $fun . ', ' . $list . ')')
            }, 'infix:<//>', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                ('p5defined_or' . '(' . $self->{'arguments'}->[0]->emit_javascript2($level, 'scalar') . ', ' . Perlito5::Javascript2::emit_function_javascript2($level, $wantarray, $self->{'arguments'}->[1]) . ')')
            }, 'exists', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                my $arg = $self->{'arguments'}->[0];
                if ($arg->isa('Perlito5::AST::Lookup')) {
                    my $v = $arg->obj();
                    if (($v->isa('Perlito5::AST::Var') && ($v->sigil() eq '$'))) {
                        $v = Perlito5::AST::Var->new('sigil', '%', 'namespace', $v->namespace(), 'name', $v->name());
                        return ('(' . $v->emit_javascript2() . ').hasOwnProperty(' . $arg->autoquote($arg->{'index_exp'})->emit_javascript2($level) . ')')
                    };
                    return ('(' . $v->emit_javascript2() . ')._hash_.hasOwnProperty(' . $arg->autoquote($arg->{'index_exp'})->emit_javascript2($level) . ')')
                };
                if ($arg->isa('Perlito5::AST::Call')) {
                    if (($arg->method() eq 'postcircumfix:<{ }>')) {
                        return ('(' . $arg->invocant()->emit_javascript2() . ')._hash_.hasOwnProperty(' . Perlito5::AST::Lookup->autoquote($arg->{'arguments'})->emit_javascript2($level) . ')')
                    }
                }
            });
    sub Perlito5::AST::Apply::emit_javascript2 {
        my $self = shift();
        my $level = shift();
        my $wantarray = shift();
        my $apply = $self->op_assign();
        if ($apply) {
            return $apply->emit_javascript2($level)
        };
        my $code = $self->{'code'};
        if ((ref($code) ne '')) {
            my @args = ();
            push(@args, $_->emit_javascript2()) for @{$self->{'arguments'}};
            return ('(' . $self->{'code'}->emit_javascript2($level) . ')(' . join(',', @args) . ')')
        };
        return $emit_js{$code}->($self, $level, $wantarray) if exists($emit_js{$code});
        if (exists($Perlito5::Javascript2::op_infix_js_str{$code})) {
            return ('(' . join($Perlito5::Javascript2::op_infix_js_str{$code}, map {
                            Perlito5::Javascript2::to_str($_)
                        } @{$self->{'arguments'}}) . ')')
        };
        if (exists($Perlito5::Javascript2::op_infix_js_num{$code})) {
            return ('(' . join($Perlito5::Javascript2::op_infix_js_num{$code}, map {
                            Perlito5::Javascript2::to_num($_)
                        } @{$self->{'arguments'}}) . ')')
        };
        if (exists($Perlito5::Javascript2::op_prefix_js_str{$code})) {
            return ($Perlito5::Javascript2::op_prefix_js_str{$code} . '(' . Perlito5::Javascript2::to_str($self->{'arguments'}->[0]) . ')')
        };
        if ((($code eq 'infix:<&&>') || ($code eq 'infix:<and>'))) {
            return ('p5and' . '(' . $self->{'arguments'}->[0]->emit_javascript2($level, 'scalar') . ', ' . Perlito5::Javascript2::emit_function_javascript2($level, $wantarray, $self->{'arguments'}->[1]) . ')')
        };
        if ((($code eq 'infix:<||>') || ($code eq 'infix:<or>'))) {
            return ('p5or' . '(' . $self->{'arguments'}->[0]->emit_javascript2($level, 'scalar') . ', ' . Perlito5::Javascript2::emit_function_javascript2($level, $wantarray, $self->{'arguments'}->[1]) . ')')
        };
        if ($self->{'namespace'}) {
            if ((($self->{'namespace'} eq 'JS') && ($code eq 'inline'))) {
                if ($self->{'arguments'}->[0]->isa('Perlito5::AST::Val::Buf')) {
                    return $self->{'arguments'}->[0]->{'buf'}
                }
                else {
                    die('JS::inline needs a string constant')
                }
            };
            $code = ('p5pkg["' . $self->{'namespace'} . '"].' . $code)
        }
        else {
            $code = (Perlito5::Javascript2::pkg() . '.' . $code)
        };
        my $sig;
        my $may_need_autoload;
        {
            my $name = $self->{'code'};
            my $namespace = ($self->{'namespace'} || $Perlito5::PKG_NAME);
            my $effective_name = ($namespace . '::' . $self->{'code'});
            if (exists($Perlito5::PROTO->{$effective_name})) {
                $sig = $Perlito5::PROTO->{$effective_name}
            }
            else {
                if ((((!($self->{'namespace'}) || ($namespace eq 'CORE'))) && exists($Perlito5::CORE_PROTO->{('CORE::' . $name)}))) {
                    $effective_name = ('CORE::' . $name);
                    $sig = $Perlito5::CORE_PROTO->{$effective_name}
                }
                else {
                    if ($self->{'bareword'}) {
                        if ($Perlito5::STRICT) {
                            die(('Bareword "' . $name . '" not allowed while "strict subs" in use'))
                        };
                        return Perlito5::Javascript2::escape_string(((($self->{'namespace'} ? ($self->{'namespace'} . '::') : '')) . $name))
                    };
                    $may_need_autoload = 1
                }
            }
        };
        if (((((($self->{'code'} eq 'say') || ($self->{'code'} eq 'print'))) && !($self->{'namespace'})) && $self->{'bareword'})) {
            $self->{'arguments'} = [Perlito5::AST::Var->new('sigil', '$', 'namespace', '', 'name', '_')]
        };
        if ($sig) {
            my @out = ();
            my @in = @{($self->{'arguments'} || [])};
            my $optional = 0;
            for ( ; length($sig); {

                } ) {
                my $c = substr($sig, 0, 1);
                if (($c eq ';')) {
                    $optional = 1
                }
                else {
                    if ((($c eq '$') || ($c eq '_'))) {
                        push(@out, shift(@in)->emit_javascript2($level, 'scalar')) if (@in || !($optional))
                    }
                    else {
                        if (($c eq '@')) {
                            push(@out, Perlito5::Javascript2::to_list(\@in)) if (@in || !($optional));
                            @in = ()
                        }
                        else {
                            if (($c eq '*')) {
                                if ((@in || !($optional))) {
                                    my $arg = shift(@in);
                                    if ($arg->{'bareword'}) {
                                        push(@out, ('p5pkg["' . (($arg->{'namespace'} || $Perlito5::PKG_NAME)) . '"]["f_' . $arg->{'code'} . '"]'))
                                    }
                                    else {
                                        push(@out, $arg->emit_javascript2($level, 'scalar'))
                                    }
                                }
                            }
                            else {
                                if (($c eq chr(92))) {
                                    if ((substr($sig, 0, 2) eq chr(92) . '$')) {
                                        $sig = substr($sig, 1);
                                        push(@out, shift(@in)->emit_javascript2($level, 'scalar')) if (@in || !($optional))
                                    }
                                    else {
                                        if (((substr($sig, 0, 2) eq chr(92) . '@') || (substr($sig, 0, 2) eq chr(92) . '%'))) {
                                            $sig = substr($sig, 1);
                                            push(@out, shift(@in)->emit_javascript2($level, 'list')) if (@in || !($optional))
                                        }
                                        else {
                                            if ((substr($sig, 0, 5) eq chr(92) . '[@%]')) {
                                                $sig = substr($sig, 4);
                                                push(@out, shift(@in)->emit_javascript2($level, 'list')) if (@in || !($optional))
                                            }
                                            else {
                                                if ((substr($sig, 0, 6) eq chr(92) . '[$@%]')) {
                                                    $sig = substr($sig, 5);
                                                    push(@out, shift(@in)->emit_javascript2($level, 'list')) if (@in || !($optional))
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                };
                $sig = substr($sig, 1)
            };
            return ($code . '([' . join(', ', @out) . '], ' . ((($wantarray eq 'list') ? '1' : (($wantarray eq 'scalar') ? '0' : (($wantarray eq 'void') ? 'null' : 'p5want')))) . ')')
        };
        my @args = ();
        my $arg_list = Perlito5::Javascript2::to_list_preprocess($self->{'arguments'});
        push(@args, $_->emit_javascript2($level)) for @{$arg_list};
        my $arg_code = (($self->{'code'} eq 'scalar') ? ('[' . join(', ', @args) . ']') : Perlito5::Javascript2::to_list($arg_list));
        if ($may_need_autoload) {
            my $name = $self->{'code'};
            my $namespace = ($self->{'namespace'} || $Perlito5::PKG_NAME);
            return ('p5call_sub(' . '"' . $namespace . '", ' . '"' . $name . '", ' . $arg_code . ', ' . ((($wantarray eq 'list') ? '1' : (($wantarray eq 'scalar') ? '0' : (($wantarray eq 'void') ? 'null' : 'p5want')))) . ')')
        };
        ($code . '(' . $arg_code . ', ' . ((($wantarray eq 'list') ? '1' : (($wantarray eq 'scalar') ? '0' : (($wantarray eq 'void') ? 'null' : 'p5want')))) . ')')
    };
    sub Perlito5::AST::Apply::emit_javascript2_set_list {
        my $self = shift();
        my $level = shift();
        my $list = shift();
        if (($self->code() eq 'undef')) {
            return ($list . '.shift()')
        };
        die('not implemented: assign to ', $self->code())
    }
};
package Perlito5::AST::If;
{
    sub Perlito5::AST::If::emit_javascript2 {
        my $self = shift();
        my $level = shift();
        my $wantarray = shift();
        my $body = ((ref($self->{'body'}) ne 'Perlito5::AST::Lit::Block') ? $self->{'body'} : ((!(@{$self->{'body'}->stmts()})) ? undef() : (($wantarray eq 'runtime') ? Perlito5::Javascript2::LexicalBlock->new('block', $self->{'body'}->stmts(), 'needs_return', 1) : Perlito5::Javascript2::LexicalBlock->new('block', $self->{'body'}->stmts(), 'needs_return', 0, 'create_context', 1))));
        my $otherwise = ((ref($self->{'otherwise'}) ne 'Perlito5::AST::Lit::Block') ? $self->{'otherwise'} : ((!(@{$self->{'otherwise'}->stmts()})) ? undef() : (($wantarray eq 'runtime') ? Perlito5::Javascript2::LexicalBlock->new('block', $self->{'otherwise'}->stmts(), 'needs_return', 1) : Perlito5::Javascript2::LexicalBlock->new('block', $self->{'otherwise'}->stmts(), 'needs_return', 0, 'create_context', 1))));
        my $s = ('if ( ' . Perlito5::Javascript2::to_bool($self->{'cond'}, ($level + 1)) . ' ) {');
        if ($body) {
            $s = ($s . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . $body->emit_javascript2(($level + 1), $wantarray) . chr(10) . Perlito5::Javascript2::tab($level) . '}')
        }
        else {
            $s = ($s . '}')
        };
        if ($otherwise) {
            if (((@{$otherwise->{'block'}} == 1) && (ref($otherwise->{'block'}->[0]) eq 'Perlito5::AST::If'))) {
                return ($s . chr(10) . Perlito5::Javascript2::tab($level) . 'else ' . $otherwise->{'block'}->[0]->emit_javascript2($level, $wantarray))
            };
            $s = ($s . chr(10) . Perlito5::Javascript2::tab($level) . 'else {' . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . $otherwise->emit_javascript2(($level + 1), $wantarray) . chr(10) . Perlito5::Javascript2::tab($level) . '}')
        };
        return $s
    }
};
package Perlito5::AST::When;
{
    sub Perlito5::AST::When::emit_javascript2 {
        my $self = shift();
        my $level = shift();
        my $cond = $self->{'cond'};
        my $body = Perlito5::Javascript2::LexicalBlock->new('block', $self->{'body'}->stmts(), 'needs_return', 0, 'create_context', 1);
        my $expr = Perlito5::AST::Apply->new('code', 'infix:<==>', 'arguments', [Perlito5::AST::Var->new('sigil', '$', 'namespace', '', 'name', '_'), $cond]);
        my $label = '';
        my $s = ('if ( ' . Perlito5::Javascript2::to_bool($expr, ($level + 1)) . ' ) {' . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . $body->emit_javascript2(($level + 1)) . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . 'throw(new p5_error("next", "' . $label . '"))' . Perlito5::Javascript2::tab($level) . '}');
        return $s
    }
};
package Perlito5::AST::While;
{
    sub Perlito5::AST::While::emit_javascript2 {
        my $self = shift();
        my $level = shift();
        my $cond = $self->{'cond'};
        my $body = ((ref($self->{'body'}) ne 'Perlito5::AST::Lit::Block') ? [$self->{'body'}] : $self->{'body'}->{'stmts'});
        return ('p5while(' . 'function () {' . chr(10) . Perlito5::Javascript2::tab(($level + 2)) . (Perlito5::Javascript2::LexicalBlock->new('block', $body, 'needs_return', 0, 'top_level', 0))->emit_javascript2(($level + 2)) . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . '}, ' . Perlito5::Javascript2::emit_function_javascript2($level, 0, $cond) . ', ' . Perlito5::AST::Lit::Block::emit_javascript2_continue($self, $level) . ', ' . '"' . (($self->{'label'} || '')) . '"' . ')')
    }
};
package Perlito5::AST::For;
{
    sub Perlito5::AST::For::emit_javascript2 {
        my $self = shift();
        my $level = shift();
        my $body = ((ref($self->{'body'}) ne 'Perlito5::AST::Lit::Block') ? [$self->{'body'}] : $self->{'body'}->{'stmts'});
        if ((ref($self->{'cond'}) eq 'ARRAY')) {
            return ('for ( ' . (($self->{'cond'}->[0] ? ($self->{'cond'}->[0]->emit_javascript2(($level + 1)) . '; ') : '; ')) . (($self->{'cond'}->[1] ? ($self->{'cond'}->[1]->emit_javascript2(($level + 1)) . '; ') : '; ')) . (($self->{'cond'}->[2] ? ($self->{'cond'}->[2]->emit_javascript2(($level + 1)) . ' ') : ' ')) . ') {' . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . (Perlito5::Javascript2::LexicalBlock->new('block', $body, 'needs_return', 0, 'top_level', 0))->emit_javascript2(($level + 1)) . chr(10) . Perlito5::Javascript2::tab($level) . '}')
        };
        my $cond = Perlito5::Javascript2::to_list([$self->{'cond'}], ($level + 1));
        my $topic;
        $topic = $self->{'body'}->{'sig'} if (ref($self->{'body'}) ne 'ARRAY');
        if (!($topic)) {
            $topic = Perlito5::AST::Decl->new('decl', 'our', 'type', '', 'var', Perlito5::AST::Var->new('name', '_', 'namespace', '', 'sigil', '$'))
        };
        my $decl = '';
        my $v = $topic;
        if ($v->{'decl'}) {
            $decl = $v->{'decl'};
            $v = $v->{'var'}
        };
        my $namespace = ($v->{'namespace'} || $Perlito5::PKG_NAME);
        my $perl5_name = $v->perl5_name_javascript2();
        my $pre_declaration = $v->perl5_get_decl_javascript2($perl5_name);
        if ($pre_declaration) {
            $decl = $pre_declaration->{'decl'}
        };
        if ((!($decl) && !($v->{'namespace'}))) {
            if ($Perlito5::STRICT) {
                die(('Global symbol "' . $perl5_name . '" requires explicit package name'))
            };
            $decl = 'our'
        };
        unshift(@{$Perlito5::VAR}, {});
        $Perlito5::VAR->[0]->{$perl5_name} = {'decl', $decl, 'namespace', $namespace};
        my $s;
        if ((($decl eq 'my') || ($decl eq 'state'))) {
            my $sig = $v->emit_javascript2(($level + 1));
            $s = ('p5for_lex(' . ('function (' . $sig . ') {' . chr(10)) . Perlito5::Javascript2::tab(($level + 2)) . (Perlito5::Javascript2::LexicalBlock->new('block', $body, 'needs_return', 0, 'top_level', 0))->emit_javascript2(($level + 2)) . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . '}, ' . $cond . ', ' . Perlito5::AST::Lit::Block::emit_javascript2_continue($self, $level) . ', ' . '"' . (($self->{'label'} || '')) . '"' . ')')
        }
        else {
            $s = ('p5for(' . 'p5make_package("' . $namespace . '"), ' . '"v_' . $v->{'name'} . '", ' . 'function () {' . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . (Perlito5::Javascript2::LexicalBlock->new('block', $body, 'needs_return', 0, 'top_level', 0))->emit_javascript2(($level + 2)) . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . '}, ' . $cond . ', ' . Perlito5::AST::Lit::Block::emit_javascript2_continue($self, $level) . ', ' . '"' . (($self->{'label'} || '')) . '"' . ')')
        };
        shift(@{$Perlito5::VAR});
        return $s
    }
};
package Perlito5::AST::Sub;
{
    sub Perlito5::AST::Sub::emit_javascript2 {
        my $self = shift();
        my $level = shift();
        my $s = ('function (List__, p5want) {' . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . (Perlito5::Javascript2::LexicalBlock->new('block', $self->{'block'}, 'needs_return', 1, 'top_level', 1))->emit_javascript2(($level + 1)) . chr(10) . Perlito5::Javascript2::tab($level) . '}');
        if ($self->{'name'}) {
            return ('p5typeglob_set("' . $self->{'namespace'} . '", "' . $self->{'name'} . '", ' . $s . ')')
        }
        else {
            return $s
        }
    }
};
package Perlito5::AST::Do;
{
    sub Perlito5::AST::Do::emit_javascript2 {
        my $self = shift();
        my $level = shift();
        my $wantarray = shift();
        my $block = $self->simplify()->block();
        return ('(function () {' . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . (Perlito5::Javascript2::LexicalBlock->new('block', $block, 'needs_return', 1))->emit_javascript2(($level + 1), $wantarray) . chr(10) . Perlito5::Javascript2::tab($level) . '})()')
    }
};
package Perlito5::AST::Use;
{
    sub Perlito5::AST::Use::emit_javascript2 {
        my $self = shift();
        my $level = shift();
        my $wantarray = shift();
        Perlito5::Grammar::Use::emit_time_eval($self);
        if (($wantarray eq 'runtime')) {
            return 'p5context([], p5want)'
        }
        else {
            return ('// ' . $self->{'code'} . ' ' . $self->{'mod'} . chr(10))
        }
    }
};

;

# use Perlito5::Javascript2::Emitter
;
package main;
undef();
package Perlito5::Javascript2::Runtime;
sub Perlito5::Javascript2::Runtime::perl5_to_js {
    my($source, $namespace, $var_env_js) = @_;
    my $strict_old = $Perlito5::STRICT;
    local $Perlito5::VAR = $var_env_js;
    local $Perlito5::PKG_NAME = $namespace;
    my $match = Perlito5::Grammar->exp_stmts($source, 0);
    if ((!($match) || ($match->{'to'} != length($source)))) {
        die('Syntax error in eval near pos ', $match->{'to'})
    };
    my $ast = Perlito5::AST::Do->new('block', Perlito5::AST::Lit::Block->new('stmts', $match->{'capture'}));
    my $js_code = $ast->emit_javascript2(0);
    $Perlito5::STRICT = $strict_old;
    return $js_code
};
sub Perlito5::Javascript2::Runtime::emit_javascript2 {
    return (('//' . chr(10) . '// lib/Perlito5/Javascript2/Runtime.js' . chr(10) . '//' . chr(10) . '// Runtime for "Perlito" Perl5-in-Javascript2' . chr(10) . '//' . chr(10) . '// AUTHORS' . chr(10) . '//' . chr(10) . '// Flavio Soibelmann Glock  fglock@gmail.com' . chr(10) . '//' . chr(10) . '// COPYRIGHT' . chr(10) . '//' . chr(10) . '// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.' . chr(10) . '//' . chr(10) . '// This program is free software; you can redistribute it and/or modify it' . chr(10) . '// under the same terms as Perl itself.' . chr(10) . '//' . chr(10) . '// See http://www.perl.com/perl/misc/Artistic.html' . chr(10) . chr(10) . 'var isNode = typeof require != "undefined";' . chr(10) . chr(10) . 'if (typeof p5pkg !== "object") {' . chr(10) . '    p5pkg = {};' . chr(10) . '    p5LOCAL = [];' . chr(10) . chr(10) . '    var universal = function () {};' . chr(10) . '    p5pkg.UNIVERSAL = new universal();' . chr(10) . '    p5pkg.UNIVERSAL._ref_ = "UNIVERSAL";' . chr(10) . '    p5pkg.UNIVERSAL.isa = function (List__) {' . chr(10) . '        // TODO - use @ISA' . chr(10) . '        return List__[0]._class_._ref_ == List__[1]' . chr(10) . '    };' . chr(10) . '    p5pkg.UNIVERSAL.can = function (List__) {' . chr(10) . '        var o = List__[0];' . chr(10) . '        var s = List__[1];' . chr(10) . '        if ( s.indexOf("::") == -1 ) {' . chr(10) . '            return p5method_lookup(s, o._class_._ref__, {})' . chr(10) . '        }' . chr(10) . '        var c = s.split("::");' . chr(10) . '        s = c.pop(); ' . chr(10) . '        return p5method_lookup(s, c.join("::"), {});' . chr(10) . '    };' . chr(10) . '    p5pkg.UNIVERSAL.DOES = p5pkg.UNIVERSAL.can;' . chr(10) . chr(10) . '    var core = function () {};' . chr(10) . '    p5pkg["CORE"] = new core();' . chr(10) . '    p5pkg["CORE"]._ref_ = "CORE";' . chr(10) . chr(10) . '    var core_global = function () {};' . chr(10) . '    core_global.prototype = p5pkg.CORE;' . chr(10) . '    p5pkg["CORE::GLOBAL"] = new core_global();' . chr(10) . '    p5pkg["CORE::GLOBAL"]._ref_ = "CORE::GLOBAL";' . chr(10) . chr(10) . '    p5_error = function (type, v) {' . chr(10) . '        this.type = type;' . chr(10) . '        this.v = v;' . chr(10) . '        this.toString = function(){' . chr(10) . '            if (this.type == ' . chr(39) . 'break' . chr(39) . ') {' . chr(10) . '                return ' . chr(39) . 'Can' . chr(92) . chr(39) . 't "break" outside a given block' . chr(39) . chr(10) . '            }' . chr(10) . '            if (this.type == ' . chr(39) . 'next' . chr(39) . ' || this.type == ' . chr(39) . 'last' . chr(39) . ' || this.type == ' . chr(39) . 'redo' . chr(39) . ') {' . chr(10) . '                if (this.v == "") { return ' . chr(39) . 'Can' . chr(92) . chr(39) . 't "' . chr(39) . ' + this.type + ' . chr(39) . '" outside a loop block' . chr(39) . ' }' . chr(10) . '                return ' . chr(39) . 'Label not found for "' . chr(39) . ' + this.type + ' . chr(39) . ' ' . chr(39) . ' + this.v + ' . chr(39) . '"' . chr(39) . ';' . chr(10) . '            }' . chr(10) . '            return this.v;' . chr(10) . '        };' . chr(10) . '    };' . chr(10) . '    p5_error.prototype = Error.prototype;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5make_package(pkg_name) {' . chr(10) . '    if (!p5pkg.hasOwnProperty(pkg_name)) {' . chr(10) . '        var tmp = function () {};' . chr(10) . '        tmp.prototype = p5pkg["CORE::GLOBAL"];' . chr(10) . '        p5pkg[pkg_name] = new tmp();' . chr(10) . '        p5pkg[pkg_name]._ref_ = pkg_name;' . chr(10) . '        p5pkg[pkg_name]._class_ = p5pkg[pkg_name];  // XXX memory leak' . chr(10) . '        p5pkg[pkg_name]._is_package_ = 1;' . chr(10) . chr(10) . '        // TODO - add the other package global variables' . chr(10) . '        p5pkg[pkg_name]["List_ISA"] = [];' . chr(10) . '        p5pkg[pkg_name]["v_a"] = null;' . chr(10) . '        p5pkg[pkg_name]["v_b"] = null;' . chr(10) . '        p5pkg[pkg_name]["v__"] = null;' . chr(10) . '        p5pkg[pkg_name]["v_AUTOLOAD"] = null;' . chr(10) . '    }' . chr(10) . '    return p5pkg[pkg_name];' . chr(10) . '}' . chr(10) . chr(10) . 'function p5code_lookup_by_name(package_name, sub_name) {' . chr(10) . '    // sub_name can be a function already' . chr(10) . '    if (typeof sub_name === "function") {' . chr(10) . '        return sub_name;' . chr(10) . '    }' . chr(10) . '    // sub_name can have an optional namespace' . chr(10) . '    var parts = sub_name.split(/::/);' . chr(10) . '    if (parts.length > 1) {' . chr(10) . '        sub_name = parts.pop();' . chr(10) . '        package_name = parts.join("::");' . chr(10) . '    }' . chr(10) . '    if (p5pkg.hasOwnProperty(package_name)) {' . chr(10) . '        var c = p5pkg[package_name];' . chr(10) . '        if ( c.hasOwnProperty(sub_name) ) {' . chr(10) . '            return c[sub_name]' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return null;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5get_class_for_method(method, class_name, seen) {' . chr(10) . '    // default mro' . chr(10) . '    // TODO - cache the methods that were already looked up' . chr(10) . '    if ( p5pkg[class_name].hasOwnProperty(method) ) {' . chr(10) . '        return class_name' . chr(10) . '    }' . chr(10) . '    var isa = p5pkg[class_name].List_ISA;' . chr(10) . '    if (isa) {' . chr(10) . '        for (var i = 0; i < isa.length; i++) {' . chr(10) . '            if (!seen[isa[i]]) {' . chr(10) . '                var m = p5get_class_for_method(method, isa[i], seen);' . chr(10) . '                if (m) {' . chr(10) . '                    return m ' . chr(10) . '                }' . chr(10) . '                seen[isa[i]]++;' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '}' . chr(10) . chr(10) . 'function p5method_lookup(method, class_name, seen) {' . chr(10) . '    var c = p5get_class_for_method(method, class_name, seen);' . chr(10) . '    if (c) {' . chr(10) . '        return p5pkg[c][method]' . chr(10) . '    }' . chr(10) . '    if ( p5pkg.UNIVERSAL.hasOwnProperty(method) ) {' . chr(10) . '        return p5pkg.UNIVERSAL[method]' . chr(10) . '    }' . chr(10) . '}' . chr(10) . chr(10) . 'function p5call(invocant, method, list, p5want) {' . chr(10) . chr(10) . '    if (typeof invocant === "string") {' . chr(10) . '        list.unshift(invocant);' . chr(10) . '        invocant = p5make_package(invocant);' . chr(10) . '    }' . chr(10) . '    else if ( invocant.hasOwnProperty("_is_package_") ) {' . chr(10) . '        list.unshift(invocant._ref_);   // invocant is a "package" object' . chr(10) . '    }' . chr(10) . '    else {' . chr(10) . '        list.unshift(invocant);' . chr(10) . '    }' . chr(10) . chr(10) . '    if ( invocant.hasOwnProperty("_class_") ) {' . chr(10) . chr(10) . '        if ( invocant._class_.hasOwnProperty(method) ) {' . chr(10) . '            return invocant._class_[method](list, p5want)' . chr(10) . '        }' . chr(10) . '        var m = p5method_lookup(method, invocant._class_._ref_, {});' . chr(10) . '        if (m) {' . chr(10) . '            return m(list, p5want)' . chr(10) . '        }' . chr(10) . chr(10) . '        // method can have an optional namespace' . chr(10) . '        var pkg_name = method.split(/::/);' . chr(10) . '        if (pkg_name.length > 1) {' . chr(10) . '            var name = pkg_name.pop();' . chr(10) . '            pkg_name = pkg_name.join("::");' . chr(10) . '            m = p5method_lookup(name, pkg_name, {});' . chr(10) . '            if (m) {' . chr(10) . '                return m(list, p5want)' . chr(10) . '            }' . chr(10) . '            p5pkg.CORE.die(["method not found: ", name, " in class ", pkg_name]);' . chr(10) . '        }' . chr(10) . chr(10) . '        pkg_name = p5get_class_for_method(' . chr(39) . 'AUTOLOAD' . chr(39) . ', invocant._class_._ref_, {}) || p5get_class_for_method(' . chr(39) . 'AUTOLOAD' . chr(39) . ', "UNIVERSAL", {});' . chr(10) . '        if (pkg_name) {' . chr(10) . '            p5pkg[pkg_name]["v_AUTOLOAD"] = invocant._class_._ref_ + "::" + method;' . chr(10) . '            return p5pkg[pkg_name]["AUTOLOAD"](list, p5want);' . chr(10) . '        }' . chr(10) . chr(10) . '        p5pkg.CORE.die(["method not found: ", method, " in class ", invocant._class_._ref_]);' . chr(10) . chr(10) . '    }' . chr(10) . chr(10) . '    p5pkg.CORE.die(["Can' . chr(39) . 't call method ", method, " on unblessed reference"]);' . chr(10) . chr(10) . '}' . chr(10) . chr(10) . 'function p5call_sub(namespace, name, list, p5want) {' . chr(10) . '    if(p5pkg[namespace].hasOwnProperty(name)) {' . chr(10) . '        return p5pkg[namespace][name](list, p5want)' . chr(10) . '    }' . chr(10) . '    if(p5pkg[namespace].hasOwnProperty("AUTOLOAD")) {' . chr(10) . '        p5pkg[namespace]["v_AUTOLOAD"] = namespace + "::" + name;' . chr(10) . '        return p5pkg[namespace]["AUTOLOAD"](list, p5want)' . chr(10) . '    }' . chr(10) . '    p5pkg.CORE.die(["Undefined subroutine &" + namespace + "::" + name]);' . chr(10) . '}' . chr(10) . chr(10) . 'function p5scalar_deref(v) {' . chr(10) . '    if (typeof v === "string") {' . chr(10) . '        var pkg_name = v.split(/::/);' . chr(10) . '        if (pkg_name.length > 1) {' . chr(10) . '            v = pkg_name.pop();' . chr(10) . '            pkg_name = pkg_name.join("::");' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            pkg_name = p5pkg["Perlito5"].v_PKG_NAME;' . chr(10) . '        }' . chr(10) . '        var c = v.charCodeAt(0);' . chr(10) . '        if (c < 27) {' . chr(10) . '            v = String.fromCharCode(c + 64) + v.substr(1);' . chr(10) . '            pkg_name = ' . chr(39) . 'main' . chr(39) . ';' . chr(10) . '        }' . chr(10) . '        return p5pkg[pkg_name]["v_"+v];' . chr(10) . '    }' . chr(10) . '    return v._scalar_;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5scalar_deref_set(v, n) {' . chr(10) . '    if (typeof v === "string") {' . chr(10) . '        var pkg_name = v.split(/::/);' . chr(10) . '        if (pkg_name.length > 1) {' . chr(10) . '            v = pkg_name.pop();' . chr(10) . '            pkg_name = pkg_name.join("::");' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            pkg_name = p5pkg["Perlito5"].v_PKG_NAME;' . chr(10) . '        }' . chr(10) . '        var c = v.charCodeAt(0);' . chr(10) . '        if (c < 27) {' . chr(10) . '            v = String.fromCharCode(c + 64) + v.substr(1);' . chr(10) . '            pkg_name = ' . chr(39) . 'main' . chr(39) . ';' . chr(10) . '        }' . chr(10) . '        p5pkg[pkg_name]["v_"+v] = n;' . chr(10) . '        return p5pkg[pkg_name]["v_"+v];' . chr(10) . '    }' . chr(10) . '    v._scalar_ = n;' . chr(10) . '    return v._scalar_;' . chr(10) . '}' . chr(10) . chr(10) . 'p5make_package("main");' . chr(10) . 'p5make_package("Perlito5");' . chr(10) . 'p5pkg["Perlito5"].v_PKG_NAME = "main";' . chr(10) . 'p5pkg["main"]["v_@"] = [];      // $@' . chr(10) . 'p5pkg["main"]["v_|"] = 0;       // $|' . chr(10) . 'p5pkg["main"]["v_/"] = "' . chr(92) . 'n";    // $/' . chr(10) . 'p5pkg["main"][' . chr(39) . 'v_"' . chr(39) . '] = " ";     // $"' . chr(10) . 'p5pkg["main"]["List_#"] = [];   // @#' . chr(10) . 'p5scalar_deref_set(String.fromCharCode(15), isNode ? "node.js" : "javascript2");  // $^O' . chr(10) . 'p5pkg["main"]["List_INC"] = [];' . chr(10) . 'p5pkg["main"]["Hash_INC"] = {};' . chr(10) . 'p5pkg["main"]["List_ARGV"] = [];' . chr(10) . 'p5pkg["main"]["Hash_ENV"] = {};' . chr(10) . 'if (isNode) {' . chr(10) . '    p5pkg["main"]["List_ARGV"] = process.argv.splice(2);' . chr(10) . chr(10) . '    p5pkg["main"]["Hash_ENV"] = {};' . chr(10) . '    for (e in process.env) p5pkg["main"]["Hash_ENV"][e] = process.env[e];' . chr(10) . chr(10) . '    p5pkg["main"]["v_$"]       = process.pid;' . chr(10) . '} else if (typeof arguments === "object") {' . chr(10) . '    p5pkg["main"]["List_ARGV"] = arguments;' . chr(10) . '}' . chr(10) . chr(10) . 'p5make_package("Perlito5::IO");' . chr(10) . 'p5make_package("Perlito5::Runtime");' . chr(10) . 'p5make_package("Perlito5::Grammar");' . chr(10) . chr(10) . 'var sigils = { ' . chr(39) . '@' . chr(39) . ' : ' . chr(39) . 'List_' . chr(39) . ', ' . chr(39) . '%' . chr(39) . ' : ' . chr(39) . 'Hash_' . chr(39) . ', ' . chr(39) . '$' . chr(39) . ' : ' . chr(39) . 'v_' . chr(39) . ' };' . chr(10) . chr(10) . 'function p5typeglob_set(namespace, name, obj) {' . chr(10) . '    p5make_package(namespace);' . chr(10) . '    if ( obj.hasOwnProperty("_ref_") ) {' . chr(10) . '        if ( obj._ref_ == "HASH" ) {' . chr(10) . '            p5pkg[namespace][sigils[' . chr(39) . '%' . chr(39) . '] + name] = obj._hash_;' . chr(10) . '        }' . chr(10) . '        else if ( obj._ref_ == "ARRAY" ) {' . chr(10) . '            p5pkg[namespace][sigils[' . chr(39) . '@' . chr(39) . '] + name] = obj._array_;' . chr(10) . '        }' . chr(10) . '        else if ( obj._ref_ == "SCALAR" ) {' . chr(10) . '            p5pkg[namespace][sigils[' . chr(39) . '$' . chr(39) . '] + name] = obj._scalar_;' . chr(10) . '        }' . chr(10) . '        else if ( obj._ref_ == "GLOB" ) {' . chr(10) . '            // TODO' . chr(10) . '            p5pkg[namespace][name] = obj;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    else {' . chr(10) . '        p5pkg[namespace][name] = obj;   // CODE' . chr(10) . '        // TODO - non-reference' . chr(10) . '    }' . chr(10) . '    return p5pkg[namespace][name];  // TODO - return GLOB' . chr(10) . '}' . chr(10) . chr(10) . 'function p5typeglob_deref_set(v, obj) {' . chr(10) . '    if (typeof v === "string") {' . chr(10) . '        var pkg_name = v.split(/::/);' . chr(10) . '        if (pkg_name.length > 1) {' . chr(10) . '            v = pkg_name.pop();' . chr(10) . '            pkg_name = pkg_name.join("::");' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            pkg_name = p5pkg["Perlito5"].v_PKG_NAME;' . chr(10) . '        }' . chr(10) . '        return p5typeglob_set(pkg_name, v, obj);' . chr(10) . '    }' . chr(10) . '    CORE.die(["TODO: can' . chr(39) . 't p5typeglob_deref_set()"]);' . chr(10) . '}' . chr(10) . chr(10) . 'function p5set_local(namespace, name, sigil) {' . chr(10) . '    var vname = sigils[sigil] + name;' . chr(10) . '    p5LOCAL.push([namespace, vname, namespace[vname]]);' . chr(10) . chr(10) . '    if (sigil == ' . chr(39) . '$' . chr(39) . ') {' . chr(10) . '        namespace[vname] = null;' . chr(10) . '    }' . chr(10) . '    else if (sigil == ' . chr(39) . '@' . chr(39) . ') {' . chr(10) . '        namespace[vname] = new p5Array([]);' . chr(10) . '    }' . chr(10) . '    else if (sigil == ' . chr(39) . '%' . chr(39) . ') {' . chr(10) . '        namespace[vname] = new p5Hash({});' . chr(10) . '    }' . chr(10) . '    return namespace[vname];' . chr(10) . '}' . chr(10) . chr(10) . 'function p5cleanup_local(idx, value) {' . chr(10) . '    while (p5LOCAL.length > idx) {' . chr(10) . '        l = p5LOCAL.pop();' . chr(10) . '        l[0][l[1]] = l[2];' . chr(10) . '    }' . chr(10) . '    return value;' . chr(10) . '}' . chr(10) . chr(10) . '//-------- Reference' . chr(10) . chr(10) . 'var p5id = Math.floor(Math.random() * 1000000000) + 1000000000;' . chr(10) . chr(10) . 'function p5HashRef(o) {' . chr(10) . '    this._hash_ = o;' . chr(10) . '    this._ref_ = "HASH";' . chr(10) . '    this.bool = function() { return 1 };' . chr(10) . '}' . chr(10) . chr(10) . 'function p5ArrayRef(o) {' . chr(10) . '    this._array_ = o;' . chr(10) . '    this._ref_ = "ARRAY";' . chr(10) . '    this.bool = function() { return 1 };' . chr(10) . '}' . chr(10) . chr(10) . 'function p5ScalarRef(o) {' . chr(10) . '    this._scalar_ = o;' . chr(10) . '    this._ref_ = "SCALAR";' . chr(10) . '    this.bool = function() { return 1 };' . chr(10) . '}' . chr(10) . chr(10) . 'function p5GlobRef(o) {' . chr(10) . '    this._scalar_ = o;' . chr(10) . '    this._ref_ = "GLOB";' . chr(10) . '    this.bool = function() { return 1 };' . chr(10) . '}' . chr(10) . chr(10) . '//-------- Hash ' . chr(10) . chr(10) . 'Object.defineProperty( Object.prototype, "p5hget", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) { return this[i] }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Object.prototype, "p5hset", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i, v) { this[i] = v; return this[i] }' . chr(10) . '});' . chr(10) . chr(10) . 'Object.defineProperty( Object.prototype, "p5incr", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        this[i] = p5incr_(this[i]);' . chr(10) . '        return this[i];' . chr(10) . '    }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Object.prototype, "p5postincr", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        var v = this[i];' . chr(10) . '        this[i] = p5incr_(this[i]);' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Object.prototype, "p5decr", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        this[i] = p5decr_(this[i]);' . chr(10) . '        return this[i];' . chr(10) . '    }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Object.prototype, "p5postdecr", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        var v = this[i];' . chr(10) . '        this[i] = p5decr_(this[i]);' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '});' . chr(10) . chr(10) . 'Object.defineProperty( Object.prototype, "p5hget_array", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        if (this[i] == null) { this[i] = new p5ArrayRef([]) }' . chr(10) . '        return this[i]' . chr(10) . '    }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Object.prototype, "p5hget_hash", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        if (this[i] == null) { this[i] = new p5HashRef({}) }' . chr(10) . '        return this[i]' . chr(10) . '    }' . chr(10) . '});' . chr(10) . chr(10) . '//-------' . chr(10) . chr(10) . chr(10) . 'p5context = function(List__, p5want) {' . chr(10) . '    if (p5want) {' . chr(10) . '        return p5list_to_a.apply(null, List__);' . chr(10) . '    }' . chr(10) . '    // scalar: return the last value' . chr(10) . '    var o = List__;' . chr(10) . '    while (o instanceof Array) {' . chr(10) . '        o =   o.length' . chr(10) . '            ? o[o.length-1]' . chr(10) . '            : null;' . chr(10) . '    }' . chr(10) . '    return o;' . chr(10) . '}' . chr(10) . chr(10) . 'p5list_to_a = function() {' . chr(10) . '    var res = [];' . chr(10) . '    for (i = 0; i < arguments.length; i++) {' . chr(10) . '        var o = arguments[i];' . chr(10) . '        if  (  o == null' . chr(10) . '            || o._class_    // perl5 blessed reference' . chr(10) . '            || o._ref_      // perl5 un-blessed reference' . chr(10) . '            )' . chr(10) . '        {' . chr(10) . '            res.push(o);' . chr(10) . '        }' . chr(10) . '        else if (o instanceof Array) {' . chr(10) . '            // perl5 array' . chr(10) . '            for (j = 0; j < o.length; j++) {' . chr(10) . '                res.push(o[j]);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        else if (typeof o === "object") {' . chr(10) . '            // perl5 hash' . chr(10) . '            for(var j in o) {' . chr(10) . '                if (o.hasOwnProperty(j)) {' . chr(10) . '                    res.push(j);' . chr(10) . '                    res.push(o[j]);' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            // non-ref' . chr(10) . '            res.push(o);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return res;' . chr(10) . '};' . chr(10) . chr(10) . 'p5a_to_h = function(a) {' . chr(10) . '    var res = {};' . chr(10) . '    for (i = 0; i < a.length; i+=2) {' . chr(10) . '        res[p5str(a[i])] = a[i+1];' . chr(10) . '    }' . chr(10) . '    return res;' . chr(10) . '};' . chr(10) . chr(10) . 'p5idx = function(a, i) {' . chr(10) . '    return i >= 0 ? i : a.length + i' . chr(10) . '};' . chr(10) . chr(10) . 'p5str = function(o) {' . chr(10) . '    if (o == null) {' . chr(10) . '        return "";' . chr(10) . '    }' . chr(10) . '    if (typeof o === "object") {' . chr(10) . chr(10) . '        if (o instanceof Array) {' . chr(10) . '            return CORE.join(["", o]);' . chr(10) . '        }' . chr(10) . chr(10) . '        if ( o.hasOwnProperty("_ref_") ) {' . chr(10) . '            if (!o._id_) { o._id_ = p5id++ }' . chr(10) . '            return [o._ref_, ' . chr(39) . '(0x' . chr(39) . ', o._id_.toString( 16 ), ' . chr(39) . ')' . chr(39) . '].join(' . chr(39) . chr(39) . ');' . chr(10) . '        }' . chr(10) . chr(10) . '    }' . chr(10) . '    // if (typeof o.string === "function") {' . chr(10) . '    //     return o.string();' . chr(10) . '    // }' . chr(10) . '    if (typeof o == "number" && Math.abs(o) < 0.0001 && o != 0) {' . chr(10) . '        return o.toExponential().replace(/e-(' . chr(92) . 'd)$/,"e-0$1");' . chr(10) . '    }' . chr(10) . '    if (typeof o === "boolean") {' . chr(10) . '        return o ? "1" : "";' . chr(10) . '    }' . chr(10) . '    if (typeof o !== "string") {' . chr(10) . '        return "" + o;' . chr(10) . '    }' . chr(10) . '    return o;' . chr(10) . '};' . chr(10) . chr(10) . 'p5num = function(o) {' . chr(10) . '    if (o == null) {' . chr(10) . '        return 0;' . chr(10) . '    }' . chr(10) . '    if (typeof o === "object" && (o instanceof Array)) {' . chr(10) . '        return o.length;' . chr(10) . '    }' . chr(10) . '    // if (typeof o.num === "function") {' . chr(10) . '    //     return o.num();' . chr(10) . '    // }' . chr(10) . '    if (typeof o !== "number") {' . chr(10) . '        var s = p5str(o).trim();' . chr(10) . '        var s1 = s.substr(0, 3).toUpperCase();' . chr(10) . '        if ( s1 == "NAN" ) { return NaN };' . chr(10) . '        if ( s1 == "INF" ) { return Infinity };' . chr(10) . '        s1 = s.substr(0, 4).toUpperCase();' . chr(10) . '        if ( s1 == "-NAN" ) { return NaN };' . chr(10) . '        if ( s1 == "-INF" ) { return -Infinity };' . chr(10) . '        s1 = parseFloat(s);' . chr(10) . '        if ( isNaN(s1) ) { return 0 };' . chr(10) . '        return s1;' . chr(10) . '    }' . chr(10) . '    return o;' . chr(10) . '};' . chr(10) . chr(10) . 'p5bool = function(o) {' . chr(10) . '    if (o) {' . chr(10) . '        if (typeof o === "boolean") {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        if (typeof o === "number") {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        if (typeof o === "string") {' . chr(10) . '            return o != "" && o != "0";' . chr(10) . '        }' . chr(10) . '        // if (typeof o.bool === "function") {' . chr(10) . '        //     return o.bool();' . chr(10) . '        // }' . chr(10) . '        if (typeof o.length === "number") {' . chr(10) . '            return o.length;' . chr(10) . '        }' . chr(10) . '        if (o instanceof Error) {' . chr(10) . '            return true;' . chr(10) . '        }' . chr(10) . '        for (var i in o) {' . chr(10) . '            return true;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return false;' . chr(10) . '};' . chr(10) . chr(10) . 'p5incr_ = function(o) {' . chr(10) . '    if (typeof o === "number") {' . chr(10) . '        return o + 1;' . chr(10) . '    }' . chr(10) . '    return p5str_inc(p5str(o));' . chr(10) . '};' . chr(10) . chr(10) . 'p5decr_ = function(o) {' . chr(10) . '    if (typeof o === "number") {' . chr(10) . '        return o - 1;' . chr(10) . '    }' . chr(10) . '    return p5num(o) - 1;' . chr(10) . '};' . chr(10) . chr(10) . 'p5modulo = function(o, k) {' . chr(10) . '    var m = o % k;' . chr(10) . '    if ( k < 0 && m > 0 ) {' . chr(10) . '        m = m + k;' . chr(10) . '    }' . chr(10) . '    else if ( k > 0 && m < 0 ) {' . chr(10) . '        m = m + k;' . chr(10) . '    }' . chr(10) . '    return m;' . chr(10) . '};' . chr(10) . chr(10) . 'p5shift_left = function(o, k) {' . chr(10) . '    return k < 31 ? o << k : o * Math.pow(2, k);' . chr(10) . '};' . chr(10) . chr(10) . 'p5and = function(a, fb) {' . chr(10) . '    if (p5bool(a)) {' . chr(10) . '        return fb();' . chr(10) . '    }' . chr(10) . '    return a;' . chr(10) . '};' . chr(10) . chr(10) . 'p5or = function(a, fb) {' . chr(10) . '    if (p5bool(a)) {' . chr(10) . '        return a;' . chr(10) . '    }' . chr(10) . '    return fb();' . chr(10) . '};' . chr(10) . chr(10) . 'p5defined_or = function(a, fb) {' . chr(10) . '    if (a == null) {' . chr(10) . '        return fb();' . chr(10) . '    }' . chr(10) . '    return a;' . chr(10) . '};' . chr(10) . chr(10) . 'p5cmp = function(a, b) {' . chr(10) . '    return a > b ? 1 : a < b ? -1 : 0 ' . chr(10) . '};' . chr(10) . chr(10) . 'p5complement = function(a) {' . chr(10) . '    return a < 0 ? ~a : 4294967295 - a' . chr(10) . '    // return a < 0 ? ~a : 18446744073709551615 - a' . chr(10) . '};' . chr(10) . chr(10) . 'p5str_replicate = function(o, n) {' . chr(10) . '    n = p5num(n);' . chr(10) . '    return n ? Array(n + 1).join(o) : "";' . chr(10) . '};' . chr(10) . chr(10) . 'p5str_inc = function(s) {' . chr(10) . '    s = p5str(s);' . chr(10) . '    if (s.length < 2) {' . chr(10) . '        if (s.match(/[012345678ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy]/)) {' . chr(10) . '            return String.fromCharCode(s.charCodeAt(0) + 1);' . chr(10) . '        }' . chr(10) . '        if (s == "9") {' . chr(10) . '            return "10";' . chr(10) . '        }' . chr(10) . '        if (s == "Z") {' . chr(10) . '            return "AA";' . chr(10) . '        }' . chr(10) . '        if (s == "z") {' . chr(10) . '            return "aa";' . chr(10) . '        }' . chr(10) . '        return "1";' . chr(10) . '    }' . chr(10) . '    var c = p5str_inc(s.substr(s.length-1, 1));' . chr(10) . '    if (c.length == 1) {' . chr(10) . '        return s.substr(0, s.length-1) + c;' . chr(10) . '    }' . chr(10) . '    return p5str_inc(s.substr(0, s.length-1)) + c.substr(c.length-1, 1);' . chr(10) . '};' . chr(10) . chr(10) . 'p5negative = function(o) {' . chr(10) . '    if (o == null) {' . chr(10) . '        return ' . chr(39) . '-0' . chr(39) . ';' . chr(10) . '    }' . chr(10) . '    if (typeof o === "object" && (o instanceof Array)) {' . chr(10) . '        return -(o.length);' . chr(10) . '    }' . chr(10) . '    if (typeof o !== "number") {' . chr(10) . '        var s = p5str(o);' . chr(10) . '        s1 = parseFloat(s.trim());' . chr(10) . '        if ( isNaN(s1) ) {' . chr(10) . '            var c = s.substr(0, 1);' . chr(10) . '            if ( c == ' . chr(39) . '+' . chr(39) . ' ) { s = s.substr(1); return ' . chr(39) . '-' . chr(39) . ' + s }' . chr(10) . '            if ( c == ' . chr(39) . '-' . chr(39) . ' ) { s = s.substr(1); return ' . chr(39) . '+' . chr(39) . ' + s }' . chr(10) . '            if ( c.length && !c.match(/[ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz]/) ) {' . chr(10) . '                if ( s.trim().substr(0,1) == "-" ) { return 0 };' . chr(10) . '                return ' . chr(39) . '-0' . chr(39) . ';' . chr(10) . '            };' . chr(10) . '            return ' . chr(39) . '-' . chr(39) . ' + s' . chr(10) . '        };' . chr(10) . '        return -s1;' . chr(10) . '    }' . chr(10) . '    return -o;' . chr(10) . '};' . chr(10) . chr(10) . 'p5for = function(namespace, var_name, func, args, cont, label) {' . chr(10) . '    var _redo = false;' . chr(10) . '    var v_old = namespace[var_name];' . chr(10) . '    for(var i = 0; i < args.length; i++) {' . chr(10) . '        namespace[var_name] = args[i];' . chr(10) . '        try {' . chr(10) . '            func()' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            if (err instanceof p5_error && err.v == label) {' . chr(10) . '                if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { i--; _redo = true }' . chr(10) . '                else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                throw(err)' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        if (cont) {' . chr(10) . '            try {' . chr(10) . '                if (!_redo) { cont() }' . chr(10) . '            }' . chr(10) . '            catch(err) {' . chr(10) . '                if (err instanceof p5_error && err.v == label) {' . chr(10) . '                    if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                    else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }' . chr(10) . '                    else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '                }            ' . chr(10) . '                else {' . chr(10) . '                    throw(err)' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '       }' . chr(10) . '   }' . chr(10) . '    namespace[var_name] = v_old;' . chr(10) . '};' . chr(10) . chr(10) . 'p5for_lex = function(func, args, cont, label) {' . chr(10) . '    var _redo = false;' . chr(10) . '    for(var i = 0; i < args.length; i++) {' . chr(10) . '        try {' . chr(10) . '            func(args[i])' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            if (err instanceof p5_error && err.v == label) {' . chr(10) . '                if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { i--; _redo = true }' . chr(10) . '                else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '            }            ' . chr(10) . '            else {' . chr(10) . '                throw(err)' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        if (cont) {' . chr(10) . '            try {' . chr(10) . '                if (!_redo) { cont() }' . chr(10) . '            }' . chr(10) . '            catch(err) {' . chr(10) . '                if (err instanceof p5_error && err.v == label) {' . chr(10) . '                    if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                    else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }' . chr(10) . '                    else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '                }            ' . chr(10) . '                else {' . chr(10) . '                    throw(err)' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . 'p5while = function(func, cond, cont, label) {' . chr(10) . '    var _redo = false;' . chr(10) . '    while (_redo || p5bool(cond())) {' . chr(10) . '        _redo = false;' . chr(10) . '        try {' . chr(10) . '            func()' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            if (err instanceof p5_error && err.v == label) {' . chr(10) . '                if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }' . chr(10) . '                else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '            }            ' . chr(10) . '            else {' . chr(10) . '                throw(err)' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        if (cont) {' . chr(10) . '            try {' . chr(10) . '                if (!_redo) { cont() }' . chr(10) . '            }' . chr(10) . '            catch(err) {' . chr(10) . '                if (err instanceof p5_error && err.v == label) {' . chr(10) . '                    if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                    else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }' . chr(10) . '                    else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '                }            ' . chr(10) . '                else {' . chr(10) . '                    throw(err)' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . 'p5map = function(namespace, func, args) {' . chr(10) . '    var v_old = namespace["v__"];' . chr(10) . '    var out = [];' . chr(10) . '    for(var i = 0; i < args.length; i++) {' . chr(10) . '        namespace["v__"] = args[i];' . chr(10) . '        var o = p5list_to_a(func(1));' . chr(10) . '        for(var j = 0; j < o.length; j++) {' . chr(10) . '            out.push(o[j]);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    namespace["v__"] = v_old;' . chr(10) . '    return out;' . chr(10) . '};' . chr(10) . chr(10) . 'p5grep = function(namespace, func, args) {' . chr(10) . '    var v_old = namespace["v__"];' . chr(10) . '    var out = [];' . chr(10) . '    for(var i = 0; i < args.length; i++) {' . chr(10) . '        namespace["v__"] = args[i];' . chr(10) . '        if (p5bool(func(0))) {' . chr(10) . '            out.push(args[i])' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    namespace["v__"] = v_old;' . chr(10) . '    return out;' . chr(10) . '};' . chr(10) . chr(10) . 'p5sort = function(namespace, func, args) {' . chr(10) . '    var a_old = namespace["v_a"];' . chr(10) . '    var b_old = namespace["v_b"];' . chr(10) . '    var out = ' . chr(10) . '        func == null' . chr(10) . '        ? args.sort()' . chr(10) . '        : args.sort(' . chr(10) . '            function(a, b) {' . chr(10) . '                namespace["v_a"] = a;' . chr(10) . '                namespace["v_b"] = b;' . chr(10) . '                return func(0);' . chr(10) . '            }' . chr(10) . '        );' . chr(10) . '    namespace["v_a"] = a_old;' . chr(10) . '    namespace["v_b"] = b_old;' . chr(10) . '    return out;' . chr(10) . '};' . chr(10) . chr(10)))
};
1;

;

# use Perlito5::Javascript2::Runtime
;
package main;
undef();
package Perlito5::Javascript2::Array;
sub Perlito5::Javascript2::Array::emit_javascript2 {
    return (('//' . chr(10) . '// lib/Perlito5/Javascript2/Runtime.js' . chr(10) . '//' . chr(10) . '// Runtime for "Perlito" Perl5-in-Javascript2' . chr(10) . '//' . chr(10) . '// AUTHORS' . chr(10) . '//' . chr(10) . '// Flavio Soibelmann Glock  fglock@gmail.com' . chr(10) . '//' . chr(10) . '// COPYRIGHT' . chr(10) . '//' . chr(10) . '// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.' . chr(10) . '//' . chr(10) . '// This program is free software; you can redistribute it and/or modify it' . chr(10) . '// under the same terms as Perl itself.' . chr(10) . '//' . chr(10) . '// See http://www.perl.com/perl/misc/Artistic.html' . chr(10) . chr(10) . '//-------- Array ' . chr(10) . chr(10) . 'Object.defineProperty( Array.prototype, "p5aget", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        return this[i] ' . chr(10) . '    }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Array.prototype, "p5aset", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i, v) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        this[i] = v;' . chr(10) . '        return this[i]' . chr(10) . '    }' . chr(10) . '});' . chr(10) . chr(10) . 'Object.defineProperty( Array.prototype, "p5incr", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        this[i] = p5incr_(this[i]);' . chr(10) . '        return this[i];' . chr(10) . '    }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Array.prototype, "p5postincr", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        var v = this[i];' . chr(10) . '        this[i] = p5incr_(this[i]);' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Array.prototype, "p5decr", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        this[i] = p5decr_(this[i]);' . chr(10) . '        return this[i];' . chr(10) . '    }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Array.prototype, "p5postdecr", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        var v = this[i];' . chr(10) . '        this[i] = p5decr_(this[i]);' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '});' . chr(10) . chr(10) . 'Object.defineProperty( Array.prototype, "p5aget_array", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        if (this[i] == null) { this[i] = new p5ArrayRef([]) }' . chr(10) . '        return this[i]' . chr(10) . '    }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Array.prototype, "p5aget_hash", {' . chr(10) . '    enumerable : false,' . chr(10) . '    value : function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        if (this[i] == null) { this[i] = new p5HashRef({}) }' . chr(10) . '        return this[i]' . chr(10) . '    }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Array.prototype, "p5unshift", {' . chr(10) . '    enumerable : false,' . chr(10) . '    configurable : true,' . chr(10) . '    value : function (args) { ' . chr(10) . '        for(var i = args.length-1; i >= 0; i--) {' . chr(10) . '            this.unshift(args[i]);' . chr(10) . '        }' . chr(10) . '        return this.length; ' . chr(10) . '    }' . chr(10) . '});' . chr(10) . 'Object.defineProperty( Array.prototype, "p5push", {' . chr(10) . '    enumerable : false,' . chr(10) . '    configurable : true,' . chr(10) . '    value : function (args) { ' . chr(10) . '        for(var i = 0; i < args.length; i++) {' . chr(10) . '            this.push(args[i]);' . chr(10) . '        }' . chr(10) . '        return this.length; ' . chr(10) . '    }' . chr(10) . '});' . chr(10) . chr(10) . 'p5tie_array = function(v, List__) {' . chr(10) . '    var pkg_name = p5str(List__.shift());' . chr(10) . chr(10) . '    var res = p5call(pkg_name, ' . chr(39) . 'TIEARRAY' . chr(39) . ', List__, null);' . chr(10) . '    ' . chr(10) . '    // TODO' . chr(10) . '    ' . chr(10) . '    //  A class implementing an ordinary array should have the following methods:' . chr(10) . '    //      TIEARRAY pkg_name, LIST' . chr(10) . '    //      FETCH this, key' . chr(10) . '    //      STORE this, key, value' . chr(10) . '    //      FETCHSIZE this' . chr(10) . '    //      STORESIZE this, count' . chr(10) . '    //      CLEAR this' . chr(10) . '    //      PUSH this, LIST' . chr(10) . '    //      POP this' . chr(10) . '    //      SHIFT this' . chr(10) . '    //      UNSHIFT this, LIST' . chr(10) . '    //      SPLICE this, offset, length, LIST' . chr(10) . '    //      EXTEND this, count' . chr(10) . '    //      DESTROY this' . chr(10) . '    //      UNTIE this' . chr(10) . '    ' . chr(10) . '    Object.defineProperty( v, "p5aget", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function (i) {' . chr(10) . '            return p5call(res, ' . chr(39) . 'FETCH' . chr(39) . ', [i]);' . chr(10) . '        }' . chr(10) . '    });' . chr(10) . '    Object.defineProperty( v, "p5aset", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function (i, value) {' . chr(10) . '            p5call(res, ' . chr(39) . 'STORE' . chr(39) . ', [i, value]);' . chr(10) . '            return value;' . chr(10) . '        }' . chr(10) . '    });' . chr(10) . '    Object.defineProperty( v, "p5incr", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function (i) {' . chr(10) . '            var value = p5incr_(p5call(res, ' . chr(39) . 'FETCH' . chr(39) . ', [i]));' . chr(10) . '            p5call(res, ' . chr(39) . 'STORE' . chr(39) . ', [i, value]);' . chr(10) . '            return value;' . chr(10) . '        }' . chr(10) . '    });' . chr(10) . '    Object.defineProperty( v, "p5postincr", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function (i) {' . chr(10) . '            var value = p5call(res, ' . chr(39) . 'FETCH' . chr(39) . ', [i]);' . chr(10) . '            p5call(res, ' . chr(39) . 'STORE' . chr(39) . ', [i, p5incr_(value)]);' . chr(10) . '            return value;' . chr(10) . '        }' . chr(10) . '    });' . chr(10) . '    Object.defineProperty( v, "p5decr", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function (i) {' . chr(10) . '            var value = p5decr_(p5call(res, ' . chr(39) . 'FETCH' . chr(39) . ', [i]));' . chr(10) . '            p5call(res, ' . chr(39) . 'STORE' . chr(39) . ', [i, value]);' . chr(10) . '            return value;' . chr(10) . '        }' . chr(10) . '    });' . chr(10) . '    Object.defineProperty( v, "p5postdecr", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function (i) {' . chr(10) . '            var value = p5call(res, ' . chr(39) . 'FETCH' . chr(39) . ', [i]);' . chr(10) . '            p5call(res, ' . chr(39) . 'STORE' . chr(39) . ', [i, p5decr_(value)]);' . chr(10) . '            return value;' . chr(10) . '        }' . chr(10) . '    });' . chr(10) . '    ' . chr(10) . '    Object.defineProperty( v, "p5aget_array", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function (i) {' . chr(10) . '            var value = p5call(res, ' . chr(39) . 'FETCH' . chr(39) . ', [i]);' . chr(10) . '            if (value == null) {' . chr(10) . '                value = new p5ArrayRef([]);' . chr(10) . '                p5call(res, ' . chr(39) . 'STORE' . chr(39) . ', [i, value]);' . chr(10) . '            }' . chr(10) . '            return value;' . chr(10) . '        }' . chr(10) . '    });' . chr(10) . '    Object.defineProperty( v, "p5aget_hash", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function (i) {' . chr(10) . '            var value = p5call(res, ' . chr(39) . 'FETCH' . chr(39) . ', [i]);' . chr(10) . '            if (value == null) {' . chr(10) . '                value = new p5HashRef({});' . chr(10) . '                p5call(res, ' . chr(39) . 'STORE' . chr(39) . ', [i, value]);' . chr(10) . '            }' . chr(10) . '            return value;' . chr(10) . '        }' . chr(10) . '    });' . chr(10) . '    Object.defineProperty( v, "p5untie", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function (i) { return p5call(res, ' . chr(39) . 'UNTIE' . chr(39) . ', []) }' . chr(10) . '    });' . chr(10) . '    Object.defineProperty( v, "shift", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function () { return p5call(res, ' . chr(39) . 'SHIFT' . chr(39) . ', []) }' . chr(10) . '    });' . chr(10) . '    Object.defineProperty( v, "pop", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function () { return p5call(res, ' . chr(39) . 'POP' . chr(39) . ', []) }' . chr(10) . '    });' . chr(10) . '    Object.defineProperty( v, "p5unshift", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function (args) { ' . chr(10) . '            for(var i = args.length-1; i >= 0; i--) {' . chr(10) . '                p5call(res, ' . chr(39) . 'UNSHIFT' . chr(39) . ', [args[i]]);' . chr(10) . '            }' . chr(10) . '            return p5call(res, ' . chr(39) . 'FETCHSIZE' . chr(39) . ', []); ' . chr(10) . '        }' . chr(10) . '    });' . chr(10) . '    Object.defineProperty( v, "p5push", {' . chr(10) . '        enumerable : false,' . chr(10) . '        configurable : true,' . chr(10) . '        value : function (args) { ' . chr(10) . '            for(var i = 0; i < args.length; i++) {' . chr(10) . '                p5call(res, ' . chr(39) . 'PUSH' . chr(39) . ', [args[i]]);' . chr(10) . '            }' . chr(10) . '            return p5call(res, ' . chr(39) . 'FETCHSIZE' . chr(39) . ', []); ' . chr(10) . '        }' . chr(10) . '    });' . chr(10) . chr(10) . '    return res;' . chr(10) . '};' . chr(10) . chr(10) . 'p5untie_array = function(v) {' . chr(10) . '    if (v.hasOwnProperty(' . chr(39) . 'p5untie' . chr(39) . ')) {' . chr(10) . '        var res = v.p5untie();  // call UNTIE' . chr(10) . '        delete v.p5aget;' . chr(10) . '        delete v.p5aset;' . chr(10) . '        delete v.p5incr;' . chr(10) . '        delete v.p5postincr;' . chr(10) . '        delete v.p5decr;' . chr(10) . '        delete v.p5postdecr;' . chr(10) . '        delete v.p5aget_array;' . chr(10) . '        delete v.p5aget_hash;' . chr(10) . '        delete v.p5untie;' . chr(10) . '        delete v.shift;' . chr(10) . '        delete v.pop;' . chr(10) . '        delete v.p5unshift;' . chr(10) . '        delete v.p5push;' . chr(10) . '        return res;' . chr(10) . '    }' . chr(10) . '    else {' . chr(10) . '        return null;' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . chr(10) . 'function p5ArrayOfAlias(o) {' . chr(10) . chr(10) . '    // this is the structure that represents @_' . chr(10) . '    // _array = [ ref, index,' . chr(10) . '    //            ref, index,' . chr(10) . '    //            ...' . chr(10) . '    //          ]' . chr(10) . chr(10) . '    // TODO - autovivify array cells' . chr(10) . chr(10) . '    this._array_ = o;' . chr(10) . chr(10) . '    this.p5aget = function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        return this._array_[i+i][this._array_[i+i+1]]; ' . chr(10) . '    }' . chr(10) . '    this.p5aset = function (i, v) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        this._array_[i+i][this._array_[i+i+1]] = v;' . chr(10) . '        return this._array_[i+i][this._array_[i+i+1]]' . chr(10) . '    }' . chr(10) . '    this.p5incr = function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        this._array_[i+i][this._array_[i+i+1]] = p5incr_(this._array_[i+i][this._array_[i+i+1]]);' . chr(10) . '        return this._array_[i+i][this._array_[i+i+1]];' . chr(10) . '    }' . chr(10) . '    this.p5postincr = function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        var v = this._array_[i+i][this._array_[i+i+1]];' . chr(10) . '        this._array_[i+i][this._array_[i+i+1]] = p5incr_(this._array_[i+i][this._array_[i+i+1]]);' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '    this.p5decr = function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        this._array_[i+i][this._array_[i+i+1]] = p5decr_(this._array_[i+i][this._array_[i+i+1]]);' . chr(10) . '        return this._array_[i+i][this._array_[i+i+1]];' . chr(10) . '    }' . chr(10) . '    this.p5postdecr = function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        var v = this._array_[i+i][this._array_[i+i+1]];' . chr(10) . '        this._array_[i+i][this._array_[i+i+1]] = p5decr_(this._array_[i+i][this._array_[i+i+1]]);' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '    this.p5aget_array = function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        if (this._array_[i+i][this._array_[i+i+1]] == null) {' . chr(10) . '            this._array_[i+i][this._array_[i+i+1]] = new p5ArrayRef([])' . chr(10) . '        }' . chr(10) . '        return this._array_[i+i][this._array_[i+i+1]]' . chr(10) . '    }' . chr(10) . '    this.p5aget_hash = function (i) {' . chr(10) . '        if (i < 0) { i =  this.length + i };' . chr(10) . '        if (this._array_[i+i][this._array_[i+i+1]] == null) {' . chr(10) . '            this._array_[i+i][this._array_[i+i+1]] = new p5HashRef({})' . chr(10) . '        }' . chr(10) . '        return this._array_[i+i][this._array_[i+i+1]]' . chr(10) . '    }' . chr(10) . '    this.p5unshift = function (args) { ' . chr(10) . '        for(var i = args.length-1; i >= 0; i--) {' . chr(10) . '            this.unshift(0);' . chr(10) . '            this.unshift([args[i]]);' . chr(10) . '        }' . chr(10) . '        return this._array_.length / 2; ' . chr(10) . '    }' . chr(10) . '    this.p5push = function (args) { ' . chr(10) . '        for(var i = 0; i < args.length; i++) {' . chr(10) . '            this.push([args[i]]);' . chr(10) . '            this.push(0);' . chr(10) . '        }' . chr(10) . '        return this._array_.length / 2; ' . chr(10) . '    }' . chr(10) . '    this.shift = function () { ' . chr(10) . '        var v0 = this._array_.shift();' . chr(10) . '        return v0[this._array_.shift()];' . chr(10) . '    }' . chr(10) . '    this.pop = function () { ' . chr(10) . '        var v1 = this._array_.pop();' . chr(10) . '        var v0 = this._array_.pop();' . chr(10) . '        return v0[v1];' . chr(10) . '    }' . chr(10) . '}' . chr(10) . chr(10) . chr(10)))
};
1;

;

# use Perlito5::Javascript2::Array
;
package main;
undef();
package Perlito5::Javascript2::CORE;
sub Perlito5::Javascript2::CORE::emit_javascript2 {
    return (('//' . chr(10) . '//' . chr(10) . '// lib/Perlito5/Javascript2/CORE.js' . chr(10) . '//' . chr(10) . '// CORE functions for "Perlito" Perl5-in-Javascript2' . chr(10) . '//' . chr(10) . '// AUTHORS' . chr(10) . '//' . chr(10) . '// Flavio Soibelmann Glock  fglock@gmail.com' . chr(10) . '//' . chr(10) . '// COPYRIGHT' . chr(10) . '//' . chr(10) . '// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.' . chr(10) . '//' . chr(10) . '// This program is free software; you can redistribute it and/or modify it' . chr(10) . '// under the same terms as Perl itself.' . chr(10) . '//' . chr(10) . '// See http://www.perl.com/perl/misc/Artistic.html' . chr(10) . chr(10) . 'var CORE = p5pkg.CORE;' . chr(10) . chr(10) . 'var isNode = typeof require != "undefined";' . chr(10) . chr(10) . 'CORE.bless = function(List__) {' . chr(10) . '    var o        = List__[0];' . chr(10) . '    var pkg_name = List__[1];' . chr(10) . '    if (typeof pkg_name === "object") {' . chr(10) . '        // bless {}, Class' . chr(10) . '        o._class_ = pkg_name;' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . '    if (!p5pkg.hasOwnProperty(pkg_name)) {' . chr(10) . '        p5make_package(pkg_name);' . chr(10) . '    }' . chr(10) . '    o._class_ = p5pkg[pkg_name];' . chr(10) . '    return o;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.caller = function(List__, want) {' . chr(10) . '    return p5pkg["Perlito5"].v_CALLER._array_ ?' . chr(10) . '           p5pkg["Perlito5"].v_CALLER._array_[0]._array_ :' . chr(10) . '           p5context([], want);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.chr = function(List__) {' . chr(10) . '    var v = p5num(List__[0]);' . chr(10) . '    return String.fromCharCode(v >= 0 ? v : 65533);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.ord = function(List__) {' . chr(10) . '    return p5str(List__[0]).charCodeAt(0);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.oct = function(List__) {' . chr(10) . '    var v = List__[0];' . chr(10) . '    var b = v.substr(0,2);' . chr(10) . '    v = v.replace("_", "");' . chr(10) . '    if (b == "0b" || b == "0B") { return parseInt(v.substr(2), 2)  }' . chr(10) . '    if (b == "0x" || b == "0X") { return parseInt(v.substr(2), 16) }' . chr(10) . '    return parseInt(v, 8);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.abs   = function(List__) { return Math.abs(List__[0]) };' . chr(10) . 'CORE.exp   = function(List__) { return Math.exp(List__[0]) };' . chr(10) . 'CORE.log   = function(List__) { return Math.log(List__[0]) };' . chr(10) . 'CORE.cos   = function(List__) { return Math.cos(List__[0]) };' . chr(10) . 'CORE.sin   = function(List__) { return Math.sin(List__[0]) };' . chr(10) . 'CORE.sqrt  = function(List__) { return Math.sqrt(List__[0]) };' . chr(10) . 'CORE.atan2 = function(List__) { return Math.atan2(List__[0], List__[1]) };' . chr(10) . 'CORE.int   = function(List__) { return List__[0] > 0 ? Math.floor(List__[0]) : Math.ceil(List__[0]) };' . chr(10) . chr(10) . 'CORE.rand = function(List__) {' . chr(10) . '    var v = p5num(List__[0]) || 1;' . chr(10) . '    return Math.random() * v;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.lc      = function(List__) { return p5str(List__[0]).toLowerCase() };' . chr(10) . 'CORE.uc      = function(List__) { return p5str(List__[0]).toUpperCase() };' . chr(10) . chr(10) . 'CORE.lcfirst = function(List__) {' . chr(10) . '    var s = p5str(List__[0]);' . chr(10) . '    var c = s.length > 0 ? s.slice(0,1).toLowerCase() : "";' . chr(10) . '    s = s.length > 1 ? s.substr(1) : "";' . chr(10) . '    return c + s' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.ucfirst = function(List__) {' . chr(10) . '    var s = p5str(List__[0]);' . chr(10) . '    var c = s.length > 0 ? s.slice(0,1).toUpperCase() : "";' . chr(10) . '    s = s.length > 1 ? s.substr(1) : "";' . chr(10) . '    return c + s' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.quotemeta = function(List__) {' . chr(10) . '    var s = p5str(List__[0]);' . chr(10) . '    var out = [];' . chr(10) . '    for(var i = 0; i < s.length; i++) {' . chr(10) . '        if (s.substr(i, 1).match(/[^0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz]/)) {' . chr(10) . '            out.push(String.fromCharCode(92));' . chr(10) . '        }' . chr(10) . '        out.push(s.substr(i, 1));' . chr(10) . '    }' . chr(10) . '    return out.join("");       ' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.substr = function(List__) {' . chr(10) . '    var expr        = List__[0];' . chr(10) . '    var offset      = List__[1];' . chr(10) . '    var length      = List__[2];' . chr(10) . '    var replacement = List__[3];' . chr(10) . '    if (length < 0) {' . chr(10) . '        var s = p5str(expr);' . chr(10) . '        length = s.length - offset + length;' . chr(10) . '    } ' . chr(10) . '    return p5str(expr).substr(offset, length);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.values = function(List__, p5want) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    delete o["_each_"];' . chr(10) . '    if (p5want) {' . chr(10) . '        if (o == null) {' . chr(10) . '            return [];' . chr(10) . '        };' . chr(10) . '        if (typeof o.values === "function") {' . chr(10) . '            return o.values();' . chr(10) . '        }' . chr(10) . '        var out = [];' . chr(10) . '        for (var i in o) {' . chr(10) . '            out.push(o[i]);' . chr(10) . '        }' . chr(10) . '        return out;' . chr(10) . '    }' . chr(10) . '    return CORE.keys(List__, p5want);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.keys = function(List__, p5want) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    delete o["_each_"];' . chr(10) . '    if (p5want) {' . chr(10) . '        if (o == null) {' . chr(10) . '            return [];' . chr(10) . '        }' . chr(10) . '        if (typeof o.keys === "function") {' . chr(10) . '            return o.keys();' . chr(10) . '        }' . chr(10) . '        var out = [];' . chr(10) . '        for (var i in o) {' . chr(10) . '            out.push(i);' . chr(10) . '        }' . chr(10) . '        return out;' . chr(10) . '    }' . chr(10) . '    else {' . chr(10) . '        if (o == null) {' . chr(10) . '            return 0;' . chr(10) . '        }' . chr(10) . '        if (typeof o.keys === "function") {' . chr(10) . '            return CORE.scalar([o.keys()]);' . chr(10) . '        }' . chr(10) . '        var out = 0;' . chr(10) . '        for (var i in o) {' . chr(10) . '            out++;' . chr(10) . '        }' . chr(10) . '        return out;' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.each = function(List__, p5want) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    if (o.hasOwnProperty("_each_")) {' . chr(10) . '        return o._each_(p5want)' . chr(10) . '    }' . chr(10) . '    var keys = CORE.keys([o], 1);' . chr(10) . '    var i = 0;' . chr(10) . '    o._each_ = function () {' . chr(10) . '        if (i < keys.length) {' . chr(10) . '            i++;' . chr(10) . '            return p5want ? [keys[i-1], o[keys[i-1]]] : keys[i-1];' . chr(10) . '        }' . chr(10) . '        i = 0;' . chr(10) . '        return p5want ? [] : null;' . chr(10) . '    };' . chr(10) . '    return o._each_(p5want);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.reverse = function(List__) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    if (o == null) {' . chr(10) . '        return "";' . chr(10) . '    }' . chr(10) . '    if (typeof o === "string") {' . chr(10) . '        return o.split("").reverse().join("")' . chr(10) . '    }' . chr(10) . '    var out = [];' . chr(10) . '    for(var i = 0; i < o.length; i++) {' . chr(10) . '        out.unshift(o[i]);' . chr(10) . '    }' . chr(10) . '    return out;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.splice = function(List__, p5want) {' . chr(10) . '    var array  = List__.shift();' . chr(10) . '    // CORE.say([ array ]);' . chr(10) . '    var offset = p5num(List__.shift());' . chr(10) . '    var limit  = List__.length ? p5num(List__.shift()) : (array.length + 1);' . chr(10) . chr(10) . '    if (limit < 0) {' . chr(10) . '        limit = array.length + limit - 1;' . chr(10) . '    }' . chr(10) . chr(10) . '    var list = [offset, limit];' . chr(10) . '    for(var i = 0; i < List__.length; i++) {' . chr(10) . '        list = p5list_to_a( list, List__[i]);' . chr(10) . '    }' . chr(10) . chr(10) . '    out = array.splice.apply(array, list);' . chr(10) . '    // CORE.say([ CORE.join([":",array]), " ofs=", offset, " lim=", limit, " list=", list, " out=", CORE.join([":",out])  ]);' . chr(10) . '    return p5want ? out : out.pop();' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.join = function(List__) {' . chr(10) . '    var s = List__[0];' . chr(10) . '    var o = List__[1];' . chr(10) . '    return o.join(s);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.index = function(List__) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    var s = List__[1];' . chr(10) . '    try {' . chr(10) . '        return o.indexOf(s, p5num(List__[2]));' . chr(10) . '    }' . chr(10) . '    catch(err) {' . chr(10) . '        return -1;' . chr(10) . '    }' . chr(10) . '};' . chr(10) . 'CORE.rindex = function(List__) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    var s = List__[1];' . chr(10) . '    try {' . chr(10) . '        if (List__.length > 2) {' . chr(10) . '            var i = p5num(List__[2]);' . chr(10) . '            if (i < 0) {' . chr(10) . '                if (s.length == 0) {' . chr(10) . '                    return 0;' . chr(10) . '                }' . chr(10) . '                return -1;' . chr(10) . '            }' . chr(10) . '            return o.lastIndexOf(s, i);' . chr(10) . '        }' . chr(10) . '        return o.lastIndexOf(s);' . chr(10) . '    }' . chr(10) . '    catch(err) {' . chr(10) . '        return -1;' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.length = function(List__) {' . chr(10) . '    return p5str(List__[0]).length;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.pack    = function(List__) { CORE.warn([ "CORE::pack not implemented" ]) };' . chr(10) . 'CORE.unpack  = function(List__) { CORE.warn([ "CORE::unpack not implemented" ]) };' . chr(10) . chr(10) . 'CORE.ref = function(List__) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    if (o == null) {' . chr(10) . '        return "";' . chr(10) . '    }' . chr(10) . '    if (o._class_ && typeof o._class_._ref_ === "string") {' . chr(10) . '        // blessed reference' . chr(10) . '        return o._class_._ref_;' . chr(10) . '    }' . chr(10) . '    if (typeof o._ref_ === "string") {' . chr(10) . '        // un-blessed reference' . chr(10) . '        return o._ref_;' . chr(10) . '    }' . chr(10) . '    if (typeof o === "function") {' . chr(10) . '        return "CODE";' . chr(10) . '    }' . chr(10) . '    return "";' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.split = function(List__) {' . chr(10) . '    var pattern = List__[0];' . chr(10) . '    var s       = List__[1];' . chr(10) . '    var limit   = List__[2];' . chr(10) . '    if (typeof pattern === "string") {' . chr(10) . '        if (pattern == " ") {' . chr(10) . '            var res = [];' . chr(10) . '            for (var i_ = 0, a_ = s.split(/(?: |' . chr(92) . 'n)+/); i_ < a_.length ; i_++) {' . chr(10) . '                if (a_[i_] != "") {' . chr(10) . '                    res.push(a_[i_])' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            return res;' . chr(10) . '        }' . chr(10) . '        return s.split(pattern);' . chr(10) . '    }' . chr(10) . '    CORE.die(["not implemented"]);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.prototype = function(List__, data) {' . chr(10) . '    var name = List__[0];' . chr(10) . '    // TODO - fully qualify "name" using information from "data"' . chr(10) . '    // XXX - lookup in CORE::GLOBAL?' . chr(10) . '    p5pkg["Perlito5"].v_PROTO._hash_[name] || p5pkg["Perlito5"].v_CORE_PROTO._hash_[name]' . chr(10) . '};' . chr(10) . chr(10)))
};
1;

;

# use Perlito5::Javascript2::CORE
;
package main;
undef();
package Perlito5::Javascript2::IO;
sub Perlito5::Javascript2::IO::emit_javascript2 {
    return (('//' . chr(10) . '//' . chr(10) . '// lib/Perlito5/Javascript2/IO.js' . chr(10) . '//' . chr(10) . '// I/O functions for "Perlito" Perl5-in-Javascript2' . chr(10) . '//' . chr(10) . '// AUTHORS' . chr(10) . '//' . chr(10) . '// Flavio Soibelmann Glock  fglock@gmail.com' . chr(10) . '//' . chr(10) . '// COPYRIGHT' . chr(10) . '//' . chr(10) . '// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.' . chr(10) . '//' . chr(10) . '// This program is free software; you can redistribute it and/or modify it' . chr(10) . '// under the same terms as Perl itself.' . chr(10) . '//' . chr(10) . '// See http://www.perl.com/perl/misc/Artistic.html' . chr(10) . chr(10) . 'var isNode = typeof require != "undefined";' . chr(10) . 'if (isNode) {' . chr(10) . chr(10) . '    var fs = require("fs");' . chr(10) . chr(10) . '    p5typeglob_set("Perlito5::IO", "print", function (List__, p5want) {' . chr(10) . '        var i;' . chr(10) . '        List__.shift(); // TODO - use IO::FILE' . chr(10) . '        for (i = 0; i < List__.length; i++) {' . chr(10) . '            process.stdout.write(p5str(List__[i]));' . chr(10) . '        }' . chr(10) . '        return 1;' . chr(10) . '    } );' . chr(10) . chr(10) . '    p5atime = function(s) {' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat["atime"];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5mtime = function(s) {' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat["mtime"];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5ctime = function(s) {' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat["ctime"];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5size = function(s) {' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat["size"];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5is_file = function(s) {' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat.isFile() ? 1 : 0;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5is_directory = function(s) {' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat.isDirectory() ? 1 : 0;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5file_exists = function(s) {' . chr(10) . '        return p5is_file(s) || p5is_directory(s);' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.chdir = function(List__) {' . chr(10) . '        try {' . chr(10) . '            process.chdir(p5str(List__[0]));' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.close = function(List__) {' . chr(10) . '        try {' . chr(10) . '            fs.closeSync(p5str(List__[0]));' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.exit = function(List__) {' . chr(10) . '        process.exit(List__[0]);' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.rename = function(List__) {' . chr(10) . '        try {' . chr(10) . '            fs.renameSync(p5str(List__[0]), p5str(List__[1]));' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.unlink = function(List__) {' . chr(10) . '        var count = 0;' . chr(10) . '        try {' . chr(10) . '            for(var i = 0; i < List__.length; i++) {' . chr(10) . '                fs.unlinkSync(p5str(List__[i]));' . chr(10) . '                count++;' . chr(10) . '            }' . chr(10) . '            return count;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return count;' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '    p5typeglob_set("Perlito5::IO", "slurp", function(List__) {' . chr(10) . '        return fs.readFileSync(List__[0],"utf8");' . chr(10) . '    });' . chr(10) . chr(10) . '} else {' . chr(10) . '    // not running in node.js' . chr(10) . '    p5typeglob_set("Perlito5::IO", "print", function (List__, p5want) {' . chr(10) . '        var i;' . chr(10) . '        List__.shift(); // TODO - use IO::FILE' . chr(10) . '        for (i = 0; i < List__.length; i++) {' . chr(10) . '            write(p5str(List__[i]));' . chr(10) . '        }' . chr(10) . '        return 1;' . chr(10) . '    });' . chr(10) . '    p5typeglob_set("Perlito5::IO", "slurp", function(List__) {' . chr(10) . '        var filename = List__[0];' . chr(10) . '        if (typeof readFile == "function") {' . chr(10) . '            return readFile(filename);' . chr(10) . '        }' . chr(10) . '        if (typeof read == "function") {' . chr(10) . '            // v8' . chr(10) . '            return read(filename);' . chr(10) . '        }' . chr(10) . '        p5pkg.CORE.die(["Perlito5::IO::slurp() not implemented"]);' . chr(10) . '    });' . chr(10) . '}' . chr(10) . chr(10) . 'CORE.die = function(List__) {' . chr(10) . '    var i;' . chr(10) . '    var s = "";' . chr(10) . '    for (i = 0; i < List__.length; i++) {' . chr(10) . '        s = s + p5str(List__[i]);' . chr(10) . '    }' . chr(10) . '    try {' . chr(10) . '        s = s + "' . chr(92) . 'n" + new Error().stack;' . chr(10) . '    }' . chr(10) . '    catch(err) { }' . chr(10) . '    p5pkg["main"]["v_@"] = "Died: " + s;' . chr(10) . '    throw(new p5_error("die", "Died: " + s));' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.say = function(List__) {' . chr(10) . '    CORE.print(List__);' . chr(10) . '    return CORE.print(["' . chr(92) . 'n"]);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.print = function(List__) {' . chr(10) . '    var i;' . chr(10) . '    for (i = 0; i < List__.length; i++) {' . chr(10) . '        p5pkg[' . chr(39) . 'Perlito5::IO' . chr(39) . '].print([ ' . chr(39) . 'STDOUT' . chr(39) . ', List__[i] ]);' . chr(10) . '    }' . chr(10) . '    return 1;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.warn = function(List__) {' . chr(10) . '    var i;' . chr(10) . '    var s = "";' . chr(10) . '    for (i = 0; i < List__.length; i++) {' . chr(10) . '        s = s + p5str(List__[i]);' . chr(10) . '    }' . chr(10) . '    try {' . chr(10) . '        s = s + "' . chr(92) . 'n" + new Error().stack;' . chr(10) . '    }' . chr(10) . '    catch(err) { }' . chr(10) . '    p5pkg[' . chr(39) . 'Perlito5::IO' . chr(39) . '].print([ ' . chr(39) . 'STDERR' . chr(39) . ', "Warning: " + s + "' . chr(92) . 'n"]);' . chr(10) . '};' . chr(10) . chr(10) . chr(10)))
};
1;

;

# use Perlito5::Javascript2::IO
;
package main;
undef();
package Perlito5::Javascript2::Sprintf;
sub Perlito5::Javascript2::Sprintf::emit_javascript2 {
    return (('/**' . chr(10) . ' * Copyright (c) 2010 Jakob Westhoff' . chr(10) . ' *' . chr(10) . ' * Permission is hereby granted, free of charge, to any person obtaining a copy' . chr(10) . ' * of this software and associated documentation files (the "Software"), to deal' . chr(10) . ' * in the Software without restriction, including without limitation the rights' . chr(10) . ' * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell' . chr(10) . ' * copies of the Software, and to permit persons to whom the Software is' . chr(10) . ' * furnished to do so, subject to the following conditions:' . chr(10) . ' * ' . chr(10) . ' * The above copyright notice and this permission notice shall be included in' . chr(10) . ' * all copies or substantial portions of the Software.' . chr(10) . ' * ' . chr(10) . ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR' . chr(10) . ' * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,' . chr(10) . ' * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE' . chr(10) . ' * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER' . chr(10) . ' * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,' . chr(10) . ' * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN' . chr(10) . ' * THE SOFTWARE.' . chr(10) . ' */' . chr(10) . chr(10) . 'CORE.sprintf = function(List__) {' . chr(10) . '    var format = List__[0];' . chr(10) . '    var list = List__[1];' . chr(10) . chr(10) . '    // Check for format definition' . chr(10) . '    if ( typeof format != ' . chr(39) . 'string' . chr(39) . ' ) {' . chr(10) . '        CORE.die(["sprintf: The first arguments need to be a valid format string."]);' . chr(10) . '    }' . chr(10) . '    ' . chr(10) . '    /**' . chr(10) . '     * Define the regex to match a formating string' . chr(10) . '     * The regex consists of the following parts:' . chr(10) . '     * percent sign to indicate the start' . chr(10) . '     * (optional) sign specifier' . chr(10) . '     * (optional) padding specifier' . chr(10) . '     * (optional) alignment specifier' . chr(10) . '     * (optional) width specifier' . chr(10) . '     * (optional) precision specifier' . chr(10) . '     * type specifier:' . chr(10) . '     *  % - literal percent sign' . chr(10) . '     *  b - binary number' . chr(10) . '     *  c - ASCII character represented by the given value' . chr(10) . '     *  d - signed decimal number' . chr(10) . '     *  f - floating point value' . chr(10) . '     *  o - octal number' . chr(10) . '     *  s - string' . chr(10) . '     *  x - hexadecimal number (lowercase characters)' . chr(10) . '     *  X - hexadecimal number (uppercase characters)' . chr(10) . '     */' . chr(10) . '    var r = new RegExp( /%(' . chr(92) . '+)?([0 ]|' . chr(39) . '(.))?(-)?([0-9]+)?(' . chr(92) . '.([0-9]+))?([%bcdfosxX])/g );' . chr(10) . chr(10) . '    /**' . chr(10) . '     * Each format string is splitted into the following parts:' . chr(10) . '     * 0: Full format string' . chr(10) . '     * 1: sign specifier (+)' . chr(10) . '     * 2: padding specifier (0/<space>/' . chr(39) . '<any char>)' . chr(10) . '     * 3: if the padding character starts with a ' . chr(39) . ' this will be the real ' . chr(10) . '     *    padding character' . chr(10) . '     * 4: alignment specifier' . chr(10) . '     * 5: width specifier' . chr(10) . '     * 6: precision specifier including the dot' . chr(10) . '     * 7: precision specifier without the dot' . chr(10) . '     * 8: type specifier' . chr(10) . '     */' . chr(10) . '    var parts      = [];' . chr(10) . '    var paramIndex = 0;' . chr(10) . '    while ( part = r.exec( format ) ) {' . chr(10) . '        // Check if an input value has been provided, for the current' . chr(10) . '        // format string' . chr(10) . '        if ( paramIndex >= list.length ) {' . chr(10) . '            CORE.die(["sprintf: At least one argument was missing."]);' . chr(10) . '        }' . chr(10) . chr(10) . '        parts[parts.length] = {' . chr(10) . '            /* beginning of the part in the string */' . chr(10) . '            begin: part.index,' . chr(10) . '            /* end of the part in the string */' . chr(10) . '            end: part.index + part[0].length,' . chr(10) . '            /* force sign */' . chr(10) . '            sign: ( part[1] == ' . chr(39) . '+' . chr(39) . ' ),' . chr(10) . '            /* is the given data negative */' . chr(10) . '            negative: ( parseInt( list[paramIndex] ) < 0 ) ? true : false,' . chr(10) . '            /* padding character (default: <space>) */' . chr(10) . '            padding: ( part[2] == undefined )' . chr(10) . '                     ? ( ' . chr(39) . ' ' . chr(39) . ' ) /* default */' . chr(10) . '                     : ( ( part[2].substring( 0, 1 ) == "' . chr(39) . '" ) ' . chr(10) . '                         ? ( part[3] ) /* use special char */' . chr(10) . '                         : ( part[2] ) /* use normal <space> or zero */' . chr(10) . '                       ),' . chr(10) . '            /* should the output be aligned left?*/' . chr(10) . '            alignLeft: ( part[4] == ' . chr(39) . '-' . chr(39) . ' ),' . chr(10) . '            /* width specifier (number or false) */' . chr(10) . '            width: ( part[5] != undefined ) ? part[5] : false,' . chr(10) . '            /* precision specifier (number or false) */' . chr(10) . '            precision: ( part[7] != undefined ) ? part[7] : false,' . chr(10) . '            /* type specifier */' . chr(10) . '            type: part[8],' . chr(10) . '            /* the given data associated with this part converted to a string */' . chr(10) . '            data: ( part[8] != ' . chr(39) . '%' . chr(39) . ' ) ? String ( list[paramIndex++] ) : false' . chr(10) . '        };' . chr(10) . '    }' . chr(10) . chr(10) . '    var newString = "";' . chr(10) . '    var start = 0;' . chr(10) . '    // Generate our new formated string' . chr(10) . '    for( var i=0; i<parts.length; ++i ) {' . chr(10) . '        // Add first unformated string part' . chr(10) . '        newString += format.substring( start, parts[i].begin );' . chr(10) . '        ' . chr(10) . '        // Mark the new string start' . chr(10) . '        start = parts[i].end;' . chr(10) . chr(10) . '        // Create the appropriate preformat substitution' . chr(10) . '        // This substitution is only the correct type conversion. All the' . chr(10) . '        // different options and flags haven' . chr(39) . 't been applied to it at this' . chr(10) . '        // point' . chr(10) . '        var preSubstitution = "";' . chr(10) . '        switch ( parts[i].type ) {' . chr(10) . '            case ' . chr(39) . '%' . chr(39) . ':' . chr(10) . '                preSubstitution = "%";' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'b' . chr(39) . ':' . chr(10) . '                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 2 );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'c' . chr(39) . ':' . chr(10) . '                preSubstitution = String.fromCharCode( Math.abs( parseInt( parts[i].data ) ) );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'd' . chr(39) . ':' . chr(10) . '                preSubstitution = String( Math.abs( parseInt( parts[i].data ) ) );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'f' . chr(39) . ':' . chr(10) . '                preSubstitution = ( parts[i].precision == false )' . chr(10) . '                                  ? ( String( ( Math.abs( parseFloat( parts[i].data ) ) ) ) )' . chr(10) . '                                  : ( Math.abs( parseFloat( parts[i].data ) ).toFixed( parts[i].precision ) );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'o' . chr(39) . ':' . chr(10) . '                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 8 );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 's' . chr(39) . ':' . chr(10) . '                preSubstitution = parts[i].data.substring( 0, parts[i].precision ? parts[i].precision : parts[i].data.length ); /* Cut if precision is defined */' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'x' . chr(39) . ':' . chr(10) . '                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 16 ).toLowerCase();' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'X' . chr(39) . ':' . chr(10) . '                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 16 ).toUpperCase();' . chr(10) . '            break;' . chr(10) . '            default:' . chr(10) . '                throw ' . chr(39) . 'sprintf: Unknown type "' . chr(39) . ' + parts[i].type + ' . chr(39) . '" detected. This should never happen. Maybe the regex is wrong.' . chr(39) . ';' . chr(10) . '        }' . chr(10) . chr(10) . '        // The % character is a special type and does not need further processing' . chr(10) . '        if ( parts[i].type ==  "%" ) {' . chr(10) . '            newString += preSubstitution;' . chr(10) . '            continue;' . chr(10) . '        }' . chr(10) . chr(10) . '        // Modify the preSubstitution by taking sign, padding and width' . chr(10) . '        // into account' . chr(10) . chr(10) . '        // Pad the string based on the given width' . chr(10) . '        if ( parts[i].width != false ) {' . chr(10) . '            // Padding needed?' . chr(10) . '            if ( parts[i].width > preSubstitution.length ) ' . chr(10) . '            {' . chr(10) . '                var origLength = preSubstitution.length;' . chr(10) . '                for( var j = 0; j < parts[i].width - origLength; ++j ) ' . chr(10) . '                {' . chr(10) . '                    preSubstitution = ( parts[i].alignLeft == true ) ' . chr(10) . '                                      ? ( preSubstitution + parts[i].padding )' . chr(10) . '                                      : ( parts[i].padding + preSubstitution );' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . chr(10) . '        // Add a sign symbol if neccessary or enforced, but only if we are' . chr(10) . '        // not handling a string' . chr(10) . '        if ( parts[i].type == ' . chr(39) . 'b' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'd' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'o' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'f' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'x' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'X' . chr(39) . ' ) {' . chr(10) . '            if ( parts[i].negative == true ) {' . chr(10) . '                preSubstitution = "-" + preSubstitution;' . chr(10) . '            }' . chr(10) . '            else if ( parts[i].sign == true ) {' . chr(10) . '                preSubstitution = "+" + preSubstitution;' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . chr(10) . '        // Add the substitution to the new string' . chr(10) . '        newString += preSubstitution;' . chr(10) . '    }' . chr(10) . chr(10) . '    // Add the last part of the given format string, which may still be there' . chr(10) . '    newString += format.substring( start, format.length );' . chr(10) . chr(10) . '    return newString;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.printf = function(List__) {' . chr(10) . '    return CORE.print([ CORE.sprintf(List__) ]);' . chr(10) . '};' . chr(10) . chr(10)))
};
1;

;

# use Perlito5::Javascript2::Sprintf
;
package main;
undef();

# use Perlito5::AST
;

# use Perlito5::Dumper
;

# use feature
;
package Perlito5::Javascript3;
{
    my $label_count = 100;
    my %label;
    sub Perlito5::Javascript3::pkg {
        ('p5pkg["' . $Perlito5::PKG_NAME . '"]')
    };
    sub Perlito5::Javascript3::pkg_new_var {
        $label{$Perlito5::PKG_NAME} = ('p5' . ($label_count)++)
    };
    sub Perlito5::Javascript3::get_label {
        ($label_count)++
    };
    sub Perlito5::Javascript3::tab {
        my $level = shift();
        join("", chr(9) x $level)
    };
    our %op_prefix_js_str = ('prefix:<-A>', 'p5atime', 'prefix:<-C>', 'p5ctime', 'prefix:<-M>', 'p5mtime', 'prefix:<-d>', 'p5is_directory', 'prefix:<-e>', 'p5file_exists', 'prefix:<-f>', 'p5is_file', 'prefix:<-s>', 'p5size');
    our %op_infix_js_str = ('infix:<eq>', ' == ', 'infix:<ne>', ' != ', 'infix:<le>', ' <= ', 'infix:<ge>', ' >= ', 'infix:<lt>', ' < ', 'infix:<gt>', ' > ');
    our %op_infix_js_num = ('infix:<==>', ' == ', 'infix:<!=>', ' != ', 'infix:<+>', ' + ', 'infix:<->', ' - ', 'infix:<*>', ' * ', 'infix:</>', ' / ', 'infix:<%>', ' % ', 'infix:<>>', ' > ', 'infix:<<>', ' < ', 'infix:<>=>', ' >= ', 'infix:<<=>', ' <= ', 'infix:<&>', ' & ', 'infix:<|>', ' | ', 'infix:<^>', ' ^ ', 'infix:<>>>', ' >>> ', 'infix:<<<>', ' << ');
    our %op_to_bool = map(+(($_, 1)), ('prefix:<!>', 'infix:<!=>', 'infix:<==>', 'infix:<<=>', 'infix:<>=>', 'infix:<>>', 'infix:<<>', 'infix:<eq>', 'infix:<ne>', 'infix:<ge>', 'infix:<le>', 'infix:<gt>', 'infix:<lt>', 'prefix:<not>', 'exists', 'defined'));
    our %op_to_str = map(+(($_, 1)), ('substr', 'join', 'list:<.>', 'chr'));
    our %op_to_num = map(+(($_, 1)), ('length', 'index', 'ord', 'oct', 'infix:<->', 'infix:<+>', 'infix:<*>', 'infix:</>', 'infix:<%>', 'infix:<**>'));
    my %safe_char = (' ', 1, '!', 1, '"', 1, '#', 1, '$', 1, '%', 1, '&', 1, '(', 1, ')', 1, '*', 1, '+', 1, ',', 1, '-', 1, '.', 1, '/', 1, ':', 1, ';', 1, '<', 1, '=', 1, '>', 1, '?', 1, '@', 1, '[', 1, ']', 1, '^', 1, '_', 1, '`', 1, '{', 1, '|', 1, '}', 1, '~', 1);
    sub Perlito5::Javascript3::escape_string {
        my $s = shift();
        my @out;
        my $tmp = '';
        return chr(39) . chr(39) if ($s eq '');
        for my  $i ((0 .. (length($s) - 1))) {
            my $c = substr($s, $i, 1);
            if ((((((($c ge 'a') && ($c le 'z'))) || ((($c ge 'A') && ($c le 'Z')))) || ((($c ge '0') && ($c le '9')))) || exists($safe_char{$c}))) {
                $tmp = ($tmp . $c)
            }
            else {
                push(@out, (chr(39) . $tmp . chr(39))) if ($tmp ne '');
                push(@out, ('String.fromCharCode(' . ord($c) . ')'));
                $tmp = ''
            }
        };
        push(@out, (chr(39) . $tmp . chr(39))) if ($tmp ne '');
        return join(' + ', @out)
    };
    sub Perlito5::Javascript3::to_str {
        my $cond = shift();
        my $level = shift();
        my $wantarray = 'scalar';
        if (((($cond->isa('Perlito5::AST::Apply') && ($cond->code() eq 'circumfix:<( )>')) && $cond->{'arguments'}) && @{$cond->{'arguments'}})) {
            return to_str($cond->{'arguments'}->[0], $level)
        };
        if ((($cond->isa('Perlito5::AST::Val::Buf')) || (($cond->isa('Perlito5::AST::Apply') && exists($op_to_str{$cond->code()}))))) {
            return $cond->emit_javascript3($level, $wantarray)
        }
        else {
            return ('p5str(' . $cond->emit_javascript3($level, $wantarray) . ')')
        }
    };
    sub Perlito5::Javascript3::to_num {
        my $cond = shift();
        my $level = shift();
        my $wantarray = 'scalar';
        if ((($cond->isa('Perlito5::AST::Val::Int') || $cond->isa('Perlito5::AST::Val::Num')) || (($cond->isa('Perlito5::AST::Apply') && exists($op_to_num{$cond->code()}))))) {
            return $cond->emit_javascript3($level, $wantarray)
        }
        else {
            return ('p5num(' . $cond->emit_javascript3($level, $wantarray) . ')')
        }
    };
    sub Perlito5::Javascript3::to_bool {
        my $cond = shift();
        my $level = shift();
        my $wantarray = 'scalar';
        if (((($cond->isa('Perlito5::AST::Apply') && ($cond->code() eq 'circumfix:<( )>')) && $cond->{'arguments'}) && @{$cond->{'arguments'}})) {
            return to_bool($cond->{'arguments'}->[0], $level)
        };
        if (($cond->isa('Perlito5::AST::Apply') && ((($cond->code() eq 'infix:<&&>') || ($cond->code() eq 'infix:<and>'))))) {
            return ('(' . to_bool($cond->{'arguments'}->[0], $level) . ' && ' . to_bool($cond->{'arguments'}->[1], $level) . ')')
        };
        if (($cond->isa('Perlito5::AST::Apply') && ((($cond->code() eq 'infix:<||>') || ($cond->code() eq 'infix:<or>'))))) {
            return ('(' . to_bool($cond->{'arguments'}->[0], $level) . ' || ' . to_bool($cond->{'arguments'}->[1], $level) . ')')
        };
        if (((($cond->isa('Perlito5::AST::Val::Int')) || ($cond->isa('Perlito5::AST::Val::Num'))) || (($cond->isa('Perlito5::AST::Apply') && exists($op_to_bool{$cond->code()}))))) {
            return $cond->emit_javascript3($level, $wantarray)
        }
        else {
            return ('p5bool(' . $cond->emit_javascript3($level, $wantarray) . ')')
        }
    };
    sub Perlito5::Javascript3::is_scalar {
        (((((!($_[0]->isa('Perlito5::AST::Val::Int')) && !($_[0]->isa('Perlito5::AST::Val::Num'))) && !($_[0]->isa('Perlito5::AST::Val::Buf'))) && !($_[0]->isa('Perlito5::AST::Sub'))) && !((($_[0]->isa('Perlito5::AST::Var') && ($_[0]->{'sigil'} eq '$'))))) && !((($_[0]->isa('Perlito5::AST::Apply') && ((((exists($op_to_str{$_[0]->{'code'}}) || exists($op_to_num{$_[0]->{'code'}})) || exists($op_to_bool{$_[0]->{'code'}})) || ($_[0]->{'code'} eq 'prefix:<' . chr(92) . '>')))))))
    };
    sub Perlito5::Javascript3::to_value {
        my $v = shift();
        my $level = shift();
        my $wantarray = shift();
        return (!($v) ? 'null' : (($v->isa('Perlito5::AST::Var') && ($v->sigil() eq '$')) ? ($v->emit_javascript3($level, $wantarray) . '.FETCH()') : $v->emit_javascript3($level, $wantarray)))
    };
    sub Perlito5::Javascript3::to_list {
        my $items = to_list_preprocess($_[0]);
        my $level = $_[1];
        my $literal_type = ($_[2] || 'array');
        my $wantarray = 'list';
        my $interpolate = 0;
        for (@{$items}) {
            $interpolate = 1 if is_scalar($_)
        };
        if (($literal_type eq 'hash')) {
            if (!($interpolate)) {
                my @out;
                my $printable = 1;
                my @in = @{$items};
                for ( ; @in; {

                    } ) {
                    my $k = shift(@in);
                    my $v = shift(@in);
                    $k = $k->emit_javascript3($level, 0);
                    $printable = 0 if ($k =~ m![ \[]!);
                    $v = to_value($v, $level, $wantarray);
                    push(@out, ($k . ' : ' . $v))
                };
                return ('{' . join(', ', @out) . '}') if $printable
            };
            return ('p5a_to_h(' . to_list($items, $level, 'array') . ')')
        };
        ($interpolate ? (('p5list_to_a(' . join(', ', map($_->emit_javascript3($level, $wantarray), @{$items})) . ')')) : (('[' . join(', ', map(to_value($_, $level, $wantarray), @{$items})) . ']')))
    };
    sub Perlito5::Javascript3::to_list_preprocess {
        my @items;
        for my  $item (@{$_[0]}) {
            if (($item->isa('Perlito5::AST::Apply') && (((($item->code() eq 'circumfix:<( )>') || ($item->code() eq 'list:<,>')) || ($item->code() eq 'infix:<=>>'))))) {
                if (($item->isa('Perlito5::AST::Apply') && ($item->code() eq 'infix:<=>>'))) {
                    $item->{'arguments'}->[0] = Perlito5::AST::Lookup->autoquote($item->{'arguments'}->[0])
                };
                for my  $arg (@{to_list_preprocess($item->arguments())}) {
                    push(@items, $arg)
                }
            }
            else {
                push(@items, $item)
            }
        };
        return \@items
    };
    sub Perlito5::Javascript3::to_scalar {
        my $items = to_scalar_preprocess($_[0]);
        my $level = $_[1];
        my $wantarray = 'scalar';
        (@{$items} ? ('(' . join(', ', map($_->emit_javascript3($level, $wantarray), @{$items})) . ')') : 'null')
    };
    sub Perlito5::Javascript3::to_scalar_preprocess {
        my @items;
        for my  $item (@{$_[0]}) {
            if (($item->isa('Perlito5::AST::Apply') && ((($item->code() eq 'list:<,>') || ($item->code() eq 'infix:<=>>'))))) {
                if (($item->isa('Perlito5::AST::Apply') && ($item->code() eq 'infix:<=>>'))) {
                    $item->{'arguments'}->[0] = Perlito5::AST::Lookup->autoquote($item->{'arguments'}->[0])
                };
                for my  $arg (@{to_scalar_preprocess($item->arguments())}) {
                    push(@items, $arg)
                }
            }
            else {
                push(@items, $item)
            }
        };
        return \@items
    };
    sub Perlito5::Javascript3::to_runtime_context {
        my $items = to_scalar_preprocess($_[0]);
        my $level = $_[1];
        my $wantarray = 'runtime';
        return $items->[0]->emit_javascript3($level, $wantarray) if ((@{$items} == 1) && is_scalar($items->[0]));
        ('p5context(' . '[' . join(', ', map($_->emit_javascript3($level, $wantarray), @{$items})) . ']' . ', p5want)')
    };
    sub Perlito5::Javascript3::autoquote {
        my $index = shift();
        my $level = shift();
        if (($index->isa('Perlito5::AST::Apply') && $index->{'bareword'})) {
            my $full_name = ((($index->{'namespace'} ? ($index->{'namespace'} . '::') : '')) . $index->{'code'});
            if (!(exists($Perlito5::PROTO->{$full_name}))) {
                $index = Perlito5::AST::Val::Buf->new('buf', $full_name)
            }
        };
        return to_str($index, $level)
    };
    sub Perlito5::Javascript3::emit_javascript3_autovivify {
        my $obj = shift();
        my $level = shift();
        my $type = shift();
        my $wantarray = 'scalar';
        return $obj->emit_javascript3($level, $wantarray, $type)
    };
    sub Perlito5::Javascript3::emit_function_javascript3 {
        my $level = shift();
        my $wantarray = shift();
        my $argument = shift();
        if (($argument->isa('Perlito5::AST::Apply') && ($argument->code() eq 'return'))) {
            return ('function () { ' . $argument->emit_javascript3($level, $wantarray) . ' }')
        };
        return ('function () { return ' . $argument->emit_javascript3($level, $wantarray) . ' }')
    }
};
package Perlito5::Javascript3::LexicalBlock;
{
    sub Perlito5::Javascript3::LexicalBlock::new {
        my $class = shift();
        bless({@_}, $class)
    };
    sub Perlito5::Javascript3::LexicalBlock::block {
        $_[0]->{'block'}
    };
    sub Perlito5::Javascript3::LexicalBlock::needs_return {
        $_[0]->{'needs_return'}
    };
    sub Perlito5::Javascript3::LexicalBlock::top_level {
        $_[0]->{'top_level'}
    };
    sub Perlito5::Javascript3::LexicalBlock::has_decl {
        my $self = $_[0];
        my $type = $_[1];
        for my  $decl (@{$self->{'block'}}) {
            if (defined($decl)) {
                if ((($decl->isa('Perlito5::AST::Decl') && ($decl->decl() eq $type)) || ($decl->isa('Perlito5::AST::Apply') && ($decl->code() eq $type)))) {
                    return 1
                };
                if (($decl->isa('Perlito5::AST::Apply') && ($decl->code() eq 'infix:<=>'))) {
                    my $var = $decl->arguments()->[0];
                    if ((($var->isa('Perlito5::AST::Decl') && ($var->decl() eq $type)) || ($decl->isa('Perlito5::AST::Apply') && ($decl->code() eq $type)))) {
                        return 1
                    }
                }
            }
        };
        return 0
    };
    sub Perlito5::Javascript3::LexicalBlock::emit_javascript3 {
        my $self = shift();
        my $level = shift();
        my $wantarray = shift();
        my @block;
        for (@{$self->{'block'}}) {
            if (defined($_)) {
                push(@block, $_)
            }
        };
        if (!(@block)) {
            return (Perlito5::Javascript3::tab($level) . 'null;')
        };
        my $out = '';
        my @str;
        my $has_local = $self->has_decl('local');
        my $create_context = ($self->{'create_context'} && $self->has_decl('my'));
        my $outer_pkg = $Perlito5::PKG_NAME;
        my $outer_throw = $Perlito5::THROW;
        unshift(@{$Perlito5::VAR}, {});
        $Perlito5::THROW = 0 if $self->{'top_level'};
        $out = ($out . (Perlito5::Javascript3::tab($level) . 'var local_idx = p5LOCAL.length;' . chr(10))) if $has_local;
        if ($self->{'top_level'}) {
            ($level)++
        };
        if ($create_context) {
            $out = ($out . (Perlito5::Javascript3::tab($level) . '(function () {' . chr(10)));
            ($level)++
        };
        my $tab = Perlito5::Javascript3::tab($level);
        my $last_statement;
        if ($self->{'needs_return'}) {
            $last_statement = pop(@block)
        };
        for my  $decl (@block) {
            if (((ref($decl) eq 'Perlito5::AST::Apply') && ($decl->code() eq 'package'))) {
                $Perlito5::PKG_NAME = $decl->{'namespace'};
                $Perlito5::VAR->[0]->{'$_'} = {'decl', 'our', 'namespace', $Perlito5::PKG_NAME};
                $Perlito5::VAR->[0]->{'$a'} = {'decl', 'our', 'namespace', $Perlito5::PKG_NAME};
                $Perlito5::VAR->[0]->{'$b'} = {'decl', 'our', 'namespace', $Perlito5::PKG_NAME};
                $Perlito5::VAR->[0]->{'$AUTOLOAD'} = {'decl', 'our', 'namespace', $Perlito5::PKG_NAME}
            };
            if ($decl->isa('Perlito5::AST::Decl')) {
                push(@str, $decl->emit_javascript3_init())
            };
            if (($decl->isa('Perlito5::AST::Apply') && ($decl->code() eq 'my'))) {
                for (@{$decl->{'arguments'}}) {
                    if ($_->isa('Perlito5::AST::Var')) {
                        my $d = Perlito5::AST::Decl->new('decl', $decl->code(), 'var', $_);
                        push(@str, $d->emit_javascript3_init())
                    }
                }
            };
            if (($decl->isa('Perlito5::AST::Apply') && ($decl->code() eq 'infix:<=>'))) {
                my $arg = $decl->{'arguments'}->[0];
                if ($arg->isa('Perlito5::AST::Decl')) {
                    push(@str, $arg->emit_javascript3_init())
                };
                if (($arg->isa('Perlito5::AST::Apply') && ($arg->code() eq 'my'))) {
                    for (@{$arg->{'arguments'}}) {
                        if ($_->isa('Perlito5::AST::Var')) {
                            my $d = Perlito5::AST::Decl->new('decl', $arg->code(), 'var', $_);
                            push(@str, $d->emit_javascript3_init())
                        }
                    }
                }
            };
            if (!((($decl->isa('Perlito5::AST::Decl') && ($decl->decl() eq 'my'))))) {
                push(@str, ($decl->emit_javascript3($level, 'void') . ';'))
            }
        };
        if (($self->{'needs_return'} && $last_statement)) {
            if ($last_statement->isa('Perlito5::AST::Decl')) {
                push(@str, $last_statement->emit_javascript3_init())
            };
            if (($last_statement->isa('Perlito5::AST::Apply') && ($last_statement->code() eq 'infix:<=>'))) {
                if ($last_statement->{'arguments'}->[0]->isa('Perlito5::AST::Decl')) {
                    push(@str, $last_statement->{'arguments'}->[0]->emit_javascript3_init())
                }
            };
            if (((($last_statement->isa('Perlito5::AST::Apply') && ($last_statement->code() eq 'return')) && $self->{'top_level'}) && @{$last_statement->{'arguments'}})) {
                $last_statement = $last_statement->{'arguments'}->[0]
            };
            if ($last_statement->isa('Perlito5::AST::If')) {
                my $cond = $last_statement->cond();
                my $body = $last_statement->body();
                my $otherwise = $last_statement->otherwise();
                $body = Perlito5::Javascript3::LexicalBlock->new('block', $body->stmts(), 'needs_return', 1);
                push(@str, ('if ( ' . Perlito5::Javascript3::to_bool($cond, ($level + 1)) . ' ) {' . chr(10) . $body->emit_javascript3(($level + 1)) . chr(10) . Perlito5::Javascript3::tab($level) . '}'));
                if ($otherwise) {
                    $otherwise = Perlito5::Javascript3::LexicalBlock->new('block', $otherwise->stmts(), 'needs_return', 1);
                    push(@str, (chr(10) . Perlito5::Javascript3::tab($level) . 'else {' . chr(10) . $otherwise->emit_javascript3(($level + 1)) . chr(10) . Perlito5::Javascript3::tab($level) . '}'))
                }
            }
            else {
                if ($last_statement->isa('Perlito5::AST::Lit::Block')) {
                    my $body = Perlito5::Javascript3::LexicalBlock->new('block', $last_statement->{'stmts'}, 'needs_return', 1);
                    push(@str, ('for (var i_ = 0; i_ < 1 ; i_++) {' . chr(10) . $body->emit_javascript3(($level + 1)) . chr(10) . Perlito5::Javascript3::tab($level) . '}'))
                }
                else {
                    if (((($last_statement->isa('Perlito5::AST::For') || $last_statement->isa('Perlito5::AST::While')) || ($last_statement->isa('Perlito5::AST::Apply') && ($last_statement->code() eq 'goto'))) || ($last_statement->isa('Perlito5::AST::Apply') && ($last_statement->code() eq 'return')))) {
                        push(@str, $last_statement->emit_javascript3($level, 'runtime'))
                    }
                    else {
                        if ($has_local) {
                            push(@str, ('return p5cleanup_local(local_idx, (' . Perlito5::Javascript3::to_runtime_context([$last_statement], $level) . '));'))
                        }
                        else {
                            push(@str, ('return (' . Perlito5::Javascript3::to_runtime_context([$last_statement], $level) . ');'))
                        }
                    }
                }
            }
        };
        if ($has_local) {
            push(@str, 'p5cleanup_local(local_idx, null);')
        };
        if ($create_context) {
            ($level)--;
            push(@str, '})();')
        };
        if (($self->{'top_level'} && $Perlito5::THROW)) {
            ($level)--;
            $out = ($out . (Perlito5::Javascript3::tab($level) . 'try {' . chr(10) . join(chr(10), map(($tab . $_), @str)) . chr(10) . Perlito5::Javascript3::tab($level) . '}' . chr(10) . Perlito5::Javascript3::tab($level) . 'catch(err) {' . chr(10) . Perlito5::Javascript3::tab(($level + 1)) . 'if ( err instanceof Error ) {' . chr(10) . Perlito5::Javascript3::tab(($level + 2)) . 'throw(err);' . chr(10) . Perlito5::Javascript3::tab(($level + 1)) . '}' . chr(10) . Perlito5::Javascript3::tab(($level + 1)) . 'else {' . chr(10) . Perlito5::Javascript3::tab(($level + 2)) . (($has_local ? 'return p5cleanup_local(local_idx, err)' : 'return(err)')) . ';' . chr(10) . Perlito5::Javascript3::tab(($level + 1)) . '}' . chr(10) . Perlito5::Javascript3::tab($level) . '}'))
        }
        else {
            $out = ($out . join(chr(10), map(($tab . $_), @str)))
        };
        $Perlito5::PKG_NAME = $outer_pkg;
        $Perlito5::THROW = $outer_throw if $self->{'top_level'};
        shift(@{$Perlito5::VAR});
        return $out
    }
};
package Perlito5::AST::CompUnit;
{
    sub Perlito5::AST::CompUnit::emit_javascript3 {
        my $self = $_[0];
        my $level = $_[1];
        my $str = ('(function () {' . chr(10) . Perlito5::Javascript3::LexicalBlock->new('block', $self->{'body'}, 'needs_return', 0)->emit_javascript3(($level + 1)) . chr(10) . Perlito5::Javascript3::tab($level) . '})()' . chr(10));
        return $str
    };
    sub Perlito5::AST::CompUnit::emit_javascript3_program {
        my $comp_units = shift();
        $Perlito5::PKG_NAME = 'main';
        my $str = ('' . 'var p5want = null;' . chr(10) . 'var ' . Perlito5::Javascript3::pkg_new_var() . ' = p5pkg[' . chr(39) . $Perlito5::PKG_NAME . chr(39) . '];' . chr(10));
        $Perlito5::VAR = [{'@_', {'decl', 'my'}, '$@', {'decl', 'our', 'namespace', 'main'}, '$|', {'decl', 'our', 'namespace', 'main'}, '$^O', {'decl', 'our', 'namespace', 'main'}, '%ENV', {'decl', 'our', 'namespace', 'main'}, '%INC', {'decl', 'our', 'namespace', 'main'}, '@#', {'decl', 'our', 'namespace', 'main'}, '@ARGV', {'decl', 'our', 'namespace', 'main'}, '@INC', {'decl', 'our', 'namespace', 'main'}, '$_', {'decl', 'our', 'namespace', $Perlito5::PKG_NAME}, '$a', {'decl', 'our', 'namespace', $Perlito5::PKG_NAME}, '$b', {'decl', 'our', 'namespace', $Perlito5::PKG_NAME}, '$AUTOLOAD', {'decl', 'our', 'namespace', $Perlito5::PKG_NAME}}];
        for my  $comp_unit (@{$comp_units}) {
            $str = ($str . $comp_unit->emit_javascript3() . chr(10))
        };
        return $str
    }
};
package Perlito5::AST::Val::Int;
{
    sub Perlito5::AST::Val::Int::emit_javascript3 {
        my $self = shift();
        my $level = shift();
        $self->{'int'}
    }
};
package Perlito5::AST::Val::Num;
{
    sub Perlito5::AST::Val::Num::emit_javascript3 {
        my $self = shift();
        my $level = shift();
        $self->{'num'}
    }
};
package Perlito5::AST::Val::Buf;
{
    sub Perlito5::AST::Val::Buf::emit_javascript3 {
        my $self = shift();
        my $level = shift();
        Perlito5::Javascript3::escape_string($self->{'buf'})
    }
};
package Perlito5::AST::Lit::Block;
{
    sub Perlito5::AST::Lit::Block::emit_javascript3 {
        my $self = shift();
        my $level = shift();
        my $init = '';
        if (($self->{'name'} eq 'INIT')) {
            my $tmp = ('p5pkg.main._tmp' . Perlito5::Javascript3::get_label());
            $init = (Perlito5::Javascript3::tab(($level + 2)) . ('if (' . $tmp . ') { return }; ' . $tmp . ' = 1;' . chr(10)))
        };
        return ('p5for_lex(' . 'function () {' . chr(10) . $init . (Perlito5::Javascript3::LexicalBlock->new('block', $self->{'stmts'}, 'needs_return', 0, 'top_level', 0))->emit_javascript3(($level + 2)) . chr(10) . Perlito5::Javascript3::tab(($level + 1)) . '}, ' . '[0], ' . $self->emit_javascript3_continue($level) . ', ' . '"' . (($self->{'label'} || '')) . '"' . ')')
    };
    sub Perlito5::AST::Lit::Block::emit_javascript3_continue {
        my $self = shift();
        my $level = shift();
        if ((!($self->{'continue'}) || !(@{$self->{'continue'}->{'stmts'}}))) {
            return 'false'
        };
        return ('function () {' . chr(10) . (Perlito5::Javascript3::LexicalBlock->new('block', $self->{'continue'}->stmts(), 'needs_return', 0, 'top_level', 0))->emit_javascript3(($level + 2)) . chr(10) . Perlito5::Javascript3::tab(($level + 1)) . '}')
    }
};
package Perlito5::AST::Index;
{
    sub Perlito5::AST::Index::emit_javascript3 {
        my $self = shift();
        my $level = shift();
        my $wantarray = shift();
        my $type = shift();
        $type = ($type ? ('"' . $type . '"') : 'null');
        if (($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '$'))) {
            my $v = Perlito5::AST::Var->new('sigil', '@', 'namespace', $self->{'obj'}->namespace(), 'name', $self->{'obj'}->name());
            return ($v->emit_javascript3($level) . '.aget(' . Perlito5::Javascript3::to_num($self->{'index_exp'}, $level) . ', ' . $type . ')')
        };
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && ($self->{'obj'}->{'code'} eq 'prefix:<$>'))) {
            return (Perlito5::Javascript3::emit_javascript3_autovivify($self->{'obj'}->{'arguments'}->[0], $level, 'array') . '.aget(' . Perlito5::Javascript3::to_num($self->{'index_exp'}) . ', ' . $type . ')')
        };
        return (Perlito5::Javascript3::emit_javascript3_autovivify($self->{'obj'}, $level, 'array') . '.aget(' . Perlito5::Javascript3::to_num($self->{'index_exp'}, $level) . ', ' . $type . ')')
    };
    sub Perlito5::AST::Index::emit_javascript3_set {
        my $self = shift();
        my $arguments = shift();
        my $level = shift();
        if (($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '$'))) {
            my $v = Perlito5::AST::Var->new('sigil', '@', 'namespace', $self->{'obj'}->namespace(), 'name', $self->{'obj'}->name());
            return ($v->emit_javascript3($level) . '.aset(' . Perlito5::Javascript3::to_num($self->{'index_exp'}, ($level + 1)) . ', ' . Perlito5::Javascript3::to_scalar([$arguments], ($level + 1)) . ')')
        };
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && ($self->{'obj'}->{'code'} eq 'prefix:<$>'))) {
            return (Perlito5::Javascript3::emit_javascript3_autovivify($self->{'obj'}->{'arguments'}->[0], $level, 'array') . '.aset(' . Perlito5::Javascript3::to_num($self->{'index_exp'}) . ', ' . Perlito5::Javascript3::to_scalar([$arguments], ($level + 1)) . ')')
        };
        return (Perlito5::Javascript3::emit_javascript3_autovivify($self->{'obj'}, $level, 'array') . '.aset(' . Perlito5::Javascript3::to_num($self->{'index_exp'}, ($level + 1)) . ', ' . Perlito5::Javascript3::to_scalar([$arguments], ($level + 1)) . ')')
    }
};
package Perlito5::AST::Lookup;
{
    sub Perlito5::AST::Lookup::emit_javascript3 {
        my $self = shift();
        my $level = shift();
        my $wantarray = shift();
        my $type = shift();
        $type = ($type ? ('"' . $type . '"') : 'null');
        if (($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '$'))) {
            my $v = Perlito5::AST::Var->new('sigil', '%', 'namespace', $self->{'obj'}->namespace(), 'name', $self->{'obj'}->name());
            return (Perlito5::Javascript3::emit_javascript3_autovivify($v, $level, 'hash') . '.hget(' . Perlito5::Javascript3::autoquote($self->{'index_exp'}, $level) . ', ' . $type . ')')
        };
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && ($self->{'obj'}->{'code'} eq 'prefix:<$>'))) {
            return (Perlito5::Javascript3::emit_javascript3_autovivify($self->{'obj'}->{'arguments'}->[0], $level, 'hash') . '.hget(' . Perlito5::Javascript3::autoquote($self->{'index_exp'}, $level, 'list') . ', ' . $type . ')')
        };
        (Perlito5::Javascript3::emit_javascript3_autovivify($self->{'obj'}, $level, 'hash') . '.hget(' . Perlito5::Javascript3::autoquote($self->{'index_exp'}, $level) . ', ' . $type . ')')
    };
    sub Perlito5::AST::Lookup::emit_javascript3_set {
        my $self = shift();
        my $arguments = shift();
        my $level = shift();
        if (($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '$'))) {
            my $v = Perlito5::AST::Var->new('sigil', '%', 'namespace', $self->{'obj'}->namespace(), 'name', $self->{'obj'}->name());
            return ($v->emit_javascript3($level) . '.hset(' . Perlito5::Javascript3::autoquote($self->{'index_exp'}, $level) . ', ' . Perlito5::Javascript3::to_scalar([$arguments], ($level + 1)) . ')')
        };
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && ($self->{'obj'}->{'code'} eq 'prefix:<$>'))) {
            return (Perlito5::Javascript3::emit_javascript3_autovivify($self->{'obj'}->{'arguments'}->[0], $level, 'hash') . '.hset(' . Perlito5::Javascript3::autoquote($self->{'index_exp'}, $level, 'list') . ', ' . Perlito5::Javascript3::to_scalar([$arguments], ($level + 1)) . ')')
        };
        (Perlito5::Javascript3::emit_javascript3_autovivify($self->{'obj'}, $level, 'hash') . '.hset(' . Perlito5::Javascript3::autoquote($self->{'index_exp'}, $level) . ', ' . Perlito5::Javascript3::to_scalar([$arguments], ($level + 1)) . ')')
    }
};
package Perlito5::AST::Var;
{
    my $table = {'$', 'v_', '@', 'List_', '%', 'Hash_', '&', ''};
    sub Perlito5::AST::Var::emit_javascript3 {
        my $self = shift();
        my $level = shift();
        my $wantarray = shift();
        my $str_name = $self->{'name'};
        $str_name = chr(92) . chr(92) if ($str_name eq chr(92));
        $str_name = chr(92) . '"' if ($str_name eq '"');
        my $perl5_name = $self->perl5_name();
        my $decl_type;
        my $decl = $self->perl5_get_decl($perl5_name);
        if ($decl) {
            $decl_type = $decl->{'decl'}
        }
        else {
            if ((!($self->{'namespace'}) && ($self->{'sigil'} ne '*'))) {
                if ($Perlito5::STRICT) {
                    die(('Global symbol "' . $perl5_name . '" requires explicit package name'))
                };
                $self->{'namespace'} = $Perlito5::PKG_NAME
            }
        };
        if (($self->{'sigil'} eq '@')) {
            if (($wantarray eq 'scalar')) {
                return ($self->emit_javascript3($level, 'list') . '.FETCHSIZE()')
            };
            if (($wantarray eq 'runtime')) {
                return ('(p5want' . ' ? ' . $self->emit_javascript3($level, 'list') . ' : ' . $self->emit_javascript3($level, 'list') . '.FETCHSIZE()' . ')')
            }
        };
        if (($self->{'sigil'} eq '&')) {
            return ('p5pkg["' . (($self->{'namespace'} || $Perlito5::PKG_NAME)) . '"]["' . $str_name . '"]')
        };
        if (($self->{'sigil'} eq '*')) {
            return ('p5pkg["' . (($self->{'namespace'} || $Perlito5::PKG_NAME)) . '"]["' . $str_name . '"]')
        };
        if (($decl_type eq 'our')) {
            my $sigil = (($self->{'sigil'} eq '$#') ? '@' : $self->{'sigil'});
            my $s = ('p5pkg["' . (($self->{'namespace'} || $decl->{'namespace'})) . '"]["' . $table->{$sigil} . $str_name . '"]');
            if (($self->{'sigil'} eq '$#')) {
                return ('(' . $s . '.FETCHSIZE() - 1)')
            };
            return $s
        };
        my $ns = '';
        if ($self->{'namespace'}) {
            {
                if (($self->{'sigil'} eq '$#')) {
                    return ('(p5global("@", "' . $self->{'namespace'} . '", "' . $str_name . '").FETCHSIZE() - 1)')
                };
                return ('p5global("' . $self->{'sigil'} . '", "' . $self->{'namespace'} . '", "' . $str_name . '")')
            }
        };
        if (($self->{'sigil'} eq '$#')) {
            return ('(' . $ns . $table->{'@'} . $str_name . '.FETCHSIZE() - 1)')
        };
        ($ns . $table->{$self->{'sigil'}} . $str_name)
    };
    sub Perlito5::AST::Var::perl5_name {
        my $self = shift();
        my $sigil = $self->{'sigil'};
        $sigil = '@' if ($sigil eq '$#');
        ($sigil . (($self->{'namespace'} ? ($self->{'namespace'} . '::') : '')) . $self->{'name'})
    };
    sub Perlito5::AST::Var::perl5_get_decl {
        my $self = shift();
        my $perl5_name = shift();
        for (@{$Perlito5::VAR}) {
            return $_->{$perl5_name} if exists($_->{$perl5_name})
        };
        return undef()
    }
};
package Perlito5::AST::Decl;
{
    sub Perlito5::AST::Decl::emit_javascript3 {
        my $self = shift();
        my $level = shift();
        $self->{'var'}->emit_javascript3($level)
    };
    sub Perlito5::AST::Decl::emit_javascript3_init {
        my $self = shift();
        my $env = {'decl', $self->{'decl'}};
        my $perl5_name = $self->{'var'}->perl5_name();
        if (($self->{'decl'} ne 'my')) {
            die(('No package name allowed for variable ' . $perl5_name . ' in "our"')) if (($self->{'decl'} eq 'our') && $self->{'var'}->{'namespace'});
            if (($self->{'var'}->{'namespace'} eq '')) {
                my $decl_namespace = '';
                my $decl = $self->{'var'}->perl5_get_decl($perl5_name);
                if (((($self->{'decl'} eq 'local') && $decl) && ((($decl->{'decl'} eq 'our') || ($decl->{'decl'} eq 'local'))))) {
                    $decl_namespace = $decl->{'namespace'}
                };
                $env->{'namespace'} = ($decl_namespace || $Perlito5::PKG_NAME)
            }
        };
        $Perlito5::VAR->[0]->{$perl5_name} = $env;
        if (($self->{'decl'} eq 'my')) {
            my $str = '';
            $str = ($str . 'var ' . $self->{'var'}->emit_javascript3() . ' = ');
            if (($self->{'var'}->sigil() eq '%')) {
                $str = ($str . 'new p5Hash({});')
            }
            else {
                if (($self->{'var'}->sigil() eq '@')) {
                    $str = ($str . 'new p5Array([]);')
                }
                else {
                    $str = ($str . 'new p5Scalar(null);')
                }
            };
            return $str
        }
        else {
            if (($self->{'decl'} eq 'our')) {
                my $str_name = $self->{'var'}->{'name'};
                $str_name = chr(92) . chr(92) if ($str_name eq chr(92));
                $str_name = chr(92) . '"' if ($str_name eq '"');
                return ('p5global("' . $self->{'var'}->{'sigil'} . '", ' . '"' . (($self->{'var'}->{'namespace'} || $Perlito5::PKG_NAME)) . '", ' . '"' . $str_name . '")')
            }
            else {
                if (($self->{'decl'} eq 'local')) {
                    my $perl5_name = $self->{'var'}->perl5_name();
                    my $decl_namespace = '';
                    my $decl = $self->{'var'}->perl5_get_decl($perl5_name);
                    if (($decl && ((($decl->{'decl'} eq 'our') || ($decl->{'decl'} eq 'local'))))) {
                        $decl_namespace = $decl->{'namespace'}
                    };
                    my $ns = ('p5pkg["' . ((($self->{'var'}->{'namespace'} || $decl_namespace) || $Perlito5::PKG_NAME)) . '"]');
                    return ('p5set_local(' . $ns . ',' . Perlito5::Javascript3::escape_string($self->{'var'}->{'name'}) . ',' . Perlito5::Javascript3::escape_string($self->{'var'}->{'sigil'}) . '); ')
                }
                else {
                    if (($self->{'decl'} eq 'state')) {
                        return ('// state ' . $self->{'var'}->emit_javascript3())
                    }
                    else {
                        die(('not implemented: Perlito5::AST::Decl ' . chr(39) . $self->{'decl'} . chr(39)))
                    }
                }
            }
        }
    }
};
package Perlito5::AST::Proto;
{
    sub Perlito5::AST::Proto::emit_javascript3 {
        my $self = shift();
        my $level = shift();
        return Perlito5::Javascript3::pkg() if ($self->{'name'} eq '__PACKAGE__');
        ('p5pkg["' . $self->{'name'} . '"]')
    }
};
package Perlito5::AST::Call;
{
    sub Perlito5::AST::Call::emit_javascript3 {
        my $self = shift();
        my $level = shift();
        my $wantarray = shift();
        my $type = shift();
        $type = ($type ? ('"' . $type . '"') : 'null');
        my $meth = $self->{'method'};
        if (($meth eq 'postcircumfix:<[ ]>')) {
            return (Perlito5::Javascript3::emit_javascript3_autovivify($self->{'invocant'}, $level, 'array') . '.aget(' . Perlito5::Javascript3::to_num($self->{'arguments'}) . ', ' . $type . ')')
        };
        if (($meth eq 'postcircumfix:<{ }>')) {
            return (Perlito5::Javascript3::emit_javascript3_autovivify($self->{'invocant'}, $level, 'hash') . '.hget(' . Perlito5::Javascript3::autoquote($self->{'arguments'}, $level, 'list') . ', ' . $type . ')')
        };
        my $invocant = $self->{'invocant'}->emit_javascript3($level, 'scalar');
        if (($meth eq 'postcircumfix:<( )>')) {
            return ('p5code(' . $invocant . ')(' . Perlito5::Javascript3::to_list($self->{'arguments'}) . ', ' . ((($wantarray eq 'list') ? '1' : (($wantarray eq 'scalar') ? '0' : (($wantarray eq 'void') ? 'null' : 'p5want')))) . ')')
        };
        if ((ref($meth) eq 'Perlito5::AST::Var')) {
            $meth = $meth->emit_javascript3($level, 'scalar')
        }
        else {
            $meth = ('"' . $meth . '"')
        };
        return ('p5call(' . $invocant . ', ' . $meth . ', ' . Perlito5::Javascript3::to_list($self->{'arguments'}) . ', ' . ((($wantarray eq 'list') ? '1' : (($wantarray eq 'scalar') ? '0' : (($wantarray eq 'void') ? 'null' : 'p5want')))) . ')')
    }
};
package Perlito5::AST::Apply;
{
    sub Perlito5::AST::Apply::emit_regex_javascript3 {
        my $op = shift();
        my $var = shift();
        my $regex = shift();
        if ($regex->isa('Perlito5::AST::Var')) {
            $regex = {'code', 'p5:m', 'arguments', [$regex, '']}
        };
        my $str;
        my $code = $regex->{'code'};
        my $regex_args = $regex->{'arguments'};
        if (($code eq 'p5:s')) {
            $str = ($var->emit_javascript3() . '.assign(p5str(' . $var->emit_javascript3() . ').replace(/' . $regex_args->[0]->{'buf'} . '/' . $regex_args->[2] . ', ' . $regex_args->[1]->emit_javascript3() . '))')
        }
        else {
            if (($code eq 'p5:m')) {
                my $ast = $regex_args->[0];
                if ($ast->isa('Perlito5::AST::Val::Buf')) {
                    $str = ('(' . 'p5str(' . $var->emit_javascript3() . ')' . '.match(/' . $ast->{'buf'} . '/' . $regex_args->[1] . ')' . ' ? 1 : 0)')
                }
                else {
                    $str = ('(new RegExp(' . $ast->emit_javascript3() . ', ' . '"' . $regex_args->[1] . '"' . '))' . '.exec(' . 'p5str(' . $var->emit_javascript3() . ')' . ')')
                }
            }
            else {
                if (($code eq 'p5:tr')) {
                    $str = ('p5tr(' . $var->emit_javascript3() . ', ' . $regex_args->[0]->emit_javascript3() . ', ' . $regex_args->[1]->emit_javascript3() . ')')
                }
                else {
                    die(('Error: regex emitter - unknown operator ' . $code))
                }
            }
        };
        if (($op eq '=~')) {
            return $str
        };
        if (($op eq '!~')) {
            return ('!(' . $str . ')')
        };
        die('Error: regex emitter')
    };
    my %emit_js = ('infix:<=~>', sub {
                my $self = $_[0];
                emit_regex_javascript3('=~', $self->{'arguments'}->[0], $self->{'arguments'}->[1])
            }, 'infix:<!~>', sub {
                my $self = $_[0];
                emit_regex_javascript3('!~', $self->{'arguments'}->[0], $self->{'arguments'}->[1])
            }, 'p5:s', sub {
                my $self = $_[0];
                emit_regex_javascript3('=~', Perlito5::AST::Var->new('sigil', '$', 'namespace', '', 'name', '_'), $self)
            }, 'p5:m', sub {
                my $self = $_[0];
                emit_regex_javascript3('=~', Perlito5::AST::Var->new('sigil', '$', 'namespace', '', 'name', '_'), $self)
            }, 'p5:tr', sub {
                my $self = $_[0];
                emit_regex_javascript3('=~', Perlito5::AST::Var->new('sigil', '$', 'namespace', '', 'name', '_'), $self)
            }, '__PACKAGE__', sub {
                my $self = $_[0];
                ('"' . $Perlito5::PKG_NAME . '"')
            }, 'wantarray', sub {
                my $self = $_[0];
                'p5want'
            }, 'package', sub {
                my $self = $_[0];
                ('var ' . Perlito5::Javascript3::pkg_new_var() . ' = p5make_package("' . $self->{'namespace'} . '")')
            }, 'infix:<=>>', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                (Perlito5::Javascript3::autoquote($self->{'arguments'}->[0], $level) . ', ' . $self->{'arguments'}->[1]->emit_javascript3($level))
            }, 'infix:<cmp>', sub {
                my $self = $_[0];
                ('p5cmp(' . join(', ', map(Perlito5::Javascript3::to_str($_), @{$self->{'arguments'}})) . ')')
            }, 'infix:<<=>>', sub {
                my $self = $_[0];
                ('p5cmp(' . join(', ', map(Perlito5::Javascript3::to_num($_), @{$self->{'arguments'}})) . ')')
            }, 'infix:<**>', sub {
                my $self = $_[0];
                ('Math.pow(' . join(', ', map(Perlito5::Javascript3::to_num($_), @{$self->{'arguments'}})) . ')')
            }, 'prefix:<!>', sub {
                my $self = shift();
                my $level = shift();
                ('!( ' . Perlito5::Javascript3::to_bool($self->{'arguments'}->[0], $level) . ')')
            }, 'prefix:<not>', sub {
                my $self = shift();
                my $level = shift();
                ('!( ' . Perlito5::Javascript3::to_bool($self->{'arguments'}->[0], $level) . ')')
            }, 'prefix:<~>', sub {
                my $self = $_[0];
                ('p5complement( ' . Perlito5::Javascript3::to_num($self->{'arguments'}->[0]) . ')')
            }, 'prefix:<->', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                ('-( ' . $self->{'arguments'}->[0]->emit_javascript3($level, 'scalar') . ')')
            }, 'prefix:<+>', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                ('(' . $self->{'arguments'}->[0]->emit_javascript3($level, $wantarray) . ')')
            }, 'require', sub {
                my $self = $_[0];
                my $level = $_[1];
                my $arg = $self->{'arguments'}->[0];
                if ($arg->isa('Perlito5::AST::Val::Num')) {
                    return '1'
                };
                ('p5pkg["Perlito5::Grammar::Use"].require([' . Perlito5::Javascript3::to_str($self->{'arguments'}->[0]) . ', ' . (($self->{'arguments'}->[0]->{'bareword'} ? 1 : 0)) . '])')
            }, 'prefix:<$>', sub {
                my $self = $_[0];
                my $level = $_[1];
                my $arg = $self->{'arguments'}->[0];
                (Perlito5::Javascript3::emit_javascript3_autovivify($arg, $level, 'scalar') . '.sderef()')
            }, 'prefix:<@>', sub {
                my $self = $_[0];
                my $level = $_[1];
                my $arg = $self->{'arguments'}->[0];
                (Perlito5::Javascript3::emit_javascript3_autovivify($arg, $level, 'array') . '.aderef()')
            }, 'prefix:<$#>', sub {
                my $self = $_[0];
                my $level = $_[1];
                my $arg = $self->{'arguments'}->[0];
                ('(' . Perlito5::Javascript3::emit_javascript3_autovivify($arg, $level, 'array') . '.aderef().FETCHSIZE() - 1)')
            }, 'prefix:<%>', sub {
                my $self = $_[0];
                my $level = $_[1];
                my $arg = $self->{'arguments'}->[0];
                (Perlito5::Javascript3::emit_javascript3_autovivify($arg, $level, 'hash') . '.hderef()')
            }, 'prefix:<&>', sub {
                my $self = $_[0];
                my $level = $_[1];
                my $arg = $self->{'arguments'}->[0];
                ('p5code_lookup_by_name("' . $Perlito5::PKG_NAME . '", ' . $arg->emit_javascript3($level) . ')')
            }, 'circumfix:<[ ]>', sub {
                my $self = $_[0];
                my $level = $_[1];
                ('(new p5ArrayRef(new p5Array(' . Perlito5::Javascript3::to_list($self->{'arguments'}) . ')))')
            }, 'circumfix:<{ }>', sub {
                my $self = $_[0];
                my $level = $_[1];
                ('(new p5HashRef(new p5Hash(' . Perlito5::Javascript3::to_list($self->{'arguments'}, $level, 'hash') . ')))')
            }, 'prefix:<' . chr(92) . '>', sub {
                my $self = $_[0];
                my $level = $_[1];
                my $arg = $self->{'arguments'}->[0];
                if ($arg->isa('Perlito5::AST::Var')) {
                    if (($arg->sigil() eq '@')) {
                        return ('(new p5ArrayRef(' . $arg->emit_javascript3($level) . '))')
                    };
                    if (($arg->sigil() eq '%')) {
                        return ('(new p5HashRef(' . $arg->emit_javascript3($level) . '))')
                    };
                    if (($arg->sigil() eq '*')) {
                        return ('(new p5GlobRef(' . $arg->emit_javascript3($level) . '))')
                    };
                    if (($arg->sigil() eq '&')) {
                        if ($arg->{'namespace'}) {
                            return ('p5pkg["' . $arg->{'namespace'} . '"].' . $arg->{'name'})
                        }
                        else {
                            return (Perlito5::Javascript3::pkg() . '.' . $arg->{'name'})
                        }
                    }
                };
                return ('(new p5ScalarRef(' . $arg->emit_javascript3($level) . '))')
            }, 'postfix:<++>', sub {
                my $self = $_[0];
                my $level = $_[1];
                (Perlito5::Javascript3::emit_javascript3_autovivify($self->{'arguments'}->[0], $level, 'lvalue') . '.p5postincr()')
            }, 'postfix:<-->', sub {
                my $self = $_[0];
                my $level = $_[1];
                (Perlito5::Javascript3::emit_javascript3_autovivify($self->{'arguments'}->[0], $level, 'lvalue') . '.p5postdecr()')
            }, 'prefix:<++>', sub {
                my $self = $_[0];
                my $level = $_[1];
                (Perlito5::Javascript3::emit_javascript3_autovivify($self->{'arguments'}->[0], $level, 'lvalue') . '.p5incr()')
            }, 'prefix:<-->', sub {
                my $self = $_[0];
                my $level = $_[1];
                (Perlito5::Javascript3::emit_javascript3_autovivify($self->{'arguments'}->[0], $level, 'lvalue') . '.p5decr()')
            }, 'infix:<x>', sub {
                my $self = $_[0];
                ('p5str_replicate(' . join(', ', map($_->emit_javascript3(), @{$self->{'arguments'}})) . ')')
            }, 'list:<.>', sub {
                my $self = $_[0];
                ('(' . join(' + ', map(Perlito5::Javascript3::to_str($_), @{$self->{'arguments'}})) . ')')
            }, 'list:<,>', sub {
                my $self = $_[0];
                Perlito5::Javascript3::to_list($self->{'arguments'})
            }, 'infix:<..>', sub {
                my $self = $_[0];
                ('(function (a) { ' . 'for (var i=' . $self->{'arguments'}->[0]->emit_javascript3() . ', l=' . $self->{'arguments'}->[1]->emit_javascript3() . '; ' . 'i<=l; ++i)' . '{ ' . 'a.push(i) ' . '}; ' . 'return a ' . '})([])')
            }, 'delete', sub {
                my $self = $_[0];
                ('(delete ' . $self->{'arguments'}->[0]->emit_javascript3() . ')')
            }, 'scalar', sub {
                my $self = $_[0];
                my $level = $_[1];
                Perlito5::Javascript3::to_scalar($self->{'arguments'}, ($level + 1))
            }, 'ternary:<? :>', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                ('( ' . Perlito5::Javascript3::to_bool($self->{'arguments'}->[0]) . ' ? ' . ($self->{'arguments'}->[1])->emit_javascript3($level, $wantarray) . ' : ' . ($self->{'arguments'}->[2])->emit_javascript3($level, $wantarray) . ')')
            }, 'my', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                ('p5context(' . '[' . join(', ', map($_->emit_javascript3($level, $wantarray), @{$self->{'arguments'}})) . '], ' . ((($wantarray eq 'runtime') ? 'p5want' : (($wantarray eq 'list') ? 1 : 0))) . ')')
            }, 'our', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                ('p5context(' . '[' . join(', ', map($_->emit_javascript3($level, $wantarray), @{$self->{'arguments'}})) . '], ' . ((($wantarray eq 'runtime') ? 'p5want' : (($wantarray eq 'list') ? 1 : 0))) . ')')
            }, 'local', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                ('p5context(' . '[' . join(', ', map($_->emit_javascript3($level, $wantarray), @{$self->{'arguments'}})) . '], ' . ((($wantarray eq 'runtime') ? 'p5want' : (($wantarray eq 'list') ? 1 : 0))) . ')')
            }, 'circumfix:<( )>', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                ('p5context(' . '[' . join(', ', map($_->emit_javascript3($level, $wantarray), @{$self->{'arguments'}})) . '], ' . ((($wantarray eq 'runtime') ? 'p5want' : (($wantarray eq 'list') ? 1 : 0))) . ')')
            }, 'infix:<=>', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                my $parameters = $self->{'arguments'}->[0];
                my $arguments = $self->{'arguments'}->[1];
                if (($parameters->isa('Perlito5::AST::Apply') && ($parameters->code() eq 'prefix:<*>'))) {
                    return ('p5set_glob(' . $parameters->{'arguments'}->[0]->emit_javascript3() . ', ' . Perlito5::Javascript3::to_scalar([$arguments], ($level + 1)) . ')')
                };
                if (($parameters->isa('Perlito5::AST::Apply') && ((((($parameters->code() eq 'my') || ($parameters->code() eq 'our')) || ($parameters->code() eq 'local')) || ($parameters->code() eq 'circumfix:<( )>'))))) {
                    my $tmp = ('tmp' . Perlito5::Javascript3::get_label());
                    my $tmp2 = ('tmp' . Perlito5::Javascript3::get_label());
                    return ('(function () { ' . 'var ' . $tmp . ' = ' . Perlito5::Javascript3::to_list([$arguments], ($level + 1)) . '; ' . 'var ' . $tmp2 . ' = ' . $tmp . '.slice(0); ' . join('; ', (map(+(((($_->isa('Perlito5::AST::Apply') && ($_->code() eq 'undef')) ? ($tmp . '.shift()') : (($_->sigil() eq '$') ? ($_->emit_javascript3() . '.assign(' . $tmp . '.shift())') : (($_->sigil() eq '@') ? ($_->emit_javascript3() . '.assign(' . $tmp . '); ' . $tmp . ' = []') : (($_->sigil() eq '%') ? ($_->emit_javascript3() . '.assign(p5a_to_h(' . $tmp . ')); ' . $tmp . ' = []') : die('not implemented'))))))), @{$parameters->arguments()})), ('return ' . $tmp2)) . ' })()')
                };
                if ((($parameters->isa('Perlito5::AST::Var') && ($parameters->sigil() eq '$')) || ($parameters->isa('Perlito5::AST::Decl') && ($parameters->var()->sigil() eq '$')))) {
                    return ('' . $parameters->emit_javascript3() . '.assign(' . Perlito5::Javascript3::to_scalar([$arguments], ($level + 1)) . ')')
                };
                if (($parameters->isa('Perlito5::AST::Call') && ($parameters->{'method'} eq 'postcircumfix:<[ ]>'))) {
                    return (Perlito5::Javascript3::emit_javascript3_autovivify($parameters->{'invocant'}, $level, 'array') . '.aset(' . Perlito5::Javascript3::to_num($parameters->{'arguments'}) . ', ' . Perlito5::Javascript3::to_scalar([$arguments], ($level + 1)) . ')')
                }
                else {
                    if (($parameters->isa('Perlito5::AST::Call') && ($parameters->{'method'} eq 'postcircumfix:<{ }>'))) {
                        return (Perlito5::Javascript3::emit_javascript3_autovivify($parameters->{'invocant'}, $level, 'hash') . '.hset(' . Perlito5::Javascript3::autoquote($parameters->{'arguments'}, $level) . ', ' . Perlito5::Javascript3::to_scalar([$arguments], ($level + 1)) . ')')
                    }
                    else {
                        if ($parameters->isa('Perlito5::AST::Index')) {
                            return $parameters->emit_javascript3_set($arguments, ($level + 1))
                        }
                        else {
                            if ($parameters->isa('Perlito5::AST::Lookup')) {
                                return $parameters->emit_javascript3_set($arguments, ($level + 1))
                            }
                        }
                    }
                };
                if (($parameters->isa('Perlito5::AST::Var') && ($parameters->sigil() eq '@'))) {
                    return ($parameters->emit_javascript3() . '.assign(new p5Array(' . Perlito5::Javascript3::to_list([$arguments], ($level + 1)) . '))')
                }
                else {
                    if (($parameters->isa('Perlito5::AST::Decl') && ($parameters->var()->sigil() eq '@'))) {
                        return ($parameters->var()->emit_javascript3() . '.assign(new p5Array(' . Perlito5::Javascript3::to_list([$arguments], ($level + 1)) . '))')
                    }
                    else {
                        if ((($parameters->isa('Perlito5::AST::Var') && ($parameters->sigil() eq '%')) || ($parameters->isa('Perlito5::AST::Decl') && ($parameters->var()->sigil() eq '%')))) {
                            return ($parameters->emit_javascript3() . '.assign(new p5Hash(' . Perlito5::Javascript3::to_list([$arguments], ($level + 1), 'hash') . '))')
                        }
                    }
                };
                if (($parameters->isa('Perlito5::AST::Var') && ($parameters->sigil() eq '*'))) {
                    return ('(' . $parameters->emit_javascript3($level) . ' = ' . $arguments->emit_javascript3(($level + 1)) . ')')
                };
                say(Perlito5::Dumper::Dumper($parameters));
                die('assignment: don' . chr(39) . 't know what to do with left side isa ', ref($parameters))
            }, 'break', sub {
                my $self = shift();
                my $level = shift();
                $Perlito5::THROW = 1;
                'throw(new p5_error("break", ""))'
            }, 'next', sub {
                my $self = shift();
                my $level = shift();
                $Perlito5::THROW = 1;
                my $label = ($self->{'arguments'}->[0]->{'code'} || '');
                ('throw(new p5_error("next", "' . $label . '"))')
            }, 'last', sub {
                my $self = shift();
                my $level = shift();
                $Perlito5::THROW = 1;
                my $label = ($self->{'arguments'}->[0]->{'code'} || '');
                ('throw(new p5_error("last", "' . $label . '"))')
            }, 'redo', sub {
                my $self = shift();
                my $level = shift();
                $Perlito5::THROW = 1;
                my $label = ($self->{'arguments'}->[0]->{'code'} || '');
                ('throw(new p5_error("redo", "' . $label . '"))')
            }, 'return', sub {
                my $self = shift();
                my $level = shift();
                $Perlito5::THROW = 1;
                ('throw(' . Perlito5::Javascript3::to_runtime_context($self->{'arguments'}, $level) . ')')
            }, 'goto', sub {
                my $self = $_[0];
                $Perlito5::THROW = 1;
                ('throw((' . $self->{'arguments'}->[0]->emit_javascript3() . ')([List__, p5want]))')
            }, 'do', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                my $ast = Perlito5::AST::Apply->new('code', 'eval', 'namespace', '', 'arguments', [Perlito5::AST::Apply->new('code', 'slurp', 'namespace', 'Perlito5::IO', 'arguments', $self->{'arguments'})]);
                $ast->emit_javascript3($level)
            }, 'eval', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                $Perlito5::THROW = 1;
                my $arg = $self->{'arguments'}->[0];
                my $eval;
                if ($arg->isa('Perlito5::AST::Do')) {
                    $eval = $arg->emit_javascript3(($level + 1), $wantarray)
                }
                else {
                    my $var_env_perl5 = Perlito5::Dumper::Dumper($Perlito5::VAR);
                    my $m = Perlito5::Grammar::Expression->term_square($var_env_perl5, 0);
                    $m = Perlito5::Grammar::Expression::expand_list(Perlito5::Match::flat($m)->[2]);
                    my $var_env_js = ('(new p5ArrayRef(new p5Array(' . Perlito5::Javascript3::to_list($m) . ')))');
                    $eval = ('eval(perl5_to_js(' . Perlito5::Javascript3::to_str($arg) . ', ' . '"' . $Perlito5::PKG_NAME . '", ' . $var_env_js . ', ' . '"' . $wantarray . '"' . '))')
                };
                ('(function (p5want) {' . chr(10) . 'var r = null;' . chr(10) . 'p5pkg["main"]["v_@"].assign("");' . chr(10) . 'try {' . chr(10) . 'r = ' . $eval . chr(10) . '}' . chr(10) . 'catch(err) {' . chr(10) . 'if ( err instanceof p5_error ) {' . chr(10) . 'p5pkg["main"]["v_@"].assign(err);' . chr(10) . '}' . chr(10) . 'else if ( err instanceof Error ) {' . chr(10) . 'p5pkg["main"]["v_@"].assign(err);' . chr(10) . '}' . chr(10) . 'else {' . chr(10) . 'return(err);' . chr(10) . '}' . chr(10) . '}' . chr(10) . 'return r;' . chr(10) . '})(' . ((($wantarray eq 'list') ? '1' : (($wantarray eq 'scalar') ? '0' : (($wantarray eq 'void') ? 'null' : 'p5want')))) . ')')
            }, 'undef', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                if (($self->{'arguments'} && @{$self->{'arguments'}})) {
                    return ($self->{'arguments'}->[0]->emit_javascript3() . '.assign(null)')
                };
                return 'null'
            }, 'shift', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                if (($self->{'arguments'} && @{$self->{'arguments'}})) {
                    return (Perlito5::Javascript3::pkg() . '.shift([' . join(', ', map($_->emit_javascript3($level), @{$self->{'arguments'}})) . '])')
                };
                return (Perlito5::Javascript3::pkg() . '.shift([List__])')
            }, 'map', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                my @in = @{$self->{'arguments'}};
                my $fun = shift(@in);
                my $list = Perlito5::Javascript3::to_list(\@in);
                if ((ref($fun) eq 'Perlito5::AST::Lit::Block')) {
                    $fun = $fun->{'stmts'}
                }
                else {
                    $fun = [$fun]
                };
                ('p5map(' . Perlito5::Javascript3::pkg() . ', ' . 'function (p5want) {' . chr(10) . (Perlito5::Javascript3::LexicalBlock->new('block', $fun, 'needs_return', 1, 'top_level', 0))->emit_javascript3(($level + 1)) . chr(10) . Perlito5::Javascript3::tab($level) . '}, ' . $list . ')')
            }, 'grep', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                my @in = @{$self->{'arguments'}};
                my $fun = shift(@in);
                my $list = Perlito5::Javascript3::to_list(\@in);
                if ((ref($fun) eq 'Perlito5::AST::Lit::Block')) {
                    $fun = $fun->{'stmts'}
                }
                else {
                    $fun = [$fun]
                };
                ('p5grep(' . Perlito5::Javascript3::pkg() . ', ' . 'function (p5want) {' . chr(10) . (Perlito5::Javascript3::LexicalBlock->new('block', $fun, 'needs_return', 1, 'top_level', 0))->emit_javascript3(($level + 1)) . chr(10) . Perlito5::Javascript3::tab($level) . '}, ' . $list . ')')
            }, 'sort', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                my @in = @{$self->{'arguments'}};
                my $fun;
                my $list;
                if ((ref($in[0]) eq 'Perlito5::AST::Lit::Block')) {
                    $fun = shift(@in);
                    $fun = ('function (p5want) {' . chr(10) . (Perlito5::Javascript3::LexicalBlock->new('block', $fun->{'stmts'}, 'needs_return', 1, 'top_level', 0))->emit_javascript3(($level + 1)) . chr(10) . Perlito5::Javascript3::tab($level) . '}')
                }
                else {
                    $fun = 'null'
                };
                $list = Perlito5::Javascript3::to_list(\@in);
                ('p5sort(' . Perlito5::Javascript3::pkg() . ', ' . $fun . ', ' . $list . ')')
            }, 'infix:<//>', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                ('p5defined_or' . '(' . $self->{'arguments'}->[0]->emit_javascript3($level, 'scalar') . ', ' . Perlito5::Javascript3::emit_function_javascript3($level, $wantarray, $self->{'arguments'}->[1]) . ')')
            }, 'exists', sub {
                my $self = shift();
                my $level = shift();
                my $wantarray = shift();
                my $arg = $self->{'arguments'}->[0];
                if ($arg->isa('Perlito5::AST::Lookup')) {
                    my $v = $arg->obj();
                    if (($v->isa('Perlito5::AST::Var') && ($v->sigil() eq '$'))) {
                        $v = Perlito5::AST::Var->new('sigil', '%', 'namespace', $v->namespace(), 'name', $v->name());
                        return ('(' . $v->emit_javascript3() . ').exists(' . Perlito5::Javascript3::autoquote($arg->{'index_exp'}, $level) . ')')
                    };
                    return ('(' . $v->emit_javascript3() . ').hderef().exists(' . Perlito5::Javascript3::autoquote($arg->{'index_exp'}, $level) . ')')
                };
                if ($arg->isa('Perlito5::AST::Call')) {
                    if (($arg->method() eq 'postcircumfix:<{ }>')) {
                        return ('(' . $arg->invocant()->emit_javascript3() . ').hderef().exists(' . Perlito5::Javascript3::autoquote($arg->{'arguments'}, $level) . ')')
                    }
                }
            });
    sub Perlito5::AST::Apply::emit_javascript3 {
        my $self = shift();
        my $level = shift();
        my $wantarray = shift();
        my $apply = $self->op_assign();
        if ($apply) {
            return $apply->emit_javascript3($level)
        };
        my $code = $self->{'code'};
        if ((ref($code) ne '')) {
            my @args = ();
            push(@args, $_->emit_javascript3()) for @{$self->{'arguments'}};
            return ('p5code(' . $self->{'code'}->emit_javascript3($level) . ')(' . join(',', @args) . ')')
        };
        return $emit_js{$code}->($self, $level, $wantarray) if exists($emit_js{$code});
        if (exists($Perlito5::Javascript3::op_infix_js_str{$code})) {
            return ('(' . join($Perlito5::Javascript3::op_infix_js_str{$code}, map(Perlito5::Javascript3::to_str($_), @{$self->{'arguments'}})) . ')')
        };
        if (exists($Perlito5::Javascript3::op_infix_js_num{$code})) {
            return ('(' . join($Perlito5::Javascript3::op_infix_js_num{$code}, map(Perlito5::Javascript3::to_num($_), @{$self->{'arguments'}})) . ')')
        };
        if (exists($Perlito5::Javascript3::op_prefix_js_str{$code})) {
            return ($Perlito5::Javascript3::op_prefix_js_str{$code} . '(' . Perlito5::Javascript3::to_str($self->{'arguments'}->[0]) . ')')
        };
        if ((($code eq 'infix:<&&>') || ($code eq 'infix:<and>'))) {
            return ('p5and' . '(' . $self->{'arguments'}->[0]->emit_javascript3($level, 'scalar') . ', ' . Perlito5::Javascript3::emit_function_javascript3($level, $wantarray, $self->{'arguments'}->[1]) . ')')
        };
        if ((($code eq 'infix:<||>') || ($code eq 'infix:<or>'))) {
            return ('p5or' . '(' . $self->{'arguments'}->[0]->emit_javascript3($level, 'scalar') . ', ' . Perlito5::Javascript3::emit_function_javascript3($level, $wantarray, $self->{'arguments'}->[1]) . ')')
        };
        if ($self->{'namespace'}) {
            if ((($self->{'namespace'} eq 'JS') && ($code eq 'inline'))) {
                if ($self->{'arguments'}->[0]->isa('Perlito5::AST::Val::Buf')) {
                    return $self->{'arguments'}->[0]->{'buf'}
                }
                else {
                    die('JS::inline needs a string constant')
                }
            };
            $code = ('p5pkg["' . $self->{'namespace'} . '"].' . $code)
        }
        else {
            $code = (Perlito5::Javascript3::pkg() . '.' . $code)
        };
        my $sig;
        my $may_need_autoload;
        {
            my $name = $self->{'code'};
            my $namespace = ($self->{'namespace'} || $Perlito5::PKG_NAME);
            my $effective_name = ($namespace . '::' . $self->{'code'});
            if (exists($Perlito5::PROTO->{$effective_name})) {
                $sig = $Perlito5::PROTO->{$effective_name}
            }
            else {
                if ((((!($self->{'namespace'}) || ($namespace eq 'CORE'))) && exists($Perlito5::CORE_PROTO->{('CORE::' . $name)}))) {
                    $effective_name = ('CORE::' . $name);
                    $sig = $Perlito5::CORE_PROTO->{$effective_name}
                }
                else {
                    if ($self->{'bareword'}) {
                        if ($Perlito5::STRICT) {
                            die(('Bareword "' . $name . '" not allowed while "strict subs" in use'))
                        };
                        return Perlito5::Javascript3::escape_string(((($self->{'namespace'} ? ($self->{'namespace'} . '::') : '')) . $name))
                    };
                    $may_need_autoload = 1
                }
            }
        };
        if (((((($self->{'code'} eq 'say') || ($self->{'code'} eq 'print'))) && !($self->{'namespace'})) && $self->{'bareword'})) {
            $self->{'arguments'} = [Perlito5::AST::Var->new('sigil', '$', 'namespace', '', 'name', '_')]
        };
        if ($sig) {
            my @out = ();
            my @in = @{($self->{'arguments'} || [])};
            my $optional = 0;
            for ( ; length($sig); {

                } ) {
                my $c = substr($sig, 0, 1);
                if (($c eq ';')) {
                    $optional = 1
                }
                else {
                    if ((($c eq '$') || ($c eq '_'))) {
                        push(@out, shift(@in)->emit_javascript3($level, 'scalar')) if (@in || !($optional))
                    }
                    else {
                        if (($c eq '@')) {
                            push(@out, ('new p5Array(' . Perlito5::Javascript3::to_list(\@in) . ')')) if (@in || !($optional));
                            @in = ()
                        }
                        else {
                            if (($c eq '*')) {
                                if ((@in || !($optional))) {
                                    my $arg = shift(@in);
                                    if ($arg->{'bareword'}) {
                                        push(@out, ('p5pkg["' . (($arg->{'namespace'} || $Perlito5::PKG_NAME)) . '"]["f_' . $arg->{'code'} . '"]'))
                                    }
                                    else {
                                        push(@out, $arg->emit_javascript3($level, 'scalar'))
                                    }
                                }
                            }
                            else {
                                if (($c eq chr(92))) {
                                    if ((substr($sig, 0, 2) eq chr(92) . '$')) {
                                        $sig = substr($sig, 1);
                                        push(@out, shift(@in)->emit_javascript3($level, 'scalar')) if (@in || !($optional))
                                    }
                                    else {
                                        if (((substr($sig, 0, 2) eq chr(92) . '@') || (substr($sig, 0, 2) eq chr(92) . '%'))) {
                                            $sig = substr($sig, 1);
                                            push(@out, shift(@in)->emit_javascript3($level, 'list')) if (@in || !($optional))
                                        }
                                        else {
                                            if ((substr($sig, 0, 5) eq chr(92) . '[@%]')) {
                                                $sig = substr($sig, 4);
                                                push(@out, shift(@in)->emit_javascript3($level, 'list')) if (@in || !($optional))
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                };
                $sig = substr($sig, 1)
            };
            return ($code . '([' . join(', ', @out) . '], ' . ((($wantarray eq 'list') ? '1' : (($wantarray eq 'scalar') ? '0' : (($wantarray eq 'void') ? 'null' : 'p5want')))) . ')')
        };
        my @args = ();
        my $arg_list = Perlito5::Javascript3::to_list_preprocess($self->{'arguments'});
        push(@args, $_->emit_javascript3($level)) for @{$arg_list};
        my $arg_code = (($self->{'code'} eq 'scalar') ? ('[' . join(', ', @args) . ']') : ('p5param_list(' . join(', ', map($_->emit_javascript3($level, 'list', 'lvalue'), @{$arg_list})) . ')'));
        if ($may_need_autoload) {
            my $name = $self->{'code'};
            my $namespace = ($self->{'namespace'} || $Perlito5::PKG_NAME);
            return ('p5call_sub(' . '"' . $namespace . '", ' . '"' . $name . '", ' . $arg_code . ', ' . ((($wantarray eq 'list') ? '1' : (($wantarray eq 'scalar') ? '0' : (($wantarray eq 'void') ? 'null' : 'p5want')))) . ')')
        };
        ($code . '(' . $arg_code . ', ' . ((($wantarray eq 'list') ? '1' : (($wantarray eq 'scalar') ? '0' : (($wantarray eq 'void') ? 'null' : 'p5want')))) . ')')
    }
};
package Perlito5::AST::If;
{
    sub Perlito5::AST::If::emit_javascript3 {
        my $self = shift();
        my $level = shift();
        my $cond = $self->{'cond'};
        my $body = Perlito5::Javascript3::LexicalBlock->new('block', $self->{'body'}->stmts(), 'needs_return', 0, 'create_context', 1);
        my $s = ('if ( ' . Perlito5::Javascript3::to_bool($cond, ($level + 1)) . ' ) {' . chr(10) . $body->emit_javascript3(($level + 1)) . chr(10) . Perlito5::Javascript3::tab($level) . '}');
        if (@{$self->{'otherwise'}->stmts()}) {
            my $otherwise = Perlito5::Javascript3::LexicalBlock->new('block', $self->{'otherwise'}->stmts(), 'needs_return', 0, 'create_context', 1);
            $s = ($s . chr(10) . Perlito5::Javascript3::tab($level) . 'else {' . chr(10) . $otherwise->emit_javascript3(($level + 1)) . chr(10) . Perlito5::Javascript3::tab($level) . '}')
        };
        return $s
    }
};
package Perlito5::AST::When;
{
    sub Perlito5::AST::When::emit_javascript3 {
        my $self = shift();
        my $level = shift();
        my $cond = $self->{'cond'};
        my $body = Perlito5::Javascript3::LexicalBlock->new('block', $self->{'body'}->stmts(), 'needs_return', 0, 'create_context', 1);
        my $expr = Perlito5::AST::Apply->new('code', 'infix:<==>', 'arguments', [Perlito5::AST::Var->new('sigil', '$', 'namespace', '', 'name', '_'), $cond]);
        my $label = '';
        my $s = ('if ( ' . Perlito5::Javascript3::to_bool($expr, ($level + 1)) . ' ) {' . chr(10) . $body->emit_javascript3(($level + 1)) . chr(10) . Perlito5::Javascript3::tab(($level + 1)) . 'throw(new p5_error("next", "' . $label . '"))' . Perlito5::Javascript3::tab($level) . '}');
        return $s
    }
};
package Perlito5::AST::While;
{
    sub Perlito5::AST::While::emit_javascript3 {
        my $self = shift();
        my $level = shift();
        my $cond = $self->{'cond'};
        return ('p5while(' . 'function () {' . chr(10) . (Perlito5::Javascript3::LexicalBlock->new('block', $self->{'body'}->stmts(), 'needs_return', 0, 'top_level', 0))->emit_javascript3(($level + 2)) . chr(10) . Perlito5::Javascript3::tab(($level + 1)) . '}, ' . Perlito5::Javascript3::emit_function_javascript3($level, 0, $cond) . ', ' . Perlito5::AST::Lit::Block::emit_javascript3_continue($self, $level) . ', ' . '"' . (($self->{'label'} || '')) . '"' . ')')
    }
};
package Perlito5::AST::For;
{
    sub Perlito5::AST::For::emit_javascript3 {
        my $self = shift();
        my $level = shift();
        if ((ref($self->{'cond'}) eq 'ARRAY')) {
            my $body = Perlito5::Javascript3::LexicalBlock->new('block', $self->{'body'}->stmts(), 'needs_return', 0, 'create_context', 1);
            return ('for ( ' . (($self->{'cond'}->[0] ? ($self->{'cond'}->[0]->emit_javascript3(($level + 1)) . '; ') : '; ')) . (($self->{'cond'}->[1] ? ($self->{'cond'}->[1]->emit_javascript3(($level + 1)) . '; ') : '; ')) . (($self->{'cond'}->[2] ? ($self->{'cond'}->[2]->emit_javascript3(($level + 1)) . ' ') : ' ')) . ') {' . chr(10) . $body->emit_javascript3(($level + 1)) . chr(10) . Perlito5::Javascript3::tab($level) . '}')
        };
        my $cond = Perlito5::Javascript3::to_list([$self->{'cond'}], ($level + 1));
        if ($self->{'body'}->sig()) {
            my $v = $self->{'body'}->sig();
            $Perlito5::VAR->[0]->{$v->perl5_name()} = {'decl', 'my'};
            my $sig = $v->emit_javascript3(($level + 1));
            return ('p5for_lex(' . ('function (' . $sig . ') {' . chr(10)) . (Perlito5::Javascript3::LexicalBlock->new('block', $self->{'body'}->stmts(), 'needs_return', 0, 'top_level', 0))->emit_javascript3(($level + 2)) . chr(10) . Perlito5::Javascript3::tab(($level + 1)) . '}, ' . $cond . ', ' . Perlito5::AST::Lit::Block::emit_javascript3_continue($self, $level) . ', ' . '"' . (($self->{'label'} || '')) . '"' . ')')
        }
        else {
            return ('p5for(' . Perlito5::Javascript3::pkg() . ', ' . 'function () {' . chr(10) . (Perlito5::Javascript3::LexicalBlock->new('block', $self->{'body'}->stmts(), 'needs_return', 0, 'top_level', 0))->emit_javascript3(($level + 2)) . chr(10) . Perlito5::Javascript3::tab(($level + 1)) . '}, ' . $cond . ', ' . Perlito5::AST::Lit::Block::emit_javascript3_continue($self, $level) . ', ' . '"' . (($self->{'label'} || '')) . '"' . ')')
        }
    }
};
package Perlito5::AST::Sub;
{
    sub Perlito5::AST::Sub::emit_javascript3 {
        my $self = shift();
        my $level = shift();
        my $s = ('function (List__, p5want) {' . chr(10) . Perlito5::Javascript3::tab(($level + 1)) . 'List__ = new p5Array(List__);' . chr(10) . (Perlito5::Javascript3::LexicalBlock->new('block', $self->{'block'}, 'needs_return', 1, 'top_level', 1))->emit_javascript3($level) . chr(10) . Perlito5::Javascript3::tab($level) . '}');
        if ($self->{'name'}) {
            return ('p5typeglob_set("' . $self->{'namespace'} . '", "' . $self->{'name'} . '", ' . $s . ')')
        }
        else {
            return $s
        }
    }
};
package Perlito5::AST::Do;
{
    sub Perlito5::AST::Do::emit_javascript3 {
        my $self = shift();
        my $level = shift();
        my $wantarray = shift();
        my $block = $self->simplify()->block();
        return ('(function () {' . chr(10) . (Perlito5::Javascript3::LexicalBlock->new('block', $block, 'needs_return', 1))->emit_javascript3(($level + 1), $wantarray) . chr(10) . Perlito5::Javascript3::tab($level) . '})()')
    }
};
package Perlito5::AST::Use;
{
    sub Perlito5::AST::Use::emit_javascript3 {
        my $self = shift();
        my $level = shift();
        Perlito5::Grammar::Use::emit_time_eval($self);
        ('// ' . $self->{'code'} . ' ' . $self->{'mod'} . chr(10))
    }
};

;

# use Perlito5::Javascript3::Emitter
;
package main;
undef();
package Perlito5::Javascript3::Runtime;
sub Perlito5::Javascript3::Runtime::emit_javascript3 {
    return (('//' . chr(10) . '// lib/Perlito5/Javascript3/Runtime.js' . chr(10) . '//' . chr(10) . '// Runtime for "Perlito" Perl5-in-Javascript3' . chr(10) . '//' . chr(10) . '// AUTHORS' . chr(10) . '//' . chr(10) . '// Flavio Soibelmann Glock  fglock@gmail.com' . chr(10) . '//' . chr(10) . '// COPYRIGHT' . chr(10) . '//' . chr(10) . '// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.' . chr(10) . '//' . chr(10) . '// This program is free software; you can redistribute it and/or modify it' . chr(10) . '// under the same terms as Perl itself.' . chr(10) . '//' . chr(10) . '// See http://www.perl.com/perl/misc/Artistic.html' . chr(10) . chr(10) . 'var isNode = typeof require != "undefined";' . chr(10) . chr(10) . 'if (typeof p5pkg !== "object") {' . chr(10) . '    p5pkg = {};' . chr(10) . '    p5LOCAL = [];' . chr(10) . chr(10) . '    var universal = function () {};' . chr(10) . '    p5pkg.UNIVERSAL = new universal();' . chr(10) . '    p5pkg.UNIVERSAL._ref_ = "UNIVERSAL";' . chr(10) . '    p5pkg.UNIVERSAL.isa = function (List__) {' . chr(10) . '        // TODO - use @ISA' . chr(10) . '        var o = List__[0];' . chr(10) . '        var s = p5str(List__[1]);' . chr(10) . '        if (o instanceof p5Scalar) {' . chr(10) . '            o = o.FETCH();' . chr(10) . '        }' . chr(10) . '        return o._class_._ref_ == s' . chr(10) . '    };' . chr(10) . '    p5pkg.UNIVERSAL.can = function (List__) {' . chr(10) . '        var o = List__[0];' . chr(10) . '        var s = p5str(List__[1]);' . chr(10) . '        if (o instanceof p5Scalar) {' . chr(10) . '            o = o.FETCH();' . chr(10) . '        }' . chr(10) . '        if ( s.indexOf("::") == -1 ) {' . chr(10) . '            return p5method_lookup(s, o._class_._ref__, {})' . chr(10) . '        }' . chr(10) . '        var c = s.split("::");' . chr(10) . '        s = c.pop(); ' . chr(10) . '        return p5method_lookup(s, c.join("::"), {});' . chr(10) . '    };' . chr(10) . '    p5pkg.UNIVERSAL.DOES = p5pkg.UNIVERSAL.can;' . chr(10) . chr(10) . '    var core = function () {};' . chr(10) . '    p5pkg["CORE"] = new core();' . chr(10) . '    p5pkg["CORE"]._ref_ = "CORE";' . chr(10) . chr(10) . '    var core_global = function () {};' . chr(10) . '    core_global.prototype = p5pkg.CORE;' . chr(10) . '    p5pkg["CORE::GLOBAL"] = new core_global();' . chr(10) . '    p5pkg["CORE::GLOBAL"]._ref_ = "CORE::GLOBAL";' . chr(10) . chr(10) . '    p5_error = function (type, v) {' . chr(10) . '        this.type = type;' . chr(10) . '        this.v = v;' . chr(10) . '        this.toString = function(){' . chr(10) . '            if (this.type == ' . chr(39) . 'break' . chr(39) . ') {' . chr(10) . '                return ' . chr(39) . 'Can' . chr(92) . chr(39) . 't "break" outside a given block' . chr(39) . chr(10) . '            }' . chr(10) . '            if (this.type == ' . chr(39) . 'next' . chr(39) . ' || this.type == ' . chr(39) . 'last' . chr(39) . ' || this.type == ' . chr(39) . 'redo' . chr(39) . ') {' . chr(10) . '                if (this.v == "") { return ' . chr(39) . 'Can' . chr(92) . chr(39) . 't "' . chr(39) . ' + this.type + ' . chr(39) . '" outside a loop block' . chr(39) . ' }' . chr(10) . '                return ' . chr(39) . 'Label not found for "' . chr(39) . ' + this.type + ' . chr(39) . ' ' . chr(39) . ' + this.v + ' . chr(39) . '"' . chr(39) . ';' . chr(10) . '            }' . chr(10) . '            return this.v;' . chr(10) . '        };' . chr(10) . '    };' . chr(10) . '    p5_error.prototype = Error.prototype;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5make_package(pkg_name) {' . chr(10) . '    if (!p5pkg.hasOwnProperty(pkg_name)) {' . chr(10) . '        var tmp = function () {};' . chr(10) . '        tmp.prototype = p5pkg["CORE::GLOBAL"];' . chr(10) . '        p5pkg[pkg_name] = new tmp();' . chr(10) . '        p5pkg[pkg_name]._ref_ = pkg_name;' . chr(10) . '        p5pkg[pkg_name]._class_ = p5pkg[pkg_name];  // XXX memory leak' . chr(10) . chr(10) . '        // TODO - add the other package global variables' . chr(10) . '        p5pkg[pkg_name]["List_ISA"] = new p5Array([]);' . chr(10) . '        p5pkg[pkg_name]["v_a"] = new p5Scalar(null);' . chr(10) . '        p5pkg[pkg_name]["v_b"] = new p5Scalar(null);' . chr(10) . '        p5pkg[pkg_name]["v__"] = new p5Scalar(null);' . chr(10) . '        p5pkg[pkg_name]["v_AUTOLOAD"] = new p5Scalar(null);' . chr(10) . '    }' . chr(10) . '    return p5pkg[pkg_name];' . chr(10) . '}' . chr(10) . chr(10) . 'function p5code_lookup_by_name(package_name, sub_name) {' . chr(10) . '    // sub_name can have an optional namespace' . chr(10) . '    var parts = sub_name.split(/::/);' . chr(10) . '    if (parts.length > 1) {' . chr(10) . '        sub_name = parts.pop();' . chr(10) . '        package_name = parts.join("::");' . chr(10) . '    }' . chr(10) . '    if (p5pkg.hasOwnProperty(package_name)) {' . chr(10) . '        var c = p5pkg[package_name];' . chr(10) . '        if ( c.hasOwnProperty(sub_name) ) {' . chr(10) . '            return c[sub_name]' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return null;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5get_class_for_method(method, class_name, seen) {' . chr(10) . '    // default mro' . chr(10) . '    // TODO - cache the methods that were already looked up' . chr(10) . '    if ( p5pkg[class_name].hasOwnProperty(method) ) {' . chr(10) . '        return class_name' . chr(10) . '    }' . chr(10) . '    var isa = p5pkg[class_name].List_ISA;' . chr(10) . '    for (var i = 0; i < isa.length; i++) {' . chr(10) . '        if (!seen[isa[i]]) {' . chr(10) . '            var m = p5get_class_for_method(method, isa[i], seen);' . chr(10) . '            if (m) {' . chr(10) . '                return m ' . chr(10) . '            }' . chr(10) . '            seen[isa[i]]++;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '}' . chr(10) . chr(10) . 'function p5method_lookup(method, class_name, seen) {' . chr(10) . '    var c = p5get_class_for_method(method, class_name, seen);' . chr(10) . '    if (c) {' . chr(10) . '        return p5pkg[c][method]' . chr(10) . '    }' . chr(10) . '    if ( p5pkg.UNIVERSAL.hasOwnProperty(method) ) {' . chr(10) . '        return p5pkg.UNIVERSAL[method]' . chr(10) . '    }' . chr(10) . '}' . chr(10) . chr(10) . 'function p5call(invocant, method, list, p5want) {' . chr(10) . '    list.unshift(invocant);' . chr(10) . chr(10) . '    if (invocant instanceof p5Scalar) {' . chr(10) . '        // TODO - move p5call() to p5Scalar method' . chr(10) . '        invocant = invocant.FETCH();' . chr(10) . '    }' . chr(10) . chr(10) . '    if ( invocant.hasOwnProperty("_class_") ) {' . chr(10) . chr(10) . '        if ( invocant._class_.hasOwnProperty(method) ) {' . chr(10) . '            return invocant._class_[method](list, p5want)' . chr(10) . '        }' . chr(10) . '        var m = p5method_lookup(method, invocant._class_._ref_, {});' . chr(10) . '        if (m) {' . chr(10) . '            return m(list, p5want)' . chr(10) . '        }' . chr(10) . chr(10) . '        // method can have an optional namespace' . chr(10) . '        var pkg_name = method.split(/::/);' . chr(10) . '        if (pkg_name.length > 1) {' . chr(10) . '            var name = pkg_name.pop();' . chr(10) . '            pkg_name = pkg_name.join("::");' . chr(10) . '            m = p5method_lookup(name, pkg_name, {});' . chr(10) . '            if (m) {' . chr(10) . '                return m(list, p5want)' . chr(10) . '            }' . chr(10) . '            p5pkg.CORE.die(["method not found: ", name, " in class ", pkg_name]);' . chr(10) . '        }' . chr(10) . chr(10) . '        pkg_name = p5get_class_for_method(' . chr(39) . 'AUTOLOAD' . chr(39) . ', invocant._class_._ref_, {}) || p5get_class_for_method(' . chr(39) . 'AUTOLOAD' . chr(39) . ', "UNIVERSAL", {});' . chr(10) . '        if (pkg_name) {' . chr(10) . '            p5pkg[pkg_name]["v_AUTOLOAD"] = invocant._class_._ref_ + "::" + method;' . chr(10) . '            return p5pkg[pkg_name]["AUTOLOAD"](list, p5want);' . chr(10) . '        }' . chr(10) . chr(10) . '        p5pkg.CORE.die(["method not found: ", method, " in class ", invocant._class_._ref_]);' . chr(10) . chr(10) . '    }' . chr(10) . chr(10) . '    // the invocant doesn' . chr(39) . 't have a class' . chr(10) . chr(10) . '    if (typeof invocant === "string") {' . chr(10) . '        var aclass = p5make_package(invocant);' . chr(10) . '        return p5call(aclass, method, list, p5want);' . chr(10) . '    }' . chr(10) . chr(10) . '    p5pkg.CORE.die(["Can' . chr(39) . 't call method ", method, " on unblessed reference"]);' . chr(10) . chr(10) . '}' . chr(10) . chr(10) . 'function p5call_sub(namespace, name, list, p5want) {' . chr(10) . '    if(p5pkg[namespace].hasOwnProperty(name)) {' . chr(10) . '        return p5pkg[namespace][name](list, p5want)' . chr(10) . '    }' . chr(10) . '    if(p5pkg[namespace].hasOwnProperty("AUTOLOAD")) {' . chr(10) . '        p5pkg[namespace]["v_AUTOLOAD"] = namespace + "::" + name;' . chr(10) . '        return p5pkg[namespace]["AUTOLOAD"](list, p5want)' . chr(10) . '    }' . chr(10) . '    p5pkg.CORE.die(["Undefined subroutine &" + namespace + "::" + name]);' . chr(10) . '}' . chr(10) . chr(10) . 'function p5scalar_deref(v) {' . chr(10) . '    if (typeof v === "string") {' . chr(10) . '        var pkg_name = v.split(/::/);' . chr(10) . '        if (pkg_name.length > 1) {' . chr(10) . '            v = pkg_name.pop();' . chr(10) . '            pkg_name = pkg_name.join("::");' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            pkg_name = p5pkg["Perlito5"].v_PKG_NAME;' . chr(10) . '        }' . chr(10) . '        var c = v.charCodeAt(0);' . chr(10) . '        if (c < 27) {' . chr(10) . '            v = String.fromCharCode(c + 64) + v.substr(1);' . chr(10) . '            pkg_name = ' . chr(39) . 'main' . chr(39) . ';' . chr(10) . '        }' . chr(10) . '        return p5pkg[pkg_name]["v_"+v];' . chr(10) . '    }' . chr(10) . '    return v._scalar_;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5scalar_deref_set(v, n) {' . chr(10) . '    if (typeof v === "string") {' . chr(10) . '        var pkg_name = v.split(/::/);' . chr(10) . '        if (pkg_name.length > 1) {' . chr(10) . '            v = pkg_name.pop();' . chr(10) . '            pkg_name = pkg_name.join("::");' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            pkg_name = p5pkg["Perlito5"].v_PKG_NAME;' . chr(10) . '        }' . chr(10) . '        var c = v.charCodeAt(0);' . chr(10) . '        if (c < 27) {' . chr(10) . '            v = String.fromCharCode(c + 64) + v.substr(1);' . chr(10) . '            pkg_name = ' . chr(39) . 'main' . chr(39) . ';' . chr(10) . '        }' . chr(10) . '        p5pkg[pkg_name]["v_"+v] = n;' . chr(10) . '        return p5pkg[pkg_name]["v_"+v];' . chr(10) . '    }' . chr(10) . '    v._scalar_ = n;' . chr(10) . '    return v._scalar_;' . chr(10) . '}' . chr(10) . chr(10) . 'p5make_package("main");' . chr(10) . 'p5make_package("Perlito5");' . chr(10) . 'p5pkg["Perlito5"].v_PKG_NAME = "main";' . chr(10) . 'p5pkg["main"]["v_@"]       = new p5Scalar("");  // $@' . chr(10) . 'p5pkg["main"]["v_|"]       = new p5Scalar(0);   // $|' . chr(10) . 'p5pkg["main"]["List_#"]    = new p5Array([]);   // @#' . chr(10) . 'p5scalar_deref_set(String.fromCharCode(15), isNode ? "node.js" : "javascript2");  // $^O' . chr(10) . 'p5pkg["main"]["List_INC"]  = new p5Array([]);' . chr(10) . 'p5pkg["main"]["Hash_INC"]  = new p5Hash({});' . chr(10) . 'p5pkg["main"]["List_ARGV"] = new p5Array([]);' . chr(10) . 'p5pkg["main"]["Hash_ENV"]  = new p5Hash({});' . chr(10) . 'if (isNode) {' . chr(10) . '    p5pkg["main"]["List_ARGV"] = new p5Array(process.argv.splice(2));' . chr(10) . '    p5pkg["main"]["Hash_ENV"]  = new p5Hash(process.env);' . chr(10) . '    p5pkg["main"]["v_$"]       = new p5Scalar(process.pid);' . chr(10) . '} else if (typeof arguments === "object") {' . chr(10) . '    p5pkg["main"]["List_ARGV"] = new p5Array(arguments);' . chr(10) . '}' . chr(10) . chr(10) . 'p5make_package("Perlito5::IO");' . chr(10) . 'p5make_package("Perlito5::Runtime");' . chr(10) . 'p5make_package("Perlito5::Grammar");' . chr(10) . chr(10) . 'function p5typeglob_set(pkg_name, sub_name, func) {' . chr(10) . '    p5make_package(pkg_name);' . chr(10) . '    p5pkg[pkg_name][sub_name] = func;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5set_glob(name, data) {' . chr(10) . '    if ( name.indexOf("::") == -1 ) {' . chr(10) . '        p5pkg[ p5pkg["Perlito5"].v_PKG_NAME.FETCH() ][name] = data;' . chr(10) . '        return data;' . chr(10) . '    }' . chr(10) . '    var c = name.split("::");' . chr(10) . '    s = c.pop(); ' . chr(10) . '    var pkg = c.join("::");' . chr(10) . '    p5make_package(pkg);' . chr(10) . '    p5pkg[pkg][s] = data;' . chr(10) . '    return data;' . chr(10) . '}' . chr(10) . chr(10) . 'var sigils = { ' . chr(39) . '@' . chr(39) . ' : ' . chr(39) . 'List_' . chr(39) . ', ' . chr(39) . '%' . chr(39) . ' : ' . chr(39) . 'Hash_' . chr(39) . ', ' . chr(39) . '$' . chr(39) . ' : ' . chr(39) . 'v_' . chr(39) . ' };' . chr(10) . chr(10) . 'function p5set_local(namespace, name, sigil) {' . chr(10) . '    var vname = sigils[sigil] + name;' . chr(10) . '    p5LOCAL.push([namespace, vname, namespace[vname]]);' . chr(10) . chr(10) . '    if (sigil == ' . chr(39) . '$' . chr(39) . ') {' . chr(10) . '        namespace[vname] = new p5Scalar(null);' . chr(10) . '    }' . chr(10) . '    else if (sigil == ' . chr(39) . '@' . chr(39) . ') {' . chr(10) . '        namespace[vname] = new p5Array([]);' . chr(10) . '    }' . chr(10) . '    else if (sigil == ' . chr(39) . '%' . chr(39) . ') {' . chr(10) . '        namespace[vname] = new p5Hash({});' . chr(10) . '    }' . chr(10) . '    return namespace[vname];' . chr(10) . '}' . chr(10) . chr(10) . 'function p5cleanup_local(idx, value) {' . chr(10) . '    while (p5LOCAL.length > idx) {' . chr(10) . '        l = p5LOCAL.pop();' . chr(10) . '        l[0][l[1]] = l[2];' . chr(10) . '    }' . chr(10) . '    return value;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5global(sigil, namespace, name) {' . chr(10) . '    // TODO - autovivify namespace' . chr(10) . '    var vname = sigils[sigil] + name;' . chr(10) . '    var v = p5pkg[namespace][vname];' . chr(10) . '    if (v != null) {' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '    if (sigil == ' . chr(39) . '$' . chr(39) . ') {' . chr(10) . '        p5pkg[namespace][vname] = new p5Scalar(null);' . chr(10) . '    }' . chr(10) . '    else if (sigil == ' . chr(39) . '@' . chr(39) . ') {' . chr(10) . '        p5pkg[namespace][vname] = new p5Array([]);' . chr(10) . '    }' . chr(10) . '    else if (sigil == ' . chr(39) . '%' . chr(39) . ') {' . chr(10) . '        p5pkg[namespace][vname] = new p5Hash({});' . chr(10) . '    }' . chr(10) . '    return p5pkg[namespace][vname];' . chr(10) . '}' . chr(10) . chr(10) . 'function p5HashRef(o) {' . chr(10) . '    this._href_ = o;' . chr(10) . '    this._ref_ = "HASH";' . chr(10) . '    this.p5bool = function() { return 1 };' . chr(10) . '    this.p5string = function() {' . chr(10) . '        return "HASH(0x0000)";  // TODO' . chr(10) . '    };' . chr(10) . '    this.hderef = function() {' . chr(10) . '        return this._href_;' . chr(10) . '    };' . chr(10) . '    this.hset = function(i, v) {' . chr(10) . '        return this._href_.hset(i, v);' . chr(10) . '    };' . chr(10) . '    this.hget = function(i, autoviv) {' . chr(10) . '        return this._href_.hget(i, autoviv);' . chr(10) . '    }' . chr(10) . '}' . chr(10) . chr(10) . 'function p5ArrayRef(o) {' . chr(10) . '    this._aref_ = o;' . chr(10) . '    this._ref_ = "ARRAY";' . chr(10) . '    this.p5bool = function() { return 1 };' . chr(10) . '    this.p5string = function() {' . chr(10) . '        return "ARRAY(0x0000)";  // TODO' . chr(10) . '    };' . chr(10) . '    this.aderef = function() {' . chr(10) . '        return this._aref_;' . chr(10) . '    };' . chr(10) . '    this.aset = function(i, v) {' . chr(10) . '        return this._aref_.aset(i, v);' . chr(10) . '    }' . chr(10) . '    this.aget = function(i, autoviv) {' . chr(10) . '        return this._aref_.aget(i, autoviv);' . chr(10) . '    }' . chr(10) . '}' . chr(10) . chr(10) . 'function p5ScalarRef(o) {' . chr(10) . '    this._scalar_ = o;' . chr(10) . '    this._ref_ = "SCALAR";' . chr(10) . '    this.p5bool = function() { return 1 };' . chr(10) . '    this.p5string = function() {' . chr(10) . '        return "SCALAR(0x0000)";  // TODO' . chr(10) . '    };' . chr(10) . '    this.sderef = function() {' . chr(10) . '        return this._scalar_;' . chr(10) . '    };' . chr(10) . '}' . chr(10) . chr(10) . 'function p5GlobRef(o) {' . chr(10) . '    this._scalar_ = o;' . chr(10) . '    this._ref_ = "GLOB";' . chr(10) . '    this.p5bool = function() { return 1 };' . chr(10) . '    this.p5string = function() {' . chr(10) . '        return "GLOB(0x0000)";  // TODO' . chr(10) . '    };' . chr(10) . '}' . chr(10) . chr(10) . 'function p5Array(o) {' . chr(10) . '    // TODO - array slice' . chr(10) . '    this._array_ = o;' . chr(10) . '    this._ref_ = "";' . chr(10) . '    this.p5bool = function() {' . chr(10) . '        return this._array_.length != 0' . chr(10) . '    };' . chr(10) . '    this.p5string = function() {' . chr(10) . '        return ' . chr(39) . chr(39) . ' + this._array_.length;' . chr(10) . '    };' . chr(10) . '    this.p5num = function() {' . chr(10) . '        return this._array_.length;' . chr(10) . '    };' . chr(10) . '    this.aset = function(i, v) {' . chr(10) . '        if (i < 0) {' . chr(10) . '            i = this._array_.length + i;' . chr(10) . '        }' . chr(10) . '        if (this._array_[i] instanceof p5Scalar) {' . chr(10) . '            this._array_[i].assign(v);' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            if (v instanceof p5Scalar) {' . chr(10) . '                this._array_[i] = v.FETCH();' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                this._array_[i] = v;' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        return v;' . chr(10) . '    };' . chr(10) . '    this.aget = function(i, autoviv) {' . chr(10) . '        if (i < 0) {' . chr(10) . '            i = this._array_.length + i;' . chr(10) . '        }' . chr(10) . '        if (autoviv) {' . chr(10) . '            if (autoviv == ' . chr(39) . 'lvalue' . chr(39) . ') {' . chr(10) . '                if (this._array_.length < i) {' . chr(10) . '                    // don' . chr(39) . 't vivify yet; create a proxy object' . chr(10) . '                    return new p5ArrayProxy(this, i);' . chr(10) . '                }' . chr(10) . '                if (!(this._array_[i] instanceof p5Scalar)) {' . chr(10) . '                    this._array_[i] = new p5Scalar(this._array_[i]);' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            else if (autoviv == ' . chr(39) . 'array' . chr(39) . ') {' . chr(10) . '                if (!(this._array_[i] instanceof p5ArrayRef) &&' . chr(10) . '                    !(this._array_[i] instanceof p5Scalar))' . chr(10) . '                {' . chr(10) . '                    this._array_[i] = new p5ArrayRef(new p5Array([]));' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            else if (autoviv == ' . chr(39) . 'hash' . chr(39) . ') {' . chr(10) . '                if (!(this._array_[i] instanceof p5HashRef) &&' . chr(10) . '                    !(this._array_[i] instanceof p5Scalar))' . chr(10) . '                {' . chr(10) . '                    this._array_[i] = new p5HashRef(new p5Hash({}));' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        return this._array_[i];' . chr(10) . '    };' . chr(10) . '    this.get_values = function(o) {' . chr(10) . '        // add values to the param (a native js list)' . chr(10) . '        for(var i = 0; i < this._array_.length; i++) {' . chr(10) . '            o.push(this._array_[i]);' . chr(10) . '        }' . chr(10) . '        return o;' . chr(10) . '    };' . chr(10) . '    this.get_lvalues = function(o) {' . chr(10) . '        // add lvalues to the param (a native js list)' . chr(10) . '        for(var i = 0; i < this._array_.length; i++) {' . chr(10) . '            o.push(this._array_[i] instanceof p5Scalar ? this._array_[i] : this.aget(i, "lvalue"));' . chr(10) . '        }' . chr(10) . '        return o;' . chr(10) . '    };' . chr(10) . '    this.assign = function(a) {' . chr(10) . '        if (a instanceof Array) {' . chr(10) . '            // TODO - cleanup, this shouldn' . chr(39) . 't happen' . chr(10) . '            this._array_ = a;' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            this._array_ = a._array_;' . chr(10) . '        }' . chr(10) . '        return this;' . chr(10) . '    };' . chr(10) . chr(10) . '    // operations that can be tie()' . chr(10) . '    this.FETCHSIZE = function() {' . chr(10) . '        return this._array_.length;' . chr(10) . '    };' . chr(10) . '    this.PUSH = function(v) {' . chr(10) . '        for(var i = 0; i < v._array_.length; i++) {' . chr(10) . '            this._array_.push(v._array_[i] instanceof p5Scalar ? v._array_[i].FETCH() :  v._array_[i]);' . chr(10) . '        }' . chr(10) . '        return this._array_.length;' . chr(10) . '    };' . chr(10) . '    this.UNSHIFT = function(v) {' . chr(10) . '        for(var i = v._array_.length-1; i >= 0; i--) {' . chr(10) . '            this._array_.unshift(v._array_[i] instanceof p5Scalar ? v._array_[i].FETCH() :  v._array_[i]);' . chr(10) . '        }' . chr(10) . '        return this._array_.length;' . chr(10) . '    };' . chr(10) . '    this.POP = function() {' . chr(10) . '        if (this._array_.length == null) {' . chr(10) . '            return null;' . chr(10) . '        }' . chr(10) . '        return this._array_.pop();' . chr(10) . '    };' . chr(10) . '    this.SHIFT = function(v) {' . chr(10) . '        if (this._array_.length == null) {' . chr(10) . '            return null;' . chr(10) . '        }' . chr(10) . '        return this._array_.shift();' . chr(10) . '    };' . chr(10) . '}' . chr(10) . chr(10) . 'function p5Hash(o) {' . chr(10) . '    // TODO - hash slice' . chr(10) . '    this._hash_ = o;' . chr(10) . '    this._ref_ = "";' . chr(10) . '    this.p5bool = function() {' . chr(10) . '        o = this._hash_;' . chr(10) . '        for (var i in o) {' . chr(10) . '            return true;' . chr(10) . '        }' . chr(10) . '        return false;' . chr(10) . '    };' . chr(10) . '    this.p5string = function() {' . chr(10) . '        return ' . chr(39) . chr(39) . ' + this.p5num() + ' . chr(39) . '/8' . chr(39) . ';' . chr(10) . '    };' . chr(10) . '    this.p5num = function() {' . chr(10) . '        var out = 0;' . chr(10) . '        for (var i in this._hash_) {' . chr(10) . '            out++;' . chr(10) . '        }' . chr(10) . '        return out;' . chr(10) . '    };' . chr(10) . '    this.exists = function(i) {' . chr(10) . '        return this._hash_.hasOwnProperty(i);' . chr(10) . '    };' . chr(10) . '    this.hset = function(i, v) {' . chr(10) . '        if (this._hash_[i] instanceof p5Scalar) {' . chr(10) . '            this._hash_[i].assign(v);' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            if (v instanceof p5Scalar) {' . chr(10) . '                this._hash_[i] = v.FETCH();' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                this._hash_[i] = v;' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        return v;' . chr(10) . '    };' . chr(10) . '    this.hget = function(i, autoviv) {' . chr(10) . '        if (autoviv) {' . chr(10) . '            if (autoviv == ' . chr(39) . 'lvalue' . chr(39) . ') {' . chr(10) . '                if (! this._hash_.hasOwnProperty(i)) {' . chr(10) . '                    // don' . chr(39) . 't autovivify yet; create a proxy object' . chr(10) . '                    return new p5HashProxy(this, i);' . chr(10) . '                }' . chr(10) . '                if (!(this._hash_[i] instanceof p5Scalar)) {' . chr(10) . '                    this._hash_[i] = new p5Scalar(this._hash_[i]);' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            else if (autoviv == ' . chr(39) . 'array' . chr(39) . ') {' . chr(10) . '                if (!(this._hash_[i] instanceof p5ArrayRef) &&' . chr(10) . '                    !(this._hash_[i] instanceof p5Scalar))' . chr(10) . '                {' . chr(10) . '                    this._hash_[i] = new p5ArrayRef(new p5Array([]));' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            else if (autoviv == ' . chr(39) . 'hash' . chr(39) . ') {' . chr(10) . '                if (!(this._hash_[i] instanceof p5HashRef) &&' . chr(10) . '                    !(this._hash_[i] instanceof p5Scalar))' . chr(10) . '                {' . chr(10) . '                    this._hash_[i] = new p5HashRef(new p5Hash({}));' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        return this._hash_[i];' . chr(10) . '    };' . chr(10) . '    this.get_values = function(o) {' . chr(10) . '        // add a native list of values to the param' . chr(10) . '        for (var i in this._hash_) {' . chr(10) . '            o.push(i);' . chr(10) . '            o.push(this._hash_[i]);' . chr(10) . '        }' . chr(10) . '        return o;' . chr(10) . '    };' . chr(10) . '    this.get_lvalues = function(o) {' . chr(10) . '        // add a native list of lvalues to the param' . chr(10) . '        for (var i in this._hash_) {' . chr(10) . '            o.push(i);' . chr(10) . '            o.push(this._hash_[i] instanceof p5Scalar ? this._hash_[i] : this.hget(i, "lvalue"));' . chr(10) . '        }' . chr(10) . '        return o;' . chr(10) . '    };' . chr(10) . '    this.assign = function(h) {' . chr(10) . '        if (h instanceof p5Hash) {' . chr(10) . '            this._hash_ = h._hash_;' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            // TODO - cleanup, this shouldn' . chr(39) . 't happen' . chr(10) . '            this._hash_ = h;' . chr(10) . '        }' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '}' . chr(10) . chr(10) . 'function p5Scalar(o) {' . chr(10) . '    this._v_ = o;' . chr(10) . '    this._ref_ = "";' . chr(10) . chr(10) . '    // be a value' . chr(10) . '    this.p5bool = function() {' . chr(10) . '        return p5bool(this._v_);' . chr(10) . '    };' . chr(10) . '    this.p5string = function() {' . chr(10) . '        return p5str(this._v_);' . chr(10) . '    };' . chr(10) . '    this.p5num = function() {' . chr(10) . '        return p5num(this._v_);' . chr(10) . '    };' . chr(10) . '    this.p5code = function() {' . chr(10) . '        return p5code(this._v_);' . chr(10) . '    };' . chr(10) . '    this.p5incr = function() {' . chr(10) . '        this._v_ = p5incr(this._v_);' . chr(10) . '        return this._v_;' . chr(10) . '    };' . chr(10) . '    this.p5postincr = function() {' . chr(10) . '        var v = this._v_;' . chr(10) . '        this._v_ = p5incr(this._v_);' . chr(10) . '        return v;' . chr(10) . '    };' . chr(10) . '    this.p5decr = function() {' . chr(10) . '        this._v_ = p5decr(this._v_);' . chr(10) . '        return this._v_;' . chr(10) . '    };' . chr(10) . '    this.p5postdecr = function() {' . chr(10) . '        var v = this._v_;' . chr(10) . '        this._v_ = p5decr(this._v_);' . chr(10) . '        return v;' . chr(10) . '    };' . chr(10) . chr(10) . '    // be a scalar ref' . chr(10) . '    this.sderef = function(i) {' . chr(10) . '        // TODO - autovivify scalar (with proxy object?)' . chr(10) . '        return this._v_.sderef();' . chr(10) . '    };' . chr(10) . chr(10) . '    // be an array ref' . chr(10) . '    this.aderef = function() {' . chr(10) . '        // TODO - autovivify array (with proxy object?)' . chr(10) . '        return this._v_.aderef();' . chr(10) . '    };' . chr(10) . '    this.aget = function(i, autoviv) {' . chr(10) . '        // TODO - autovivify array (with proxy object?)' . chr(10) . '        if (this._v_ == null) {' . chr(10) . '            this._v_ = new p5ArrayRef(new p5Array([]));' . chr(10) . '        }' . chr(10) . '        return this._v_.aget(i, autoviv);' . chr(10) . '    };' . chr(10) . '    this.aset = function(i, v) {' . chr(10) . '        if (this._v_ == null) {' . chr(10) . '            this._v_ = new p5ArrayRef(new p5Array([]));' . chr(10) . '        }' . chr(10) . '        return this._v_.aset(i, v);' . chr(10) . '    };' . chr(10) . chr(10) . '    // be a hash ref' . chr(10) . '    this.hderef = function() {' . chr(10) . '        // TODO - autovivify hash (with proxy object?)' . chr(10) . '        if (this._v_ == null) {' . chr(10) . '            this._v_ = new p5HashRef(new p5Hash([]));' . chr(10) . '        }' . chr(10) . '        return this._v_.hderef();' . chr(10) . '    };' . chr(10) . '    this.hget = function(i, autoviv) {' . chr(10) . '        // TODO - autovivify hash (with proxy object?)' . chr(10) . '        if (this._v_ == null) {' . chr(10) . '            this._v_ = new p5HashRef(new p5Hash([]));' . chr(10) . '        }' . chr(10) . '        return this._v_.hget(i, autoviv);' . chr(10) . '    }' . chr(10) . '    this.hset = function(i, v) {' . chr(10) . '        if (this._v_ == null) {' . chr(10) . '            this._v_ = new p5HashRef(new p5Hash([]));' . chr(10) . '        }' . chr(10) . '        return this._v_.hset(i, v);' . chr(10) . '    }' . chr(10) . chr(10) . '    // be a container' . chr(10) . '    this.get_values = function(o) {' . chr(10) . '        // add a native list of values to the param' . chr(10) . '        o.push(this);' . chr(10) . '        return o;' . chr(10) . '    };' . chr(10) . '    this.get_lvalues = function(o) {' . chr(10) . '        // add a native list of lvalues to the param' . chr(10) . '        o.push(this);' . chr(10) . '        return o;' . chr(10) . '    };' . chr(10) . '    this.assign = function(v) {' . chr(10) . '        if (v instanceof p5Scalar) {' . chr(10) . '            this._v_ = v.FETCH();' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            this._v_ = v;' . chr(10) . '        }' . chr(10) . '        return this;' . chr(10) . '    };' . chr(10) . chr(10) . '    // operations that can be tie()' . chr(10) . '    this.FETCH = function() {' . chr(10) . '        // not an lvalue' . chr(10) . '        return this._v_;' . chr(10) . '    };' . chr(10) . '}' . chr(10) . chr(10) . chr(10) . 'function p5HashProxy(h, k) {' . chr(10) . '    this._hashobj_ = h;' . chr(10) . '    this._key_ = k;' . chr(10) . '    this._v_ = null;' . chr(10) . '    this.assign = function(v) {' . chr(10) . '        // write-through; alternately, use read-through' . chr(10) . '        if (v instanceof p5Scalar) {' . chr(10) . '            this._v_ = v.FETCH();' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            this._v_ = v;' . chr(10) . '        }' . chr(10) . '        return this._hashobj_.hset(this._key_, this._v_);' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'p5HashProxy.prototype = new p5Scalar();' . chr(10) . chr(10) . chr(10) . 'function p5ArrayProxy(a, k) {' . chr(10) . '    this._arrayobj_ = a;' . chr(10) . '    this._key_ = k;' . chr(10) . '    this._v_ = null;' . chr(10) . '    this.assign = function(v) {' . chr(10) . '        // write-through; alternately, use read-through' . chr(10) . '        if (v instanceof p5Scalar) {' . chr(10) . '            this._v_ = v.FETCH();' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            this._v_ = v;' . chr(10) . '        }' . chr(10) . '        return this._arrayobj_.aset(this._key_, this._v_);' . chr(10) . '    }' . chr(10) . '}' . chr(10) . 'p5ArrayProxy.prototype = new p5Scalar();' . chr(10) . chr(10) . chr(10) . 'p5param_list = function() {' . chr(10) . '    var res = [];' . chr(10) . '    for (i = 0; i < arguments.length; i++) {' . chr(10) . '        if (arguments[i] == null) {' . chr(10) . '            res.push(null)' . chr(10) . '        }' . chr(10) . '        else if (arguments[i].hasOwnProperty("get_lvalues")) {' . chr(10) . '            // container' . chr(10) . '            arguments[i].get_lvalues(res);' . chr(10) . '        }' . chr(10) . '        else if (arguments[i] instanceof Array) {' . chr(10) . '            // js Array -- possibly generated by p5context()' . chr(10) . '            // maybe too late to get lvalues -- needs more testing' . chr(10) . '            // this doesn' . chr(39) . 't handle nested Array' . chr(10) . '            o = arguments[i];' . chr(10) . '            for (j = 0; j < o.length; j++) {' . chr(10) . '                res.push(o[j]);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            // non-container' . chr(10) . '            res.push(arguments[i]);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return res;' . chr(10) . '};' . chr(10) . chr(10) . 'p5list_to_a = function() {' . chr(10) . '    var res = [];' . chr(10) . '    for (i = 0; i < arguments.length; i++) {' . chr(10) . '        if (arguments[i] == null) {' . chr(10) . '            res.push(null)' . chr(10) . '        }' . chr(10) . '        else if (arguments[i].hasOwnProperty("get_values")) {' . chr(10) . '            // container' . chr(10) . '            arguments[i].get_values(res);' . chr(10) . '        }' . chr(10) . '        else if (arguments[i] instanceof Array) {' . chr(10) . '            // js Array -- possibly generated by p5context()' . chr(10) . '            o = arguments[i];' . chr(10) . '            for (j = 0; j < o.length; j++) {' . chr(10) . '                res.push(o[j]);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            // non-container' . chr(10) . '            res.push(arguments[i]);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return res;' . chr(10) . '};' . chr(10) . chr(10) . 'p5a_to_h = function(a) {' . chr(10) . '    var res = {};' . chr(10) . '    for (i = 0; i < a.length; i+=2) {' . chr(10) . '        res[p5str(a[i])] = a[i+1];' . chr(10) . '    }' . chr(10) . '    return res;' . chr(10) . '};' . chr(10) . chr(10) . 'if (isNode) {' . chr(10) . '    var fs = require("fs");' . chr(10) . '    p5typeglob_set("Perlito5::IO", "slurp", function(List__) {' . chr(10) . '        var filename = p5str(List__[0]);' . chr(10) . '        return fs.readFileSync(filename, "utf8");' . chr(10) . '    });' . chr(10) . '} else {' . chr(10) . '    p5typeglob_set("Perlito5::IO", "slurp", function(List__) {' . chr(10) . '        var filename = p5str(List__[0]);' . chr(10) . '        if (typeof readFile == "function") {' . chr(10) . '            return readFile(filename);' . chr(10) . '        }' . chr(10) . '        if (typeof read == "function") {' . chr(10) . '            // v8' . chr(10) . '            return read(filename);' . chr(10) . '        }' . chr(10) . '        p5pkg.CORE.die(["Perlito5::IO::slurp() not implemented"]);' . chr(10) . '    });' . chr(10) . '}' . chr(10) . chr(10) . 'p5context = function(List__, p5want) {' . chr(10) . '    if (p5want) {' . chr(10) . '        return p5list_to_a.apply(null, List__);' . chr(10) . '    }' . chr(10) . '    // scalar: return the last value' . chr(10) . '    var o = List__;' . chr(10) . '    while (o instanceof Array) {' . chr(10) . '        o =   o.length' . chr(10) . '            ? o[o.length-1]' . chr(10) . '            : null;' . chr(10) . '    }' . chr(10) . '    return o;' . chr(10) . '}' . chr(10) . chr(10) . 'p5code = function(o) {' . chr(10) . '    if (typeof o === "function") {' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . '    return o.p5code();' . chr(10) . '};' . chr(10) . chr(10) . 'p5str = function(o) {' . chr(10) . '    if (o == null) {' . chr(10) . '        return "";' . chr(10) . '    }' . chr(10) . '    if (typeof o === "object" && (o instanceof Array)) {' . chr(10) . '        return CORE.join(["", o]);' . chr(10) . '    }' . chr(10) . '    if (typeof o.p5string === "function") {' . chr(10) . '        return o.p5string();' . chr(10) . '    }' . chr(10) . '    if (typeof o == "number" && Math.abs(o) < 0.0001 && o != 0) {' . chr(10) . '        return o.toExponential().replace(/e-(' . chr(92) . 'd)$/,"e-0$1");' . chr(10) . '    }' . chr(10) . '    if (typeof o === "boolean") {' . chr(10) . '        return o ? "1" : "";' . chr(10) . '    }' . chr(10) . '    if (typeof o !== "string") {' . chr(10) . '        return "" + o;' . chr(10) . '    }' . chr(10) . '    return o;' . chr(10) . '};' . chr(10) . chr(10) . 'p5num = function(o) {' . chr(10) . '    if (o == null) {' . chr(10) . '        return 0;' . chr(10) . '    }' . chr(10) . '    if (typeof o === "object" && (o instanceof Array)) {' . chr(10) . '        return o.length;' . chr(10) . '    }' . chr(10) . '    if (typeof o.p5num === "function") {' . chr(10) . '        return o.p5num();' . chr(10) . '    }' . chr(10) . '    if (typeof o !== "number") {' . chr(10) . '        return parseFloat(p5str(o));' . chr(10) . '    }' . chr(10) . '    return o;' . chr(10) . '};' . chr(10) . chr(10) . 'p5bool = function(o) {' . chr(10) . '    if (o) {' . chr(10) . '        if (typeof o === "boolean") {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        if (typeof o === "number") {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        if (typeof o === "string") {' . chr(10) . '            return o != "" && o != "0";' . chr(10) . '        }' . chr(10) . '        if (typeof o.p5bool === "function") {' . chr(10) . '            return o.p5bool();' . chr(10) . '        }' . chr(10) . '        if (typeof o.length === "number") {' . chr(10) . '            return o.length;' . chr(10) . '        }' . chr(10) . '        if (o instanceof Error) {' . chr(10) . '            return true;' . chr(10) . '        }' . chr(10) . '        for (var i in o) {' . chr(10) . '            return true;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return false;' . chr(10) . '};' . chr(10) . chr(10) . 'p5incr = function(o) {' . chr(10) . '    if (typeof o === "number") {' . chr(10) . '        return o + 1;' . chr(10) . '    }' . chr(10) . '    return p5str_inc(p5str(o));' . chr(10) . '};' . chr(10) . chr(10) . 'p5decr = function(o) {' . chr(10) . '    if (typeof o === "number") {' . chr(10) . '        return o - 1;' . chr(10) . '    }' . chr(10) . '    return p5num(o) - 1;' . chr(10) . '};' . chr(10) . chr(10) . 'p5and = function(a, fb) {' . chr(10) . '    if (p5bool(a)) {' . chr(10) . '        return fb();' . chr(10) . '    }' . chr(10) . '    return a;' . chr(10) . '};' . chr(10) . chr(10) . 'p5or = function(a, fb) {' . chr(10) . '    if (p5bool(a)) {' . chr(10) . '        return a;' . chr(10) . '    }' . chr(10) . '    return fb();' . chr(10) . '};' . chr(10) . chr(10) . 'p5defined_or = function(a, fb) {' . chr(10) . '    if (a == null) {' . chr(10) . '        return fb();' . chr(10) . '    }' . chr(10) . '    return a;' . chr(10) . '};' . chr(10) . chr(10) . 'p5cmp = function(a, b) {' . chr(10) . '    return a > b ? 1 : a < b ? -1 : 0 ' . chr(10) . '};' . chr(10) . chr(10) . 'p5complement = function(a) {' . chr(10) . '    return a < 0 ? ~a : 4294967295 - a' . chr(10) . '    // return a < 0 ? ~a : 18446744073709551615 - a' . chr(10) . '};' . chr(10) . chr(10) . 'p5str_replicate = function(o, n) {' . chr(10) . '    n = p5num(n);' . chr(10) . '    return n ? Array(n + 1).join(o) : "";' . chr(10) . '};' . chr(10) . chr(10) . 'p5str_inc = function(s) {' . chr(10) . '    s = p5str(s);' . chr(10) . '    if (s.length < 2) {' . chr(10) . '        if (s.match(/[012345678ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy]/)) {' . chr(10) . '            return String.fromCharCode(s.charCodeAt(0) + 1);' . chr(10) . '        }' . chr(10) . '        if (s == "9") {' . chr(10) . '            return "10";' . chr(10) . '        }' . chr(10) . '        if (s == "Z") {' . chr(10) . '            return "AA";' . chr(10) . '        }' . chr(10) . '        if (s == "z") {' . chr(10) . '            return "aa";' . chr(10) . '        }' . chr(10) . '        return "1";' . chr(10) . '    }' . chr(10) . '    var c = p5str_inc(s.substr(s.length-1, 1));' . chr(10) . '    if (c.length == 1) {' . chr(10) . '        return s.substr(0, s.length-1) + c;' . chr(10) . '    }' . chr(10) . '    return p5str_inc(s.substr(0, s.length-1)) + c.substr(c.length-1, 1);' . chr(10) . '};' . chr(10) . chr(10) . 'p5for = function(namespace, func, args, cont, label) {' . chr(10) . '    var _redo = false;' . chr(10) . chr(10) . '    var v_old = namespace["v__"];' . chr(10) . '    namespace["v__"] = new p5Scalar(null);' . chr(10) . chr(10) . '    for(var i = 0; i < args.length; i++) {' . chr(10) . '        namespace["v__"].assign(args[i]);   // ??? - should this be a bind?' . chr(10) . '        try {' . chr(10) . '            func()' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            if (err instanceof p5_error && err.v == label) {' . chr(10) . '                if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { i--; _redo = true }' . chr(10) . '                else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                throw(err)' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        if (cont) {' . chr(10) . '            try {' . chr(10) . '                if (!_redo) { cont() }' . chr(10) . '            }' . chr(10) . '            catch(err) {' . chr(10) . '                if (err instanceof p5_error && err.v == label) {' . chr(10) . '                    if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                    else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }' . chr(10) . '                    else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '                }            ' . chr(10) . '                else {' . chr(10) . '                    throw(err)' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    namespace["v__"] = v_old;' . chr(10) . '};' . chr(10) . chr(10) . 'p5for_lex = function(func, args, cont, label) {' . chr(10) . '    var _redo = false;' . chr(10) . '    var _arg  = new p5Scalar(null);' . chr(10) . '    for(var i = 0; i < args.length; i++) {' . chr(10) . '        try {' . chr(10) . '            _arg.assign(args[i]);' . chr(10) . '            func(_arg)' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            if (err instanceof p5_error && err.v == label) {' . chr(10) . '                if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { i--; _redo = true }' . chr(10) . '                else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '            }            ' . chr(10) . '            else {' . chr(10) . '                throw(err)' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        if (cont) {' . chr(10) . '            try {' . chr(10) . '                if (!_redo) { cont() }' . chr(10) . '            }' . chr(10) . '            catch(err) {' . chr(10) . '                if (err instanceof p5_error && err.v == label) {' . chr(10) . '                    if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                    else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }' . chr(10) . '                    else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '                }            ' . chr(10) . '                else {' . chr(10) . '                    throw(err)' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . 'p5while = function(func, cond, cont, label) {' . chr(10) . '    var _redo = false;' . chr(10) . '    while (_redo || p5bool(cond())) {' . chr(10) . '        _redo = false;' . chr(10) . '        try {' . chr(10) . '            func()' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            if (err instanceof p5_error && err.v == label) {' . chr(10) . '                if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }' . chr(10) . '                else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '            }            ' . chr(10) . '            else {' . chr(10) . '                throw(err)' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        if (cont) {' . chr(10) . '            try {' . chr(10) . '                if (!_redo) { cont() }' . chr(10) . '            }' . chr(10) . '            catch(err) {' . chr(10) . '                if (err instanceof p5_error && err.v == label) {' . chr(10) . '                    if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                    else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }' . chr(10) . '                    else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '                }            ' . chr(10) . '                else {' . chr(10) . '                    throw(err)' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . 'p5map = function(namespace, func, args) {' . chr(10) . '    var v_old = namespace["v__"];' . chr(10) . '    namespace["v__"] = new p5Scalar(null);' . chr(10) . chr(10) . '    var out = [];' . chr(10) . '    for(var i = 0; i < args.length; i++) {' . chr(10) . '        namespace["v__"].assign(args[i]);' . chr(10) . '        var o = p5list_to_a(func(1));' . chr(10) . '        for(var j = 0; j < o.length; j++) {' . chr(10) . '            out.push(o[j]);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    namespace["v__"] = v_old;' . chr(10) . '    return out;' . chr(10) . '};' . chr(10) . chr(10) . 'p5grep = function(namespace, func, args) {' . chr(10) . '    var v_old = namespace["v__"];' . chr(10) . '    namespace["v__"] = new p5Scalar(null);' . chr(10) . chr(10) . '    var out = [];' . chr(10) . '    for(var i = 0; i < args.length; i++) {' . chr(10) . '        namespace["v__"].assign(args[i]);' . chr(10) . '        if (p5bool(func(0))) {' . chr(10) . '            out.push(args[i])' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    namespace["v__"] = v_old;' . chr(10) . '    return out;' . chr(10) . '};' . chr(10) . chr(10) . 'p5sort = function(namespace, func, args) {' . chr(10) . '    var a_old = namespace["v_a"];' . chr(10) . '    var b_old = namespace["v_b"];' . chr(10) . '    namespace["v_a"] = new p5Scalar(null);' . chr(10) . '    namespace["v_b"] = new p5Scalar(null);' . chr(10) . chr(10) . '    var out = ' . chr(10) . '        func == null' . chr(10) . '        ? args.sort()' . chr(10) . '        : args.sort(' . chr(10) . '            function(a, b) {' . chr(10) . '                namespace["v_a"].assign(a);' . chr(10) . '                namespace["v_b"].assign(b);' . chr(10) . '                return func(0);' . chr(10) . '            }' . chr(10) . '        );' . chr(10) . '    namespace["v_a"] = a_old;' . chr(10) . '    namespace["v_b"] = b_old;' . chr(10) . '    return out;' . chr(10) . '};' . chr(10) . chr(10) . 'perl5_to_js = function( source, namespace, var_env_js, p5want ) {' . chr(10) . '    // CORE.say(["source: [" + source + "]"]);' . chr(10) . chr(10) . '    var strict_old = p5global("$", "Perlito5", "STRICT").FETCH();' . chr(10) . '    var var_env_js_old = p5global("$", "Perlito5", "VAR").FETCH();' . chr(10) . '    p5pkg["Perlito5"].v_VAR.assign(var_env_js);' . chr(10) . chr(10) . '    var namespace_old = p5global("$", "Perlito5", "PKG_NAME").FETCH();' . chr(10) . '    p5pkg["Perlito5"].v_PKG_NAME.assign(namespace);' . chr(10) . chr(10) . '    match = p5call(p5pkg["Perlito5::Grammar"], "exp_stmts", [source, 0]);' . chr(10) . chr(10) . '    if ( !p5bool(match) || p5str(match.hget("to")) != source.length ) {' . chr(10) . '        CORE.die(["Syntax error in eval near pos ", match.hget("to") ]);' . chr(10) . '    }' . chr(10) . chr(10) . '    ast = p5pkg.CORE.bless([' . chr(10) . '        new p5HashRef(new p5Hash({' . chr(10) . '            block:  p5pkg.CORE.bless([' . chr(10) . '                        new p5HashRef(new p5Hash({' . chr(10) . '                            stmts:   p5pkg["Perlito5::Match"].flat([match])' . chr(10) . '                        })),' . chr(10) . '                        p5pkg["Perlito5::AST::Lit::Block"]' . chr(10) . '                    ])' . chr(10) . '        })),' . chr(10) . '        p5pkg["Perlito5::AST::Do"]' . chr(10) . '    ]);' . chr(10) . chr(10) . '    // CORE.say(["ast: [" + ast + "]"]);' . chr(10) . '    js_code = p5call(ast, "emit_javascript3", [0, p5want]);' . chr(10) . '    // CORE.say(["js-source: [" + js_code + "]"]);' . chr(10) . chr(10) . '    p5pkg["Perlito5"].v_PKG_NAME.assign(namespace_old);' . chr(10) . '    p5pkg["Perlito5"].v_VAR.assign(var_env_js_old);' . chr(10) . '    p5pkg["Perlito5"].v_STRICT.assign(strict_old);' . chr(10) . '    return js_code;' . chr(10) . '}' . chr(10) . chr(10)))
};
1;

;

# use Perlito5::Javascript3::Runtime
;
package main;
undef();
package Perlito5::Javascript3::CORE;
sub Perlito5::Javascript3::CORE::emit_javascript3 {
    return (('//' . chr(10) . '//' . chr(10) . '// lib/Perlito5/Javascript3/CORE.js' . chr(10) . '//' . chr(10) . '// CORE functions for "Perlito" Perl5-in-Javascript3' . chr(10) . '//' . chr(10) . '// AUTHORS' . chr(10) . '//' . chr(10) . '// Flavio Soibelmann Glock  fglock@gmail.com' . chr(10) . '//' . chr(10) . '// COPYRIGHT' . chr(10) . '//' . chr(10) . '// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.' . chr(10) . '//' . chr(10) . '// This program is free software; you can redistribute it and/or modify it' . chr(10) . '// under the same terms as Perl itself.' . chr(10) . '//' . chr(10) . '// See http://www.perl.com/perl/misc/Artistic.html' . chr(10) . chr(10) . 'var CORE = p5pkg.CORE;' . chr(10) . chr(10) . 'var isNode = typeof require != "undefined";' . chr(10) . 'if (isNode) {' . chr(10) . '    CORE.print = function(List__) {' . chr(10) . '        var i;' . chr(10) . '        for (i = 0; i < List__.length; i++) {' . chr(10) . '            process.stdout.write(p5str(List__[i]));' . chr(10) . '        }' . chr(10) . '        return 1;' . chr(10) . '    }' . chr(10) . '} else {' . chr(10) . '    CORE.print = function(List__) {' . chr(10) . '        var i;' . chr(10) . '        for (i = 0; i < List__.length; i++) {' . chr(10) . '            write(p5str(List__[i]));' . chr(10) . '        }' . chr(10) . '        return 1;' . chr(10) . '    };' . chr(10) . '}' . chr(10) . chr(10) . 'CORE.say = function(List__) {' . chr(10) . '    CORE.print(List__);' . chr(10) . '    return CORE.print(["' . chr(92) . 'n"]);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.die = function(List__) {' . chr(10) . '    var o = List__[0]._array_;   // prototype is ' . chr(39) . '@' . chr(39) . chr(10) . '    var i;' . chr(10) . '    var s = "";' . chr(10) . '    for (i = 0; i < o.length; i++) {' . chr(10) . '        s = s + p5str(o[i]);' . chr(10) . '    }' . chr(10) . '    try {' . chr(10) . '        s = s + "' . chr(92) . 'n" + new Error().stack;' . chr(10) . '    }' . chr(10) . '    catch(err) { }' . chr(10) . '    p5pkg["main"]["v_@"].assign("Died: " + s);' . chr(10) . '    throw(new p5_error("die", "Died: " + s));' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.warn = function(List__) {' . chr(10) . '    var o = List__[0]._array_;   // prototype is ' . chr(39) . '@' . chr(39) . chr(10) . '    var i;' . chr(10) . '    var s = "";' . chr(10) . '    for (i = 0; i < o.length; i++) {' . chr(10) . '        s = s + p5str(o[i]);' . chr(10) . '    }' . chr(10) . '    try {' . chr(10) . '        s = s + "' . chr(92) . 'n" + new Error().stack;' . chr(10) . '    }' . chr(10) . '    catch(err) { }' . chr(10) . '    CORE.print(["Warning: " + s + "' . chr(92) . 'n"]);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.bless = function(List__) {' . chr(10) . '    var o        = List__[0];' . chr(10) . '    var pkg_name = List__[1];' . chr(10) . '    if (o instanceof p5Scalar) {' . chr(10) . '        o = o.FETCH();' . chr(10) . '    }' . chr(10) . '    if (pkg_name instanceof p5Scalar) {' . chr(10) . '        pkg_name = pkg_name.FETCH();' . chr(10) . '    }' . chr(10) . '    if (typeof pkg_name === "object") {' . chr(10) . '        // bless {}, Class' . chr(10) . '        o._class_ = pkg_name;' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . '    if (!p5pkg.hasOwnProperty(pkg_name)) {' . chr(10) . '        p5make_package(pkg_name);' . chr(10) . '    }' . chr(10) . '    o._class_ = p5pkg[pkg_name];' . chr(10) . '    return o;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.caller = function(List__, p5want) {' . chr(10) . '    if (p5want) {' . chr(10) . '        return p5pkg["Perlito5"]["CALLER"][0];' . chr(10) . '    }' . chr(10) . '    return p5pkg["Perlito5"]["CALLER"][0][0];' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.chr = function(List__) {' . chr(10) . '    var v = p5num(List__[0]);' . chr(10) . '    return String.fromCharCode(v >= 0 ? v : 65533);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.ord = function(List__) {' . chr(10) . '    return p5str(List__[0]).charCodeAt(0);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.oct = function(List__) {' . chr(10) . '    var v = p5str(List__[0]);' . chr(10) . '    var b = v.substr(0,2);' . chr(10) . '    v = v.replace("_", "");' . chr(10) . '    if (b == "0b" || b == "0B") { return parseInt(v.substr(2), 2)  }' . chr(10) . '    if (b == "0x" || b == "0X") { return parseInt(v.substr(2), 16) }' . chr(10) . '    return parseInt(v, 8);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.abs   = function(List__) { return Math.abs(p5num(List__[0])) };' . chr(10) . 'CORE.exp   = function(List__) { return Math.exp(p5num(List__[0])) };' . chr(10) . 'CORE.log   = function(List__) { return Math.log(p5num(List__[0])) };' . chr(10) . 'CORE.cos   = function(List__) { return Math.cos(p5num(List__[0])) };' . chr(10) . 'CORE.sin   = function(List__) { return Math.sin(p5num(List__[0])) };' . chr(10) . 'CORE.sqrt  = function(List__) { return Math.sqrt(p5num(List__[0])) };' . chr(10) . 'CORE.atan2 = function(List__) { return Math.atan2(p5num(List__[0]), p5num(List__[1])) };' . chr(10) . 'CORE.int   = function(List__) { ' . chr(10) . '    var v = p5num(List__[0]);' . chr(10) . '    return v > 0 ? Math.floor(v) : Math.ceil(v)' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.rand = function(List__) {' . chr(10) . '    var v = p5num(List__[0]) || 1;' . chr(10) . '    return Math.random() * v;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.lc      = function(List__) { return p5str(List__[0]).toLowerCase() };' . chr(10) . 'CORE.uc      = function(List__) { return p5str(List__[0]).toUpperCase() };' . chr(10) . chr(10) . 'CORE.lcfirst = function(List__) {' . chr(10) . '    var s = p5str(List__[0]);' . chr(10) . '    var c = s.length > 0 ? s.slice(0,1).toLowerCase() : "";' . chr(10) . '    s = s.length > 1 ? s.substr(1) : "";' . chr(10) . '    return c + s' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.ucfirst = function(List__) {' . chr(10) . '    var s = p5str(List__[0]);' . chr(10) . '    var c = s.length > 0 ? s.slice(0,1).toUpperCase() : "";' . chr(10) . '    s = s.length > 1 ? s.substr(1) : "";' . chr(10) . '    return c + s' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.quotemeta = function(List__) {' . chr(10) . '    var s = p5str(List__[0]);' . chr(10) . '    var out = [];' . chr(10) . '    for(var i = 0; i < s.length; i++) {' . chr(10) . '        if (s.substr(i, 1).match(/[^0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz]/)) {' . chr(10) . '            out.push(String.fromCharCode(92));' . chr(10) . '        }' . chr(10) . '        out.push(s.substr(i, 1));' . chr(10) . '    }' . chr(10) . '    return out.join("");       ' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.substr = function(List__) {' . chr(10) . chr(10) . '    // TODO - lvalue substr()' . chr(10) . chr(10) . '    var s           = p5str(List__[0]);' . chr(10) . '    var offset      = p5num(List__[1]);' . chr(10) . '    var length      = List__.length > 2 ? p5num(List__[2]) : s.length;' . chr(10) . '    var replacement = List__[3];' . chr(10) . chr(10) . '    if (length < 0) {' . chr(10) . '        length = s.length - offset + length;' . chr(10) . '    }' . chr(10) . '    return s.substr(offset, length);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.defined = function(List__) {' . chr(10) . '    return (List__[0] instanceof p5Scalar) ? ( List__[0].FETCH() != null ) : ( List__[0] != null )' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.values = function(List__, p5want) {' . chr(10) . '    var o = List__[0]._hash_;' . chr(10) . '    delete o["_each_"];' . chr(10) . '    if (p5want) {' . chr(10) . '        if (o == null) {' . chr(10) . '            return new p5Array([]);' . chr(10) . '        };' . chr(10) . '        if (typeof o.values === "function") {' . chr(10) . '            return o.values();' . chr(10) . '        }' . chr(10) . '        var out = [];' . chr(10) . '        for (var i in o) {' . chr(10) . '            out.push(o[i]);' . chr(10) . '        }' . chr(10) . '        return new p5Array(out);' . chr(10) . '    }' . chr(10) . '    return CORE.keys(List__, p5want);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.keys = function(List__, p5want) {' . chr(10) . '    var o = List__[0]._hash_;' . chr(10) . '    delete o["_each_"];' . chr(10) . '    if (p5want) {' . chr(10) . '        if (o == null) {' . chr(10) . '            return new p5Array([]);' . chr(10) . '        }' . chr(10) . '        if (typeof o.keys === "function") {' . chr(10) . '            return o.keys();' . chr(10) . '        }' . chr(10) . '        var out = [];' . chr(10) . '        for (var i in o) {' . chr(10) . '            out.push(i);' . chr(10) . '        }' . chr(10) . '        return new p5Array(out);' . chr(10) . '    }' . chr(10) . '    else {' . chr(10) . '        if (o == null) {' . chr(10) . '            return 0;' . chr(10) . '        }' . chr(10) . '        if (typeof o.keys === "function") {' . chr(10) . '            return CORE.scalar([o.keys()]);' . chr(10) . '        }' . chr(10) . '        var out = 0;' . chr(10) . '        for (var i in o) {' . chr(10) . '            out++;' . chr(10) . '        }' . chr(10) . '        return out;' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.each = function(List__, p5want) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    if (o.hasOwnProperty("_each_")) {' . chr(10) . '        return o._each_(p5want)' . chr(10) . '    }' . chr(10) . '    var keys = CORE.keys([o], 1);' . chr(10) . '    var i = 0;' . chr(10) . '    o._each_ = function () {' . chr(10) . '        if (i < keys.length) {' . chr(10) . '            i++;' . chr(10) . '            return p5want ? [keys[i-1], o[keys[i-1]]] : keys[i-1];' . chr(10) . '        }' . chr(10) . '        i = 0;' . chr(10) . '        return p5want ? [] : null;' . chr(10) . '    };' . chr(10) . '    return o._each_(p5want);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.reverse = function(List__) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    if (o instanceof p5Scalar) {' . chr(10) . '        o = o.FETCH();' . chr(10) . '    }' . chr(10) . '    if (o == null) {' . chr(10) . '        return "";' . chr(10) . '    }' . chr(10) . '    if (typeof o === "string") {' . chr(10) . '        return o.split("").reverse().join("")' . chr(10) . '    }' . chr(10) . '    var out = [];' . chr(10) . '    for(var i = 0; i < o.length; i++) {' . chr(10) . '        out.unshift(o[i]);' . chr(10) . '    }' . chr(10) . '    return out;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.splice = function(List__, p5want) {' . chr(10) . '    var array  = List__.shift()._array_;' . chr(10) . '    // CORE.say([ array ]);' . chr(10) . '    var offset = p5num(List__.shift());' . chr(10) . '    var limit  = List__.length ? p5num(List__.shift()) : (array.length + 1);' . chr(10) . chr(10) . '    if (limit < 0) {' . chr(10) . '        limit = array.length + limit - 1;' . chr(10) . '    }' . chr(10) . chr(10) . '    var list = [offset, limit];' . chr(10) . '    for(var i = 0; i < List__.length; i++) {' . chr(10) . '        list = p5list_to_a( list, List__[i]);' . chr(10) . '    }' . chr(10) . chr(10) . '    out = array.splice.apply(array, list);' . chr(10) . '    // CORE.say([ CORE.join([":",array]), " ofs=", offset, " lim=", limit, " list=", list, " out=", CORE.join([":",out])  ]);' . chr(10) . '    return p5want ? out : out.pop();' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.pop = function(List__) {' . chr(10) . '    return List__[0].POP();' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.shift = function(List__) {' . chr(10) . '    return List__[0].SHIFT();' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.push = function(List__) {' . chr(10) . '    return List__[0].PUSH(List__[1]);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.unshift = function(List__) {' . chr(10) . '    return List__[0].UNSHIFT(List__[1]);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.join = function(List__) {' . chr(10) . '    var s = List__[0];' . chr(10) . '    var o = List__[1]._array_;' . chr(10) . '    var a = [];' . chr(10) . '    for (i = 0; i < o.length; i++) {' . chr(10) . '        a.push( p5str(o[i]) );' . chr(10) . '    }' . chr(10) . '    return a.join(s);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.index = function(List__) {' . chr(10) . '    try {' . chr(10) . '        return p5str(List__[0]).indexOf(p5str(List__[1]), p5num(List__[2]));' . chr(10) . '    }' . chr(10) . '    catch(err) {' . chr(10) . '        return -1;' . chr(10) . '    }' . chr(10) . '};' . chr(10) . 'CORE.rindex = function(List__) {' . chr(10) . '    var o = p5str(List__[0]);' . chr(10) . '    var s = List__[1];' . chr(10) . '    try {' . chr(10) . '        if (List__.length > 2) {' . chr(10) . '            var i = p5num(List__[2]);' . chr(10) . '            if (i < 0) {' . chr(10) . '                if (s.length == 0) {' . chr(10) . '                    return 0;' . chr(10) . '                }' . chr(10) . '                return -1;' . chr(10) . '            }' . chr(10) . '            return o.lastIndexOf(s, i);' . chr(10) . '        }' . chr(10) . '        return o.lastIndexOf(s);' . chr(10) . '    }' . chr(10) . '    catch(err) {' . chr(10) . '        return -1;' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.length = function(List__) {' . chr(10) . '    var o = p5str(List__[0]);' . chr(10) . '    return o.length;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.pack    = function(List__) { CORE.warn([ "CORE::pack not implemented" ]) };' . chr(10) . 'CORE.unpack  = function(List__) { CORE.warn([ "CORE::unpack not implemented" ]) };' . chr(10) . chr(10) . 'CORE.ref = function(List__) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    if (o instanceof p5Scalar) {' . chr(10) . '        o = o.FETCH();' . chr(10) . '    }' . chr(10) . '    if (o == null) {' . chr(10) . '        return "";' . chr(10) . '    }' . chr(10) . '    if (o._class_ && typeof o._class_._ref_ === "string") {' . chr(10) . '        // blessed reference' . chr(10) . '        return o._class_._ref_;' . chr(10) . '    }' . chr(10) . '    if (typeof o._ref_ === "string") {' . chr(10) . '        // un-blessed reference' . chr(10) . '        return o._ref_;' . chr(10) . '    }' . chr(10) . '    if (typeof o === "function") {' . chr(10) . '        return "CODE";' . chr(10) . '    }' . chr(10) . '    return "";' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.split = function(List__) {' . chr(10) . '    var pattern = List__[0];' . chr(10) . '    var s       = p5str(List__[1]);' . chr(10) . '    var limit   = List__[2];' . chr(10) . '    if (typeof pattern === "string") {' . chr(10) . '        if (pattern == " ") {' . chr(10) . '            var res = [];' . chr(10) . '            for (var i_ = 0, a_ = s.split(/(?: |' . chr(92) . 'n)+/); i_ < a_.length ; i_++) {' . chr(10) . '                if (a_[i_] != "") {' . chr(10) . '                    res.push(a_[i_])' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            return res;' . chr(10) . '        }' . chr(10) . '        return s.split(pattern);' . chr(10) . '    }' . chr(10) . '    CORE.die(["not implemented"]);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.prototype = function(List__, data) {' . chr(10) . '    var name = List__[0];' . chr(10) . '    // TODO - fully qualify "name" using information from "data"' . chr(10) . '    // XXX - lookup in CORE::GLOBAL?' . chr(10) . '    p5pkg["Perlito5"].v_PROTO._hash_[name] || p5pkg["Perlito5"].v_CORE_PROTO._hash_[name]' . chr(10) . '};' . chr(10) . chr(10)))
};
1;

;

# use Perlito5::Javascript3::CORE
;
package main;
undef();
package Perlito5::Javascript3::IO;
sub Perlito5::Javascript3::IO::emit_javascript3 {
    return (('//' . chr(10) . '//' . chr(10) . '// lib/Perlito5/Javascript3/IO.js' . chr(10) . '//' . chr(10) . '// I/O functions for "Perlito" Perl5-in-Javascript3' . chr(10) . '//' . chr(10) . '// AUTHORS' . chr(10) . '//' . chr(10) . '// Flavio Soibelmann Glock  fglock@gmail.com' . chr(10) . '//' . chr(10) . '// COPYRIGHT' . chr(10) . '//' . chr(10) . '// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.' . chr(10) . '//' . chr(10) . '// This program is free software; you can redistribute it and/or modify it' . chr(10) . '// under the same terms as Perl itself.' . chr(10) . '//' . chr(10) . '// See http://www.perl.com/perl/misc/Artistic.html' . chr(10) . chr(10) . 'var isNode = typeof require != "undefined";' . chr(10) . 'if (isNode) {' . chr(10) . chr(10) . '    var fs = require("fs");' . chr(10) . chr(10) . '    p5atime = function(s) {' . chr(10) . '        s = p5str(s);' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat["atime"];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5mtime = function(s) {' . chr(10) . '        s = p5str(s);' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat["mtime"];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5ctime = function(s) {' . chr(10) . '        s = p5str(s);' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat["ctime"];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5size = function(s) {' . chr(10) . '        s = p5str(s);' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat["size"];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5is_file = function(s) {' . chr(10) . '        s = p5str(s);' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat.isFile() ? 1 : 0;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5is_directory = function(s) {' . chr(10) . '        s = p5str(s);' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat.isDirectory() ? 1 : 0;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5file_exists = function(s) {' . chr(10) . '        s = p5str(s);' . chr(10) . '        return p5is_file(s) || p5is_directory(s);' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.chdir = function(List__) {' . chr(10) . '        try {' . chr(10) . '            process.chdir(p5str(List__[0]));' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.close = function(List__) {' . chr(10) . '        try {' . chr(10) . '            fs.closeSync(p5str(List__[0]));' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.exit = function(List__) {' . chr(10) . '        process.exit(List__[0]);' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.rename = function(List__) {' . chr(10) . '        try {' . chr(10) . '            fs.renameSync(p5str(List__[0]), p5str(List__[1]));' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.unlink = function(List__) {' . chr(10) . '        var count = 0;' . chr(10) . '        try {' . chr(10) . '            for(var i = 0; i < List__.length; i++) {' . chr(10) . '                fs.unlinkSync(p5str(List__[i]));' . chr(10) . '                count++;' . chr(10) . '            }' . chr(10) . '            return count;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return count;' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '}' . chr(10) . chr(10)))
};
1;

;

# use Perlito5::Javascript3::IO
;
package main;
undef();
package Perlito5::Javascript3::Sprintf;
sub Perlito5::Javascript3::Sprintf::emit_javascript3 {
    return (('/**' . chr(10) . ' * Copyright (c) 2010 Jakob Westhoff' . chr(10) . ' *' . chr(10) . ' * Permission is hereby granted, free of charge, to any person obtaining a copy' . chr(10) . ' * of this software and associated documentation files (the "Software"), to deal' . chr(10) . ' * in the Software without restriction, including without limitation the rights' . chr(10) . ' * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell' . chr(10) . ' * copies of the Software, and to permit persons to whom the Software is' . chr(10) . ' * furnished to do so, subject to the following conditions:' . chr(10) . ' * ' . chr(10) . ' * The above copyright notice and this permission notice shall be included in' . chr(10) . ' * all copies or substantial portions of the Software.' . chr(10) . ' * ' . chr(10) . ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR' . chr(10) . ' * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,' . chr(10) . ' * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE' . chr(10) . ' * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER' . chr(10) . ' * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,' . chr(10) . ' * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN' . chr(10) . ' * THE SOFTWARE.' . chr(10) . ' */' . chr(10) . chr(10) . 'CORE.sprintf = function(List__) {' . chr(10) . '    var format = List__[0];' . chr(10) . '    var list = List__[1];' . chr(10) . chr(10) . '    // Check for format definition' . chr(10) . '    if ( typeof format != ' . chr(39) . 'string' . chr(39) . ' ) {' . chr(10) . '        CORE.die(["sprintf: The first arguments need to be a valid format string."]);' . chr(10) . '    }' . chr(10) . '    ' . chr(10) . '    /**' . chr(10) . '     * Define the regex to match a formating string' . chr(10) . '     * The regex consists of the following parts:' . chr(10) . '     * percent sign to indicate the start' . chr(10) . '     * (optional) sign specifier' . chr(10) . '     * (optional) padding specifier' . chr(10) . '     * (optional) alignment specifier' . chr(10) . '     * (optional) width specifier' . chr(10) . '     * (optional) precision specifier' . chr(10) . '     * type specifier:' . chr(10) . '     *  % - literal percent sign' . chr(10) . '     *  b - binary number' . chr(10) . '     *  c - ASCII character represented by the given value' . chr(10) . '     *  d - signed decimal number' . chr(10) . '     *  f - floating point value' . chr(10) . '     *  o - octal number' . chr(10) . '     *  s - string' . chr(10) . '     *  x - hexadecimal number (lowercase characters)' . chr(10) . '     *  X - hexadecimal number (uppercase characters)' . chr(10) . '     */' . chr(10) . '    var r = new RegExp( /%(' . chr(92) . '+)?([0 ]|' . chr(39) . '(.))?(-)?([0-9]+)?(' . chr(92) . '.([0-9]+))?([%bcdfosxX])/g );' . chr(10) . chr(10) . '    /**' . chr(10) . '     * Each format string is splitted into the following parts:' . chr(10) . '     * 0: Full format string' . chr(10) . '     * 1: sign specifier (+)' . chr(10) . '     * 2: padding specifier (0/<space>/' . chr(39) . '<any char>)' . chr(10) . '     * 3: if the padding character starts with a ' . chr(39) . ' this will be the real ' . chr(10) . '     *    padding character' . chr(10) . '     * 4: alignment specifier' . chr(10) . '     * 5: width specifier' . chr(10) . '     * 6: precision specifier including the dot' . chr(10) . '     * 7: precision specifier without the dot' . chr(10) . '     * 8: type specifier' . chr(10) . '     */' . chr(10) . '    var parts      = [];' . chr(10) . '    var paramIndex = 0;' . chr(10) . '    while ( part = r.exec( format ) ) {' . chr(10) . '        // Check if an input value has been provided, for the current' . chr(10) . '        // format string' . chr(10) . '        if ( paramIndex >= list.length ) {' . chr(10) . '            CORE.die(["sprintf: At least one argument was missing."]);' . chr(10) . '        }' . chr(10) . chr(10) . '        parts[parts.length] = {' . chr(10) . '            /* beginning of the part in the string */' . chr(10) . '            begin: part.index,' . chr(10) . '            /* end of the part in the string */' . chr(10) . '            end: part.index + part[0].length,' . chr(10) . '            /* force sign */' . chr(10) . '            sign: ( part[1] == ' . chr(39) . '+' . chr(39) . ' ),' . chr(10) . '            /* is the given data negative */' . chr(10) . '            negative: ( parseInt( list[paramIndex] ) < 0 ) ? true : false,' . chr(10) . '            /* padding character (default: <space>) */' . chr(10) . '            padding: ( part[2] == undefined )' . chr(10) . '                     ? ( ' . chr(39) . ' ' . chr(39) . ' ) /* default */' . chr(10) . '                     : ( ( part[2].substring( 0, 1 ) == "' . chr(39) . '" ) ' . chr(10) . '                         ? ( part[3] ) /* use special char */' . chr(10) . '                         : ( part[2] ) /* use normal <space> or zero */' . chr(10) . '                       ),' . chr(10) . '            /* should the output be aligned left?*/' . chr(10) . '            alignLeft: ( part[4] == ' . chr(39) . '-' . chr(39) . ' ),' . chr(10) . '            /* width specifier (number or false) */' . chr(10) . '            width: ( part[5] != undefined ) ? part[5] : false,' . chr(10) . '            /* precision specifier (number or false) */' . chr(10) . '            precision: ( part[7] != undefined ) ? part[7] : false,' . chr(10) . '            /* type specifier */' . chr(10) . '            type: part[8],' . chr(10) . '            /* the given data associated with this part converted to a string */' . chr(10) . '            data: ( part[8] != ' . chr(39) . '%' . chr(39) . ' ) ? String ( list[paramIndex++] ) : false' . chr(10) . '        };' . chr(10) . '    }' . chr(10) . chr(10) . '    var newString = "";' . chr(10) . '    var start = 0;' . chr(10) . '    // Generate our new formated string' . chr(10) . '    for( var i=0; i<parts.length; ++i ) {' . chr(10) . '        // Add first unformated string part' . chr(10) . '        newString += format.substring( start, parts[i].begin );' . chr(10) . '        ' . chr(10) . '        // Mark the new string start' . chr(10) . '        start = parts[i].end;' . chr(10) . chr(10) . '        // Create the appropriate preformat substitution' . chr(10) . '        // This substitution is only the correct type conversion. All the' . chr(10) . '        // different options and flags haven' . chr(39) . 't been applied to it at this' . chr(10) . '        // point' . chr(10) . '        var preSubstitution = "";' . chr(10) . '        switch ( parts[i].type ) {' . chr(10) . '            case ' . chr(39) . '%' . chr(39) . ':' . chr(10) . '                preSubstitution = "%";' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'b' . chr(39) . ':' . chr(10) . '                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 2 );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'c' . chr(39) . ':' . chr(10) . '                preSubstitution = String.fromCharCode( Math.abs( parseInt( parts[i].data ) ) );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'd' . chr(39) . ':' . chr(10) . '                preSubstitution = String( Math.abs( parseInt( parts[i].data ) ) );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'f' . chr(39) . ':' . chr(10) . '                preSubstitution = ( parts[i].precision == false )' . chr(10) . '                                  ? ( String( ( Math.abs( parseFloat( parts[i].data ) ) ) ) )' . chr(10) . '                                  : ( Math.abs( parseFloat( parts[i].data ) ).toFixed( parts[i].precision ) );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'o' . chr(39) . ':' . chr(10) . '                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 8 );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 's' . chr(39) . ':' . chr(10) . '                preSubstitution = parts[i].data.substring( 0, parts[i].precision ? parts[i].precision : parts[i].data.length ); /* Cut if precision is defined */' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'x' . chr(39) . ':' . chr(10) . '                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 16 ).toLowerCase();' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'X' . chr(39) . ':' . chr(10) . '                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 16 ).toUpperCase();' . chr(10) . '            break;' . chr(10) . '            default:' . chr(10) . '                throw ' . chr(39) . 'sprintf: Unknown type "' . chr(39) . ' + parts[i].type + ' . chr(39) . '" detected. This should never happen. Maybe the regex is wrong.' . chr(39) . ';' . chr(10) . '        }' . chr(10) . chr(10) . '        // The % character is a special type and does not need further processing' . chr(10) . '        if ( parts[i].type ==  "%" ) {' . chr(10) . '            newString += preSubstitution;' . chr(10) . '            continue;' . chr(10) . '        }' . chr(10) . chr(10) . '        // Modify the preSubstitution by taking sign, padding and width' . chr(10) . '        // into account' . chr(10) . chr(10) . '        // Pad the string based on the given width' . chr(10) . '        if ( parts[i].width != false ) {' . chr(10) . '            // Padding needed?' . chr(10) . '            if ( parts[i].width > preSubstitution.length ) ' . chr(10) . '            {' . chr(10) . '                var origLength = preSubstitution.length;' . chr(10) . '                for( var j = 0; j < parts[i].width - origLength; ++j ) ' . chr(10) . '                {' . chr(10) . '                    preSubstitution = ( parts[i].alignLeft == true ) ' . chr(10) . '                                      ? ( preSubstitution + parts[i].padding )' . chr(10) . '                                      : ( parts[i].padding + preSubstitution );' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . chr(10) . '        // Add a sign symbol if neccessary or enforced, but only if we are' . chr(10) . '        // not handling a string' . chr(10) . '        if ( parts[i].type == ' . chr(39) . 'b' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'd' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'o' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'f' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'x' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'X' . chr(39) . ' ) {' . chr(10) . '            if ( parts[i].negative == true ) {' . chr(10) . '                preSubstitution = "-" + preSubstitution;' . chr(10) . '            }' . chr(10) . '            else if ( parts[i].sign == true ) {' . chr(10) . '                preSubstitution = "+" + preSubstitution;' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . chr(10) . '        // Add the substitution to the new string' . chr(10) . '        newString += preSubstitution;' . chr(10) . '    }' . chr(10) . chr(10) . '    // Add the last part of the given format string, which may still be there' . chr(10) . '    newString += format.substring( start, format.length );' . chr(10) . chr(10) . '    return newString;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.printf = function(List__) {' . chr(10) . '    return CORE.print([ CORE.sprintf(List__) ]);' . chr(10) . '};' . chr(10) . chr(10)))
};
1;

;

# use Perlito5::Javascript3::Sprintf
;
package main;
undef();
package Perlito5::AST::Apply;
my %op = ('infix:<+=>', 'infix:<+>', 'infix:<-=>', 'infix:<->', 'infix:<*=>', 'infix:<*>', 'infix:</=>', 'infix:</>', 'infix:<||=>', 'infix:<||>', 'infix:<&&=>', 'infix:<&&>', 'infix:<|=>', 'infix:<|>', 'infix:<&=>', 'infix:<&>', 'infix:<//=>', 'infix:<//>', 'infix:<.=>', 'list:<.>');
sub Perlito5::AST::Apply::op_assign {
    my $self = $_[0];
    my $code = $self->{'code'};
    return 0 if ref($code);
    if (exists($op{$code})) {
        return Perlito5::AST::Apply->new('code', 'infix:<=>', 'arguments', [$self->{'arguments'}->[0], Perlito5::AST::Apply->new('code', $op{$code}, 'arguments', $self->{'arguments'})])
    };
    return 0
};
package Perlito5::AST::Do;
sub Perlito5::AST::Do::simplify {
    my $self = $_[0];
    my $block;
    if ($self->{'block'}->isa('Perlito5::AST::Lit::Block')) {
        $block = $self->{'block'}->stmts()
    }
    else {
        $block = [$self->{'block'}]
    };
    if ((scalar(@{$block}) == 1)) {
        my $stmt = $block->[0];
        if (($stmt->isa('Perlito5::AST::Apply') && ($stmt->code() eq 'circumfix:<( )>'))) {
            my $args = $stmt->arguments();
            return Perlito5::AST::Do->new('block', $args->[0])->simplify() if (@{$args} == 1);
            return Perlito5::AST::Do->new('block', $block)
        };
        if ($stmt->isa('Perlito5::AST::Do')) {
            return $stmt->simplify()
        }
    };
    return Perlito5::AST::Do->new('block', $block)
};

;

# use Perlito5::Macro
;
package main;
undef();

# use Perlito5::AST
;
package Perlito5::Perl5;
{
    sub Perlito5::Perl5::tab {
        my $level = shift();
        join("", '    ' x $level)
    };
    sub Perlito5::Perl5::escape_string {
        return Perlito5::Dumper::escape_string($_[0])
    };
    sub Perlito5::Perl5::emit_perl5_block {
        my $block = $_[0];
        my $level = $_[1];
        ('{' . chr(10) . join(';' . chr(10), map((defined($_) && (Perlito5::Perl5::tab(($level + 1)) . $_->emit_perl5(($level + 1)))), @{$block})) . chr(10) . Perlito5::Perl5::tab($level) . '}')
    }
};
package Perlito5::AST::CompUnit;
{
    sub Perlito5::AST::CompUnit::emit_perl5 {
        my $self = $_[0];
        my $level = $_[1];
        my @body;
        for (@{$self->{'body'}}) {
            if (defined($_)) {
                push(@body, $_)
            }
        };
        ('package ' . $self->{'name'} . ';' . chr(10) . join(';' . chr(10), map((Perlito5::Perl5::tab($level) . $_->emit_perl5($level)), @body)) . ';' . chr(10) . chr(10))
    };
    sub Perlito5::AST::CompUnit::emit_perl5_program {
        my $comp_units = $_[0];
        my $str = 'use v5.10;' . chr(10);
        for my  $comp_unit (@{$comp_units}) {
            $str = ($str . $comp_unit->emit_perl5(0))
        };
        $str = ($str . '1;' . chr(10));
        return $str
    }
};
package Perlito5::AST::Val::Int;
{
    sub Perlito5::AST::Val::Int::emit_perl5 {
        my $self = $_[0];
        my $level = $_[1];
        $self->{'int'}
    }
};
package Perlito5::AST::Val::Num;
{
    sub Perlito5::AST::Val::Num::emit_perl5 {
        my $self = $_[0];
        my $level = $_[1];
        $self->{'num'}
    }
};
package Perlito5::AST::Val::Buf;
{
    sub Perlito5::AST::Val::Buf::emit_perl5 {
        my $self = $_[0];
        my $level = $_[1];
        Perlito5::Perl5::escape_string($self->{'buf'})
    }
};
package Perlito5::AST::Lit::Block;
{
    sub Perlito5::AST::Lit::Block::emit_perl5 {
        my $self = $_[0];
        my $level = $_[1];
        Perlito5::Perl5::emit_perl5_block($self->{'stmts'}, $level)
    }
};
package Perlito5::AST::Index;
{
    sub Perlito5::AST::Index::emit_perl5 {
        my $self = $_[0];
        my $level = $_[1];
        if (($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '$'))) {
            my $v = $self->{'obj'};
            return ($v->emit_perl5($level) . '[' . $self->{'index_exp'}->emit_perl5(($level + 1)) . ']')
        };
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && ($self->{'obj'}->{'code'} eq 'prefix:<$>'))) {
            return ($self->{'obj'}->{'arguments'}->[0]->emit_perl5($level) . '->[' . $self->{'index_exp'}->emit_perl5($level) . ']')
        };
        ($self->{'obj'}->emit_perl5($level) . '->[' . $self->{'index_exp'}->emit_perl5(($level + 1)) . ']')
    }
};
package Perlito5::AST::Lookup;
{
    sub Perlito5::AST::Lookup::emit_perl5 {
        my $self = $_[0];
        my $level = $_[1];
        if (($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '$'))) {
            my $v = $self->{'obj'};
            return ($v->emit_perl5($level) . '{' . $self->autoquote($self->{'index_exp'})->emit_perl5($level) . '}')
        };
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && ($self->{'obj'}->{'code'} eq 'prefix:<$>'))) {
            return ($self->{'obj'}->{'arguments'}->[0]->emit_perl5($level) . '->{' . $self->autoquote($self->{'index_exp'})->emit_perl5($level) . '}')
        };
        ($self->{'obj'}->emit_perl5($level) . '->{' . $self->autoquote($self->{'index_exp'})->emit_perl5($level) . '}')
    }
};
package Perlito5::AST::Var;
{
    sub Perlito5::AST::Var::emit_perl5 {
        my $self = $_[0];
        my $level = $_[1];
        my $str_name = $self->{'name'};
        $str_name = chr(92) . chr(92) if ($str_name eq chr(92));
        $str_name = chr(92) . '"' if ($str_name eq '"');
        my $perl5_name = $self->perl5_name();
        my $decl_type;
        my $decl = $self->perl5_get_decl($perl5_name);
        if ($decl) {
            $decl_type = $decl->{'decl'}
        }
        else {
            if ((!($self->{'namespace'}) && ($self->{'sigil'} ne '*'))) {

            }
        };
        my $ns = '';
        if ($self->{'namespace'}) {
            if ((($self->{'namespace'} eq 'main') && (substr($self->{'name'}, 0, 1) eq '^'))) {
                return ($self->{'sigil'} . '{' . $self->{'name'} . '}')
            }
            else {
                $ns = ($self->{'namespace'} . '::')
            }
        };
        my $c = substr($self->{'name'}, 0, 1);
        if (((((($c ge 'a') && ($c le 'z'))) || ((($c ge 'A') && ($c le 'Z')))) || (($c eq '_')))) {
            return ($self->{'sigil'} . $ns . $self->{'name'})
        };
        return ($self->{'sigil'} . '{' . chr(39) . $ns . $str_name . chr(39) . '}')
    }
};
package Perlito5::AST::Proto;
{
    sub Perlito5::AST::Proto::emit_perl5 {
        my $self = $_[0];
        my $level = $_[1];
        $self->{'name'}
    }
};
package Perlito5::AST::Call;
{
    sub Perlito5::AST::Call::emit_perl5 {
        my $self = $_[0];
        my $level = $_[1];
        my $invocant = $self->{'invocant'}->emit_perl5(($level + 1));
        if (($self->{'method'} eq 'postcircumfix:<[ ]>')) {
            return ($invocant . '->[' . $self->{'arguments'}->emit_perl5(($level + 1)) . ']')
        };
        if (($self->{'method'} eq 'postcircumfix:<{ }>')) {
            return ($invocant . '->{' . Perlito5::AST::Lookup->autoquote($self->{'arguments'})->emit_perl5($level) . '}')
        };
        my $meth = $self->{'method'};
        if (($meth eq 'postcircumfix:<( )>')) {
            if (((ref($self->{'invocant'}) eq 'Perlito5::AST::Var') && ($self->{'invocant'}->{'sigil'} eq '&'))) {
                return ($invocant . '(' . join(', ', map($_->emit_perl5(($level + 1)), @{$self->{'arguments'}})) . ')')
            };
            $meth = ''
        };
        if ((ref($meth) eq 'Perlito5::AST::Var')) {
            $meth = $meth->emit_perl5(($level + 1))
        };
        ($invocant . '->' . $meth . '(' . join(', ', map($_->emit_perl5(($level + 1)), @{$self->{'arguments'}})) . ')')
    }
};
package Perlito5::AST::Apply;
{
    my %op_prefix_perl5 = ('say', 'say', 'print', 'print', 'keys', 'keys', 'values', 'values', 'warn', 'warn', 'scalar', 'scalar', 'pop', 'pop', 'push', 'push', 'shift', 'shift', 'unshift', 'unshift', 'join', 'join', 'undef', 'undef', 'prefix:<!>', '!', 'prefix:<++>', '++', 'prefix:<-->', '--', 'prefix:<+>', '+', 'prefix:<->', '-', 'prefix:<-d>', '-d', 'prefix:<-e>', '-e', 'prefix:<-f>', '-f', 'prefix:<not>', 'not', 'prefix:<~>', '~');
    my %op_infix_perl5 = ('list:<,>', ', ', 'list:<.>', ' . ', 'infix:<+>', ' + ', 'infix:<->', ' - ', 'infix:<*>', ' * ', 'infix:</>', ' / ', 'infix:<%>', ' % ', 'infix:<**>', ' ** ', 'infix:<>>', ' > ', 'infix:<<>', ' < ', 'infix:<>=>', ' >= ', 'infix:<<=>', ' <= ', 'infix:<<<>', ' << ', 'infix:<>>>', ' >> ', 'infix:<&>', ' & ', 'infix:<|>', ' | ', 'infix:<^>', ' ^ ', 'infix:<&&>', ' && ', 'infix:<||>', ' || ', 'infix:<and>', ' and ', 'infix:<or>', ' or ', 'infix:<//>', ' // ', 'infix:<eq>', ' eq ', 'infix:<ne>', ' ne ', 'infix:<le>', ' le ', 'infix:<ge>', ' ge ', 'infix:<lt>', ' lt ', 'infix:<gt>', ' gt ', 'infix:<==>', ' == ', 'infix:<!=>', ' != ', 'infix:<=~>', ' =~ ', 'infix:<!~>', ' !~ ');
    sub Perlito5::AST::Apply::emit_perl5_args {
        my $self = $_[0];
        my $level = $_[1];
        return '' if !($self->{'arguments'});
        join(', ', map($_->emit_perl5($level), @{$self->{'arguments'}}))
    };
    sub Perlito5::AST::Apply::emit_perl5 {
        my $self = $_[0];
        my $level = $_[1];
        my $apply = $self->op_assign();
        if ($apply) {
            return $apply->emit_perl5($level)
        };
        my $ns = '';
        if ($self->{'namespace'}) {
            $ns = ($self->{'namespace'} . '::')
        };
        my $code = ($ns . $self->{'code'});
        if ((ref($code) ne '')) {
            return ('(' . $self->{'code'}->emit_perl5(($level + 1)) . ')->(' . $self->emit_perl5_args(($level + 1)) . ')')
        };
        if (exists($op_infix_perl5{$code})) {
            return ('(' . join($op_infix_perl5{$code}, (map($_->emit_perl5(($level + 1)), @{$self->{'arguments'}}))) . ')')
        };
        if (exists($op_prefix_perl5{$code})) {
            return ($op_prefix_perl5{$code} . '(' . $self->emit_perl5_args(($level + 1)) . ')')
        };
        if (($self->{'code'} eq 'p5:s')) {
            return ('s!' . $self->{'arguments'}->[0]->{'buf'} . '!' . $self->{'arguments'}->[1]->{'buf'} . '!' . $self->{'arguments'}->[2])
        };
        if (($self->{'code'} eq 'p5:m')) {
            my $s;
            if ($self->{'arguments'}->[0]->isa('Perlito5::AST::Val::Buf')) {
                $s = $self->{'arguments'}->[0]->{'buf'}
            }
            else {
                for my  $ast (@{$self->{'arguments'}->[0]->{'arguments'}}) {
                    if ($ast->isa('Perlito5::AST::Val::Buf')) {
                        $s = ($s . $ast->{'buf'})
                    }
                    else {
                        $s = ($s . $ast->emit_perl5(($level + 1)))
                    }
                }
            };
            return ('m!' . $s . '!' . $self->{'arguments'}->[1])
        };
        if (($self->{'code'} eq 'p5:tr')) {
            return ('tr!' . $self->{'arguments'}->[0]->{'buf'} . '!' . $self->{'arguments'}->[1]->{'buf'} . '!')
        };
        if (($code eq '__PACKAGE__')) {
            return ('"' . $Perlito5::PKG_NAME . '"')
        };
        if (($self->{'code'} eq 'package')) {
            return ('package ' . $self->{'namespace'})
        };
        if (($code eq 'map')) {
            if ($self->{'special_arg'}) {
                return ('map {' . chr(10) . join(';' . chr(10), map {
                                (Perlito5::Perl5::tab(($level + 1)) . $_->emit_perl5(($level + 1)))
                            } @{$self->{'special_arg'}->{'stmts'}}) . chr(10) . Perlito5::Perl5::tab($level) . '} ' . $self->emit_perl5_args(($level + 1)))
            };
            return ('map(' . $self->emit_perl5_args(($level + 1)) . ')')
        };
        if (($code eq 'infix:<x>')) {
            return ('join("", ' . join(' x ', map($_->emit_perl5(($level + 1)), @{$self->{'arguments'}})) . ')')
        };
        if (($code eq 'infix:<=>>')) {
            return (Perlito5::AST::Lookup->autoquote($self->{'arguments'}->[0])->emit_perl5($level) . ', ' . $self->{'arguments'}->[1]->emit_perl5($level))
        };
        if (($code eq 'circumfix:<[ ]>')) {
            return ('[' . $self->emit_perl5_args(($level + 1)) . ']')
        };
        if (($code eq 'circumfix:<{ }>')) {
            return ('{' . $self->emit_perl5_args(($level + 1)) . '}')
        };
        if (($code eq 'circumfix:<( )>')) {
            return ('(' . $self->emit_perl5_args(($level + 1)) . ')')
        };
        if (($code eq 'prefix:<' . chr(92) . '>')) {
            return (chr(92) . $self->{'arguments'}->[0]->emit_perl5(($level + 1)) . '')
        };
        if (($code eq 'prefix:<$>')) {
            return ('${' . $self->emit_perl5_args(($level + 1)) . '}')
        };
        if (($code eq 'prefix:<@>')) {
            return ('@{' . $self->emit_perl5_args(($level + 1)) . '}')
        };
        if (($code eq 'prefix:<%>')) {
            return ('%{' . $self->emit_perl5_args(($level + 1)) . '}')
        };
        if (($code eq 'prefix:<&>')) {
            return ('&{' . $self->emit_perl5_args(($level + 1)) . '}')
        };
        if (($code eq 'prefix:<*>')) {
            return ('*{' . $self->emit_perl5_args(($level + 1)) . '}')
        };
        if (($code eq 'prefix:<$#>')) {
            return ('$#{' . $self->emit_perl5_args(($level + 1)) . '}')
        };
        if (($code eq 'postfix:<++>')) {
            return ('(' . $self->emit_perl5_args(($level + 1)) . ')++')
        };
        if (($code eq 'postfix:<-->')) {
            return ('(' . $self->emit_perl5_args(($level + 1)) . ')--')
        };
        if (($code eq 'infix:<..>')) {
            return ('(' . join(' .. ', map($_->emit_perl5(($level + 1)), @{$self->{'arguments'}})) . ')')
        };
        if (($code eq 'ternary:<? :>')) {
            return ('(' . $self->{'arguments'}->[0]->emit_perl5(($level + 1)) . ' ? ' . $self->{'arguments'}->[1]->emit_perl5(($level + 1)) . ' : ' . $self->{'arguments'}->[2]->emit_perl5(($level + 1)) . ')')
        };
        if (($code eq 'infix:<=>')) {
            return emit_perl5_bind($self->{'arguments'}->[0], $self->{'arguments'}->[1], $level)
        };
        if (($code eq 'require')) {
            return ('Perlito5::Grammar::Use::require(' . $self->{'arguments'}->[0]->emit_perl5(($level + 1)) . ')')
        };
        if (($code eq 'do')) {
            my $ast = Perlito5::AST::Apply->new('code', 'eval', 'namespace', '', 'arguments', [Perlito5::AST::Apply->new('code', 'slurp', 'namespace', 'Perlito5::IO', 'arguments', $self->{'arguments'})]);
            return $ast->emit_perl5($level)
        };
        if (($code eq 'eval')) {
            my $arg = $self->{'arguments'}->[0];
            my $eval;
            if ($arg->isa('Perlito5::AST::Do')) {
                my $do = $arg->simplify()->block();
                return ('eval {' . chr(10) . join(';' . chr(10), map((defined($_) && (Perlito5::Perl5::tab(($level + 1)) . $_->emit_perl5(($level + 1)))), @{$do})) . chr(10) . Perlito5::Perl5::tab($level) . '}')
            };
            return ('eval ' . $self->emit_perl5_args(($level + 1)))
        };
        if (($code eq 'return')) {
            return ('return ' . $self->emit_perl5_args(($level + 1)))
        };
        if (($self->{'bareword'} && !(@{$self->{'arguments'}}))) {
            return $code
        };
        ($code . '(' . $self->emit_perl5_args(($level + 1)) . ')')
    };
    sub Perlito5::AST::Apply::emit_perl5_bind {
        my $parameters = shift();
        my $arguments = shift();
        my $level = shift();
        if ($parameters->isa('Perlito5::AST::Call')) {
            if ((($parameters->method() eq 'postcircumfix:<{ }>') || ($parameters->method() eq 'postcircumfix:<[ ]>'))) {
                return ($parameters->emit_perl5(($level + 1)) . ' = ' . $arguments->emit_perl5(($level + 1)))
            }
        };
        ($parameters->emit_perl5(($level + 1)) . ' = ' . $arguments->emit_perl5(($level + 1)))
    }
};
package Perlito5::AST::If;
{
    sub Perlito5::AST::If::emit_perl5 {
        my $self = $_[0];
        my $level = $_[1];
        if (($self->{'body'} && (ref($self->{'body'}) ne 'Perlito5::AST::Lit::Block'))) {
            return ($self->{'body'}->emit_perl5(($level + 1)) . ' if ' . $self->{'cond'}->emit_perl5(($level + 1)))
        };
        if (($self->{'otherwise'} && (ref($self->{'otherwise'}) ne 'Perlito5::AST::Lit::Block'))) {
            return ($self->{'otherwise'}->emit_perl5(($level + 1)) . ' unless ' . $self->{'cond'}->emit_perl5(($level + 1)))
        };
        return ('if (' . $self->{'cond'}->emit_perl5(($level + 1)) . ') ' . (($self->{'body'} ? Perlito5::Perl5::emit_perl5_block($self->{'body'}->stmts(), $level) : '{ }')) . ((($self->{'otherwise'} && scalar(@{$self->{'otherwise'}->stmts()})) ? ((chr(10) . Perlito5::Perl5::tab($level) . 'else ' . Perlito5::Perl5::emit_perl5_block($self->{'otherwise'}->stmts(), $level))) : '')))
    }
};
package Perlito5::AST::When;
{
    sub Perlito5::AST::When::emit_perl5 {
        my $self = $_[0];
        my $level = $_[1];
        return ('when (' . $self->{'cond'}->emit_perl5(($level + 1)) . ') ' . (($self->{'body'} ? Perlito5::Perl5::emit_perl5_block($self->{'body'}->stmts(), $level) : '{ }')))
    }
};
package Perlito5::AST::While;
{
    sub Perlito5::AST::While::emit_perl5 {
        my $self = $_[0];
        my $level = $_[1];
        if (($self->{'body'} && (ref($self->{'body'}) ne 'Perlito5::AST::Lit::Block'))) {
            return ($self->{'body'}->emit_perl5(($level + 1)) . ' while ' . $self->{'cond'}->emit_perl5(($level + 1)))
        };
        ('for ( ' . (($self->{'init'} ? ($self->{'init'}->emit_perl5(($level + 1)) . '; ') : '; ')) . (($self->{'cond'} ? ($self->{'cond'}->emit_perl5(($level + 1)) . '; ') : '; ')) . (($self->{'continue'} ? ($self->{'continue'}->emit_perl5(($level + 1)) . ' ') : ' ')) . ') ' . Perlito5::Perl5::emit_perl5_block($self->{'body'}->stmts(), $level))
    }
};
package Perlito5::AST::For;
{
    sub Perlito5::AST::For::emit_perl5 {
        my $self = $_[0];
        my $level = $_[1];
        if (($self->{'body'} && (ref($self->{'body'}) ne 'Perlito5::AST::Lit::Block'))) {
            return ($self->{'body'}->emit_perl5(($level + 1)) . ' for ' . $self->{'cond'}->emit_perl5(($level + 1)))
        };
        my $cond;
        if ((ref($self->{'cond'}) eq 'ARRAY')) {
            $cond = ((($self->{'cond'}->[0] ? ($self->{'cond'}->[0]->emit_javascript(($level + 1)) . '; ') : '; ')) . (($self->{'cond'}->[1] ? ($self->{'cond'}->[1]->emit_javascript(($level + 1)) . '; ') : '; ')) . (($self->{'cond'}->[2] ? ($self->{'cond'}->[2]->emit_javascript(($level + 1)) . ' ') : ' ')))
        }
        else {
            $cond = $self->{'cond'}->emit_perl5(($level + 1))
        };
        my $sig = '';
        my $sig_ast = $self->{'body'}->sig();
        if (!($sig_ast)) {

        }
        else {
            if ($sig_ast->{'decl'}) {
                $sig = ($sig_ast->{'decl'} . ' ' . $sig_ast->{'type'} . ' ' . $sig_ast->{'var'}->emit_perl5(($level + 1)) . ' ')
            }
            else {
                $sig = ($sig_ast->emit_perl5(($level + 1)) . ' ')
            }
        };
        return ('for ' . $sig . '(' . $cond . ') ' . Perlito5::Perl5::emit_perl5_block($self->{'body'}->stmts(), $level))
    }
};
package Perlito5::AST::Decl;
{
    sub Perlito5::AST::Decl::emit_perl5 {
        my $self = $_[0];
        my $level = $_[1];
        my $str = ($self->{'decl'} . ' ' . (($self->{'type'} ? ($self->{'type'} . ' ') : '')) . $self->{'var'}->emit_perl5(($level + 1)));
        return $str
    }
};
package Perlito5::AST::Sub;
{
    sub Perlito5::AST::Sub::emit_perl5 {
        my $self = $_[0];
        my $level = $_[1];
        my @parts;
        push(@parts, ($self->{'namespace'} . '::' . $self->{'name'})) if $self->{'name'};
        push(@parts, ('(' . $self->{'sig'} . ')')) if defined($self->{'sig'});
        push(@parts, Perlito5::Perl5::emit_perl5_block($self->{'block'}, $level)) if defined($self->{'block'});
        join(' ', 'sub', @parts)
    }
};
package Perlito5::AST::Do;
{
    sub Perlito5::AST::Do::emit_perl5 {
        my $self = $_[0];
        my $level = $_[1];
        my $block = $self->simplify()->block();
        ('(do ' . Perlito5::Perl5::emit_perl5_block($block, $level) . ')')
    }
};
package Perlito5::AST::Use;
{
    sub Perlito5::AST::Use::emit_perl5 {
        my $self = shift();
        my $level = shift();
        Perlito5::Grammar::Use::emit_time_eval($self);
        return (chr(10) . Perlito5::Perl5::tab($level) . '# ' . $self->{'code'} . ' ' . $self->{'mod'} . chr(10))
    }
};

;

# use Perlito5::Perl5::Emitter
;
package main;
package Perlito5::Perl5::Runtime;
sub Perlito5::Perl5::Runtime::emit_perl5 {
    return ((chr(10) . 'package Perlito5::IO;' . chr(10) . chr(10) . 'sub slurp {' . chr(10) . '    my $source_filename = shift;' . chr(10) . '    open FILE, $source_filename' . chr(10) . '      or die "Cannot read $source_filename' . chr(92) . 'n";' . chr(10) . '    local $/ = undef;' . chr(10) . '    $source = <FILE>;' . chr(10) . '    close FILE;' . chr(10) . '    return $source;' . chr(10) . '}' . chr(10) . chr(10)))
};
1;

;

# use Perlito5::Perl5::Runtime
;
package main;
undef();

# use Perlito5::AST
;
package Perlito5::Perl6;
{
    sub Perlito5::Perl6::tab {
        my $level = shift();
        join("", chr(9) x $level)
    };
    my %safe_char = ('$', 1, '%', 1, '@', 1, '&', 1, '_', 1, ',', 1, '.', 1, ':', 1, ';', 1, '-', 1, '+', 1, '*', 1, ' ', 1, '(', 1, ')', 1, '<', 1, '=', 1, '>', 1, '[', 1, ']', 1, '{', 1, '|', 1, '}', 1);
    sub Perlito5::Perl6::escape_string {
        my $s = shift();
        my @out;
        my $tmp = '';
        return chr(39) . chr(39) if ($s eq '');
        for my  $i ((0 .. (length($s) - 1))) {
            my $c = substr($s, $i, 1);
            if ((((((($c ge 'a') && ($c le 'z'))) || ((($c ge 'A') && ($c le 'Z')))) || ((($c ge '0') && ($c le '9')))) || exists($safe_char{$c}))) {
                $tmp = ($tmp . $c)
            }
            else {
                push(@out, (chr(39) . $tmp . chr(39))) if ($tmp ne '');
                push(@out, ('chr(' . ord($c) . ')'));
                $tmp = ''
            }
        };
        push(@out, (chr(39) . $tmp . chr(39))) if ($tmp ne '');
        return join(' ~ ', @out)
    };
    sub Perlito5::Perl6::to_str {
        my $cond = shift();
        if ($cond->isa('Perlito5::AST::Val::Buf')) {
            return $cond->emit_perl6()
        }
        else {
            return ('(' . $cond->emit_perl6() . ')')
        }
    };
    sub Perlito5::Perl6::to_num {
        my $cond = shift();
        if (($cond->isa('Perlito5::AST::Val::Int') || $cond->isa('Perlito5::AST::Val::Num'))) {
            return $cond->emit_perl6()
        }
        else {
            return ('(' . $cond->emit_perl6() . ')')
        }
    };
    sub Perlito5::Perl6::to_bool {
        my $cond = shift();
        if (((((($cond->isa('Perlito5::AST::Val::Int')) || ($cond->isa('Perlito5::AST::Val::Num'))) || (($cond->isa('Perlito5::AST::Apply') && ($cond->code() eq 'infix:<||>')))) || (($cond->isa('Perlito5::AST::Apply') && ($cond->code() eq 'infix:<&&>')))) || (($cond->isa('Perlito5::AST::Apply') && ($cond->code() eq 'prefix:<!>'))))) {
            return $cond->emit_perl6()
        }
        else {
            return ('(' . $cond->emit_perl6() . ')')
        }
    }
};
package Perlito5::Perl6::LexicalBlock;
{
    sub Perlito5::Perl6::LexicalBlock::new {
        my $class = shift();
        bless({@_}, $class)
    };
    sub Perlito5::Perl6::LexicalBlock::block {
        $_[0]->{'block'}
    };
    sub Perlito5::Perl6::LexicalBlock::needs_return {
        $_[0]->{'needs_return'}
    };
    sub Perlito5::Perl6::LexicalBlock::top_level {
        $_[0]->{'top_level'}
    };
    sub Perlito5::Perl6::LexicalBlock::emit_perl6 {
        my $self = shift();
        my $level = shift();
        if ($self->{'top_level'}) {
            my $block = Perlito5::Perl6::LexicalBlock->new('block', $self->block(), 'needs_return', $self->needs_return(), 'top_level', 0);
            return ($block->emit_perl6(($level + 1)) . ';' . chr(10))
        };
        my @block;
        for (@{$self->{'block'}}) {
            if (defined($_)) {
                push(@block, $_)
            }
        };
        if (!(@block)) {
            return (Perlito5::Perl6::tab($level) . ';')
        };
        my @str;
        for my  $decl (@block) {
            if (($decl->isa('Perlito5::AST::Decl') && ($decl->decl() eq 'my'))) {
                push(@str, (Perlito5::Perl6::tab($level) . $decl->emit_perl6_init()))
            };
            if (($decl->isa('Perlito5::AST::Apply') && ($decl->code() eq 'infix:<=>'))) {
                my $var = $decl->arguments()->[0];
                if (($var->isa('Perlito5::AST::Decl') && ($var->decl() eq 'my'))) {
                    push(@str, (Perlito5::Perl6::tab($level) . $var->emit_perl6_init()))
                }
            }
        };
        for my  $decl (@block) {
            if (!((($decl->isa('Perlito5::AST::Decl') && ($decl->decl() eq 'my'))))) {
                push(@str, ($decl->emit_perl6($level) . ';'))
            }
        };
        return (join(chr(10), @str) . ';')
    }
};
package Perlito5::AST::CompUnit;
{
    sub Perlito5::AST::CompUnit::emit_perl6 {
        my $self = $_[0];
        my $level = $_[1];
        my @body;
        my $i = 0;
        for ( ; ($i <= scalar(@{$self->{'body'}})); {

            } ) {
            my $stmt = $self->{'body'}->[$i];
            if (((ref($stmt) eq 'Perlito5::AST::Apply') && ($stmt->code() eq 'package'))) {
                my $name = $stmt->namespace();
                my @stmts;
                ($i)++;
                for ( ; (($i <= scalar(@{$self->{'body'}})) && !((((ref($self->{'body'}->[$i]) eq 'Perlito5::AST::Apply') && ($self->{'body'}->[$i]->code() eq 'package'))))); {

                    } ) {
                    push(@stmts, $self->{'body'}->[$i]);
                    ($i)++
                };
                push(@body, Perlito5::AST::CompUnit->new('name', $name, 'body', \@stmts))
            }
            else {
                push(@body, $stmt) if defined($stmt);
                ($i)++
            }
        };
        my $class_name = $self->{'name'};
        my $str = ('package ' . $class_name . '{' . chr(10));
        for my  $decl (@body) {
            if (($decl->isa('Perlito5::AST::Decl') && (($decl->decl() eq 'my')))) {
                $str = ($str . '  ' . $decl->emit_perl6_init())
            };
            if (($decl->isa('Perlito5::AST::Apply') && ($decl->code() eq 'infix:<=>'))) {
                my $var = $decl->arguments()->[0];
                if (($var->isa('Perlito5::AST::Decl') && ($var->decl() eq 'my'))) {
                    $str = ($str . '  ' . $var->emit_perl6_init())
                }
            }
        };
        for my  $decl (@body) {
            if ($decl->isa('Perlito5::AST::Sub')) {
                $str = ($str . ($decl)->emit_perl6(($level + 1)) . ';' . chr(10))
            }
        };
        for my  $decl (@body) {
            if (((defined($decl) && (!((($decl->isa('Perlito5::AST::Decl') && ($decl->decl() eq 'my')))))) && (!(($decl->isa('Perlito5::AST::Sub')))))) {
                $str = ($str . ($decl)->emit_perl6(($level + 1)) . ';' . chr(10))
            }
        };
        ($str . '}' . chr(10))
    };
    sub Perlito5::AST::CompUnit::emit_perl6_program {
        my $comp_units = shift();
        my $str = '';
        for my  $comp_unit (@{$comp_units}) {
            $str = ($str . $comp_unit->emit_perl6() . chr(10))
        };
        return $str
    }
};
package Perlito5::AST::Val::Int;
{
    sub Perlito5::AST::Val::Int::emit_perl6 {
        my $self = shift();
        my $level = shift();
        (Perlito5::Perl6::tab($level) . $self->{'int'})
    }
};
package Perlito5::AST::Val::Num;
{
    sub Perlito5::AST::Val::Num::emit_perl6 {
        my $self = shift();
        my $level = shift();
        (Perlito5::Perl6::tab($level) . $self->{'num'})
    }
};
package Perlito5::AST::Val::Buf;
{
    sub Perlito5::AST::Val::Buf::emit_perl6 {
        my $self = shift();
        my $level = shift();
        (Perlito5::Perl6::tab($level) . Perlito5::Perl6::escape_string($self->{'buf'}))
    }
};
package Perlito5::AST::Lit::Block;
{
    sub Perlito5::AST::Lit::Block::emit_perl6 {
        my $self = shift();
        my $level = shift();
        my $sig = '$_';
        if ($self->{'sig'}) {
            $sig = $self->{'sig'}->emit_perl6(($level + 1))
        };
        return (Perlito5::Perl6::tab($level) . ('(function (' . $sig . ') {' . chr(10)) . (Perlito5::Perl6::LexicalBlock->new('block', $self->{'stmts'}, 'needs_return', 1))->emit_perl6(($level + 1)) . chr(10) . Perlito5::Perl6::tab($level) . '})')
    }
};
package Perlito5::AST::Index;
{
    sub Perlito5::AST::Index::emit_perl6 {
        my $self = shift();
        my $level = shift();
        if (($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '$'))) {
            my $v = Perlito5::AST::Var->new('sigil', '@', 'namespace', $self->{'obj'}->namespace(), 'name', $self->{'obj'}->name());
            return ($v->emit_perl6($level) . '[' . $self->{'index_exp'}->emit_perl6() . ']')
        };
        (Perlito5::Perl6::tab($level) . $self->{'obj'}->emit_perl6() . '[' . $self->{'index_exp'}->emit_perl6() . ']')
    }
};
package Perlito5::AST::Lookup;
{
    sub Perlito5::AST::Lookup::emit_perl6 {
        my $self = shift();
        my $level = shift();
        if (($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '$'))) {
            my $v = Perlito5::AST::Var->new('sigil', '%', 'namespace', $self->{'obj'}->namespace(), 'name', $self->{'obj'}->name());
            return ($v->emit_perl6($level) . '{' . $self->{'index_exp'}->emit_perl6() . '}')
        };
        return ($self->{'obj'}->emit_perl6($level) . '{' . $self->{'index_exp'}->emit_perl6() . '}')
    }
};
package Perlito5::AST::Var;
{
    sub Perlito5::AST::Var::emit_perl6 {
        my $self = shift();
        my $level = shift();
        if (($self->{'sigil'} eq '*')) {
            my $ns = 'PKG';
            if ($self->{'namespace'}) {
                $ns = ('NAMESPACE["' . $self->{'namespace'} . '"]')
            };
            return ($ns . '::' . $self->{'name'})
        };
        my $ns = '';
        if ($self->{'namespace'}) {
            $ns = ($self->{'namespace'} . '::')
        };
        ($ns . $self->{'sigil'} . $self->{'name'})
    }
};
package Perlito5::AST::Proto;
{
    sub Perlito5::AST::Proto::emit_perl6 {
        my $self = shift();
        my $level = shift();
        (Perlito5::Perl6::tab($level) . $self->{'name'})
    }
};
package Perlito5::AST::Call;
{
    sub Perlito5::AST::Call::emit_perl6 {
        my $self = shift();
        my $level = shift();
        my $invocant = $self->{'invocant'}->emit_perl6();
        my $meth = $self->{'method'};
        if (($meth eq 'postcircumfix:<[ ]>')) {
            return (Perlito5::Perl6::tab($level) . $invocant . '[' . $self->{'arguments'}->emit_perl6() . ']')
        };
        if (($meth eq 'postcircumfix:<{ }>')) {
            return (Perlito5::Perl6::tab($level) . $invocant . '{' . $self->{'arguments'}->emit_perl6() . '}')
        };
        if (($meth eq 'postcircumfix:<( )>')) {
            my @args = ();
            push(@args, $_->emit_perl6()) for @{$self->{'arguments'}};
            return (Perlito5::Perl6::tab($level) . '(' . $invocant . ')(' . join(',', @args) . ')')
        };
        my @args = ($invocant);
        push(@args, $_->emit_perl6()) for @{$self->{'arguments'}};
        return (Perlito5::Perl6::tab($level) . $invocant . '.' . $meth . '(' . join(',', @args) . ')')
    }
};
package Perlito5::AST::Apply;
{
    my %op_infix_js = ('infix:<->', ' - ', 'infix:<*>', ' * ', 'infix:<x>', ' x ', 'infix:<+>', ' + ', 'infix:<.>', ' ~ ', 'infix:</>', ' / ', 'infix:<>>', ' > ', 'infix:<<>', ' < ', 'infix:<>=>', ' >= ', 'infix:<<=>', ' <= ', 'infix:<eq>', ' eq ', 'infix:<ne>', ' ne ', 'infix:<le>', ' le ', 'infix:<ge>', ' ge ', 'infix:<==>', ' == ', 'infix:<!=>', ' != ', 'infix:<..>', ' .. ', 'infix:<&&>', ' && ', 'infix:<||>', ' || ', 'infix:<and>', ' and ', 'infix:<or>', ' or ', 'infix:<//>', ' // ');
    sub Perlito5::AST::Apply::emit_perl6 {
        my $self = shift();
        my $level = shift();
        my $apply = $self->op_assign();
        if ($apply) {
            return $apply->emit_perl6($level)
        };
        my $code = $self->{'code'};
        if ((ref($code) ne '')) {
            my @args = ();
            push(@args, $_->emit_perl6()) for @{$self->{'arguments'}};
            return (Perlito5::Perl6::tab($level) . '(' . $self->{'code'}->emit_perl6() . ')(' . join(',', @args) . ')')
        };
        if (($code eq 'infix:<=>>')) {
            return (Perlito5::Perl6::tab($level) . join(', ', map($_->emit_perl6(), @{$self->{'arguments'}})))
        };
        if (exists($op_infix_js{$code})) {
            return (Perlito5::Perl6::tab($level) . '(' . join($op_infix_js{$code}, map($_->emit_perl6(), @{$self->{'arguments'}})) . ')')
        };
        if (($code eq 'eval')) {
            return ('eval(perl5_to_js(' . Perlito5::Perl6::to_str($self->{'arguments'}->[0]) . '))')
        };
        if (($code eq 'undef')) {
            return (Perlito5::Perl6::tab($level) . 'Any')
        };
        if (($code eq 'shift')) {
            if (!((($self->{'arguments'} && @{$self->{'arguments'}})))) {
                return 'shift(@_)'
            }
        };
        if (($code eq 'map')) {
            my $fun = $self->{'arguments'}->[0];
            my $list = $self->{'arguments'}->[1];
            return ('(function (a_) { ' . 'var out = []; ' . 'if ( a_ == null ) { return out; }; ' . 'for(var i = 0; i < a_.length; i++) { ' . 'my $_ = a_[i]; ' . 'out.push(' . $fun->emit_perl6() . ')' . '}; ' . 'return out;' . ' })(' . $list->emit_perl6() . ')')
        };
        if ((($code eq 'bless') || ($code eq 'ref'))) {
            return ('Perlito5::Perl6::Runtime::' . $code . '( ' . join(', ', map($_->emit_perl6(), @{$self->{'arguments'}})) . ')')
        };
        if (($code eq 'prefix:<!>')) {
            return ('!( ' . Perlito5::Perl6::to_bool($self->{'arguments'}->[0]) . ')')
        };
        if (($code eq 'prefix:<$>')) {
            my $arg = $self->{'arguments'}->[0];
            return ('$(' . $arg->emit_perl6() . ')')
        };
        if (($code eq 'prefix:<@>')) {
            return ('@(' . join(' ', map($_->emit_perl6(), @{$self->{'arguments'}})) . ')')
        };
        if (($code eq 'prefix:<%>')) {
            my $arg = $self->{'arguments'}->[0];
            return ('%(' . $arg->emit_perl6() . ')')
        };
        if (($code eq 'circumfix:<[ ]>')) {
            return ('[' . join(', ', map($_->emit_perl6(), @{$self->{'arguments'}})) . ']')
        };
        if (($code eq 'circumfix:<{ }>')) {
            return ('{' . join(', ', map($_->emit_perl6(), @{$self->{'arguments'}})) . '}')
        };
        if (($code eq 'prefix:<' . chr(92) . '>')) {
            my $arg = $self->{'arguments'}->[0];
            if ($arg->isa('Perlito5::AST::Var')) {
                if (($arg->sigil() eq '@')) {
                    return $arg->emit_perl6()
                };
                if (($arg->sigil() eq '%')) {
                    return ('(HashRef.new(' . $arg->emit_perl6() . '))')
                }
            };
            return ('(ScalarRef.new(' . $arg->emit_perl6() . '))')
        };
        if (($code eq 'postfix:<++>')) {
            return ('(' . join(' ', map($_->emit_perl6(), @{$self->{'arguments'}})) . ')++')
        };
        if (($code eq 'postfix:<-->')) {
            return ('(' . join(' ', map($_->emit_perl6(), @{$self->{'arguments'}})) . ')--')
        };
        if (($code eq 'prefix:<++>')) {
            return ('++(' . join(' ', map($_->emit_perl6(), @{$self->{'arguments'}})) . ')')
        };
        if (($code eq 'prefix:<-->')) {
            return ('--(' . join(' ', map($_->emit_perl6(), @{$self->{'arguments'}})) . ')')
        };
        if (($code eq 'prefix:<+>')) {
            return ('+(' . $self->{'arguments'}->[0]->emit_perl6() . ')')
        };
        if (($code eq 'list:<.>')) {
            return ('(' . join(' ~ ', map(Perlito5::Perl6::to_str($_), @{$self->{'arguments'}})) . ')')
        };
        if (($code eq 'ternary:<? :>')) {
            return (Perlito5::Perl6::tab($level) . '( ' . Perlito5::Perl6::to_bool($self->{'arguments'}->[0]) . ' ?? ' . ($self->{'arguments'}->[1])->emit_perl6() . ' !! ' . ($self->{'arguments'}->[2])->emit_perl6() . ')')
        };
        if (($code eq 'circumfix:<( )>')) {
            return (Perlito5::Perl6::tab($level) . '(' . join(', ', map($_->emit_perl6(), @{$self->{'arguments'}})) . ')')
        };
        if (($code eq 'infix:<=>')) {
            return emit_perl6_bind($self->{'arguments'}->[0], $self->{'arguments'}->[1], $level)
        };
        if (($code eq 'return')) {
            return (Perlito5::Perl6::tab($level) . 'return(' . ((($self->{'arguments'} && @{$self->{'arguments'}}) ? $self->{'arguments'}->[0]->emit_perl6() : '')) . ')')
        };
        if ($self->{'namespace'}) {
            if ((($self->{'namespace'} eq 'Perl6') && ($code eq 'inline'))) {
                if ($self->{'arguments'}->[0]->isa('Perlito5::AST::Val::Buf')) {
                    return $self->{'arguments'}->[0]->{'buf'}
                }
                else {
                    die('Perl6::inline needs a string constant')
                }
            };
            $code = ($self->{'namespace'} . '::' . ($code))
        };
        my @args = ();
        push(@args, $_->emit_perl6()) for @{$self->{'arguments'}};
        (Perlito5::Perl6::tab($level) . $code . '(' . join(', ', @args) . ')')
    };
    sub Perlito5::AST::Apply::emit_perl6_bind {
        my $parameters = shift();
        my $arguments = shift();
        my $level = shift();
        (Perlito5::Perl6::tab($level) . '(' . $parameters->emit_perl6() . ' = ' . $arguments->emit_perl6() . ')')
    }
};
package Perlito5::AST::If;
{
    sub Perlito5::AST::If::emit_perl6 {
        my $self = shift();
        my $level = shift();
        my $cond = $self->{'cond'};
        if (($cond->isa('Perlito5::AST::Var') && ($cond->sigil() eq '@'))) {
            $cond = Perlito5::AST::Apply->new('code', 'prefix:<@>', 'arguments', [$cond])
        };
        my $body = Perlito5::Perl6::LexicalBlock->new('block', $self->{'body'}->stmts(), 'needs_return', 0);
        my $s = (Perlito5::Perl6::tab($level) . 'if ( ' . Perlito5::Perl6::to_bool($cond) . ' ) {' . chr(10) . $body->emit_perl6(($level + 1)) . chr(10) . Perlito5::Perl6::tab($level) . '}');
        if (@{$self->{'otherwise'}->stmts()}) {
            my $otherwise = Perlito5::Perl6::LexicalBlock->new('block', $self->{'otherwise'}->stmts(), 'needs_return', 0);
            $s = ($s . chr(10) . Perlito5::Perl6::tab($level) . 'else {' . chr(10) . $otherwise->emit_perl6(($level + 1)) . chr(10) . Perlito5::Perl6::tab($level) . '}')
        };
        return $s
    }
};
package Perlito5::AST::While;
{
    sub Perlito5::AST::While::emit_perl6 {
        my $self = shift();
        my $level = shift();
        my $body = Perlito5::Perl6::LexicalBlock->new('block', $self->{'body'}->stmts(), 'needs_return', 0);
        return (Perlito5::Perl6::tab($level) . 'loop ( ' . (($self->{'init'} ? ($self->{'init'}->emit_perl6() . '; ') : '; ')) . (($self->{'cond'} ? (Perlito5::Perl6::to_bool($self->{'cond'}) . '; ') : '; ')) . (($self->{'continue'} ? ($self->{'continue'}->emit_perl6() . ' ') : ' ')) . ') {' . chr(10) . $body->emit_perl6(($level + 1)) . ' }')
    }
};
package Perlito5::AST::For;
{
    sub Perlito5::AST::For::emit_perl6 {
        my $self = shift();
        my $level = shift();
        my $cond = $self->{'cond'};
        my $body = Perlito5::Perl6::LexicalBlock->new('block', $self->{'body'}->stmts(), 'needs_return', 0);
        my $sig = '$_';
        if ($self->{'body'}->sig()) {
            $sig = $self->{'body'}->sig()->emit_perl6(($level + 1))
        };
        (Perlito5::Perl6::tab($level) . 'for ' . $cond->emit_perl6() . ' -> ' . $sig . ' { ' . $body->emit_perl6(($level + 1)) . '}' . chr(10))
    }
};
package Perlito5::AST::Decl;
{
    sub Perlito5::AST::Decl::emit_perl6 {
        my $self = shift();
        my $level = shift();
        (Perlito5::Perl6::tab($level) . $self->{'var'}->emit_perl6())
    };
    sub Perlito5::AST::Decl::emit_perl6_init {
        my $self = shift();
        ($self->{'decl'} . ' ' . ($self->{'var'})->emit_perl6() . ';')
    }
};
package Perlito5::AST::Sub;
{
    sub Perlito5::AST::Sub::emit_perl6 {
        my $self = shift();
        my $level = shift();
        (Perlito5::Perl6::tab($level) . 'sub ' . (($self->{'name'} ? $self->{'name'} : '')) . '(*@_) {' . chr(10) . (Perlito5::Perl6::LexicalBlock->new('block', $self->{'block'}, 'needs_return', 1, 'top_level', 1))->emit_perl6(($level + 1)) . chr(10) . Perlito5::Perl6::tab($level) . '}')
    }
};
package Perlito5::AST::Do;
{
    sub Perlito5::AST::Do::emit_perl6 {
        my $self = shift();
        my $level = shift();
        my $block = $self->simplify()->block();
        return (Perlito5::Perl6::tab($level) . '(do {' . chr(10) . (Perlito5::Perl6::LexicalBlock->new('block', $block, 'needs_return', 1))->emit_perl6(($level + 1)) . chr(10) . Perlito5::Perl6::tab($level) . '})')
    }
};
package Perlito5::AST::Use;
{
    sub Perlito5::AST::Use::emit_perl6 {
        my $self = shift();
        my $level = shift();
        my $mod = $self->{'mod'};
        return (chr(10) . Perlito5::Perl6::tab($level) . '# use ' . $self->{'mod'} . ';')
    }
};

;

# use Perlito5::Perl6::Emitter
;
package main;
undef();

# use Perlito5::AST
;
package Perlito5::XS;
{
    sub Perlito5::XS::tab {
        my $level = shift();
        join("", '    ' x $level)
    };
    my %safe_char = (' ', 1, '!', 1, '"', 1, '#', 1, '$', 1, '%', 1, '&', 1, '(', 1, ')', 1, '*', 1, '+', 1, ',', 1, '-', 1, '.', 1, '/', 1, ':', 1, ';', 1, '<', 1, '=', 1, '>', 1, '?', 1, '@', 1, '[', 1, ']', 1, '^', 1, '_', 1, '`', 1, '{', 1, '|', 1, '}', 1, '~', 1);
    sub Perlito5::XS::escape_string {
        my $s = shift();
        my $tmp = '';
        return '""' if ($s eq '');
        for my  $i ((0 .. (length($s) - 1))) {
            my $c = substr($s, $i, 1);
            if ((((((($c ge 'a') && ($c le 'z'))) || ((($c ge 'A') && ($c le 'Z')))) || ((($c ge '0') && ($c le '9')))) || exists($safe_char{$c}))) {
                $tmp = ($tmp . $c)
            }
            else {
                $tmp = ($tmp . sprintf(chr(92) . 'x%02x', ord($c)))
            }
        };
        return ('"' . $tmp . '"')
    }
};
package Perlito5::AST::CompUnit;
{
    sub Perlito5::AST::CompUnit::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        my @body;
        for (@{$self->{'body'}}) {
            if (defined($_)) {
                push(@body, $_)
            }
        };
        (join(chr(10), map((Perlito5::XS::tab($level) . $_->emit_xs($level)), @body)) . chr(10) . chr(10) . chr(10))
    };
    sub Perlito5::AST::CompUnit::emit_xs_program {
        my $comp_units = $_[0];
        my $str = ('#include "EXTERN.h"' . chr(10) . '#include "perl.h"' . chr(10) . '#include "XSUB.h"' . chr(10) . chr(10));
        for my  $comp_unit (@{$comp_units}) {
            $str = ($str . $comp_unit->emit_xs(0))
        };
        $str = ($str . chr(10));
        return $str
    }
};
package Perlito5::AST::Val::Int;
{
    sub Perlito5::AST::Val::Int::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        ('newSViv(' . $self->{'int'} . ')')
    }
};
package Perlito5::AST::Val::Num;
{
    sub Perlito5::AST::Val::Num::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        ('newSVnv(' . $self->{'num'} . ')')
    }
};
package Perlito5::AST::Val::Buf;
{
    sub Perlito5::AST::Val::Buf::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        ('newSVpv(' . Perlito5::XS::escape_string($self->{'buf'}) . ', 0)')
    }
};
package Perlito5::AST::Lit::Block;
{
    sub Perlito5::AST::Lit::Block::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        ('do {{' . chr(10) . join(';' . chr(10), map((Perlito5::XS::tab(($level + 1)) . $_->emit_xs(($level + 1))), @{$self->{'stmts'}})) . chr(10) . Perlito5::XS::tab($level) . '}}')
    }
};
package Perlito5::AST::Index;
{
    sub Perlito5::AST::Index::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        if (($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '$'))) {
            my $v = $self->{'obj'};
            return ($v->emit_xs($level) . '[' . $self->{'index_exp'}->emit_xs(($level + 1)) . ']')
        };
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && ($self->{'obj'}->{'code'} eq 'prefix:<$>'))) {
            return ($self->{'obj'}->{'arguments'}->[0]->emit_xs($level) . '->[' . $self->{'index_exp'}->emit_xs($level) . ']')
        };
        ($self->{'obj'}->emit_xs($level) . '->[' . $self->{'index_exp'}->emit_xs(($level + 1)) . ']')
    }
};
package Perlito5::AST::Lookup;
{
    sub Perlito5::AST::Lookup::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        if (($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '$'))) {
            my $v = $self->{'obj'};
            return ($v->emit_xs($level) . '{' . $self->autoquote($self->{'index_exp'})->emit_xs($level) . '}')
        };
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && ($self->{'obj'}->{'code'} eq 'prefix:<$>'))) {
            return ($self->{'obj'}->{'arguments'}->[0]->emit_xs($level) . '->{' . $self->autoquote($self->{'index_exp'})->emit_xs($level) . '}')
        };
        ($self->{'obj'}->emit_xs($level) . '->{' . $self->autoquote($self->{'index_exp'})->emit_xs($level) . '}')
    }
};
package Perlito5::AST::Var;
{
    sub Perlito5::AST::Var::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        my $str_name = $self->{'name'};
        $str_name = chr(92) . chr(92) if ($str_name eq chr(92));
        $str_name = chr(92) . '"' if ($str_name eq '"');
        my $xs_name = $self->perl5_name();
        my $decl_type;
        my $decl = $self->perl5_get_decl($xs_name);
        if ($decl) {
            $decl_type = $decl->{'decl'}
        }
        else {
            if ((!($self->{'namespace'}) && ($self->{'sigil'} ne '*'))) {

            }
        };
        my $ns = '';
        if ((0 && $self->{'namespace'})) {
            if ((($self->{'namespace'} eq 'main') && (substr($self->{'name'}, 0, 1) eq '^'))) {
                return ($self->{'sigil'} . '{' . $self->{'name'} . '}')
            }
            else {
                $ns = ($self->{'namespace'} . '::')
            }
        };
        my $c = substr($self->{'name'}, 0, 1);
        if (((((($c ge 'a') && ($c le 'z'))) || ((($c ge 'A') && ($c le 'Z')))) || (($c eq '_')))) {
            return $self->{'name'};
            $self->{'sigil'} = '*';
            return ($self->{'sigil'} . $ns . $self->{'name'})
        };
        return ($self->{'sigil'} . '{' . chr(39) . $ns . $str_name . chr(39) . '}')
    }
};
package Perlito5::AST::Proto;
{
    sub Perlito5::AST::Proto::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        $self->{'name'}
    }
};
package Perlito5::AST::Call;
{
    sub Perlito5::AST::Call::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        my $invocant = $self->{'invocant'}->emit_xs();
        if (($self->{'method'} eq 'postcircumfix:<[ ]>')) {
            return ($invocant . '->[' . $self->{'arguments'}->emit_xs(($level + 1)) . ']')
        };
        if (($self->{'method'} eq 'postcircumfix:<{ }>')) {
            return ($invocant . '->{' . Perlito5::AST::Lookup->autoquote($self->{'arguments'})->emit_xs($level) . '}')
        };
        my $meth = $self->{'method'};
        if (($meth eq 'postcircumfix:<( )>')) {
            $meth = ''
        };
        if ((ref($meth) eq 'Perlito5::AST::Var')) {
            $meth = $meth->emit_xs(($level + 1))
        };
        ($invocant . '->' . $meth . '(' . join(', ', map($_->emit_xs(($level + 1)), @{$self->{'arguments'}})) . ')')
    }
};
package Perlito5::AST::Apply;
{
    my %op_prefix_xs = ('say', 'say', 'keys', 'keys', 'values', 'values', 'prefix:<!>', '!', 'prefix:<++>', '++', 'prefix:<-->', '--', 'prefix:<+>', '+', 'prefix:<->', '-', 'prefix:<-d>', '-d', 'prefix:<-e>', '-e', 'prefix:<-f>', '-f', 'prefix:<not>', 'not', 'prefix:<~>', '~');
    my %op_infix_xs = ('list:<,>', ', ', 'list:<.>', ' . ', 'infix:<+>', ' + ', 'infix:<->', ' - ', 'infix:<*>', ' * ', 'infix:</>', ' / ', 'infix:<%>', ' % ', 'infix:<**>', ' ** ', 'infix:<>>', ' > ', 'infix:<<>', ' < ', 'infix:<>=>', ' >= ', 'infix:<<=>', ' <= ', 'infix:<&>', ' & ', 'infix:<|>', ' | ', 'infix:<^>', ' ^ ', 'infix:<&&>', ' && ', 'infix:<||>', ' || ', 'infix:<and>', ' and ', 'infix:<or>', ' or ', 'infix:<//>', ' // ', 'infix:<eq>', ' eq ', 'infix:<ne>', ' ne ', 'infix:<le>', ' le ', 'infix:<ge>', ' ge ', 'infix:<lt>', ' lt ', 'infix:<gt>', ' gt ', 'infix:<==>', ' == ', 'infix:<!=>', ' != ', 'infix:<=~>', ' =~ ', 'infix:<!~>', ' !~ ');
    sub Perlito5::AST::Apply::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        my $apply = $self->op_assign();
        if ($apply) {
            return $apply->emit_xs($level)
        };
        my $ns = '';
        if ($self->{'namespace'}) {
            $ns = ($self->{'namespace'} . '::')
        };
        my $code = ($ns . $self->{'code'});
        if ((ref($code) ne '')) {
            return ('(' . $self->{'code'}->emit_xs(($level + 1)) . ')->(' . join(', ', map($_->emit_xs(($level + 1)), @{$self->{'arguments'}})) . ')')
        };
        if (exists($op_infix_xs{$code})) {
            return ('(' . join($op_infix_xs{$code}, (map($_->emit_xs(($level + 1)), @{$self->{'arguments'}}))) . ')')
        };
        if (exists($op_prefix_xs{$code})) {
            return ($op_prefix_xs{$code} . '(' . join(', ', map($_->emit_xs(($level + 1)), @{$self->{'arguments'}})) . ')')
        };
        if (($self->{'code'} eq 'p5:s')) {
            return ('s!' . $self->{'arguments'}->[0]->{'buf'} . '!' . $self->{'arguments'}->[1]->{'buf'} . '!' . $self->{'arguments'}->[2])
        };
        if (($self->{'code'} eq 'p5:m')) {
            my $s;
            if ($self->{'arguments'}->[0]->isa('Perlito5::AST::Val::Buf')) {
                $s = $self->{'arguments'}->[0]->{'buf'}
            }
            else {
                for my  $ast (@{$self->{'arguments'}->[0]->{'arguments'}}) {
                    if ($ast->isa('Perlito5::AST::Val::Buf')) {
                        $s = ($s . $ast->{'buf'})
                    }
                    else {
                        $s = ($s . $ast->emit_xs(($level + 1)))
                    }
                }
            };
            return ('m!' . $s . '!' . $self->{'arguments'}->[1])
        };
        if (($self->{'code'} eq 'p5:tr')) {
            return ('tr!' . $self->{'arguments'}->[0]->{'buf'} . '!' . $self->{'arguments'}->[1]->{'buf'} . '!')
        };
        if (($code eq '__PACKAGE__')) {
            return ('"' . $Perlito5::PKG_NAME . '"')
        };
        if (($self->{'code'} eq 'package')) {
            return ('MODULE = ' . $self->{'namespace'} . ' PACKAGE = ' . $self->{'namespace'})
        };
        if (($code eq 'undef')) {
            return 'undef()'
        };
        if (($code eq 'scalar')) {
            return ('scalar(' . ($self->{'arguments'}->[0]->emit_xs()) . ')')
        };
        if (($code eq 'pop')) {
            return ('pop(' . ($self->{'arguments'}->[0]->emit_xs()) . ')')
        };
        if (($code eq 'push')) {
            return ('push(' . ($self->{'arguments'}->[0]->emit_xs()) . ', ' . ($self->{'arguments'}->[1])->emit_xs(($level + 1)) . ' )')
        };
        if (($code eq 'shift')) {
            if (($self->{'arguments'} && @{$self->{'arguments'}})) {
                return ('shift(' . join(' ', map($_->emit_xs(($level + 1)), @{$self->{'arguments'}})) . ')')
            };
            return 'shift()'
        };
        if (($code eq 'unshift')) {
            return ('unshift(' . $self->{'arguments'}->[0]->emit_xs(($level + 1)) . ', ' . $self->{'arguments'}->[1]->emit_xs(($level + 1)) . ')')
        };
        if (($code eq 'map')) {
            if ($self->{'special_arg'}) {
                return ('map {' . chr(10) . join(';' . chr(10), map {
                                (Perlito5::XS::tab(($level + 1)) . $_->emit_xs(($level + 1)))
                            } @{$self->{'special_arg'}->{'stmts'}}) . chr(10) . Perlito5::XS::tab($level) . '} ' . join(',', map {
                                $_->emit_xs(($level + 1))
                            } @{$self->{'arguments'}}))
            };
            my $str = shift(@{$self->{'arguments'}});
            return ('map(' . $str->emit_xs(($level + 1)) . ', ' . join(',', map {
                            $_->emit_xs(($level + 1))
                        } @{$self->{'arguments'}}) . ')')
        };
        if (($code eq 'infix:<x>')) {
            return ('join("", ' . join(' x ', map($_->emit_xs(($level + 1)), @{$self->{'arguments'}})) . ')')
        };
        if (($code eq 'infix:<=>>')) {
            return (Perlito5::AST::Lookup->autoquote($self->{'arguments'}->[0])->emit_xs($level) . ', ' . $self->{'arguments'}->[1]->emit_xs($level))
        };
        if (($code eq 'join')) {
            my $str = shift(@{$self->{'arguments'}});
            return ('join(' . $str->emit_xs() . ', ' . join(',', map($_->emit_xs(($level + 1)), @{$self->{'arguments'}})) . ')')
        };
        if (($code eq 'circumfix:<[ ]>')) {
            return ('[' . join(', ', map($_->emit_xs(($level + 1)), @{$self->{'arguments'}})) . ']')
        };
        if (($code eq 'circumfix:<{ }>')) {
            return ('{' . join(', ', map($_->emit_xs(($level + 1)), @{$self->{'arguments'}})) . '}')
        };
        if (($code eq 'prefix:<' . chr(92) . '>')) {
            return (chr(92) . join(' ', map($_->emit_xs(($level + 1)), @{$self->{'arguments'}})) . '')
        };
        if (($code eq 'prefix:<$>')) {
            return ('${' . join(' ', map($_->emit_xs(($level + 1)), @{$self->{'arguments'}})) . '}')
        };
        if (($code eq 'prefix:<@>')) {
            return ('@{' . join(' ', map($_->emit_xs(($level + 1)), @{$self->{'arguments'}})) . '}')
        };
        if (($code eq 'prefix:<%>')) {
            return ('%{' . join(' ', map($_->emit_xs(($level + 1)), @{$self->{'arguments'}})) . '}')
        };
        if (($code eq 'prefix:<&>')) {
            return ('&{' . join(' ', map($_->emit_xs(($level + 1)), @{$self->{'arguments'}})) . '}')
        };
        if (($code eq 'prefix:<$#>')) {
            return ('$#{' . join(' ', map($_->emit_xs(($level + 1)), @{$self->{'arguments'}})) . '}')
        };
        if (($code eq 'postfix:<++>')) {
            return ('(' . join(' ', map($_->emit_xs(($level + 1)), @{$self->{'arguments'}})) . ')++')
        };
        if (($code eq 'postfix:<-->')) {
            return ('(' . join(' ', map($_->emit_xs(($level + 1)), @{$self->{'arguments'}})) . ')--')
        };
        if (($code eq 'infix:<..>')) {
            return ('(' . join(' .. ', map($_->emit_xs(($level + 1)), @{$self->{'arguments'}})) . ')')
        };
        if (($code eq 'ternary:<? :>')) {
            return ('(' . $self->{'arguments'}->[0]->emit_xs(($level + 1)) . ' ? ' . $self->{'arguments'}->[1]->emit_xs(($level + 1)) . ' : ' . $self->{'arguments'}->[2]->emit_xs(($level + 1)) . ')')
        };
        if (($code eq 'circumfix:<( )>')) {
            return ('(' . join(', ', map($_->emit_xs(($level + 1)), @{$self->{'arguments'}})) . ')')
        };
        if (($code eq 'infix:<=>')) {
            return emit_xs_bind($self->{'arguments'}->[0], $self->{'arguments'}->[1], $level)
        };
        if (($code eq 'require')) {
            return ('Perlito5::Grammar::Use::require(' . $self->{'arguments'}->[0]->emit_xs(($level + 1)) . ')')
        };
        if (($code eq 'do')) {
            my $ast = Perlito5::AST::Apply->new('code', 'eval', 'namespace', '', 'arguments', [Perlito5::AST::Apply->new('code', 'slurp', 'namespace', 'Perlito5::IO', 'arguments', $self->{'arguments'})]);
            return $ast->emit_xs($level)
        };
        if (($code eq 'eval')) {
            my $arg = $self->{'arguments'}->[0];
            my $eval;
            if ($arg->isa('Perlito5::AST::Do')) {
                $eval = $arg->emit_xs(($level + 1))
            }
            else {
                $eval = ('(do { ' . 'my $m = Perlito5::Grammar->exp_stmts(' . $arg->emit_xs(($level + 1), 'scalar') . ', 0);' . 'my $source; ' . '$source .= (defined $_ ? $_->emit_xs(0, "scalar") : "") . ";' . chr(92) . 'n" ' . 'for @{ Perlito5::Match::flat($m) }; ' . 'eval $source;' . '})')
            };
            return $eval
        };
        if (($code eq 'return')) {
            return ('PUSHs(' . join(', ', map($_->emit_xs(($level + 1)), @{$self->{'arguments'}})) . ')')
        };
        if (($code eq 'print')) {
            return ('puts( SvPVx_nolen( ' . join(', ', map($_->emit_xs(($level + 1)), @{$self->{'arguments'}})) . ') )')
        };
        if (($code eq 'warn')) {
            return ('warn( SvPVx_nolen( ' . join(', ', map($_->emit_xs(($level + 1)), @{$self->{'arguments'}})) . ') )')
        };
        if (($self->{'bareword'} && !(@{$self->{'arguments'}}))) {
            return $code
        };
        ($code . '(' . join(', ', map($_->emit_xs(($level + 1)), @{$self->{'arguments'}})) . ')')
    };
    sub Perlito5::AST::Apply::emit_xs_bind {
        my $parameters = shift();
        my $arguments = shift();
        my $level = shift();
        if ($parameters->isa('Perlito5::AST::Call')) {
            if ((($parameters->method() eq 'postcircumfix:<{ }>') || ($parameters->method() eq 'postcircumfix:<[ ]>'))) {
                return ('(' . $parameters->emit_xs(($level + 1)) . ' = ' . $arguments->emit_xs(($level + 1)) . ')')
            }
        };
        ($parameters->emit_xs(($level + 1)) . ' = ' . $arguments->emit_xs(($level + 1)))
    }
};
package Perlito5::AST::If;
{
    sub Perlito5::AST::If::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        return ('if (' . $self->{'cond'}->emit_xs(($level + 1)) . ') {' . chr(10) . (($self->{'body'} ? (join(';' . chr(10), map((Perlito5::XS::tab(($level + 1)) . $_->emit_xs(($level + 1))), @{$self->{'body'}->stmts()})) . chr(10)) : '')) . Perlito5::XS::tab($level) . '}' . ((($self->{'otherwise'} && scalar(@{$self->{'otherwise'}->stmts()})) ? ((chr(10) . Perlito5::XS::tab($level) . 'else {' . chr(10) . join(';' . chr(10), map((Perlito5::XS::tab(($level + 1)) . $_->emit_xs(($level + 1))), @{$self->{'otherwise'}->stmts()})) . chr(10) . Perlito5::XS::tab($level) . '}')) : '')))
    }
};
package Perlito5::AST::When;
{
    sub Perlito5::AST::When::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        return ('when (' . $self->{'cond'}->emit_xs(($level + 1)) . ') {' . chr(10) . (($self->{'body'} ? (join(';' . chr(10), map((Perlito5::XS::tab(($level + 1)) . $_->emit_xs(($level + 1))), @{$self->{'body'}->stmts()})) . chr(10)) : '')) . Perlito5::XS::tab($level) . '}')
    }
};
package Perlito5::AST::While;
{
    sub Perlito5::AST::While::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        my $cond = $self->{'cond'};
        ('for ( ' . (($self->{'init'} ? ($self->{'init'}->emit_xs(($level + 1)) . '; ') : '; ')) . (($cond ? ($cond->emit_xs(($level + 1)) . '; ') : '; ')) . (($self->{'continue'} ? ($self->{'continue'}->emit_xs(($level + 1)) . ' ') : ' ')) . ') {' . chr(10) . join(';' . chr(10), map((Perlito5::XS::tab(($level + 1)) . $_->emit_xs(($level + 1))), @{$self->{'body'}->stmts()})) . chr(10) . Perlito5::XS::tab($level) . '}')
    }
};
package Perlito5::AST::For;
{
    sub Perlito5::AST::For::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        my $cond;
        if ((ref($self->{'cond'}) eq 'ARRAY')) {
            $cond = ((($self->{'cond'}->[0] ? ($self->{'cond'}->[0]->emit_javascript(($level + 1)) . '; ') : '; ')) . (($self->{'cond'}->[1] ? ($self->{'cond'}->[1]->emit_javascript(($level + 1)) . '; ') : '; ')) . (($self->{'cond'}->[2] ? ($self->{'cond'}->[2]->emit_javascript(($level + 1)) . ' ') : ' ')))
        }
        else {
            $cond = $self->{'cond'}->emit_xs(($level + 1))
        };
        my $sig = '';
        my $sig_ast = $self->{'body'}->sig();
        if (!($sig_ast)) {

        }
        else {
            if ($sig_ast->{'decl'}) {
                $sig = ($sig_ast->{'decl'} . ' ' . $sig_ast->{'type'} . ' ' . $sig_ast->{'var'}->emit_xs(($level + 1)) . ' ')
            }
            else {
                $sig = ($sig_ast->emit_xs(($level + 1)) . ' ')
            }
        };
        return ('for ' . $sig . '(' . $cond . ') {' . chr(10) . join(';' . chr(10), map((Perlito5::XS::tab(($level + 1)) . $_->emit_xs(($level + 1))), @{$self->{'body'}->stmts()})) . chr(10) . Perlito5::XS::tab($level) . '}')
    }
};
package Perlito5::AST::Decl;
{
    sub Perlito5::AST::Decl::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        $self->{'type'} = 'SV *';
        my $decl = $self->{'decl'};
        my $str = ($self->{'type'} . $self->{'var'}->emit_xs(($level + 1)));
        return $str
    }
};
package Perlito5::AST::Sub;
{
    sub Perlito5::AST::Sub::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        my $name = '';
        $name = ($self->{'name'} . ' ') if $self->{'name'};
        my $sig = $self->{'sig'};
        my $i = 0;
        ('void ' . $name . '()' . chr(10) . 'PPCODE:' . chr(10) . join(';' . chr(10), map((Perlito5::XS::tab(($level + 1)) . $_->emit_xs(($level + 1))), @{$self->{'block'}})) . ';' . chr(10))
    }
};
package Perlito5::AST::Do;
{
    sub Perlito5::AST::Do::emit_xs {
        my $self = $_[0];
        my $level = $_[1];
        my $block = $self->simplify()->block();
        ('(do {' . chr(10) . join(';' . chr(10), map((defined($_) && (Perlito5::XS::tab($level) . $_->emit_xs(($level + 1)))), @{$block})) . chr(10) . Perlito5::XS::tab($level) . '})')
    }
};
package Perlito5::AST::Use;
{
    sub Perlito5::AST::Use::emit_xs {
        my $self = shift();
        my $level = shift();
        Perlito5::Grammar::Use::emit_time_eval($self);
        return (chr(10) . Perlito5::XS::tab($level) . '# ' . $self->{'code'} . ' ' . $self->{'mod'} . chr(10))
    }
};

;

# use Perlito5::XS::Emitter
;

# use Perlito5::Grammar::Precedence
;
package main;
package Perlito5::strict;
sub Perlito5::strict::import {
    $Perlito5::STRICT = 1
};
sub Perlito5::strict::unimport {
    $Perlito5::STRICT = 0
};
1;

;
package main;
package Perlito5;

# use Perlito5::strict
;
${chr(15)} = 'perlito5' unless defined(${chr(15)});
${'main::]'} = 5.014001 unless ${'main::]'};
${'/'} = chr(10) unless defined(${'/'});
${'\"'} = ' ' unless defined(${'\"'});
${','} = undef() unless defined(${','});
${'!'} = '' unless defined(${'!'});
${';'} = chr(28) unless defined(${';'});
${'?'} = 0 unless defined(${'?'});
${'['} = 0 unless defined(${'['});
${chr(22)} = bless({'original', 'v5.14.1', 'qv', 1, 'version', [5, 14, 1]}, 'version') unless defined(${chr(22)});
our $EXPAND_USE = 1;
our $STRICT = 0;
our $WARNINGS = 0;
our $UTF8 = 0;
our $BYTES = 0;
our $CALLER = [];
our %DATA_SECTION = ();
our $PKG_NAME = '';
our $LINE_NUMBER = 0;
our $FILE_NAME = '';
our $PACKAGES = {'STDERR', 1, 'STDOUT', 1, 'STDIN', 1, 'main', 1, 'strict', 1, 'warnings', 1, 'utf8', 1, 'bytes', 1, 'encoding', 1, 'UNIVERSAL', 1, 'CORE', 1, 'CORE::GLOBAL', 1, 'Perlito5::IO', 1};
push(@INC, $_) for split(':', (($ENV{'PERL5LIB'} || '')));
our $SPECIAL_VAR = {'$_', 'ARG', '$&', '$MATCH', '$`', '$PREMATCH', '$' . chr(39), '$POSTMATCH', '$+', '$LAST_PAREN_MATCH', '@+', '@LAST_MATCH_END', '%+', '%LAST_PAREN_MATCH', '@-', '@LAST_MATCH_START', '$|', 'autoflush', '$/', '$RS', '@_', '@ARG', '< $', '$EUID', '$.', '$NR', '< $< ', '$UID', '$(', '$GID', '$#', undef(), '$@', '$EVAL_ERROR', '$=', '$FORMAT_LINES_PER_PAGE', '$,', '$OFS', '$?', '$CHILD_ERROR', '$*', undef(), '$[', undef(), '$$', '$PID', '%-', undef(), '$~', '$FORMAT_NAME', '$-', '$FORMAT_LINES_LEFT', '$&', '$MATCH', '$%', '$FORMAT_PAGE_NUMBER', '$)', '$EGID', '$]', undef(), '$!', '$ERRNO', '$;', '$SUBSEP', '$' . chr(92), '$ORS', '%!', undef(), '$"', '$LIST_SEPARATOR', '$_', '$ARG', '$:', 'FORMAT_LINE_BREAK_CHARACTERS'};
our $CORE_OVERRIDABLE = {'say', 1, 'break', 1, 'given', 1, 'when', 1, 'default', 1, 'state', 1, 'lock', 1};
our $CORE_PROTO = {'CORE::shutdown', '*$', 'CORE::chop', undef(), 'CORE::lstat', '*', 'CORE::rename', '$$', 'CORE::lock', chr(92) . '$', 'CORE::rand', ';$', 'CORE::gmtime', ';$', 'CORE::gethostbyname', '$', 'CORE::each', chr(92) . '[@%]', 'CORE::ref', '_', 'CORE::syswrite', '*$;$$', 'CORE::msgctl', '$$$', 'CORE::getnetbyname', '$', 'CORE::write', ';*', 'CORE::alarm', '_', 'CORE::print', undef(), 'CORE::getnetent', '', 'CORE::semget', '$$$', 'CORE::use', undef(), 'CORE::abs', '_', 'CORE::break', '', 'CORE::undef', undef(), 'CORE::no', undef(), 'CORE::eval', '_', 'CORE::split', undef(), 'CORE::localtime', ';$', 'CORE::sort', undef(), 'CORE::chown', '@', 'CORE::endpwent', '', 'CORE::getpwent', '', 'CORE::pos', undef(), 'CORE::lcfirst', '_', 'CORE::kill', '@', 'CORE::send', '*$$;$', 'CORE::endprotoent', '', 'CORE::semctl', '$$$$', 'CORE::waitpid', '$$', 'CORE::utime', '@', 'CORE::dbmclose', chr(92) . '%', 'CORE::getpwnam', '$', 'CORE::substr', '$$;$$', 'CORE::listen', '*$', 'CORE::getprotoent', '', 'CORE::shmget', '$$$', 'CORE::our', undef(), 'CORE::readlink', '_', 'CORE::shmwrite', '$$$$', 'CORE::times', '', 'CORE::package', undef(), 'CORE::map', undef(), 'CORE::join', '$@', 'CORE::rmdir', '_', 'CORE::shmread', '$$$$', 'CORE::uc', '_', 'CORE::bless', '$;$', 'CORE::closedir', '*', 'CORE::getppid', '', 'CORE::tie', chr(92) . '[$@%]$;@', 'CORE::readdir', '*', 'CORE::gethostent', '', 'CORE::getlogin', '', 'CORE::last', undef(), 'CORE::gethostbyaddr', '$$', 'CORE::accept', '**', 'CORE::log', '_', 'CORE::tell', ';*', 'CORE::readline', ';*', 'CORE::tied', undef(), 'CORE::socket', '*$$$', 'CORE::umask', ';$', 'CORE::sysread', '*' . chr(92) . '$$;$', 'CORE::syscall', '$@', 'CORE::quotemeta', '_', 'CORE::dump', '', 'CORE::opendir', '*$', 'CORE::untie', undef(), 'CORE::truncate', '$$', 'CORE::select', ';*', 'CORE::sleep', ';$', 'CORE::seek', '*$$', 'CORE::read', '*' . chr(92) . '$$;$', 'CORE::rewinddir', '*', 'CORE::scalar', undef(), 'CORE::wantarray', '', 'CORE::oct', '_', 'CORE::bind', '*$', 'CORE::stat', '*', 'CORE::sqrt', '_', 'CORE::getc', ';*', 'CORE::fileno', '*', 'CORE::getpeername', '*', 'CORE::sin', '_', 'CORE::getnetbyaddr', '$$', 'CORE::grep', undef(), 'CORE::setservent', '$', 'CORE::sub', undef(), 'CORE::shmctl', '$$$', 'CORE::study', undef(), 'CORE::msgrcv', '$$$$$', 'CORE::setsockopt', '*$$$', 'CORE::int', '_', 'CORE::pop', ';' . chr(92) . '@', 'CORE::link', '$$', 'CORE::exec', undef(), 'CORE::setpwent', '', 'CORE::mkdir', '_;$', 'CORE::sysseek', '*$$', 'CORE::endservent', '', 'CORE::chr', '_', 'CORE::when', undef(), 'CORE::getpwuid', '$', 'CORE::setprotoent', '$', 'CORE::reverse', '@', 'CORE::say', undef(), 'CORE::goto', undef(), 'CORE::getgrent', '', 'CORE::endnetent', '', 'CORE::hex', '_', 'CORE::binmode', '*;$', 'CORE::formline', '$@', 'CORE::getgrnam', '$', 'CORE::ucfirst', '_', 'CORE::chdir', ';$', 'CORE::setnetent', '$', 'CORE::splice', chr(92) . '@;$$@', 'CORE::unlink', '@', 'CORE::time', '', 'CORE::push', chr(92) . '@@', 'CORE::exit', ';$', 'CORE::endgrent', '', 'CORE::unshift', chr(92) . '@@', 'CORE::local', undef(), 'CORE::my', undef(), 'CORE::cos', '_', 'CORE::redo', undef(), 'CORE::warn', '@', 'CORE::getsockname', '*', 'CORE::pipe', '**', 'CORE::sprintf', '$@', 'CORE::open', '*;$@', 'CORE::setpgrp', ';$$', 'CORE::exp', '_', 'CORE::seekdir', '*$', 'CORE::getservbyport', '$$', 'CORE::given', undef(), 'CORE::pack', '$@', 'CORE::msgget', '$$', 'CORE::rindex', '$$;$', 'CORE::srand', ';$', 'CORE::telldir', '*', 'CORE::connect', '*$', 'CORE::getprotobyname', '$', 'CORE::msgsnd', '$$$', 'CORE::length', '_', 'CORE::state', undef(), 'CORE::die', '@', 'CORE::delete', undef(), 'CORE::getservent', '', 'CORE::getservbyname', '$$', 'CORE::setpriority', '$$$', 'CORE::lc', '_', 'CORE::fcntl', '*$$', 'CORE::chroot', '_', 'CORE::recv', '*' . chr(92) . '$$$', 'CORE::dbmopen', chr(92) . '%$$', 'CORE::socketpair', '**$$$', 'CORE::vec', '$$$', 'CORE::system', undef(), 'CORE::defined', '_', 'CORE::index', '$$;$', 'CORE::caller', ';$', 'CORE::close', ';*', 'CORE::atan2', '$$', 'CORE::semop', '$$', 'CORE::unpack', '$;$', 'CORE::ord', '_', 'CORE::chmod', '@', 'CORE::prototype', undef(), 'CORE::getprotobynumber', '$', 'CORE::values', chr(92) . '[@%]', 'CORE::chomp', undef(), 'CORE::ioctl', '*$$', 'CORE::eof', ';*', 'CORE::crypt', '$$', 'CORE::do', undef(), 'CORE::flock', '*$', 'CORE::wait', '', 'CORE::sethostent', '$', 'CORE::return', undef(), 'CORE::getsockopt', '*$$', 'CORE::fork', '', 'CORE::require', undef(), 'CORE::format', undef(), 'CORE::readpipe', '_', 'CORE::endhostent', '', 'CORE::getpgrp', ';$', 'CORE::setgrent', '', 'CORE::keys', chr(92) . '[@%]', 'CORE::glob', undef(), 'CORE::getpriority', '$$', 'CORE::reset', ';$', 'CORE::sysopen', '*$$;$', 'CORE::continue', '', 'CORE::next', undef(), 'CORE::getgrgid', '$', 'CORE::default', undef(), 'CORE::shift', ';' . chr(92) . '@', 'CORE::symlink', '$$', 'CORE::exists', '$', 'CORE::printf', '$@', 'CORE::m', undef(), 'CORE::q', undef(), 'CORE::qq', undef(), 'CORE::qw', undef(), 'CORE::qx', undef(), 'CORE::qr', undef(), 'CORE::s', undef(), 'CORE::tr', undef(), 'CORE::y', undef(), 'CORE::if', undef(), 'CORE::unless', undef(), 'CORE::when', undef(), 'CORE::for', undef(), 'CORE::foreach', undef(), 'CORE::while', undef(), 'CORE::given', undef(), 'CORE::and', undef(), 'CORE::or', undef(), 'CORE::xor', undef(), 'CORE::not', undef(), 'CORE::cmp', undef()};
1;

;

# use Perlito5::Runtime
;

# use Perlito5::Dumper
;

# use strict
;
my $_V5_COMPILER_NAME = 'Perlito5';
my $_V5_COMPILER_VERSION = '9.0';
my $source = '';
my $backend = ${chr(15)};
my $execute = 1;
my $verbose = 0;
my $expand_use = 1;
if ($verbose) {
    warn('// Perlito5 compiler');
    warn(('// ARGV: ' . join(' ', @ARGV)))
};
my $help_message = chr(10) . 'perlito5 [switches] [programfile]' . chr(10) . '  switches:' . chr(10) . '    -h --help' . chr(10) . '    --verbose' . chr(10) . '    -V --version' . chr(10) . '    -v' . chr(10) . '    -Idirectory     specify @INC/include directory (several -I' . chr(39) . 's allowed)' . chr(10) . '    -Ctarget        target backend: js, perl5, perl6, xs' . chr(10) . '    -Cast-perl5     emits a dump of the abstract syntax tree' . chr(10) . '    --expand_use --noexpand_use' . chr(10) . '                    expand ' . chr(39) . 'use' . chr(39) . ' statements at compile time' . chr(10) . '    -e program      one line of program (omit programfile)' . chr(10);
my $copyright_message = ((('This is Perlito5 ' . $_V5_COMPILER_VERSION . ', an implementation of the Perl language.' . chr(10) . chr(10) . 'The Perl language is Copyright 1987-2012, Larry Wall' . chr(10) . 'The Perlito5 implementation is Copyright 2011, 2012 by Flavio Soibelmann Glock and others.' . chr(10) . chr(10) . 'Perl may be copied only under the terms of either the Artistic License or the' . chr(10) . 'GNU General Public License, which may be found in the Perl 5 source kit.' . chr(10) . chr(10) . 'Complete documentation for Perl, including FAQ lists, should be found on' . chr(10) . 'this system using "man perl" or "perldoc perl".  If you have access to the' . chr(10) . 'Internet, point your browser at http://www.perl.org/, the Perl Home Page.') . chr(10)));
for ( ; ((substr($ARGV[0], 0, 1) eq '-') && (substr($ARGV[0], 0, 2) ne '-e')); {

    } ) {
    if (($ARGV[0] eq '--verbose')) {
        $verbose = 1;
        shift(@ARGV)
    }
    else {
        if (($ARGV[0] eq '-I')) {
            shift(@ARGV);
            my $lib = shift(@ARGV);
            unshift(@INC, $lib)
        }
        else {
            if ((substr($ARGV[0], 0, 2) eq '-I')) {
                my $lib = substr($ARGV[0], 2);
                unshift(@INC, $lib);
                shift(@ARGV)
            }
            else {
                if ((substr($ARGV[0], 0, 2) eq '-C')) {
                    $backend = substr($ARGV[0], 2, 10);
                    $execute = 0;
                    shift(@ARGV)
                }
                else {
                    if (($ARGV[0] eq '-MO=Deparse')) {
                        $backend = 'perl5';
                        $execute = 0;
                        $expand_use = 0;
                        shift(@ARGV)
                    }
                    else {
                        if (((($ARGV[0] eq '-V')) || (($ARGV[0] eq '--version')))) {
                            $backend = '';
                            say($_V5_COMPILER_NAME, ' ', $_V5_COMPILER_VERSION);
                            shift(@ARGV)
                        }
                        else {
                            if (($ARGV[0] eq '-v')) {
                                $backend = '';
                                say($copyright_message);
                                shift(@ARGV)
                            }
                            else {
                                if (((($ARGV[0] eq '-h') || ($ARGV[0] eq '--help')) || !(@ARGV))) {
                                    $backend = '';
                                    say($_V5_COMPILER_NAME, ' ', $_V5_COMPILER_VERSION, $help_message);
                                    shift(@ARGV)
                                }
                                else {
                                    if (($ARGV[0] eq '--expand_use')) {
                                        $expand_use = 1;
                                        shift(@ARGV)
                                    }
                                    else {
                                        if (($ARGV[0] eq '--noexpand_use')) {
                                            $expand_use = 0;
                                            shift(@ARGV)
                                        }
                                        else {
                                            die(('Unrecognized switch: ' . $ARGV[0] . '  (-h will show valid options).' . chr(10)))
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
};
if (($backend && @ARGV)) {
    if (($ARGV[0] eq '-e')) {
        shift(@ARGV);
        if ($verbose) {
            warn('// source from command line: ', $ARGV[0])
        };
        $source = shift(@ARGV)
    }
    else {
        if ($verbose) {
            warn('// source from file: ', $ARGV[0])
        };
        $source = Perlito5::IO::slurp(shift(@ARGV))
    };
    if ($verbose) {
        warn('// backend: ', $backend);
        warn('now parsing')
    };
    $Perlito5::PKG_NAME = 'main';
    $Perlito5::PROTO = {};
    if ($execute) {
        $Perlito5::EXPAND_USE = 1;
        local(${'@'});
        eval ('package main; no strict; no warnings; ' . $source . '; $@ = undef');
        if (${'@'}) {
            my $error = ${'@'};
            warn($error);
            exit(255)
        }
    }
    else {
        eval {
            %INC = ();
            $Perlito5::EXPAND_USE = 0;
            my $m;
            my $ok;
            eval {
                $m = Perlito5::Grammar->exp_stmts($source, 0);
                $ok = 1
            };
            if ((!($ok) || ($m->{'to'} != length($source)))) {
                my $error = ((${'@'} || ((($m->{'to'} != length($source)) && ('Syntax Error near ' . $m->{'to'})))) || 'Unknown error');
                warn($error);
                exit(255)
            }
            else {
                my $comp_units;
                if ($expand_use) {
                    my $ok;
                    eval {
                        $comp_units = Perlito5::Grammar::Use::add_comp_unit(Perlito5::Match::flat($m));
                        $ok = 1
                    };
                    if (!($ok)) {
                        my $error = (${'@'} || 'Unknown error loading a module');
                        warn($error);
                        exit(255)
                    }
                }
                else {
                    $comp_units = Perlito5::Match::flat($m)
                };
                $comp_units = [Perlito5::AST::CompUnit->new('name', 'main', 'body', $comp_units)];
                if (($backend eq 'perl5')) {
                    say('# Do not edit this file - Generated by ', $_V5_COMPILER_NAME, ' ', $_V5_COMPILER_VERSION);
                    if ($expand_use) {
                        print(Perlito5::Perl5::Runtime->emit_perl5())
                    };
                    print(Perlito5::AST::CompUnit::emit_perl5_program($comp_units))
                };
                if (($backend eq 'perl6')) {
                    say('# Do not edit this file - Generated by ', $_V5_COMPILER_NAME, ' ', $_V5_COMPILER_VERSION);
                    print(Perlito5::AST::CompUnit::emit_perl6_program($comp_units))
                };
                if (($backend eq 'js')) {
                    say('// Do not edit this file - Generated by ', $_V5_COMPILER_NAME, ' ', $_V5_COMPILER_VERSION);
                    if ($expand_use) {
                        print(Perlito5::Javascript2::Runtime->emit_javascript2());
                        print(Perlito5::Javascript2::Array->emit_javascript2());
                        print(Perlito5::Javascript2::CORE->emit_javascript2());
                        print(Perlito5::Javascript2::IO->emit_javascript2());
                        print(Perlito5::Javascript2::Sprintf->emit_javascript2())
                    };
                    print(Perlito5::AST::CompUnit::emit_javascript2_program($comp_units))
                };
                if (($backend eq 'js3')) {
                    say('// Do not edit this file - Generated by ', $_V5_COMPILER_NAME, ' ', $_V5_COMPILER_VERSION);
                    if ($expand_use) {
                        print(Perlito5::Javascript3::Runtime->emit_javascript3());
                        print(Perlito5::Javascript3::CORE->emit_javascript3());
                        print(Perlito5::Javascript3::IO->emit_javascript3());
                        print(Perlito5::Javascript3::Sprintf->emit_javascript3())
                    };
                    print(Perlito5::AST::CompUnit::emit_javascript3_program($comp_units))
                };
                if (($backend eq 'xs')) {
                    say('/* Do not edit this file - Generated by ', $_V5_COMPILER_NAME, ' ', $_V5_COMPILER_VERSION, ' */');
                    print(Perlito5::AST::CompUnit::emit_xs_program($comp_units))
                };
                if (($backend eq 'ast-perl5')) {
                    say(Perlito5::Dumper::Dumper($comp_units))
                }
                else {
                    if (($backend eq 'ast-pretty')) {
                        eval 'use Data::Printer {colored=>1,class=>{expand=>"all",show_methods=>"none"}};p($comp_units);1';
                        print(${'@'})
                    }
                }
            };
            ${'@'} = undef()
        }
    };
    if (${'@'}) {
        my $error = ${'@'};
        warn($error);
        exit(255)
    }
};

1;
