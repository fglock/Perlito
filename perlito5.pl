
use v5.10;
use feature 'say';

# Do not edit this file - Generated by Perlito5 9.023

{
    package main;
    package feature;
    sub feature::import {}
    sub feature::unimport {}
    1
}
{
    package main;
    package Perlito5;
    $VERSION = 9.023;
    1
}
{
    package main;
    package strict;
    $Perlito5::STRICT_REFS = 2;
    $Perlito5::STRICT_SUBS = 512;
    $Perlito5::STRICT_VARS = 1024;
    sub strict::import {
        (my $pkg, my @args) = @_;
        !@args && (@args = ("refs", "subs", "vars"));
        for $_ (@args) {
            $_ eq "refs" && (${^H} |= $Perlito5::STRICT_REFS);
            $_ eq "subs" && (${^H} |= $Perlito5::STRICT_SUBS);
            $_ eq "vars" && (${^H} |= $Perlito5::STRICT_VARS)
        }
    }
    sub strict::unimport {
        (my $pkg, my @args) = @_;
        !@args && (@args = ("refs", "subs", "vars"));
        for $_ (@args) {
            $_ eq "refs" && (${^H} &= ~$Perlito5::STRICT_REFS);
            $_ eq "subs" && (${^H} &= ~$Perlito5::STRICT_SUBS);
            $_ eq "vars" && (${^H} &= ~$Perlito5::STRICT_VARS)
        }
    }
    1
}
{
    package main;
    package warnings;
    sub warnings::import {;
        $Perlito5::WARNINGS = 1
    }
    sub warnings::unimport {;
        $Perlito5::WARNINGS = 0
    }
    sub warnings::register_categories {}
    sub warnings::warnif {;
        warn(pop(@_))
    }
    1
}
{
    package main;
    package Perlito5::Match;
    sub Perlito5::Match::flat {
        my $self = $_[0];
        defined($self->{"capture"}) && return $self->{"capture"};
        return join('', @{$self->{"str"}}[$self->{"from"} .. ($self->{"to"}) - 1])
    }
    1
}
{
    package main;
    package Perlito5::Grammar::Precedence;
    my $Operator = {};
    my $Precedence = {};
    my $PrefixPrecedence = {};
    my $Assoc = {};
    sub Perlito5::Grammar::Precedence::is_assoc_type {
        my $assoc_type = shift;
        my $op_name = shift;
        return $Assoc->{$assoc_type}->{$op_name}
    }
    sub Perlito5::Grammar::Precedence::is_fixity_type {
        my $fixity_type = shift;
        my $op_name = shift;
        return $Operator->{$fixity_type}->{$op_name}
    }
    my @Parsed_op_chars = (2, 1);
    my %Parsed_op = ("?", sub {;
        Perlito5::Grammar::Expression::term_ternary($_[0], $_[1])
    }, "(", sub {;
        Perlito5::Grammar::Expression::term_paren($_[0], $_[1])
    }, "[", sub {;
        Perlito5::Grammar::Expression::term_square($_[0], $_[1])
    }, "{", sub {;
        Perlito5::Grammar::Expression::term_curly($_[0], $_[1])
    }, "->", sub {;
        Perlito5::Grammar::Expression::term_arrow($_[0], $_[1])
    });
    my @Term_chars;
    my %Term;
    sub Perlito5::Grammar::Precedence::add_term {
        my $name = shift;
        my $param = shift;
        $Term{$name} = $param;
        unshift(@Term_chars, scalar(@Term_chars) + 1)
            while @Term_chars < length($name)
    }
    my $End_token;
    my $End_token_chars;
    my %Op;
    my @Op_chars = (4, 3, 2, 1);
    sub Perlito5::Grammar::Precedence::op_parse {
        my $str = shift;
        my $pos = shift;
        my $last_is_term = shift;
        my $tok = join('', @{$str}[$pos .. $pos + 10]);
        for my $len (@{$End_token_chars}) {
            my $term = substr($tok, 0, $len);
            if (exists($End_token->{$term})) {
                my $c1 = $str->[($pos + $len) - 1];
                my $c2 = $str->[$pos + $len];
                if (!($Perlito5::Grammar::is_ident_middle{$c1} && $Perlito5::Grammar::is_ident_middle{$c2}) && !($c1 eq "<" && $c2 eq "<")) {;
                    return {"str" => $str, "from" => $pos, "to" => $pos, "capture" => ["end", $term], }
                }
            }
        }
        if (!$last_is_term) {;
            for my $len (@Term_chars) {
                my $term = substr($tok, 0, $len);
                if (exists($Term{$term})) {
                    my $c1 = $str->[($pos + $len) - 1];
                    my $c2 = $str->[$pos + $len];
                    if (($c1 ge 0 && $c1 le 9) || !$Perlito5::Grammar::is_ident_middle{$c1} || !$Perlito5::Grammar::is_ident_middle{$c2}) {
                        my $m = $Term{$term}->($str, $pos);
                        $m && return $m
                    }
                }
            }
        }
        for my $len (@Parsed_op_chars) {
            my $op = substr($tok, 0, $len);
            if (exists($Parsed_op{$op})) {
                my $m = $Parsed_op{$op}->($str, $pos);
                $m && return $m
            }
        }
        for my $len (@Op_chars) {
            my $op = substr($tok, 0, $len);
            if (exists($Op{$op})) {
                my $c1 = $str->[($pos + $len) - 1];
                my $c2 = $str->[$pos + $len];
                if ((!($Perlito5::Grammar::is_ident_middle{$c1} && $Perlito5::Grammar::is_ident_middle{$c2}) && !($c1 eq "&" && $c2 eq "&")) || ($c1 eq "x" && $c2 ge 0 && $c2 le 9)) {
                    if (exists($Operator->{"infix"}->{$op}) && !exists($Operator->{"prefix"}->{$op}) && !$last_is_term) {}
                    else {;
                        return {"str" => $str, "from" => $pos, "to" => $pos + $len, "capture" => ["op", $op], }
                    }
                }
            }
        }
        return Perlito5::Grammar::Bareword::term_bareword($str, $pos)
    }
    sub Perlito5::Grammar::Precedence::add_op {
        (my $fixity, my $names, my $precedence, my $param) = @_;
        $param //= {};
        my $assoc = $param->{"assoc"} || "left";
        for my $name (@{$names}) {
            $Operator->{$fixity}->{$name} = 1;
            $Precedence->{$name} = $precedence;
            $fixity eq "prefix" && ($PrefixPrecedence->{$name} = $precedence);
            $Assoc->{$assoc}->{$name} = 1;
            $Op{$name} = 1
        }
    }
    my $prec = 100;
    Perlito5::Grammar::Precedence::add_op("postfix", [".( )", ".[ ]", ".{ }", "( )", "[ ]", "funcall", "funcall_no_params", "methcall", "methcall_no_params", "block", "hash"], $prec);
    $prec = $prec - 1;
    Perlito5::Grammar::Precedence::add_op("prefix", ["++", "--"], $prec);
    Perlito5::Grammar::Precedence::add_op("postfix", ["++", "--"], $prec);
    $prec = $prec - 1;
    Perlito5::Grammar::Precedence::add_op("infix", ["**"], $prec, {"assoc" => "right", });
    $prec = $prec - 1;
    Perlito5::Grammar::Precedence::add_op("prefix", ["\\", "+", "-", "~", "~.", "!"], $prec);
    $prec = $prec - 1;
    Perlito5::Grammar::Precedence::add_op("infix", ["=~", "!~"], $prec);
    $prec = $prec - 1;
    Perlito5::Grammar::Precedence::add_op("infix", ["*", "/", "%", "x"], $prec);
    $prec = $prec - 1;
    Perlito5::Grammar::Precedence::add_op("infix", ["+", "-"], $prec);
    Perlito5::Grammar::Precedence::add_op("infix", ["."], $prec, {"assoc" => "list", });
    $prec = $prec - 1;
    Perlito5::Grammar::Precedence::add_op("infix", ["<<", ">>"], $prec);
    $prec = $prec - 1;
    $prec = $prec - 1;
    Perlito5::Grammar::Precedence::add_op("infix", ["lt", "le", "gt", "ge", "<=", ">=", "<", ">"], $prec, {"assoc" => "chain", });
    $prec = $prec - 1;
    Perlito5::Grammar::Precedence::add_op("infix", ["<=>", "cmp", "==", "!=", "ne", "eq"], $prec, {"assoc" => "chain", });
    $prec = $prec - 1;
    Perlito5::Grammar::Precedence::add_op("infix", ["&", "&."], $prec);
    $prec = $prec - 1;
    Perlito5::Grammar::Precedence::add_op("infix", ["|", "|.", "^", "^."], $prec);
    $prec = $prec - 1;
    Perlito5::Grammar::Precedence::add_op("infix", ["..", "..."], $prec);
    Perlito5::Grammar::Precedence::add_op("infix", ["~~"], $prec, {"assoc" => "chain", });
    $prec = $prec - 1;
    Perlito5::Grammar::Precedence::add_op("infix", ["&&"], $prec, {"assoc" => "right", });
    $prec = $prec - 1;
    Perlito5::Grammar::Precedence::add_op("infix", ["||"], $prec, {"assoc" => "right", });
    Perlito5::Grammar::Precedence::add_op("infix", ["//"], $prec);
    $prec = $prec - 1;
    Perlito5::Grammar::Precedence::add_op("ternary", ["? :"], $prec, {"assoc" => "right", });
    $prec = $prec - 1;
    Perlito5::Grammar::Precedence::add_op("infix", ["=", "**=", "+=", "-=", "*=", "/=", "x=", "|=", "&=", ".=", "<<=", ">>=", "%=", "||=", "&&=", "^=", "//=", "|.=", "&.=", "^.="], $prec, {"assoc" => "right", });
    $prec = $prec - 1;
    Perlito5::Grammar::Precedence::add_op("infix", ["=>"], $prec, {"assoc" => "right", });
    $prec = $prec - 1;
    Perlito5::Grammar::Precedence::add_op("list", [","], $prec, {"assoc" => "list", });
    $prec = $prec - 1;
    Perlito5::Grammar::Precedence::add_op("prefix", ["not"], $prec);
    $prec = $prec - 1;
    Perlito5::Grammar::Precedence::add_op("infix", ["and"], $prec);
    $prec = $prec - 1;
    Perlito5::Grammar::Precedence::add_op("infix", ["or", "xor"], $prec);
    $prec = $prec - 1;
    Perlito5::Grammar::Precedence::add_op("infix", ["*start*"], $prec);
    sub Perlito5::Grammar::Precedence::get_token_precedence {
        my $token = $_[0];
        if ($token->[0] eq "prefix") {;
            return $PrefixPrecedence->{$token->[1]}
        }
        return $Precedence->{$token->[1]}
    }
    sub Perlito5::Grammar::Precedence::precedence_parse {
        my $get_token = $_[0];
        my $last_end_token = $End_token;
        my $last_end_token_chars = $End_token_chars;
        $End_token = $_[1];
        $End_token_chars = $_[2];
        my $op_stack = [];
        my $num_stack = [];
        my $last = ["op", "*start*"];
        my $last_is_term = 0;
        my $token = $get_token->($last_is_term);
        if ($token->[0] eq "space") {;
            $token = $get_token->($last_is_term)
        }
        while ((defined($token)) && ($token->[0] ne "end")) {
            my $token_is_term = ($token->[0] eq "term") || ($token->[0] eq "postfix_or_term") || ($token->[0] eq "postfix");
            if (($token->[1] eq ",") && (($last->[1] eq "*start*") || ($last->[1] eq ","))) {;
                push(@{$num_stack}, ["term", undef])
            }
            if ($Operator->{"prefix"}->{$token->[1]} && (($last->[1] eq "*start*") || !$last_is_term)) {
                $token->[0] = "prefix";
                unshift(@{$op_stack}, $token)
            }
            elsif ($Operator->{"postfix"}->{$token->[1]} && $last_is_term) {
                my $pr = $Precedence->{$token->[1]};
                while (scalar(@{$op_stack}) && ($pr <= Perlito5::Grammar::Precedence::get_token_precedence($op_stack->[0]))) {;
                    Perlito5::Grammar::Expression::reduce_to_ast($op_stack, $num_stack)
                }
                if ($token->[0] ne "postfix_or_term") {;
                    $token->[0] = "postfix"
                }
                unshift(@{$op_stack}, $token);
                $token_is_term = 1
            }
            elsif ($token_is_term) {
                if ($last_is_term) {;
                    Perlito5::Compiler::error("Value tokens must be separated by an operator (did you forget a comma?)")
                }
                $token->[0] = "term";
                push(@{$num_stack}, $token)
            }
            elsif ($Precedence->{$token->[1]}) {
                my $pr = $Precedence->{$token->[1]};
                if ($Assoc->{"right"}->{$token->[1]}) {;
                    while (scalar(@{$op_stack}) && ($pr < Perlito5::Grammar::Precedence::get_token_precedence($op_stack->[0]))) {;
                        Perlito5::Grammar::Expression::reduce_to_ast($op_stack, $num_stack)
                    }
                }
                else {;
                    while (scalar(@{$op_stack}) && ($pr <= Perlito5::Grammar::Precedence::get_token_precedence($op_stack->[0]))) {;
                        Perlito5::Grammar::Expression::reduce_to_ast($op_stack, $num_stack)
                    }
                }
                if ($Operator->{"ternary"}->{$token->[1]}) {;
                    $token->[0] = "ternary"
                }
                else {;
                    $token->[0] = "infix"
                }
                unshift(@{$op_stack}, $token)
            }
            else {;
                Perlito5::Compiler::error("Unknown token: '", $token->[1], "'")
            }
            $last = $token;
            $last_is_term = $token_is_term;
            $token = $get_token->($last_is_term);
            if ($token->[0] eq "space") {;
                $token = $get_token->($last_is_term)
            }
        }
        if (defined($token) && ($token->[0] ne "end")) {;
            Perlito5::Compiler::error("Unexpected end token: ", $token)
        }
        while (scalar(@{$op_stack})) {;
            Perlito5::Grammar::Expression::reduce_to_ast($op_stack, $num_stack)
        }
        $End_token = $last_end_token;
        $End_token_chars = $last_end_token_chars;
        return $num_stack
    }
    1
}
{
    package main;
    package Perlito5::Grammar::Bareword;
    sub Perlito5::Grammar::Bareword::the_object {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = ((do {
            my $tmp162 = $MATCH->{"to"};
            (((do {
                my $tmp = $MATCH;
                $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
                my $res = (("\$" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1));
                $MATCH = $tmp;
                $res ? 1 : 0
            }) && (do {
                my $m2 = Perlito5::Grammar::Sigil::term_sigil($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::Sigil::term_sigil"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Sigil::term_sigil"})->[1];
                1
            }))) || ($MATCH->{"to"} = $tmp162, ((("{" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $m2 = Perlito5::Grammar::Expression::curly_parse($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::Expression::curly_parse"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (("}" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::curly_parse"});
                1
            }))) || ($MATCH->{"to"} = $tmp162, ((do {
                my $m2 = Perlito5::Grammar::Print::typeglob($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::Print::typeglob"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Print::typeglob"});
                1
            })))
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Bareword::term_bareword {
        my $str = $_[0];
        my $pos = $_[1];
        my $p = $pos;
        my $m_namespace = Perlito5::Grammar::optional_namespace_before_ident($str, $p);
        my $namespace = Perlito5::Match::flat($m_namespace);
        $p = $m_namespace->{"to"};
        my $m_name = Perlito5::Grammar::ident($str, $p);
        if (!$m_name) {
            if ($namespace) {
                $m_namespace->{"capture"} = ["term", Perlito5::AST::Var::->new("sigil", "::", "name", '', "namespace", $namespace)];
                return $m_namespace
            }
            return
        }
        my $name = Perlito5::Match::flat($m_name);
        $p = $m_name->{"to"};
        if ($str->[$p] eq ":" && $str->[$p + 1] eq ":") {
            $m_name->{"to"} = $p + 2;
            $m_name->{"capture"} = ["term", Perlito5::AST::Var::->new("sigil", "::", "name", '', "namespace", $namespace . "::" . $name)];
            return $m_name
        }
        my $full_name = $name;
        $namespace && ($full_name = $namespace . "::" . $name);
        my $m = Perlito5::Grammar::Space::ws($str, $p);
        if ($m) {;
            $p = $m->{"to"}
        }
        my $invocant;
        my $is_subroutine_name;
        my $effective_name = ($namespace || $Perlito5::PKG_NAME) . "::" . $name;
        if (exists(&{$effective_name})) {
            my $p = eval {;
                prototype($effective_name)
            };
            $Perlito5::PROTO->{$effective_name} = $p
        }
        if (exists($Perlito5::Grammar::Print::Print{$name})) {;
            $invocant = undef
        }
        elsif (exists($Perlito5::PROTO->{$effective_name}) || ((!$namespace || $namespace eq "CORE") && exists($Perlito5::CORE_PROTO->{"CORE::" . $name}))) {
            if ($name eq "__END__" || $name eq "__DATA__") {;
                return Perlito5::Grammar::Space::term_end(@_)
            }
            $is_subroutine_name = 1;
            $invocant = Perlito5::Grammar::full_ident($str, $p);
            if ($invocant) {
                my $package = Perlito5::Match::flat($invocant);
                if ($package) {
                    $invocant->{"capture"} = Perlito5::AST::Var::->new("sigil", "::", "name", '', "namespace", $package);
                    if ($str->[$invocant->{"to"}] eq ":" && $str->[($invocant->{"to"}) + 1] eq ":") {;
                        $invocant->{"to"} = ($invocant->{"to"}) + 2
                    }
                    elsif (!$Perlito5::PACKAGES->{$package}) {;
                        $invocant = undef
                    }
                }
            }
        }
        else {;
            $invocant = Perlito5::Grammar::Bareword::the_object($str, $p)
        }
        if ($invocant) {
            $p = $invocant->{"to"};
            my $arg = [];
            $m = Perlito5::Grammar::Space::ws($str, $p);
            $m && ($p = $m->{"to"});
            if ($str->[$p] eq "-" && $str->[$p + 1] eq ">") {}
            elsif ($str->[$p] eq "(") {
                my $m = Perlito5::Grammar::Expression::term_paren($str, $p);
                if ($m) {
                    $arg = $m->{"capture"}->[2];
                    $p = $m->{"to"};
                    $arg = Perlito5::Grammar::Expression::expand_list($arg)
                }
            }
            else {
                my $m = Perlito5::Grammar::Expression::list_parse($str, $p);
                if ($m->{"capture"} ne "*undef*") {
                    $arg = Perlito5::Grammar::Expression::expand_list($m->{"capture"});
                    $p = $m->{"to"}
                }
            }
            $m_name->{"capture"} = ["term", Perlito5::AST::Call::->new("method", $full_name, "invocant", Perlito5::Match::flat($invocant), "arguments", $arg)];
            $m_name->{"to"} = $p;
            return $m_name
        }
        if ($str->[$p] eq "=" && $str->[$p + 1] eq ">") {
            $m_name->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", $name, "namespace", $namespace, "arguments", [], "bareword", 1)];
            $m_name->{"to"} = $p;
            return $m_name
        }
        my $sig = undef;
        {
            my $op = ($str->[$p]) . ($str->[$p + 1]);
            if ($op eq "!=" || $op eq "!~" || $op eq "=~") {;
                $sig = ''
            }
        }
        if (exists($Perlito5::PROTO->{$effective_name})) {
            $sig = $Perlito5::PROTO->{$effective_name};
            $namespace ||= $Perlito5::PKG_NAME
        }
        elsif ((!$namespace || $namespace eq "CORE") && exists($Perlito5::CORE_PROTO->{"CORE::" . $name})) {
            $effective_name = "CORE::" . $name;
            $sig = $Perlito5::CORE_PROTO->{$effective_name};
            my $core_global_name = "CORE::GLOBAL::" . $name;
            if (!$namespace && exists($Perlito5::CORE_GLOBAL_OVERRIDABLE->{$name}) && exists(&{$core_global_name})) {
                $namespace = "CORE::GLOBAL";
                $effective_name = $core_global_name;
                if (!exists($Perlito5::PROTO->{$core_global_name})) {;
                    $Perlito5::PROTO->{$core_global_name} = prototype(&{$core_global_name})
                }
            }
            my $local_name = $Perlito5::PKG_NAME . ("::" . $name);
            if (!$namespace && exists($Perlito5::CORE_OVERRIDABLE->{$name}) && exists(&{$local_name})) {
                $namespace = ${$Perlito5::PKG_NAME};
                $effective_name = $local_name;
                if (!exists($Perlito5::PROTO->{$local_name})) {;
                    $Perlito5::PROTO->{$local_name} = prototype(&{$local_name})
                }
            }
        }
        else {
            my $m = Perlito5::Grammar::Number::val_version($str, $pos);
            if ($m) {
                $m->{"capture"} = ["term", $m->{"capture"}];
                return $m
            }
        }
        if ($str->[$p] eq "-" && $str->[$p + 1] eq ">") {
            if ($is_subroutine_name) {;
                $m_name->{"capture"} = ["term", Perlito5::AST::Apply::->new("arguments", [], "code", $name, "namespace", $namespace)]
            }
            else {;
                $m_name->{"capture"} = ["term", Perlito5::AST::Var::->new("name", '', "namespace", $full_name, "sigil", "::")]
            }
            $m_name->{"to"} = $p;
            return $m_name
        }
        if (defined($sig) && $sig eq '') {
            my $expr = $Perlito5::CONSTANT{$namespace . "::" . $name};
            if ($expr) {
                if ($str->[$p] eq "(") {
                    $p++;
                    my $m = Perlito5::Grammar::Space::ws($str, $p);
                    if ($m) {;
                        $p = $m->{"to"}
                    }
                    if ($str->[$p] ne ")") {;
                        Perlito5::Compiler::error("Too many arguments for " . $namespace . "::" . $name)
                    }
                    $p++
                }
                $m_name->{"capture"} = ["term", $expr];
                $m_name->{"to"} = $p;
                return $m_name
            }
        }
        my $has_paren = 0;
        if (defined($sig)) {
            my $arg_index = 1;
            my $optional = 0;
            my @args;
            my $sig_part = substr($sig, 0, 1);
            my $m;
            my $capture;
            if ($sig_part eq "&") {
                $m = Perlito5::Grammar::Space::ws($str, $p);
                $m && ($p = $m->{"to"});
                if ($str->[$p] ne "(") {
                    $sig = substr($sig, 1);
                    $m = Perlito5::Grammar::Bareword::prototype_is_ampersand($str, $p);
                    $m && ($capture = $m->{"capture"});
                    if (!$m) {;
                        Perlito5::Compiler::error("Type of arg " . $arg_index . " to " . $name . " must be block or sub {}")
                    }
                    $p = $m->{"to"};
                    push(@args, $capture)
                }
            }
            if (substr($sig, 0, 1) eq ";" && $str->[$p] eq "/" && $str->[$p + 1] eq "/") {
                $m_name->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", $name, "namespace", $namespace, "arguments", [], "bareword", 1)];
                $m_name->{"to"} = $p;
                return $m_name
            }
            if ($sig eq '') {
                if ($str->[$p] eq "(") {
                    $p++;
                    $has_paren = 1;
                    my $m = Perlito5::Grammar::Space::ws($str, $p);
                    if ($m) {;
                        $p = $m->{"to"}
                    }
                    if ($str->[$p] ne ")") {;
                        Perlito5::Compiler::error("syntax error near ", join('', @{$str}[$pos .. $pos + 10]))
                    }
                    $p++
                }
                if ($name eq "__FILE__") {;
                    $m_name->{"capture"} = ["term", Perlito5::AST::Buf::->new("buf", $Perlito5::FILE_NAME)]
                }
                elsif ($name eq "__LINE__") {;
                    $m_name->{"capture"} = ["term", Perlito5::AST::Int::->new("int", $Perlito5::LINE_NUMBER)]
                }
                else {;
                    $m_name->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", $name, "namespace", $namespace, "arguments", \@args, "bareword", ($has_paren == 0))]
                }
                $m_name->{"to"} = $p;
                return $m_name
            }
            if ($sig eq "_" || $sig eq "\$" || $sig eq "+" || $sig eq ";\$") {
                my $m;
                my $arg;
                if ($str->[$p] eq "(") {
                    $m = Perlito5::Grammar::Expression::term_paren($str, $p);
                    if (!$m) {;
                        return $m
                    }
                    $p = $m->{"to"};
                    $has_paren = 1;
                    $arg = $m->{"capture"}->[2];
                    $arg = Perlito5::Grammar::Expression::expand_list($arg);
                    my $v = shift(@{$arg});
                    @{$arg} && Perlito5::Compiler::error("Too many arguments for " . $name);
                    $arg = $v
                }
                else {
                    $m = Perlito5::Grammar::Expression::argument_parse($str, $p);
                    $arg = $m->{"capture"};
                    if ($arg eq "*undef*") {;
                        $arg = undef
                    }
                    elsif (ref($arg) eq "Perlito5::AST::Apply" && $arg->{"code"} eq "circumfix:<( )>") {
                        my $v = shift(@{$arg->{"arguments"}});
                        @{$arg->{"arguments"}} && Perlito5::Compiler::error("Too many arguments for " . $name);
                        $arg = $v
                    }
                }
                if (defined($arg)) {
                    push(@args, $arg);
                    $has_paren = 1
                }
                else {
                    $sig eq "\$" && Perlito5::Compiler::error("Not enough arguments for " . $name);
                    $sig eq "_" && push(@args, Perlito5::AST::Var::->new("namespace", '', "name", "_", "sigil", "\$"))
                }
                my $ast = Perlito5::AST::Apply::->new("code", $name, "namespace", $namespace, "arguments", \@args, "bareword", ($has_paren == 0));
                if ($name eq "eval" && !$namespace) {
                    $ast->{"_scope"} = Perlito5::Grammar::Scope::get_snapshot($Perlito5::CLOSURE_SCOPE);
                    $ast->{"_scalar_hints"} = ${^H};
                    $ast->{"_hash_hints"} = {%{^H}, }
                }
                $m->{"capture"} = ["term", $ast];
                return $m
            }
            if ($sig eq ";\@" || $sig eq "\@") {
                if ($str->[$p] eq "(") {
                    $m = Perlito5::Grammar::Expression::term_paren($str, $p);
                    $has_paren = 1;
                    my $arg = $m->{"capture"}->[2];
                    $arg = Perlito5::Grammar::Expression::expand_list($arg);
                    push(@args, @{$arg})
                }
                else {
                    $m = Perlito5::Grammar::Expression::list_parse($str, $p);
                    my $arg = $m->{"capture"};
                    if ($arg ne "*undef*") {
                        $arg = Perlito5::Grammar::Expression::expand_list($arg);
                        push(@args, @{$arg})
                    }
                }
                my $ast = Perlito5::AST::Apply::->new("code", $name, "namespace", $namespace, "arguments", \@args, "bareword", ($has_paren == 0));
                $m->{"capture"} = ["term", $ast];
                return $m
            }
            if ($sig eq "*") {}
        }
        if ($str->[$p] eq "(") {
            $m = Perlito5::Grammar::Expression::term_paren($str, $p);
            if (!$m) {;
                return $m
            }
            my $arg = $m->{"capture"}->[2];
            $arg = Perlito5::Grammar::Expression::expand_list($arg);
            if ($namespace eq '' || $namespace eq "CORE") {
                if ($name eq "print" || $name eq "say") {;
                    if (@{$arg} == 0) {;
                        push(@{$arg}, Perlito5::AST::Var::->new("namespace", '', "name", "_", "sigil", "\$"))
                    }
                }
                if ($name eq "split") {
                    if (@{$arg} == 0) {;
                        push(@{$arg}, Perlito5::AST::Buf::->new("buf", " "))
                    }
                    if (@{$arg} == 1) {;
                        push(@{$arg}, Perlito5::AST::Var::->new("namespace", '', "name", "_", "sigil", "\$"))
                    }
                }
            }
            $m->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", $name, "namespace", $namespace, "arguments", $arg, "proto", $sig)];
            return $m
        }
        my $m_list = Perlito5::Grammar::Expression::list_parse($str, $p);
        my $list = $m_list->{"capture"};
        if ($list ne "*undef*") {
            my $param_list = Perlito5::Grammar::Expression::expand_list($list);
            if (${^H} & $Perlito5::STRICT_SUBS) {;
                for my $i (0 .. $#{$param_list}) {
                    my $arg = $param_list->[$i];
                    if (ref($arg) eq "Perlito5::AST::Apply" && $arg->{"bareword"} && $arg->{"_not_a_subroutine"}) {
                        my $name = $arg->{"code"};
                        my $namespace = $arg->{"namespace"};
                        if ($sig && (substr($sig, $i, 1) eq "*" || substr($sig, $i, 2) eq ";*")) {}
                        else {;
                            Perlito5::Compiler::error("Bareword \"" . ($namespace ? $namespace . "::" : '') . $name . "\" not allowed while \"strict subs\" in use")
                        }
                    }
                }
            }
            $m_name->{"capture"} = ["postfix_or_term", "funcall", $namespace, $name, $param_list];
            $m_name->{"to"} = $m_list->{"to"};
            return $m_name
        }
        if ($namespace eq '' || $namespace eq "CORE") {
            if ($name eq "print" || $name eq "say") {
                $m_name->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", $name, "namespace", $namespace, "arguments", [Perlito5::AST::Var::->new("namespace", '', "name", "_", "sigil", "\$")])];
                return $m_name
            }
            if ($name eq "split" && ($namespace eq '' || $namespace eq "CORE")) {
                $m_name->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", $name, "namespace", $namespace, "arguments", [Perlito5::AST::Buf::->new("buf", " "), Perlito5::AST::Var::->new("namespace", '', "name", "_", "sigil", "\$")])];
                return $m_name
            }
        }
        if (${^H} & $Perlito5::STRICT_SUBS) {
            my $m = Perlito5::Grammar::Space::opt_ws($str, $p);
            my $p = $m->{"to"};
            if ($str->[$p] eq ":") {}
            elsif (!(exists($Perlito5::PROTO->{$effective_name}) || ((!$namespace || $namespace eq "CORE") && exists($Perlito5::CORE_PROTO->{"CORE::" . $name})))) {
                $m_name->{"capture"} = ["postfix_or_term", "funcall_no_params", Perlito5::AST::Apply::->new("code", $name, "namespace", $namespace, "arguments", [], "bareword", 1, "_not_a_subroutine", 1)];
                return $m_name
            }
        }
        $m_name->{"capture"} = ["postfix_or_term", "funcall_no_params", Perlito5::AST::Apply::->new("code", $name, "namespace", $namespace, "arguments", [], "bareword", 1)];
        return $m_name
    }
    sub Perlito5::Grammar::Bareword::prototype_is_ampersand {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = ((do {
            my $tmp223 = $MATCH->{"to"};
            (((("s" eq $str->[($MATCH->{"to"}) + 0]) && ("u" eq $str->[($MATCH->{"to"}) + 1]) && ("b" eq $str->[($MATCH->{"to"}) + 2]) && ($MATCH->{"to"} += 3)) && (do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $m2 = Perlito5::Grammar::Block::anon_sub_def($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::Block::anon_sub_def"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Block::anon_sub_def"});
                1
            }))) || ($MATCH->{"to"} = $tmp223, ((do {
                my $m2 = Perlito5::Grammar::block($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::block"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                $MATCH->{"capture"} = Perlito5::AST::Sub::->new("attributes", [], "block", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::block"}), "name", undef, "namespace", undef, "sig", undef);
                1
            }))) || ($MATCH->{"to"} = $tmp223, ((do {
                my $tmp = $MATCH;
                $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
                my $res = ((("\\" eq $str->[($MATCH->{"to"}) + 0]) && ("\\" eq $str->[($MATCH->{"to"}) + 1]) && ($MATCH->{"to"} += 2)) && (do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (("&" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)));
                $MATCH = $tmp;
                $res ? 1 : 0
            }) && (do {
                my $m2 = Perlito5::Grammar::Expression::argument_parse($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::Expression::argument_parse"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::argument_parse"});
                1
            })))
        }));
        $tmp ? $MATCH : undef
    }
    1
}
{
    package main;
    package Perlito5::Grammar::Attribute;
    sub Perlito5::Grammar::Attribute::opt_attribute {
        my $str = $_[0];
        my $pos = $_[1];
        my @attributes;
        my $ws = Perlito5::Grammar::Space::opt_ws($str, $pos);
        if ($str->[$ws->{"to"}] ne ":") {;
            return {"to" => $pos, "capture" => [], }
        }
        $ws = Perlito5::Grammar::Space::opt_ws($str, ($ws->{"to"}) + 1);
        my $p = $ws->{"to"};
        my $m = Perlito5::Grammar::ident($str, $p);
        !$m && Perlito5::Compiler::error("syntax error");
        my $to;
        while (1) {
            my $attr = [Perlito5::Match::flat($m), undef];
            $to = $m->{"to"};
            my $delimiter = $str->[$to];
            if ($delimiter eq "(") {
                my $params = Perlito5::Grammar::String::string_interpolation_parse($str, ($m->{"to"}) + 1, "(", ")", 0);
                !$params && Perlito5::Compiler::error("syntax error");
                $attr->[1] = Perlito5::Match::flat($params)->{"buf"};
                $to = $params->{"to"}
            }
            push(@attributes, $attr);
            $ws = Perlito5::Grammar::Space::opt_ws($str, $to);
            if ($str->[$ws->{"to"}] eq ":") {;
                $ws = Perlito5::Grammar::Space::opt_ws($str, ($ws->{"to"}) + 1)
            }
            $p = $ws->{"to"};
            $m = Perlito5::Grammar::ident($str, $p);
            !$m && return {"to" => $to, "capture" => \@attributes, }
        }
    }
    1
}
{
    package main;
    package Perlito5::Clone;
    sub Perlito5::Clone::clone {;
        Perlito5::Clone::_clone($_[0])
    }
    sub Perlito5::Clone::_clone {
        (my $obj) = @_;
        !defined($obj) && return undef;
        my $ref = ref($obj);
        if (!$ref) {;
            return $obj
        }
        if ($ref eq "ARRAY") {
            my @out;
            for my $i (0 .. $#{$obj}) {;
                push(@out, Perlito5::Clone::_clone($obj->[$i]))
            }
            return \@out
        }
        elsif ($ref eq "HASH") {
            my @out;
            for my $i (keys(%{$obj})) {;
                push(@out, $i, Perlito5::Clone::_clone($obj->{$i}))
            }
            return {@out, }
        }
        elsif ($ref eq "SCALAR" || $ref eq "REF") {;
            return \Perlito5::Clone::_clone(${$obj})
        }
        elsif ($ref eq "CODE") {;
            return $ref
        }
        elsif ($ref eq "GLOB") {;
            return $ref
        }
        my @out;
        my $res;
        local ${"\@"};
        $res = eval {
            for my $i (0 .. $#{$obj}) {;
                push(@out, Perlito5::Clone::_clone($obj->[$i]))
            }
            bless(\@out, $ref)
        };
        $res && return $res;
        for my $i (keys(%{$obj})) {;
            push(@out, $i, Perlito5::Clone::_clone($obj->{$i}))
        }
        return bless({@out, }, $ref)
    }
    1
}
{
    package main;
    package Perlito5::Dumper;
    sub Perlito5::Dumper::ast_dumper {
        my $seen = {};
        my $level = '';
        my $pos = "[TODO - recursive structure in AST is not supported]";
        return Perlito5::Dumper::_dumper($_[0], $level, $seen, $pos)
    }
    sub Perlito5::Dumper::Dumper {
        my $seen = {};
        my $level = "    ";
        my @out;
        for my $i (0 .. $#_) {
            my $pos = "\$VAR" . ($i + 1);
            push(@out, $pos . " = " . Perlito5::Dumper::_dumper($_[$i], $level, $seen, $pos) . ";
")
        }
        return join('', @out)
    }
    sub Perlito5::Dumper::_dumper {
        (my $obj, my $tab, my $seen, my $pos) = @_;
        !defined($obj) && return "undef";
        my $ref = ref($obj);
        if (!$ref) {
            if (ref(\$obj) eq "GLOB") {;
                return '' . $obj
            }
            return Perlito5::Dumper::escape_string($obj)
        }
        my $as_string = '' . $obj;
        $seen->{$as_string} && return $seen->{$as_string};
        $seen->{$as_string} = $pos;
        my $tab1 = $tab . "    ";
        if ($ref eq "ARRAY") {
            @{$obj} || return "[]";
            my @out;
            for my $i (0 .. $#{$obj}) {
                my $here = $pos . "->[" . $i . "]";
                push(@out, $tab1, Perlito5::Dumper::_dumper($obj->[$i], $tab1, $seen, $here), ",
")
            }
            return join('', "[
", @out, $tab, "]")
        }
        elsif ($ref eq "HASH") {
            keys(%{$obj}) || return "{}";
            my @out;
            for my $i (sort {;
                $a cmp $b
            } keys(%{$obj})) {
                my $here = $pos . "->{" . $i . "}";
                push(@out, $tab1, "'" . $i . "' => ", Perlito5::Dumper::_dumper($obj->{$i}, $tab1, $seen, $here), ",
")
            }
            return join('', "{
", @out, $tab, "}")
        }
        elsif ($ref eq "SCALAR" || $ref eq "REF") {;
            return "\\" . Perlito5::Dumper::_dumper(${$obj}, $tab1, $seen, $pos)
        }
        elsif ($ref eq "CODE") {;
            return "sub { \"DUMMY\" }"
        }
        elsif ($ref eq "GLOB") {;
            return "\\" . *{$obj}
        }
        my @out;
        my $res;
        local ${"\@"};
        $res = eval {
            for my $i (0 .. $#{$obj}) {
                my $here = $pos . "->[" . $i . "]";
                push(@out, $tab1, Perlito5::Dumper::_dumper($obj->[$i], $tab1, $seen, $here), ",
")
            }
            join('', "bless([
", @out, $tab, "], '" . $ref . "')")
        };
        $res && return $res;
        $res = eval {;
            "bless(\\" . Perlito5::Dumper::_dumper(${$obj}, $tab1, $seen, $pos) . (", '" . $ref . "')")
        };
        $res && return $res;
        for my $i (sort {;
            $a cmp $b
        } keys(%{$obj})) {
            my $here = $pos . "->{" . $i . "}";
            push(@out, $tab1, "'" . $i . "' => ", Perlito5::Dumper::_dumper($obj->{$i}, $tab1, $seen, $here), ",
")
        }
        return join('', "bless({
", @out, $tab, "}, '" . $ref . "')")
    }
    our %safe_char = (" ", 1, "!", 1, "\"", 1, "'", 1, "#", 1, "\$", 1, "%", 1, "&", 1, "(", 1, ")", 1, "*", 1, "+", 1, ",", 1, "-", 1, ".", 1, "/", 1, ":", 1, ";", 1, "<", 1, "=", 1, ">", 1, "?", 1, "\@", 1, "[", 1, "]", 1, "^", 1, "_", 1, "`", 1, "{", 1, "|", 1, "}", 1, "~", 1, "
", 1, map {;
        $_ => 1
    } ("A" .. "Z", "a" .. "z", 0 .. 9));
    sub Perlito5::Dumper::escape_string {
        my $s = shift;
        my $tmp = '';
        $s eq '' && return "''";
        (0 + $s) eq $s && $s =~ m/[0-9]/ && return 0 + $s;
        my @out = "\"";
        for my $c (split('', $s)) {
            if ($c eq "\\" || $c eq "\$" || $c eq "\@" || $c eq "\"") {;
                push(@out, "\\" . $c)
            }
            elsif (exists($safe_char{$c})) {;
                push(@out, $c)
            }
            else {;
                push(@out, "\\x{" . sprintf("%x", ord($c)) . "}")
            }
        }
        push(@out, "\"");
        return join('', @out)
    }
    sub Perlito5::Dumper::_identity {;
        '' . $_[0] eq '' . $_[1]
    }
    1
}
{
    package main;
    package Perlito5::TreeGrammar;
    my %dispatch = ("Ref", sub {;
        Perlito5::TreeGrammar::Ref(@_)
    }, "Lookup", sub {;
        Perlito5::TreeGrammar::Lookup(@_)
    }, "Index", sub {;
        Perlito5::TreeGrammar::Index(@_)
    }, "Value", sub {;
        Perlito5::TreeGrammar::Value(@_)
    }, "And", sub {;
        Perlito5::TreeGrammar::And(@_)
    }, "Or", sub {;
        Perlito5::TreeGrammar::Or(@_)
    }, "Not", sub {;
        Perlito5::TreeGrammar::Not(@_)
    }, "Action", sub {;
        Perlito5::TreeGrammar::Action(@_)
    }, "Progn", sub {;
        Perlito5::TreeGrammar::Progn(@_)
    }, "Star", sub {;
        Perlito5::TreeGrammar::Star(@_)
    });
    sub Perlito5::TreeGrammar::render {
        (my $rule, my $node) = @_;
        return $dispatch{$rule->[0]}->($rule, $node)
    }
    sub Perlito5::TreeGrammar::scan {
        (my $rule, my $node) = @_;
        $rule && Perlito5::TreeGrammar::render($rule, $node);
        if (ref($node) eq "ARRAY") {;
            Perlito5::TreeGrammar::scan($rule, $_)
                for @{$node}
        }
        elsif (ref($node)) {;
            Perlito5::TreeGrammar::scan($rule, $_)
                for values(%{$node})
        }
        return
    }
    sub Perlito5::TreeGrammar::Action {
        (my $rule, my $node) = @_;
        $rule->[1]->($node);
        return 1
    }
    sub Perlito5::TreeGrammar::Not {
        (my $rule, my $node) = @_;
        my $result;
        Perlito5::TreeGrammar::render($rule->[1], $node) && return;
        return 1
    }
    sub Perlito5::TreeGrammar::Star {
        (my $rule, my $node) = @_;
        my $result;
        while (1) {;
            Perlito5::TreeGrammar::render($rule->[1], $node) || return
        }
    }
    sub Perlito5::TreeGrammar::Progn {
        (my $rule, my $node) = @_;
        my $result;
        for $_ (@{$rule}[1 .. $#{$rule}]) {;
            $result = Perlito5::TreeGrammar::render($_, $node)
        }
        return $result
    }
    sub Perlito5::TreeGrammar::And {
        (my $rule, my $node) = @_;
        my $result;
        for $_ (@{$rule}[1 .. $#{$rule}]) {;
            $result = Perlito5::TreeGrammar::render($_, $node) or return
        }
        return $result
    }
    sub Perlito5::TreeGrammar::Or {
        (my $rule, my $node) = @_;
        my $result;
        for $_ (@{$rule}[1 .. $#{$rule}]) {;
            $result = Perlito5::TreeGrammar::render($_, $node) and return $result
        }
        return
    }
    sub Perlito5::TreeGrammar::Ref {
        (my $rule, my $node) = @_;
        ref($node) ne $rule->[1] && return;
        !$rule->[2] && return 1;
        return Perlito5::TreeGrammar::render($rule->[2], $node)
    }
    sub Perlito5::TreeGrammar::Lookup {
        (my $rule, my $node) = @_;
        (!ref($node) || ref($node) eq "ARRAY" || !exists($node->{$rule->[1]})) && return;
        !$rule->[2] && return 1;
        return Perlito5::TreeGrammar::render($rule->[2], $node->{$rule->[1]})
    }
    sub Perlito5::TreeGrammar::Index {
        (my $rule, my $node) = @_;
        (!ref($node) || ref($node) ne "ARRAY" || !exists($node->[$rule->[1]])) && return;
        !$rule->[2] && return 1;
        return Perlito5::TreeGrammar::render($rule->[2], $node->[$rule->[1]])
    }
    sub Perlito5::TreeGrammar::Value {
        (my $rule, my $node) = @_;
        (ref($node) || $node ne $rule->[1]) && return;
        !$rule->[2] && return 1;
        return Perlito5::TreeGrammar::render($rule->[2], $node)
    }
    1
}
{
    package main;
    package Perlito5::Macro;
    sub Perlito5::Macro::rewrite_goto {
        (my $stmts) = @_;
        !@Perlito5::GOTO && return $stmts;
        @Perlito5::GOTO = grep {;
            $_->{"arguments"}->[0]->{"bareword"}
        } @Perlito5::GOTO;
        !@Perlito5::GOTO && return $stmts;
        my $change = 0;
        my $outer_label = Perlito5::get_label();
        my @unprocessed;
        GOTO:
        for my $goto (@Perlito5::GOTO) {
            my $label = $goto->{"arguments"}->[0]->{"code"};
            $label || next(GOTO);
            my @label;
            for my $id (reverse(0 .. $#{$stmts})) {
                my $ast = $stmts->[$id];
                if ($ast->{"label"} && $ast->{"label"} eq $label) {
                    my @stmt_list = @{$stmts}[$id .. $#{$stmts}];
                    if ($id == 0) {
                        $goto->{"code"} = "redo";
                        $goto->{"arguments"} = [Perlito5::AST::Apply::->new("code", $outer_label, "bareword", 1)];
                        $change = 1;
                        next(GOTO)
                    }
                    $goto->{"code"} = "do";
                    $goto->{"arguments"} = [Perlito5::AST::Block::->new("stmts", [@{Perlito5::Clone::clone(\@stmt_list)}, Perlito5::AST::Apply::->new("code", "last", "arguments", [Perlito5::AST::Apply::->new("code", $outer_label, "bareword", 1)])])];
                    $change = 1;
                    next(GOTO)
                }
            }
            push(@unprocessed, $goto)
        }
        @Perlito::GOTO = @unprocessed;
        if ($change) {;
            return [Perlito5::AST::Block::->new("label", $outer_label, "stmts", [@{$stmts}])]
        }
        return $stmts
    }
    {
        package Perlito5::AST::Apply;
        my %op = ("infix:<+=>", "infix:<+>", "infix:<-=>", "infix:<->", "infix:<*=>", "infix:<*>", "infix:</=>", "infix:</>", "infix:<%=>", "infix:<%>", "infix:<||=>", "infix:<||>", "infix:<&&=>", "infix:<&&>", "infix:<|=>", "infix:<|>", "infix:<&=>", "infix:<&>", "infix:<^=>", "infix:<^>", "infix:<//=>", "infix:<//>", "infix:<**=>", "infix:<**>", "infix:<.=>", "list:<.>", "infix:<x=>", "infix:<x>", "infix:<<<=>", "infix:<<<>", "infix:<>>=>", "infix:<>>>", "infix:<&.=>", "infix:<&.>", "infix:<|.=>", "infix:<|.>", "infix:<^.=>", "infix:<^.>");
        sub Perlito5::AST::Apply::op_assign {
            my $self = $_[0];
            my $code = $self->{"code"};
            ref($code) && return 0;
            if (exists($op{$code})) {;
                return Perlito5::AST::Apply::->new("code", "infix:<=>", "arguments", [$self->{"arguments"}->[0], Perlito5::AST::Apply::->new("code", $op{$code}, "arguments", $self->{"arguments"}, ($self->{"_integer"} ? ("_integer", 1) : ()))])
            }
            return 0
        }
        my %op_auto = ("prefix:<++>", 1, "prefix:<-->", 1, "postfix:<++>", 1, "postfix:<-->", 1);
        sub Perlito5::AST::Apply::op_auto {
            my $self = $_[0];
            my $code = $self->{"code"};
            ref($code) && return 0;
            if (exists($op_auto{$code})) {
                my $paren = $self->{"arguments"}->[0];
                if ($paren->{"code"} eq "circumfix:<( )>") {
                    my $arg = $paren->{"arguments"}->[-1];
                    if ($arg->{"code"} eq "infix:<=>") {
                        my $var = $arg->{"arguments"}->[0];
                        return Perlito5::AST::Apply::->new("code", "do", "arguments", [Perlito5::AST::Block::->new("stmts", [$paren, Perlito5::AST::Apply::->new("code", $code, "arguments", [$var])])])
                    }
                }
            }
            return 0
        }
    }
    {
        package Perlito5::AST::Sub;
        sub Perlito5::AST::Sub::maybe_rewrite_statevars {
            (my $self) = @_;
            my $block = $self->{"block"} || return 0;
            my @init_flags;
            my @vars;
            my @base_rules = (["Lookup", "block"], ["Lookup", "stmts"]);
            for my $idx (0 .. $#{$block->{"stmts"}}) {
                my $stmt = $block->{"stmts"}->[$idx];
                (my $node, my @rules) = Perlito5::AST::Sub::find_state_expr($stmt, @base_rules, ["Index", $idx]);
                if (defined($node)) {
                    (my $transformed, my $var, my $flagvar) = Perlito5::AST::Sub::rewrite_state_expr($node);
                    push(@vars, $var, $flagvar);
                    my $last_rule = pop(@rules);
                    push(@rules, ["Action", sub {
                        (my $parent) = @_;
                        if ($last_rule->[0] eq "Lookup") {;
                            $parent->{$last_rule->[1]} = $transformed
                        }
                        else {;
                            $parent->[$last_rule->[1]] = $transformed
                        }
                    }]);
                    my $rule = Perlito5::AST::Sub::nest(\@rules);
                    Perlito5::TreeGrammar::render($rule, $self)
                }
            }
            if (scalar(@vars)) {;
                return Perlito5::AST::Apply::->new("code", "do", "namespace", $block->{"namespace"}, "arguments", [Perlito5::AST::Block::->new("sig", undef, "stmts", [Perlito5::AST::Sub::myvar_declaration_stmt(@vars), $self])])
            }
            return 0
        }
        sub Perlito5::AST::Sub::myvar_declaration_stmt {
            (grep {;
                ($_->{"decl"} // "my") ne "my"
            } @_) && die("Can only handle `my` variables");
            return map {;
                Perlito5::AST::Decl::->new("decl", "my", "var", $_)
            } @_
        }
        sub Perlito5::AST::Sub::rewrite_state_expr {
            (my $target) = @_;
            (my $decl, my $rhs);
            if (ref($target) eq "Perlito5::AST::Apply") {
                $decl = $target->{"arguments"}->[0];
                $rhs = $target->{"arguments"}->[1]
            }
            elsif (ref($target) eq "Perlito5::AST::Decl") {;
                $decl = $target
            }
            else {;
                die("Invalid node type for state variable transformation: " . (ref($target)))
            }
            my $state_var = $decl->{"var"};
            my $var = Perlito5::AST::Var::->new("namespace", $state_var->{"namespace"}, "sigil", $state_var->{"sigil"}, "name", $state_var->{"name"}, "_id", $state_var->{"_id"}, "_decl", "my");
            my $label = Perlito5::get_label();
            my $flagvar = Perlito5::AST::Var::->new("name", ($var->{"name"}) . "_inited_" . $label, "sigil", "\$", "namespace", '', "_id", $Perlito5::ID++, "_decl", "my");
            my $init_block = Perlito5::AST::Apply::->new("code", "do", "namespace", $decl->{"namespace"}, "arguments", [Perlito5::AST::Block::->new("sig", undef, "stmts", [Perlito5::AST::Apply::->new("code", "infix:<=>", "namespace", $decl->{"namespace"}, "arguments", [$flagvar, Perlito5::AST::Int::->new("int", 1)]), ((ref($target) eq "Perlito5::AST::Apply") ? Perlito5::AST::Apply::->new("code", "infix:<=>", "namespace", $decl->{"namespace"}, "arguments", [$var, $rhs]) : $var)])]);
            my $transformed = Perlito5::AST::Apply::->new("code", "ternary:<? :>", "namespace", $decl->{"namespace"}, "arguments", [$flagvar, $var, $init_block]);
            return ($transformed, $var, $flagvar)
        }
        sub Perlito5::AST::Sub::nest {
            (my $xs) = @_;
            if (scalar(@{$xs}) == 0) {;
                return
            }
            return [Perlito5::AST::Sub::flatten($xs->[0]), Perlito5::AST::Sub::nest([@{$xs}[1 .. $#{$xs}]])]
        }
        sub Perlito5::AST::Sub::flatten {
            (my $arg) = @_;
            if (ref($arg) eq "ARRAY") {;
                return (@{$arg})
            }
            return $arg
        }
        sub Perlito5::AST::Sub::find_state_expr {
            (my $node, my @rules) = @_;
            if (Perlito5::AST::Sub::is_node_state_decl($node) || Perlito5::AST::Sub::is_node_state_assignment($node)) {;
                return ($node, @rules)
            }
            for my $branch ("stmts", "arguments") {;
                if (exists($node->{$branch}) && ref($node->{$branch}) eq "ARRAY") {;
                    for $_ (0 .. $#{$node->{$branch}}) {
                        (my $retnode, my @retrules) = Perlito5::AST::Sub::find_state_expr($node->{$branch}->[$_], @rules, ["Lookup", $branch], ["Index", $_]);
                        if ($retnode) {;
                            return ($retnode, @retrules)
                        }
                    }
                }
            }
            return undef
        }
        sub Perlito5::AST::Sub::is_node_state_assignment {
            (my $node) = @_;
            (ref($node) eq "Perlito5::AST::Apply" && $node->{"code"} eq "infix:<=>" && Perlito5::AST::Sub::is_node_state_decl($node->{"arguments"}->[0]))
        }
        sub Perlito5::AST::Sub::is_node_state_decl {
            (my $node) = @_;
            (ref($node) eq "Perlito5::AST::Decl" && $node->{"decl"} eq "state")
        }
    }
    sub Perlito5::Macro::while_file {
        my $self = $_[0];
        ref($self) ne "Perlito5::AST::While" && return 0;
        my $cond = $self->{"cond"};
        if ((ref($cond) eq "Perlito5::AST::Apply") && ($cond->{"code"} eq "readline")) {
            $self->{"cond"} = bless({"arguments" => [bless({"arguments" => [Perlito5::AST::Var::SCALAR_ARG(), $cond], "code" => "infix:<=>", "namespace" => '', }, "Perlito5::AST::Apply")], "bareword" => '', "code" => "defined", "namespace" => '', }, "Perlito5::AST::Apply");
            return $self
        }
        return 0
    }
    sub Perlito5::Macro::insert_return_in_block {
        (my $self) = @_;
        if (@{$self->{"stmts"}} == 0) {;
            push(@{$self->{"stmts"}}, Perlito5::AST::Apply::->new("arguments", [], "code", "return", "namespace", '', "_return_from_block", 1))
        }
        else {
            my $last_statement = pop(@{$self->{"stmts"}});
            push(@{$self->{"stmts"}}, Perlito5::Macro::insert_return($last_statement))
        }
        return $self
    }
    sub Perlito5::Macro::insert_return_in_if {
        my $self = $_[0];
        $self->{"body"} = Perlito5::Macro::insert_return_in_block($self->{"body"} || Perlito5::AST::Block::->new("stmts", []));
        $self->{"otherwise"} = Perlito5::Macro::insert_return_in_block($self->{"otherwise"} || Perlito5::AST::Block::->new("stmts", []));
        return $self
    }
    sub Perlito5::Macro::insert_return {
        my $self = $_[0];
        if ((ref($self) eq "Perlito5::AST::If")) {;
            return Perlito5::Macro::insert_return_in_if($self)
        }
        if ((ref($self) eq "Perlito5::AST::Block")) {;
            return Perlito5::Macro::insert_return_in_block($self)
        }
        if ((ref($self) eq "Perlito5::AST::For")) {;
            return ($self, Perlito5::AST::Apply::->new("arguments", [Perlito5::AST::Buf::->new("buf", '')], "code", "return", "namespace", '', "_return_from_block", 1))
        }
        if ((ref($self) eq "Perlito5::AST::While")) {
            if ($self->{"cond"}->isa("Perlito5::AST::Int") && $self->{"cond"}->{"int"}) {;
                return $self
            }
            else {;
                return ($self, Perlito5::AST::Apply::->new("arguments", [Perlito5::AST::Int::->new("int", 0)], "code", "return", "namespace", '', "_return_from_block", 1))
            }
        }
        if ((ref($self) eq "Perlito5::AST::Sub")) {
            if (!$self->{"name"}) {;
                return Perlito5::AST::Apply::->new("arguments", [$self], "code", "return", "namespace", '', "_return_from_block", 1)
            }
            else {;
                return ($self, Perlito5::AST::Apply::->new("arguments", [Perlito5::AST::Int::->new("int", 0)], "code", "return", "namespace", '', "_return_from_block", 1))
            }
        }
        if ((ref($self) eq "Perlito5::AST::Int") || (ref($self) eq "Perlito5::AST::Num") || (ref($self) eq "Perlito5::AST::Buf") || (ref($self) eq "Perlito5::AST::Index") || (ref($self) eq "Perlito5::AST::Lookup") || (ref($self) eq "Perlito5::AST::Call") || (ref($self) eq "Perlito5::AST::Var") || (ref($self) eq "Perlito5::AST::Decl")) {;
            return Perlito5::AST::Apply::->new("arguments", [$self], "code", "return", "namespace", '', "_return_from_block", 1)
        }
        if ((ref($self) eq "Perlito5::AST::Apply")) {
            if ($self->code() eq "return") {;
                return $self
            }
            return Perlito5::AST::Apply::->new("arguments", [$self], "code", "return", "namespace", '', "_return_from_block", 1)
        }
        return $self
    }
    sub Perlito5::Macro::split_code_too_large {
        my @stmts = @_;
        while (@stmts > 20) {
            my @do = splice(@stmts, -15, 15);
            push(@stmts, Perlito5::AST::Apply::->new("arguments", [Perlito5::AST::Block::->new("stmts", \@do)], "code", "do"))
        }
        return @stmts
    }
    sub Perlito5::Macro::preprocess_regex {
        my $regex = shift;
        if ((ref($regex) eq "Perlito5::AST::Apply") && $regex->{"code"} eq "circumfix:<( )>") {
            ($regex) = @{$regex->{"arguments"}};
            return Perlito5::Macro::preprocess_regex($regex)
        }
        if ((ref($regex) eq "Perlito5::AST::Buf") || (ref($regex) eq "Perlito5::AST::Var") || ((ref($regex) eq "Perlito5::AST::Apply") && $regex->{"code"} eq "list:<.>")) {;
            $regex = Perlito5::AST::Apply::->new("code", "p5:m", "arguments", [$regex, Perlito5::AST::Buf::->new("buf", '')])
        }
        return $regex
    }
    1
}
{
    package main;
    package Perlito5::Grammar::Statement;
    my @Statement_chars;
    my %Statement;
    sub Perlito5::Grammar::Statement::add_statement {
        my $name = shift;
        my $param = shift;
        $Statement{$name} = $param;
        unshift(@Statement_chars, scalar(@Statement_chars) + 1)
            while @Statement_chars < length($name)
    }
    sub Perlito5::Grammar::Statement::stmt_yadayada {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((("." eq $str->[($MATCH->{"to"}) + 0]) && ("." eq $str->[($MATCH->{"to"}) + 1]) && ("." eq $str->[($MATCH->{"to"}) + 2]) && ($MATCH->{"to"} += 3)) && (do {
            $MATCH->{"capture"} = Perlito5::AST::Apply::->new("code", "die", "namespace", '', "arguments", [Perlito5::AST::Buf::->new("buf", "Unimplemented")]);
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Statement::stmt_format {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((("f" eq $str->[($MATCH->{"to"}) + 0]) && ("o" eq $str->[($MATCH->{"to"}) + 1]) && ("r" eq $str->[($MATCH->{"to"}) + 2]) && ("m" eq $str->[($MATCH->{"to"}) + 3]) && ("a" eq $str->[($MATCH->{"to"}) + 4]) && ("t" eq $str->[($MATCH->{"to"}) + 5]) && ($MATCH->{"to"} += 6)) && (do {
            my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $tmp389 = $MATCH->{"to"};
            ((do {
                my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::full_ident"} = $m2;
                    1
                }
                else {;
                    0
                }
            })) || ($MATCH->{"to"} = $tmp389, (do {
                $MATCH->{"Perlito5::Grammar::full_ident"} = "STDOUT";
                1
            }))
        }) && (do {
            my $placeholder = Perlito5::AST::Apply::->new("code", "list:<.>", "namespace", '', "arguments", [Perlito5::AST::Apply::->new("code", "list:<.>", "namespace", '', "arguments", [])]);
            push(@Perlito5::Grammar::String::Here_doc, ["single_quote", $placeholder->{"arguments"}->[0]->{"arguments"}, "."]);
            $MATCH->{"capture"} = Perlito5::AST::Apply::->new("code", "p5:format", "namespace", '', "arguments", [Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::full_ident"}), $placeholder]);
            1
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (("=" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Statement::stmt_package {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((("p" eq $str->[($MATCH->{"to"}) + 0]) && ("a" eq $str->[($MATCH->{"to"}) + 1]) && ("c" eq $str->[($MATCH->{"to"}) + 2]) && ("k" eq $str->[($MATCH->{"to"}) + 3]) && ("a" eq $str->[($MATCH->{"to"}) + 4]) && ("g" eq $str->[($MATCH->{"to"}) + 5]) && ("e" eq $str->[($MATCH->{"to"}) + 6]) && ($MATCH->{"to"} += 7)) && (do {
            my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::full_ident"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $tmp400 = $MATCH->{"to"};
            (((do {
                my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $m2 = Perlito5::Grammar::Use::version_string($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::Use::version_string"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $version = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Use::version_string"});
                $MATCH->{"_version"} = $version;
                1
            }) && (do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }))) || ($MATCH->{"to"} = $tmp400, (do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }))
        }) && (do {
            my $tmp401 = $MATCH->{"to"};
            (((do {
                my $name = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::full_ident"});
                $MATCH->{"_package"} = $Perlito5::PKG_NAME;
                $Perlito5::PACKAGES->{$name} = 1;
                $Perlito5::PKG_NAME = $name;
                1
            }) && (do {
                my $m2 = Perlito5::Grammar::block($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::block"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $namespace = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::full_ident"});
                my @statements = @{$MATCH->{"Perlito5::Grammar::block"}->{"capture"}->{"stmts"}};
                if (@statements == 1) {
                    my $stmt = $statements[0];
                    if ($stmt && ref($stmt) eq "Perlito5::AST::Apply" && ($stmt->{"code"} eq "infix:<=>>" || $stmt->{"code"} eq "list:<,>")) {;
                        push(@Perlito::ANNOTATION, [$namespace, Perlito5::AST::Apply::->new("arguments", [$stmt], "code", "circumfix:<{ }>")])
                    }
                }
                if ($MATCH->{"_version"}) {;
                    unshift(@statements, Perlito5::AST::Apply::->new("arguments", [Perlito5::AST::Var::->new("name", "VERSION", "namespace", $namespace, "sigil", "\$"), $MATCH->{"_version"}], "code", "infix:<=>"))
                }
                $MATCH->{"capture"} = Perlito5::AST::Block::->new("stmts", [Perlito5::AST::Apply::->new("code", "package", "arguments", [], "namespace", $namespace), @statements]);
                $Perlito5::PKG_NAME = $MATCH->{"_package"};
                1
            }))) || ($MATCH->{"to"} = $tmp401, (do {
                my $name = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::full_ident"});
                $Perlito5::PACKAGES->{$name} = 1;
                $Perlito5::PKG_NAME = $name;
                $MATCH->{"capture"} = Perlito5::AST::Apply::->new("code", "package", "arguments", [], "namespace", $name);
                1
            }))
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Statement::exp_stmt {
        my $str = $_[0];
        my $pos = $_[1];
        my $tok = join('', @{$str}[$pos .. $pos + 15]);
        for my $len (@Statement_chars) {
            my $term = substr($tok, 0, $len);
            if (exists($Statement{$term})) {
                my $m = $Statement{$term}->($_[0], $pos);
                $m && return $m
            }
        }
        return 0
    }
    my @Modifier_chars = (7, 6, 5, 4, 3, 2);
    my %Modifier = ("if", 1, "unless", 1, "when", 1, "for", 1, "foreach", 1, "while", 1, "until", 1, "given", 1);
    sub Perlito5::Grammar::Statement::statement_modifier {
        my $str = $_[0];
        my $pos = $_[1];
        my $tok = join('', @{$str}[$pos .. $pos + 15]);
        my $expression = $_[2];
        for my $len (@Modifier_chars) {
            my $term = substr($tok, 0, $len);
            if (exists($Modifier{$term})) {
                my $m = Perlito5::Grammar::Statement::modifier($_[0], $pos + $len, $term, $expression);
                $m && return $m
            }
        }
        return 0
    }
    sub Perlito5::Grammar::Statement::modifier {
        my $str = $_[0];
        my $pos = $_[1];
        my $modifier = $_[2];
        my $expression = $_[3];
        my $modifier_exp = Perlito5::Grammar::Expression::exp_parse($str, $pos);
        if (!$modifier_exp) {;
            Perlito5::Compiler::error("Expected expression after '", Perlito5::Match::flat($modifier), "'")
        }
        if ($modifier eq "if") {;
            return {"str" => $str, "from" => $pos, "to" => $modifier_exp->{"to"}, "capture" => Perlito5::AST::Apply::->new("arguments", [Perlito5::Match::flat($modifier_exp), $expression], "code", "infix:<&&>", "namespace", ''), }
        }
        if ($modifier eq "unless") {;
            return {"str" => $str, "from" => $pos, "to" => $modifier_exp->{"to"}, "capture" => Perlito5::AST::Apply::->new("arguments", [Perlito5::Match::flat($modifier_exp), $expression], "code", "infix:<||>", "namespace", ''), }
        }
        if ($modifier eq "when") {;
            return {"str" => $str, "from" => $pos, "to" => $modifier_exp->{"to"}, "capture" => Perlito5::AST::When::->new("cond", Perlito5::Match::flat($modifier_exp), "body", $expression), }
        }
        if ($modifier eq "while") {
            my $stmt = Perlito5::AST::While::->new("cond", Perlito5::Match::flat($modifier_exp), "body", $expression);
            my $out = Perlito5::Macro::while_file($stmt);
            $out && ($stmt = $out);
            return {"str" => $str, "from" => $pos, "to" => $modifier_exp->{"to"}, "capture" => $stmt, }
        }
        if ($modifier eq "until") {
            my $stmt = Perlito5::AST::While::->new("cond", Perlito5::AST::Apply::->new("arguments", [Perlito5::Match::flat($modifier_exp)], "code", "prefix:<!>", "namespace", ''), "body", $expression);
            return {"str" => $str, "from" => $pos, "to" => $modifier_exp->{"to"}, "capture" => $stmt, }
        }
        if ($modifier eq "for" || $modifier eq "foreach") {;
            return {"str" => $str, "from" => $pos, "to" => $modifier_exp->{"to"}, "capture" => Perlito5::AST::For::->new("cond", Perlito5::Match::flat($modifier_exp), "body", $expression, "topic", Perlito5::AST::Var::SCALAR_ARG()), }
        }
        Perlito5::Compiler::error("Unexpected statement modifier '" . $modifier . "'")
    }
    sub Perlito5::Grammar::Statement::statement_parse {
        my $m = Perlito5::Grammar::Statement::statement_parse_inner(@_);
        !@Perlito5::SCOPE_STMT && return $m;
        Perlito5::Grammar::Scope::check_variable_declarations();
        return $m
    }
    sub Perlito5::Grammar::Statement::statement_parse_inner {
        my $str = $_[0];
        my $pos = $_[1];
        my $res = Perlito5::Grammar::Statement::exp_stmt($str, $pos);
        if ($res) {
            if (ref($res->{"capture"}) eq "Perlito5::AST::Apply" && $res->{"capture"}->{"code"} eq "circumfix:<{ }>") {}
            else {;
                return $res
            }
        }
        $res = Perlito5::Grammar::Expression::exp_parse($str, $pos);
        if (!$res) {;
            return
        }
        if ($str->[$res->{"to"}] eq ":" && ref($res->{"capture"}) eq "Perlito5::AST::Apply" && $res->{"capture"}->{"bareword"}) {
            my $label = $res->{"capture"}->{"code"};
            my $ws = Perlito5::Grammar::Space::opt_ws($str, ($res->{"to"}) + 1);
            my $stmt = Perlito5::Grammar::Statement::statement_parse($str, $ws->{"to"});
            if ($stmt) {
                $stmt->{"capture"}->{"label"} = $label;
                return $stmt
            }
            $res->{"to"} = $ws->{"to"};
            $res->{"capture"} = Perlito5::AST::Apply::->new("arguments", [], "code", "undef", "namespace", '', "label", $label);
            return $res
        }
        my $modifier = Perlito5::Grammar::Statement::statement_modifier($str, $res->{"to"}, Perlito5::Match::flat($res));
        my $p = $modifier ? $modifier->{"to"} : $res->{"to"};
        my $terminator = $str->[$p];
        if ($terminator ne ";" && $terminator ne "}" && $terminator ne '') {
            my $type = "Number or Bareword";
            $terminator ge 0 && $terminator le 9 && ($type = "Number");
            ($terminator eq "\"" || $terminator eq "'") && ($type = "String");
            $terminator eq "\$" && ($type = "Scalar");
            $terminator eq "\@" && ($type = "Array");
            Perlito5::Compiler::error($type . " found where operator expected")
        }
        if (!$modifier) {;
            return $res
        }
        return $modifier
    }
    Perlito5::Grammar::Statement::add_statement("...", \&stmt_yadayada);
    Perlito5::Grammar::Statement::add_statement("package", \&stmt_package);
    Perlito5::Grammar::Statement::add_statement("format", \&stmt_format);
    1
}
{
    package main;
    package Perlito5::Grammar::Expression;
    sub Perlito5::Grammar::Expression::expand_list_fat_arrow {
        my $param_list = shift;
        if (ref($param_list) eq "Perlito5::AST::Apply" && $param_list->{"code"} eq "infix:<=>>") {;
            return (Perlito5::AST::Lookup::->autoquote($param_list->{"arguments"}->[0]), Perlito5::Grammar::Expression::expand_list_fat_arrow($param_list->{"arguments"}->[1]))
        }
        return $param_list
    }
    sub Perlito5::Grammar::Expression::expand_list {
        my $param_list = shift;
        if (ref($param_list) eq "Perlito5::AST::Apply" && $param_list->{"code"} eq "list:<,>") {;
            return [map {;
                Perlito5::Grammar::Expression::expand_list_fat_arrow($_)
            } grep {;
                defined($_)
            } @{$param_list->arguments()}]
        }
        if (ref($param_list) eq "Perlito5::AST::Apply" && $param_list->{"code"} eq "infix:<=>>") {;
            return [Perlito5::Grammar::Expression::expand_list_fat_arrow($param_list)]
        }
        elsif ($param_list eq "*undef*") {;
            return []
        }
        else {;
            return [$param_list]
        }
    }
    sub Perlito5::Grammar::Expression::block_or_hash {
        my $o = shift;
        if (defined($o->sig())) {;
            return $o
        }
        my $stmts = $o->stmts();
        if (!defined($stmts) || scalar(@{$stmts}) == 0) {;
            return Perlito5::AST::Apply::->new("code", "circumfix:<{ }>", "namespace", '', "arguments", [])
        }
        if (scalar(@{$stmts}) != 1) {;
            return $o
        }
        my $stmt = $stmts->[0];
        if (ref($stmt) eq "Perlito5::AST::Var") {;
            return Perlito5::AST::Apply::->new("code", "circumfix:<{ }>", "namespace", '', "arguments", [$stmt])
        }
        if (ref($stmt) ne "Perlito5::AST::Apply") {;
            return $o
        }
        if ($stmt->{"code"} eq "infix:<=>>" || $stmt->{"code"} eq "prefix:<%>" || $stmt->{"code"} eq "prefix:<\@>" || $stmt->{"code"} eq "list:<,>") {
            if (@{$stmt->{"arguments"}}) {
                my $arg = $stmt->{"arguments"}->[0];
                if (ref($arg) eq "Perlito5::AST::Apply" && $arg->{"code"} eq "prefix:<&>") {;
                    return $o
                }
            }
            return Perlito5::AST::Apply::->new("code", "circumfix:<{ }>", "namespace", '', "arguments", [$stmt])
        }
        return Perlito5::AST::Apply::->new("code", "circumfix:<{ }>", "namespace", '', "arguments", Perlito5::Grammar::Expression::expand_list($stmt))
    }
    sub Perlito5::Grammar::Expression::pop_term {
        my $num_stack = shift;
        my $v = pop(@{$num_stack});
        if (ref($v) eq "ARRAY") {
            ref($v->[1]) && return $v->[1];
            if ($v->[1] eq "methcall_no_params") {
                $v = Perlito5::AST::Call::->new("invocant", undef, "method", $v->[2], "arguments", []);
                return $v
            }
            if ($v->[1] eq "funcall_no_params") {
                $v = $v->[2];
                return $v
            }
            if ($v->[1] eq "methcall") {
                my $param_list = Perlito5::Grammar::Expression::expand_list(($v->[3]));
                $v = Perlito5::AST::Call::->new("invocant", undef, "method", $v->[2], "arguments", $param_list);
                return $v
            }
            if ($v->[1] eq "funcall") {
                $v = Perlito5::AST::Apply::->new("code", $v->[3], "arguments", $v->[4], "namespace", $v->[2]);
                return $v
            }
            if ($v->[1] eq "( )") {
                my $param_list = Perlito5::Grammar::Expression::expand_list($v->[2]);
                $v = Perlito5::AST::Apply::->new("code", "circumfix:<( )>", "arguments", $param_list, "namespace", '');
                return $v
            }
            if ($v->[1] eq "[ ]") {
                my $param_list = Perlito5::Grammar::Expression::expand_list($v->[2]);
                $v = Perlito5::AST::Apply::->new("code", "circumfix:<[ ]>", "arguments", $param_list, "namespace", '');
                return $v
            }
            if ($v->[1] eq "block") {
                $v = Perlito5::AST::Block::->new("stmts", $v->[2], "sig", $v->[3]);
                $v = Perlito5::Grammar::Expression::block_or_hash($v);
                return $v
            }
            if ($v->[1] eq ".( )") {
                $v = Perlito5::AST::Call::->new("invocant", undef, "method", "postcircumfix:<( )>", "arguments", $v->[2]);
                return $v
            }
            if ($v->[1] eq ".[ ]") {
                $v = Perlito5::AST::Index::->new("obj", undef, "index_exp", $v->[2]);
                return $v
            }
            if ($v->[1] eq ".{ }") {
                $v = Perlito5::AST::Lookup::->new("obj", undef, "index_exp", $v->[2]);
                return $v
            }
            return $v->[1]
        }
        return $v
    }
    sub Perlito5::Grammar::Expression::reduce_postfix {
        my $op = shift;
        my $value = shift;
        my $v = $op;
        if ($v->[1] eq ".{ }") {
            $v = Perlito5::AST::Call::->new("invocant", $value, "method", "postcircumfix:<{ }>", "arguments", $v->[2]);
            return $v
        }
        if ($v->[1] eq ".[ ]") {
            $v = Perlito5::AST::Call::->new("invocant", $value, "method", "postcircumfix:<[ ]>", "arguments", $v->[2]);
            return $v
        }
        if ($v->[1] eq "methcall_no_params") {
            if ($v->[2] eq "\@*") {;
                return Perlito5::AST::Apply::->new("code", "prefix:<\@>", "arguments", [$value])
            }
            $v = Perlito5::AST::Call::->new("invocant", $value, "method", $v->[2], "arguments", [], (ref($v->[2]) ? () : ("_no_params", 1)));
            return $v
        }
        if ($v->[1] eq "funcall_no_params") {;
            Perlito5::Compiler::error("Bareword found where operator expected")
        }
        if ($v->[1] eq "methcall") {
            my $param_list = Perlito5::Grammar::Expression::expand_list($v->[3]);
            $v = Perlito5::AST::Call::->new("invocant", $value, "method", $v->[2], "arguments", $param_list);
            return $v
        }
        if ($v->[1] eq "funcall") {;
            Perlito5::Compiler::error("unexpected function call")
        }
        if ($v->[1] eq "( )") {
            my $param_list = Perlito5::Grammar::Expression::expand_list($v->[2]);
            if (ref($value) eq "Perlito5::AST::Apply" && !defined($value->arguments())) {
                $value->{"arguments"} = $param_list;
                return $value
            }
            if (ref($value) eq "Perlito5::AST::Call" && !defined($value->arguments())) {
                $value->{"arguments"} = $param_list;
                return $value
            }
            if (ref($value) eq "Perlito5::AST::Var" && $value->{"sigil"} eq "&") {
                $v = Perlito5::AST::Apply::->new("ignore_proto", 1, "code", $value->{"name"}, "namespace", $value->{"namespace"}, "arguments", $param_list, "proto", undef);
                return $v
            }
            if (ref($value) eq "Perlito5::AST::Apply" && $value->{"code"} eq "prefix:<&>") {
                $v = Perlito5::AST::Apply::->new("ignore_proto", 1, "code", $value, "namespace", '', "arguments", $param_list, "proto", undef);
                return $v
            }
            if (ref($value) eq "Perlito5::AST::Var") {;
                Perlito5::Compiler::error("syntax error")
            }
            $v = Perlito5::AST::Call::->new("invocant", $value, "method", "postcircumfix:<( )>", "arguments", $param_list);
            return $v
        }
        if ($v->[1] eq "[ ]") {
            if (ref($value) eq "Perlito5::AST::Var") {;
                $value->{"_real_sigil"} = "\@"
            }
            $v = Perlito5::AST::Index::->new("obj", $value, "index_exp", $v->[2]);
            return $v
        }
        if ($v->[1] eq "block") {
            if (ref($value) eq "Perlito5::AST::Var") {
                $value->{"_real_sigil"} = "%";
                $value->{"sigil"} eq "*" && ($value->{"_real_sigil"} = "*")
            }
            $v = Perlito5::AST::Lookup::->new("obj", $value, "index_exp", $v->[2]->[0]);
            return $v
        }
        if ($v->[1] eq ".( )") {
            my $param_list = Perlito5::Grammar::Expression::expand_list($v->[2]);
            $v = Perlito5::AST::Call::->new("invocant", $value, "method", "postcircumfix:<( )>", "arguments", $param_list);
            return $v
        }
        push(@{$op}, $value);
        return $op
    }
    sub Perlito5::Grammar::Expression::reduce_to_ast {
        my $op_stack = shift;
        my $num_stack = shift;
        my $last_op = shift(@{$op_stack});
        if ($last_op->[0] eq "prefix") {
            my $v = Perlito5::Grammar::Expression::pop_term($num_stack);
            if (ref($v) eq "Perlito5::AST::Apply" && $v->{"code"} eq "circumfix:<( )>" && @{$v->{"arguments"}} == 1) {;
                $v = $v->{"arguments"}
            }
            else {;
                $v = [$v]
            }
            push(@{$num_stack}, Perlito5::AST::Apply::->new("namespace", '', "code", "prefix:<" . ($last_op->[1]) . ">", "arguments", $v))
        }
        elsif ($last_op->[0] eq "postfix") {;
            push(@{$num_stack}, Perlito5::AST::Apply::->new("namespace", '', "code", "postfix:<" . ($last_op->[1]) . ">", "arguments", [Perlito5::Grammar::Expression::pop_term($num_stack)]))
        }
        elsif ($last_op->[0] eq "postfix_or_term") {;
            push(@{$num_stack}, Perlito5::Grammar::Expression::reduce_postfix($last_op, Perlito5::Grammar::Expression::pop_term($num_stack)))
        }
        elsif (Perlito5::Grammar::Precedence::is_assoc_type("list", $last_op->[1])) {
            my $arg;
            if (scalar(@{$num_stack}) < 2) {
                my $v2 = Perlito5::Grammar::Expression::pop_term($num_stack);
                if (ref($v2) eq "Perlito5::AST::Apply" && $v2->{"code"} eq ("list:<" . ($last_op->[1]) . ">")) {;
                    push(@{$num_stack}, Perlito5::AST::Apply::->new("namespace", $v2->namespace(), "code", $v2->{"code"}, "arguments", [@{$v2->arguments()}]))
                }
                else {;
                    push(@{$num_stack}, Perlito5::AST::Apply::->new("namespace", '', "code", "list:<" . ($last_op->[1]) . ">", "arguments", [$v2]))
                }
                return
            }
            else {
                my $v2 = Perlito5::Grammar::Expression::pop_term($num_stack);
                $arg = [Perlito5::Grammar::Expression::pop_term($num_stack), $v2]
            }
            if (ref($arg->[0]) eq "Perlito5::AST::Apply" && $last_op->[0] eq "infix" && ($arg->[0]->{"code"} eq "list:<" . ($last_op->[1]) . ">")) {
                push(@{$num_stack}, Perlito5::AST::Apply::->new("namespace", '', "code", ($arg->[0])->{"code"}, "arguments", [@{($arg->[0])->arguments()}, $arg->[1]]));
                return
            }
            push(@{$num_stack}, Perlito5::AST::Apply::->new("namespace", '', "code", "list:<" . ($last_op->[1]) . ">", "arguments", $arg))
        }
        elsif (Perlito5::Grammar::Precedence::is_assoc_type("chain", $last_op->[1])) {
            if (scalar(@{$num_stack}) < 2) {;
                Perlito5::Compiler::error("Missing value after operator " . ($last_op->[1]))
            }
            my $v2 = Perlito5::Grammar::Expression::pop_term($num_stack);
            my $arg = [Perlito5::Grammar::Expression::pop_term($num_stack), $v2];
            push(@{$num_stack}, Perlito5::AST::Apply::->new("namespace", '', "code", "infix:<" . ($last_op->[1]) . ">", "arguments", $arg))
        }
        elsif ($last_op->[0] eq "ternary") {
            if (scalar(@{$num_stack}) < 2) {;
                Perlito5::Compiler::error("Missing value after ternary operator")
            }
            my $v2 = Perlito5::Grammar::Expression::pop_term($num_stack);
            push(@{$num_stack}, Perlito5::AST::Apply::->new("namespace", '', "code", "ternary:<" . ($last_op->[1]) . ">", "arguments", [Perlito5::Grammar::Expression::pop_term($num_stack), $last_op->[2], $v2]))
        }
        else {
            if (scalar(@{$num_stack}) < 2) {;
                Perlito5::Compiler::error("missing value after operator '" . ($last_op->[1]) . "'")
            }
            my $v2 = Perlito5::Grammar::Expression::pop_term($num_stack);
            my $op = $last_op->[1];
            push(@{$num_stack}, Perlito5::AST::Apply::->new("namespace", '', "code", "infix:<" . $op . ">", "arguments", [Perlito5::Grammar::Expression::pop_term($num_stack), $v2], Perlito5::integer_flag($op), Perlito5::overloading_flag()))
        }
    }
    sub Perlito5::Grammar::Expression::term_arrow {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((("-" eq $str->[($MATCH->{"to"}) + 0]) && (">" eq $str->[($MATCH->{"to"}) + 1]) && ($MATCH->{"to"} += 2)) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $tmp484 = $MATCH->{"to"};
            (((("(" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $m2 = Perlito5::Grammar::Expression::paren_parse($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"paren_parse"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && ((")" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                $MATCH->{"capture"} = ["postfix_or_term", ".( )", Perlito5::Match::flat($MATCH->{"paren_parse"})];
                1
            }))) || ($MATCH->{"to"} = $tmp484, ((("[" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $m2 = Perlito5::Grammar::Expression::square_parse($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"square_parse"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (("]" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                $MATCH->{"capture"} = ["postfix_or_term", ".[ ]", Perlito5::Match::flat($MATCH->{"square_parse"})];
                1
            }))) || ($MATCH->{"to"} = $tmp484, ((("{" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $tmp485 = $MATCH->{"to"};
                (((do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $m2 = Perlito5::Grammar::ident($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::ident"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (("}" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    $MATCH->{"capture"} = ["postfix_or_term", ".{ }", Perlito5::AST::Buf::->new("buf", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::ident"}))];
                    1
                }))) || ($MATCH->{"to"} = $tmp485, ((do {
                    my $m2 = Perlito5::Grammar::Expression::curly_parse($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"curly_parse"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $tmp486 = $MATCH->{"to"};
                    ((("}" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp486, (do {
                        Perlito5::Compiler::error("Missing right curly or square bracket");
                        1
                    }))
                }) && (do {
                    $MATCH->{"capture"} = ["postfix_or_term", ".{ }", Perlito5::Match::flat($MATCH->{"curly_parse"})];
                    1
                })))
            }))) || ($MATCH->{"to"} = $tmp484, ((do {
                my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::full_ident"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $tmp487 = $MATCH->{"to"};
                (((("(" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $m2 = Perlito5::Grammar::Expression::paren_parse($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"paren_parse"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && ((")" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    $MATCH->{"capture"} = ["postfix_or_term", "methcall", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::full_ident"}), Perlito5::Match::flat($MATCH->{"paren_parse"})];
                    1
                }))) || ($MATCH->{"to"} = $tmp487, (do {
                    $MATCH->{"capture"} = ["postfix_or_term", "methcall_no_params", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::full_ident"})];
                    1
                }))
            }))) || ($MATCH->{"to"} = $tmp484, ((do {
                my $tmp = $MATCH;
                $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
                my $res = (("\$" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1));
                $MATCH = $tmp;
                $res ? 1 : 0
            }) && (do {
                my $m2 = Perlito5::Grammar::Sigil::term_sigil($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::Sigil::term_sigil"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $tmp488 = $MATCH->{"to"};
                (((("(" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $m2 = Perlito5::Grammar::Expression::paren_parse($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"paren_parse"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && ((")" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    $MATCH->{"capture"} = ["postfix_or_term", "methcall", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Sigil::term_sigil"})->[1], Perlito5::Match::flat($MATCH->{"paren_parse"})];
                    1
                }))) || ($MATCH->{"to"} = $tmp488, (do {
                    $MATCH->{"capture"} = ["postfix_or_term", "methcall_no_params", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Sigil::term_sigil"})->[1]];
                    1
                }))
            }))) || ($MATCH->{"to"} = $tmp484, ((("\@" eq $str->[($MATCH->{"to"}) + 0]) && ("*" eq $str->[($MATCH->{"to"}) + 1]) && ($MATCH->{"to"} += 2)) && (do {
                $MATCH->{"capture"} = ["postfix_or_term", "methcall_no_params", "\@*"];
                1
            })))
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Expression::term_ternary {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((("?" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $m2 = Perlito5::Grammar::Expression::ternary5_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"ternary5_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && ((":" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
            $MATCH->{"capture"} = ["op", "? :", Perlito5::Match::flat($MATCH->{"ternary5_parse"})];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Expression::term_paren {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((("(" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $m2 = Perlito5::Grammar::Expression::paren_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"paren_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && ((")" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
            $MATCH->{"capture"} = ["postfix_or_term", "( )", Perlito5::Match::flat($MATCH->{"paren_parse"})];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Expression::term_square {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((("[" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $m2 = Perlito5::Grammar::Expression::square_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"square_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (("]" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
            $MATCH->{"capture"} = ["postfix_or_term", "[ ]", Perlito5::Match::flat($MATCH->{"square_parse"})];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Expression::term_curly {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((("{" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $m = $MATCH;
            if (!(do {
                my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            })) {;
                $MATCH = $m
            }
            1
        }) && (do {
            my $tmp528 = $MATCH->{"to"};
            (((do {
                my $m2 = Perlito5::Grammar::ident($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::ident"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $m = $MATCH;
                if (!(do {
                    my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                })) {;
                    $MATCH = $m
                }
                1
            }) && (("}" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                $MATCH->{"capture"} = ["postfix_or_term", "block", [Perlito5::AST::Apply::->new("arguments", [], "bareword", 1, "code", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::ident"}), "namespace", '')]];
                1
            }))) || ($MATCH->{"to"} = $tmp528, ((do {
                $MATCH->{"_save_scope"} = [@Perlito5::SCOPE_STMT];
                @Perlito5::SCOPE_STMT = ();
                1
            }) && (do {
                my $m2 = Perlito5::Grammar::exp_stmts($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::exp_stmts"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                @Perlito5::SCOPE_STMT = @{$MATCH->{"_save_scope"}};
                1
            }) && (do {
                my $m = $MATCH;
                if (!(do {
                    my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                })) {;
                    $MATCH = $m
                }
                1
            }) && (do {
                my $tmp529 = $MATCH->{"to"};
                ((("}" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp529, (do {
                    Perlito5::Compiler::error("Missing right curly or square bracket");
                    1
                }))
            }) && (do {
                $MATCH->{"capture"} = ["postfix_or_term", "block", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::exp_stmts"})];
                1
            })))
        })));
        $tmp ? $MATCH : undef
    }
    my $Expr_end_token_chars = [7, 6, 5, 4, 3, 2, 1];
    my $Expr_end_token = {"]" => 1, ")" => 1, "}" => 1, ";" => 1, "if" => 1, "for" => 1, "else" => 1, "when" => 1, "while" => 1, "until" => 1, "elsif" => 1, "unless" => 1, "foreach" => 1, };
    my $List_end_token = {":" => 1, "or" => 1, "and" => 1, "xor" => 1, %{$Expr_end_token}, };
    my $Next_Last_Redo_end_token = {"," => 1, "=>" => 1, %{$List_end_token}, };
    my $Argument_end_token = {"," => 1, "<" => 1, ">" => 1, "=" => 1, "|" => 1, "^" => 1, "?" => 1, "=>" => 1, "lt" => 1, "le" => 1, "gt" => 1, "=>" => 1, "lt" => 1, "le" => 1, "gt" => 1, "ge" => 1, "<=" => 1, ">=" => 1, "==" => 1, "!=" => 1, "ne" => 1, "eq" => 1, ".." => 1, "~~" => 1, "&&" => 1, "||" => 1, "+=" => 1, "-=" => 1, "*=" => 1, "/=" => 1, "x=" => 1, "|=" => 1, "&=" => 1, ".=" => 1, "^=" => 1, "%=" => 1, "//" => 1, "|." => 1, "&." => 1, "^." => 1, "..." => 1, "<=>" => 1, "cmp" => 1, "<<=" => 1, ">>=" => 1, "||=" => 1, "&&=" => 1, "//=" => 1, "**=" => 1, "|.=" => 1, "&.=" => 1, "^.=" => 1, "last" => 1, "next" => 1, "redo" => 1, %{$List_end_token}, };
    sub Perlito5::Grammar::Expression::list_parser {
        (my $str, my $pos, my $end_token) = @_;
        my $last_pos = $pos;
        my $is_first_token = 1;
        my $get_token = sub {
            my $last_is_term = $_[0];
            my $v;
            my $m = Perlito5::Grammar::Precedence::op_parse($str, $last_pos, $last_is_term);
            if (!$m) {;
                return ["end", "*end*"]
            }
            my $spc = Perlito5::Grammar::Space::ws($str, $m->{"to"});
            if ($spc) {;
                $m->{"to"} = $spc->{"to"}
            }
            $v = $m->{"capture"};
            if ($is_first_token && ($v->[0] eq "op") && !Perlito5::Grammar::Precedence::is_fixity_type("prefix", $v->[1])) {;
                $v->[0] = "end"
            }
            if ($v->[0] ne "end") {;
                $last_pos = $m->{"to"}
            }
            $is_first_token = 0;
            return $v
        };
        my $res = Perlito5::Grammar::Precedence::precedence_parse($get_token, $end_token, $Expr_end_token_chars);
        if (scalar(@{$res}) == 0) {;
            return {"str" => $str, "from" => $pos, "to" => $last_pos, "capture" => "*undef*", }
        }
        my $result = Perlito5::Grammar::Expression::pop_term($res);
        return {"str" => $str, "from" => $pos, "to" => $last_pos, "capture" => $result, }
    }
    sub Perlito5::Grammar::Expression::next_last_redo_parse {
        (my $str, my $pos) = @_;
        return Perlito5::Grammar::Expression::list_parser($str, $pos, $Next_Last_Redo_end_token)
    }
    sub Perlito5::Grammar::Expression::argument_parse {
        (my $str, my $pos) = @_;
        my $m = Perlito5::Grammar::Expression::list_parser($str, $pos, $Argument_end_token);
        if ($m->{"capture"} eq "*undef*") {
            my $term = Perlito5::Grammar::String::term_glob($str, $pos);
            if ($term) {
                $m->{"capture"} = $term->{"capture"}->[1];
                $m->{"to"} = $term->{"to"}
            }
        }
        return $m
    }
    sub Perlito5::Grammar::Expression::list_parse {
        (my $str, my $pos) = @_;
        return Perlito5::Grammar::Expression::list_parser($str, $pos, $List_end_token)
    }
    sub Perlito5::Grammar::Expression::circumfix_parse {
        (my $str, my $pos, my $delimiter) = @_;
        my $last_pos = $pos;
        my $get_token = sub {
            my $last_is_term = $_[0];
            my $m = Perlito5::Grammar::Precedence::op_parse($str, $last_pos, $last_is_term);
            if (!$m) {
                my $msg = "Expected closing delimiter: " . $delimiter;
                ($delimiter eq "}" || $delimiter eq "]") && ($msg = "Missing right curly or square bracket");
                Perlito5::Compiler::error($msg . " near ", $last_pos)
            }
            my $spc = Perlito5::Grammar::Space::ws($str, $m->{"to"});
            if ($spc) {;
                $m->{"to"} = $spc->{"to"}
            }
            my $v = $m->{"capture"};
            if ($v->[0] ne "end") {;
                $last_pos = $m->{"to"}
            }
            return $v
        };
        my %delim_token;
        $delim_token{$delimiter} = 1;
        my $res = Perlito5::Grammar::Precedence::precedence_parse($get_token, \%delim_token, [length($delimiter)]);
        $res = Perlito5::Grammar::Expression::pop_term($res);
        if (!defined($res)) {;
            $res = "*undef*"
        }
        return {"str" => $str, "from" => $pos, "to" => $last_pos, "capture" => $res, }
    }
    sub Perlito5::Grammar::Expression::ternary5_parse {;
        return Perlito5::Grammar::Expression::circumfix_parse(@_, ":")
    }
    sub Perlito5::Grammar::Expression::curly_parse {;
        return Perlito5::Grammar::Expression::circumfix_parse(@_, "}")
    }
    sub Perlito5::Grammar::Expression::square_parse {;
        return Perlito5::Grammar::Expression::circumfix_parse(@_, "]")
    }
    sub Perlito5::Grammar::Expression::paren_parse {;
        return Perlito5::Grammar::Expression::circumfix_parse(@_, ")")
    }
    sub Perlito5::Grammar::Expression::exp_parse {
        (my $str, my $pos) = @_;
        my $last_pos = $pos;
        my $get_token = sub {
            my $last_is_term = $_[0];
            my $v;
            my $m = Perlito5::Grammar::Precedence::op_parse($str, $last_pos, $last_is_term);
            if (!$m) {;
                return ["end", "*end*"]
            }
            my $spc = Perlito5::Grammar::Space::ws($str, $m->{"to"});
            if ($spc) {;
                $m->{"to"} = $spc->{"to"}
            }
            $v = $m->{"capture"};
            if ($v->[0] ne "end") {;
                $last_pos = $m->{"to"}
            }
            return $v
        };
        my $res = Perlito5::Grammar::Precedence::precedence_parse($get_token, $Expr_end_token, $Expr_end_token_chars);
        if (scalar(@{$res}) == 0) {;
            return 0
        }
        my $result = Perlito5::Grammar::Expression::pop_term($res);
        return {"str" => $str, "from" => $pos, "to" => $last_pos, "capture" => $result, }
    }
    1
}
{
    package main;
    package Perlito5::Grammar;
    sub Perlito5::Grammar::unless {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((("u" eq $str->[($MATCH->{"to"}) + 0]) && ("n" eq $str->[($MATCH->{"to"}) + 1]) && ("l" eq $str->[($MATCH->{"to"}) + 2]) && ("e" eq $str->[($MATCH->{"to"}) + 3]) && ("s" eq $str->[($MATCH->{"to"}) + 4]) && ("s" eq $str->[($MATCH->{"to"}) + 5]) && ($MATCH->{"to"} += 6)) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            Perlito5::Grammar::Scope::create_new_compile_time_scope();
            1
        }) && (do {
            my $m2 = Perlito5::Grammar::Expression::term_paren($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Expression::term_paren"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::block($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"block"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $tmp591 = $MATCH->{"to"};
            (((do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (("e" eq $str->[($MATCH->{"to"}) + 0]) && ("l" eq $str->[($MATCH->{"to"}) + 1]) && ("s" eq $str->[($MATCH->{"to"}) + 2]) && ("e" eq $str->[($MATCH->{"to"}) + 3]) && ($MATCH->{"to"} += 4)) && (do {
                my $m2 = Perlito5::Grammar::block2($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"block2"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                $MATCH->{"capture"} = Perlito5::AST::If::->new("cond", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::term_paren"})->[2], "body", Perlito5::Match::flat($MATCH->{"block2"}), "otherwise", Perlito5::Match::flat($MATCH->{"block"}));
                1
            }))) || ($MATCH->{"to"} = $tmp591, ((do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (("e" eq $str->[($MATCH->{"to"}) + 0]) && ("l" eq $str->[($MATCH->{"to"}) + 1]) && ("s" eq $str->[($MATCH->{"to"}) + 2]) && ($MATCH->{"to"} += 3)) && (do {
                my $m2 = Perlito5::Grammar::if_($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"if_"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                $MATCH->{"capture"} = Perlito5::AST::If::->new("cond", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::term_paren"})->[2], "body", Perlito5::AST::Block::->new("stmts", [Perlito5::Match::flat($MATCH->{"if_"})]), "otherwise", Perlito5::Match::flat($MATCH->{"block"}));
                1
            }))) || ($MATCH->{"to"} = $tmp591, (do {
                $MATCH->{"capture"} = Perlito5::AST::If::->new("cond", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::term_paren"})->[2], "body", Perlito5::AST::Block::->new("stmts", []), "otherwise", Perlito5::Match::flat($MATCH->{"block"}));
                1
            }))
        }) && (do {
            Perlito5::Grammar::Scope::end_compile_time_scope();
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::if_ {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((("i" eq $str->[($MATCH->{"to"}) + 0]) && ("f" eq $str->[($MATCH->{"to"}) + 1]) && ($MATCH->{"to"} += 2)) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            Perlito5::Grammar::Scope::create_new_compile_time_scope();
            1
        }) && (do {
            my $m2 = Perlito5::Grammar::Expression::term_paren($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Expression::term_paren"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::block($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"block"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $tmp605 = $MATCH->{"to"};
            (((do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (("e" eq $str->[($MATCH->{"to"}) + 0]) && ("l" eq $str->[($MATCH->{"to"}) + 1]) && ("s" eq $str->[($MATCH->{"to"}) + 2]) && ("e" eq $str->[($MATCH->{"to"}) + 3]) && ($MATCH->{"to"} += 4)) && (do {
                my $m2 = Perlito5::Grammar::block2($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"block2"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                $MATCH->{"capture"} = Perlito5::AST::If::->new("cond", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::term_paren"})->[2], "body", Perlito5::Match::flat($MATCH->{"block"}), "otherwise", Perlito5::Match::flat($MATCH->{"block2"}));
                1
            }))) || ($MATCH->{"to"} = $tmp605, ((do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (("e" eq $str->[($MATCH->{"to"}) + 0]) && ("l" eq $str->[($MATCH->{"to"}) + 1]) && ("s" eq $str->[($MATCH->{"to"}) + 2]) && ($MATCH->{"to"} += 3)) && (do {
                my $m2 = Perlito5::Grammar::if_($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"if_"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                $MATCH->{"capture"} = Perlito5::AST::If::->new("cond", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::term_paren"})->[2], "body", Perlito5::Match::flat($MATCH->{"block"}), "otherwise", Perlito5::AST::Block::->new("stmts", [Perlito5::Match::flat($MATCH->{"if_"})]));
                1
            }))) || ($MATCH->{"to"} = $tmp605, (do {
                $MATCH->{"capture"} = Perlito5::AST::If::->new("cond", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::term_paren"})->[2], "body", Perlito5::Match::flat($MATCH->{"block"}), "otherwise", Perlito5::AST::Block::->new("stmts", []));
                1
            }))
        }) && (do {
            Perlito5::Grammar::Scope::end_compile_time_scope();
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::when {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((("w" eq $str->[($MATCH->{"to"}) + 0]) && ("h" eq $str->[($MATCH->{"to"}) + 1]) && ("e" eq $str->[($MATCH->{"to"}) + 2]) && ("n" eq $str->[($MATCH->{"to"}) + 3]) && ($MATCH->{"to"} += 4)) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            Perlito5::Grammar::Scope::create_new_compile_time_scope();
            1
        }) && (do {
            my $m2 = Perlito5::Grammar::Expression::term_paren($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Expression::term_paren"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::block($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"block"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = Perlito5::AST::When::->new("cond", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::term_paren"})->[2], "body", Perlito5::Match::flat($MATCH->{"block"}));
            1
        }) && (do {
            Perlito5::Grammar::Scope::end_compile_time_scope();
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::is_bareword {
        my $term = shift;
        (ref($term) eq "Perlito5::AST::Apply") and $term->{"bareword"}
    }
    sub Perlito5::Grammar::for {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((("f" eq $str->[($MATCH->{"to"}) + 0]) && ("o" eq $str->[($MATCH->{"to"}) + 1]) && ("r" eq $str->[($MATCH->{"to"}) + 2]) && ($MATCH->{"to"} += 3)) && (do {
            my $m = $MATCH;
            if (!(("e" eq $str->[($MATCH->{"to"}) + 0]) && ("a" eq $str->[($MATCH->{"to"}) + 1]) && ("c" eq $str->[($MATCH->{"to"}) + 2]) && ("h" eq $str->[($MATCH->{"to"}) + 3]) && ($MATCH->{"to"} += 4))) {;
                $MATCH = $m
            }
            1
        }) && (do {
            Perlito5::Grammar::Scope::create_new_compile_time_scope();
            1
        }) && (do {
            my $tmp628 = $MATCH->{"to"};
            (((do {
                my $tmp629 = $MATCH->{"to"};
                (((do {
                    my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $m2 = Perlito5::Grammar::Expression::term_declarator($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Expression::term_declarator"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{"_tmp"} = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::term_declarator"})->[1];
                    1
                }))) || ($MATCH->{"to"} = $tmp629, ((do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $tmp = $MATCH;
                    $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
                    my $res = (("\$" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1));
                    $MATCH = $tmp;
                    $res ? 1 : 0
                }) && (do {
                    my $m2 = Perlito5::Grammar::Sigil::term_sigil($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Sigil::term_sigil"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{"_tmp"} = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Sigil::term_sigil"})->[1];
                    my $v = $MATCH->{"_tmp"};
                    my $look = Perlito5::Grammar::Scope::lookup_variable($v);
                    my $decl = $look && $look->{"_decl"} ? $look->{"_decl"} : "global";
                    if ($decl ne "global") {
                        $v->{"_id"} = $Perlito5::ID++;
                        $v->{"_decl"} = $decl;
                        $MATCH->{"_tmp"} = Perlito5::AST::Decl::->new("decl", $decl, "var", $v)
                    }
                    1
                })))
            }) && (do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (("(" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $m2 = Perlito5::Grammar::Expression::paren_parse($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::Expression::paren_parse"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && ((")" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $m2 = Perlito5::Grammar::block($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"block"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $m2 = Perlito5::Grammar::opt_continue_block($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"opt_continue_block"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $body = Perlito5::Match::flat($MATCH->{"block"});
                my $header = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::paren_parse"});
                my $topic = $MATCH->{"_tmp"};
                my $continue_block = $MATCH->{"opt_continue_block"}->{"capture"};
                $MATCH->{"capture"} = Perlito5::AST::For::->new("cond", $header, "body", $body, "continue", $continue_block, "topic", $topic);
                1
            }))) || ($MATCH->{"to"} = $tmp628, ((do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (("(" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $tmp630 = $MATCH->{"to"};
                (((do {
                    my $m2 = Perlito5::Grammar::Expression::exp_parse($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Expression::exp_parse"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    Perlito5::Grammar::Scope::check_variable_declarations();
                    1
                }))) || ($MATCH->{"to"} = $tmp630, ()) || ($MATCH->{"to"} = $tmp630, ((do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $tmp = $MATCH;
                    $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
                    my $res = ((";" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1));
                    $MATCH = $tmp;
                    $res ? 1 : 0
                })))
            }) && (do {
                my $tmp631 = $MATCH->{"to"};
                ((((";" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    $MATCH->{"c_style_for"} = 1;
                    1
                }) && (do {
                    my $tmp632 = $MATCH->{"to"};
                    (((do {
                        my $m2 = Perlito5::Grammar::exp($str, $MATCH->{"to"});
                        if ($m2) {
                            $MATCH->{"to"} = $m2->{"to"};
                            $MATCH->{"Perlito5::Grammar::exp"} = $m2;
                            1
                        }
                        else {;
                            0
                        }
                    }) && (do {
                        Perlito5::Grammar::Scope::check_variable_declarations();
                        1
                    }))) || ($MATCH->{"to"} = $tmp632, ()) || ($MATCH->{"to"} = $tmp632, (do {
                        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                        if ($m2) {
                            $MATCH->{"to"} = $m2->{"to"};
                            1
                        }
                        else {;
                            0
                        }
                    }))
                }) && ((";" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $tmp633 = $MATCH->{"to"};
                    ((do {
                        my $m2 = Perlito5::Grammar::exp2($str, $MATCH->{"to"});
                        if ($m2) {
                            $MATCH->{"to"} = $m2->{"to"};
                            $MATCH->{"Perlito5::Grammar::exp2"} = $m2;
                            1
                        }
                        else {;
                            0
                        }
                    })) || ($MATCH->{"to"} = $tmp633, ()) || ($MATCH->{"to"} = $tmp633, (do {
                        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                        if ($m2) {
                            $MATCH->{"to"} = $m2->{"to"};
                            1
                        }
                        else {;
                            0
                        }
                    }))
                }))) || ($MATCH->{"to"} = $tmp631, 1)
            }) && ((")" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $m2 = Perlito5::Grammar::block($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"block"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $m2 = Perlito5::Grammar::opt_continue_block($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"opt_continue_block"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $header;
                my $body = Perlito5::Match::flat($MATCH->{"block"});
                my $topic;
                my $continue_block = $MATCH->{"opt_continue_block"}->{"capture"};
                if ($MATCH->{"c_style_for"}) {;
                    $header = [$MATCH->{"Perlito5::Grammar::Expression::exp_parse"}->{"capture"}, $MATCH->{"Perlito5::Grammar::exp"}->{"capture"}, $MATCH->{"Perlito5::Grammar::exp2"}->{"capture"}]
                }
                else {
                    $header = $MATCH->{"Perlito5::Grammar::Expression::exp_parse"}->{"capture"};
                    $topic = Perlito5::AST::Var::SCALAR_ARG()
                }
                $MATCH->{"capture"} = Perlito5::AST::For::->new("cond", $header, "body", $body, "continue", $continue_block, "topic", $topic);
                1
            })))
        }) && (do {
            Perlito5::Grammar::Scope::end_compile_time_scope();
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::while {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((("w" eq $str->[($MATCH->{"to"}) + 0]) && ("h" eq $str->[($MATCH->{"to"}) + 1]) && ("i" eq $str->[($MATCH->{"to"}) + 2]) && ("l" eq $str->[($MATCH->{"to"}) + 3]) && ("e" eq $str->[($MATCH->{"to"}) + 4]) && ($MATCH->{"to"} += 5)) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            Perlito5::Grammar::Scope::create_new_compile_time_scope();
            1
        }) && (("(" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $m2 = Perlito5::Grammar::Expression::paren_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Expression::paren_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && ((")" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $m2 = Perlito5::Grammar::block($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"block"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::opt_continue_block($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"opt_continue_block"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $cond = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::paren_parse"});
            if ($cond eq "*undef*") {;
                $cond = Perlito5::AST::Int::->new("int", 1)
            }
            my $stmt = Perlito5::AST::While::->new("cond", Perlito5::FoldConstant::fold_constant($cond), "body", Perlito5::Match::flat($MATCH->{"block"}), "continue", $MATCH->{"opt_continue_block"}->{"capture"});
            my $out = Perlito5::Macro::while_file($stmt);
            $out && ($stmt = $out);
            $MATCH->{"capture"} = $stmt;
            1
        }) && (do {
            Perlito5::Grammar::Scope::end_compile_time_scope();
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::until {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((("u" eq $str->[($MATCH->{"to"}) + 0]) && ("n" eq $str->[($MATCH->{"to"}) + 1]) && ("t" eq $str->[($MATCH->{"to"}) + 2]) && ("i" eq $str->[($MATCH->{"to"}) + 3]) && ("l" eq $str->[($MATCH->{"to"}) + 4]) && ($MATCH->{"to"} += 5)) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            Perlito5::Grammar::Scope::create_new_compile_time_scope();
            1
        }) && (("(" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $m2 = Perlito5::Grammar::Expression::paren_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Expression::paren_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && ((")" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $m2 = Perlito5::Grammar::block($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"block"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::opt_continue_block($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"opt_continue_block"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $cond = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::paren_parse"});
            if ($cond eq "*undef*") {;
                $cond = Perlito5::AST::Int::->new("int", 1)
            }
            $MATCH->{"capture"} = Perlito5::AST::While::->new("cond", Perlito5::FoldConstant::fold_constant(Perlito5::AST::Apply::->new("arguments", [$cond], "code", "prefix:<!>", "namespace", '')), "body", Perlito5::Match::flat($MATCH->{"block"}), "continue", $MATCH->{"opt_continue_block"}->{"capture"});
            1
        }) && (do {
            Perlito5::Grammar::Scope::end_compile_time_scope();
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::given {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((("g" eq $str->[($MATCH->{"to"}) + 0]) && ("i" eq $str->[($MATCH->{"to"}) + 1]) && ("v" eq $str->[($MATCH->{"to"}) + 2]) && ("e" eq $str->[($MATCH->{"to"}) + 3]) && ("n" eq $str->[($MATCH->{"to"}) + 4]) && ($MATCH->{"to"} += 5)) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            Perlito5::Grammar::Scope::create_new_compile_time_scope();
            1
        }) && (("(" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $m2 = Perlito5::Grammar::Expression::paren_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Expression::paren_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && ((")" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $m2 = Perlito5::Grammar::block($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"block"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $body = Perlito5::Match::flat($MATCH->{"block"});
            $body->{"sig"} = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::var_ident"});
            $MATCH->{"capture"} = Perlito5::AST::Given::->new("cond", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::paren_parse"}), "body", $body);
            1
        }) && (do {
            Perlito5::Grammar::Scope::end_compile_time_scope();
            1
        })));
        $tmp ? $MATCH : undef
    }
    Perlito5::Grammar::Statement::add_statement("if", \&if_);
    Perlito5::Grammar::Statement::add_statement("for", \&for);
    Perlito5::Grammar::Statement::add_statement("foreach", \&for);
    Perlito5::Grammar::Statement::add_statement("when", \&when);
    Perlito5::Grammar::Statement::add_statement("while", \&while);
    Perlito5::Grammar::Statement::add_statement("until", \&until);
    Perlito5::Grammar::Statement::add_statement("given", \&given);
    Perlito5::Grammar::Statement::add_statement("unless", \&unless)
}
{
    package main;
    package Perlito5::Grammar::String;
    sub Perlito5::Grammar::String::term_q_quote {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $tmp705 = $MATCH->{"to"};
            (((("q" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $tmp706 = $MATCH->{"to"};
                ((("#" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp706, ((do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $tmp = $MATCH;
                    $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
                    my $res = (("=" eq $str->[($MATCH->{"to"}) + 0]) && (">" eq $str->[($MATCH->{"to"}) + 1]) && ($MATCH->{"to"} += 2));
                    $MATCH = $tmp;
                    $res ? 0 : 1
                }) && ('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"})))
            }))) || ($MATCH->{"to"} = $tmp705, (("'" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)))
        }) && (do {
            my $m2 = Perlito5::Grammar::String::q_quote_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"q_quote_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = ["term", Perlito5::Match::flat($MATCH->{"q_quote_parse"})];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::String::term_qq_quote {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $tmp717 = $MATCH->{"to"};
            (((("q" eq $str->[($MATCH->{"to"}) + 0]) && ("q" eq $str->[($MATCH->{"to"}) + 1]) && ($MATCH->{"to"} += 2)) && (do {
                my $tmp718 = $MATCH->{"to"};
                ((("#" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp718, ((do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $tmp = $MATCH;
                    $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
                    my $res = (("=" eq $str->[($MATCH->{"to"}) + 0]) && (">" eq $str->[($MATCH->{"to"}) + 1]) && ($MATCH->{"to"} += 2));
                    $MATCH = $tmp;
                    $res ? 0 : 1
                }) && ('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"})))
            }))) || ($MATCH->{"to"} = $tmp717, (("\"" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)))
        }) && (do {
            my $m2 = Perlito5::Grammar::String::qq_quote_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"qq_quote_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = ["term", Perlito5::Match::flat($MATCH->{"qq_quote_parse"})];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::String::term_qw_quote {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((("q" eq $str->[($MATCH->{"to"}) + 0]) && ("w" eq $str->[($MATCH->{"to"}) + 1]) && ($MATCH->{"to"} += 2)) && (do {
            my $tmp729 = $MATCH->{"to"};
            ((("#" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp729, ((do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $tmp = $MATCH;
                $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
                my $res = (("=" eq $str->[($MATCH->{"to"}) + 0]) && (">" eq $str->[($MATCH->{"to"}) + 1]) && ($MATCH->{"to"} += 2));
                $MATCH = $tmp;
                $res ? 0 : 1
            }) && ('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"})))
        }) && (do {
            my $m2 = Perlito5::Grammar::String::qw_quote_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"qw_quote_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = ["term", Perlito5::Match::flat($MATCH->{"qw_quote_parse"})];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::String::term_m_quote {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $tmp739 = $MATCH->{"to"};
            (((("m" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $tmp740 = $MATCH->{"to"};
                ((("#" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp740, ((do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $tmp = $MATCH;
                    $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
                    my $res = (("=" eq $str->[($MATCH->{"to"}) + 0]) && (">" eq $str->[($MATCH->{"to"}) + 1]) && ($MATCH->{"to"} += 2));
                    $MATCH = $tmp;
                    $res ? 0 : 1
                }) && ('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"})))
            }))) || ($MATCH->{"to"} = $tmp739, (("/" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)))
        }) && (do {
            my $m2 = Perlito5::Grammar::String::m_quote_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"m_quote_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = ["term", Perlito5::Match::flat($MATCH->{"m_quote_parse"})];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::String::term_s_quote {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((("s" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $tmp751 = $MATCH->{"to"};
            ((("#" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp751, ((do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $tmp = $MATCH;
                $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
                my $res = (("=" eq $str->[($MATCH->{"to"}) + 0]) && (">" eq $str->[($MATCH->{"to"}) + 1]) && ($MATCH->{"to"} += 2));
                $MATCH = $tmp;
                $res ? 0 : 1
            }) && ('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"})))
        }) && (do {
            my $m2 = Perlito5::Grammar::String::s_quote_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"s_quote_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = ["term", Perlito5::Match::flat($MATCH->{"s_quote_parse"})];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::String::term_qx {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $tmp761 = $MATCH->{"to"};
            (((("q" eq $str->[($MATCH->{"to"}) + 0]) && ("x" eq $str->[($MATCH->{"to"}) + 1]) && ($MATCH->{"to"} += 2)) && (do {
                my $tmp762 = $MATCH->{"to"};
                ((("#" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp762, ((do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $tmp = $MATCH;
                    $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
                    my $res = (("=" eq $str->[($MATCH->{"to"}) + 0]) && (">" eq $str->[($MATCH->{"to"}) + 1]) && ($MATCH->{"to"} += 2));
                    $MATCH = $tmp;
                    $res ? 0 : 1
                }) && ('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"})))
            }))) || ($MATCH->{"to"} = $tmp761, (("`" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)))
        }) && (do {
            my $m2 = Perlito5::Grammar::String::qx_quote_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"qx_quote_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = ["term", Perlito5::Match::flat($MATCH->{"qx_quote_parse"})];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::String::term_glob {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((("<" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $m2 = Perlito5::Grammar::String::glob_quote_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"glob_quote_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = ["term", Perlito5::Match::flat($MATCH->{"glob_quote_parse"})];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::String::term_tr_quote {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $tmp778 = $MATCH->{"to"};
            ((("t" eq $str->[($MATCH->{"to"}) + 0]) && ("r" eq $str->[($MATCH->{"to"}) + 1]) && ($MATCH->{"to"} += 2))) || ($MATCH->{"to"} = $tmp778, (("y" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)))
        }) && (do {
            my $tmp779 = $MATCH->{"to"};
            ((("#" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp779, ((do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $tmp = $MATCH;
                $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
                my $res = (("=" eq $str->[($MATCH->{"to"}) + 0]) && (">" eq $str->[($MATCH->{"to"}) + 1]) && ($MATCH->{"to"} += 2));
                $MATCH = $tmp;
                $res ? 0 : 1
            }) && ('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"})))
        }) && (do {
            my $m2 = Perlito5::Grammar::String::tr_quote_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"tr_quote_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = ["term", Perlito5::Match::flat($MATCH->{"tr_quote_parse"})];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::String::term_qr_quote {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((("q" eq $str->[($MATCH->{"to"}) + 0]) && ("r" eq $str->[($MATCH->{"to"}) + 1]) && ($MATCH->{"to"} += 2)) && (do {
            my $tmp790 = $MATCH->{"to"};
            ((("#" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp790, ((do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $tmp = $MATCH;
                $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
                my $res = (("=" eq $str->[($MATCH->{"to"}) + 0]) && (">" eq $str->[($MATCH->{"to"}) + 1]) && ($MATCH->{"to"} += 2));
                $MATCH = $tmp;
                $res ? 0 : 1
            }) && ('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"})))
        }) && (do {
            my $m2 = Perlito5::Grammar::String::qr_quote_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"qr_quote_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = ["term", Perlito5::Match::flat($MATCH->{"qr_quote_parse"})];
            1
        })));
        $tmp ? $MATCH : undef
    }
    our $unicode_table;
    sub Perlito5::Grammar::String::get_unicode_table {
        !$unicode_table && ($unicode_table = Perlito5::Grammar::Use::slurp_file("unicore/UnicodeData.txt"));
        return $unicode_table
    }
    my %pair = ("{", "}", "(", ")", "[", "]", "<", ">");
    my %escape_sequence = ("a", 7, "b", 8, "e", 27, "f", 12, "n", 10, "r", 13, "t", 9);
    my %hex = map(+($_, 1), 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "A", "B", "C", "D", "E", "F");
    my %octal = map(+($_, 1), 0, 1, 2, 3, 4, 5, 6, 7);
    sub Perlito5::Grammar::String::q_quote_parse {
        my $str = $_[0];
        my $pos = $_[1];
        my $delimiter = $str->[$pos - 1];
        my $open_delimiter = $delimiter;
        exists($pair{$delimiter}) && ($delimiter = $pair{$delimiter});
        return Perlito5::Grammar::String::string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 0)
    }
    sub Perlito5::Grammar::String::qq_quote_parse {
        my $str = $_[0];
        my $pos = $_[1];
        my $delimiter = $str->[$pos - 1];
        my $open_delimiter = $delimiter;
        exists($pair{$delimiter}) && ($delimiter = $pair{$delimiter});
        return Perlito5::Grammar::String::string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 1)
    }
    sub Perlito5::Grammar::String::qw_quote_parse {
        my $str = $_[0];
        my $pos = $_[1];
        my $delimiter = $str->[$pos - 1];
        my $open_delimiter = $delimiter;
        exists($pair{$delimiter}) && ($delimiter = $pair{$delimiter});
        my $m = Perlito5::Grammar::String::string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 0);
        if ($m) {;
            $m->{"capture"} = Perlito5::AST::Apply::->new("code", "list:<,>", "arguments", [map(Perlito5::AST::Buf::->new("buf", $_), split(" ", Perlito5::Match::flat($m)->{"buf"}))], "namespace", '')
        }
        return $m
    }
    sub Perlito5::Grammar::String::m_quote_parse {
        my $str = $_[0];
        my $pos = $_[1];
        my $delimiter = $str->[$pos - 1];
        my $open_delimiter = $delimiter;
        my $closing_delimiter = $delimiter;
        exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
        my $interpolate = 2;
        $delimiter eq "'" && ($interpolate = 3);
        my $part1 = Perlito5::Grammar::String::string_interpolation_parse($str, $pos, $open_delimiter, $closing_delimiter, $interpolate);
        $part1 || return $part1;
        my $str_regex = $part1->{"capture"};
        my $p = $part1->{"to"};
        my $modifiers = '';
        my $m = Perlito5::Grammar::ident($str, $p);
        if ($m) {
            $modifiers = Perlito5::Match::flat($m);
            $part1->{"to"} = $m->{"to"}
        }
        $part1->{"capture"} = Perlito5::AST::Apply::->new("code", "p5:m", "arguments", [$str_regex, Perlito5::AST::Buf::->new("buf", $modifiers), Perlito5::AST::Var::SCALAR_ARG()], "namespace", '');
        return $part1
    }
    sub Perlito5::Grammar::String::s_quote_parse {
        my $str = $_[0];
        my $pos = $_[1];
        my $delimiter = $str->[$pos - 1];
        my $open_delimiter = $delimiter;
        my $closing_delimiter = $delimiter;
        exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
        my $interpolate = 2;
        $delimiter eq "'" && ($interpolate = 3);
        my $part1 = Perlito5::Grammar::String::string_interpolation_parse($str, $pos, $open_delimiter, $closing_delimiter, $interpolate);
        $part1 || return $part1;
        my $str_regex = Perlito5::Match::flat($part1);
        my $part2;
        my $m;
        my $p = $part1->{"to"};
        if (exists($pair{$delimiter})) {
            $m = Perlito5::Grammar::Space::opt_ws($str, $p);
            $p = $m->{"to"};
            $delimiter = $str->[$p];
            $open_delimiter = $delimiter;
            $p++;
            $closing_delimiter = $delimiter;
            exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter})
        }
        $part2 = Perlito5::Grammar::String::string_interpolation_parse($str, $p, $open_delimiter, $closing_delimiter, 0);
        $part2 || return $part2;
        my @replace = @{$str}[$p .. ($part2->{"to"}) - 2];
        my $replace;
        $p = $part2->{"to"};
        my $modifiers = '';
        $m = Perlito5::Grammar::ident($str, $p);
        if ($m) {;
            $modifiers = Perlito5::Match::flat($m)
        }
        if ($modifiers =~ m/e/) {
            my $m = Perlito5::Grammar::block(["{", @replace, "}"], 0);
            if (!$m) {;
                Perlito5::Compiler::error("syntax error")
            }
            $replace = Perlito5::Match::flat($m);
            if ($modifiers =~ m/ee/) {;
                $replace = Perlito5::AST::Block::->new("sig", undef, "stmts", [Perlito5::AST::Apply::->new("code", "eval", "arguments", [Perlito5::AST::Apply::->new("code", "do", "arguments", [$replace])], "bareword", '', "namespace", '')])
            }
        }
        else {
            $interpolate = 1;
            $delimiter eq chr(39) && ($interpolate = 3);
            my $m = Perlito5::Grammar::String::string_interpolation_parse([$open_delimiter, @replace, $closing_delimiter], 1, $open_delimiter, $closing_delimiter, $interpolate);
            if (!$m) {;
                Perlito5::Compiler::error("syntax error")
            }
            $replace = Perlito5::Match::flat($m)
        }
        if ($m) {;
            $part2->{"to"} = $m->{"to"}
        }
        $part2->{"capture"} = Perlito5::AST::Apply::->new("code", "p5:s", "arguments", [$str_regex, $replace, Perlito5::AST::Buf::->new("buf", $modifiers), Perlito5::AST::Var::SCALAR_ARG()], "namespace", '');
        return $part2
    }
    sub Perlito5::Grammar::String::qr_quote_parse {
        my $str = $_[0];
        my $pos = $_[1];
        my $delimiter = $str->[$pos - 1];
        my $open_delimiter = $delimiter;
        my $closing_delimiter = $delimiter;
        exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
        my $interpolate = 2;
        $delimiter eq "'" && ($interpolate = 3);
        my $part1 = Perlito5::Grammar::String::string_interpolation_parse($str, $pos, $open_delimiter, $closing_delimiter, $interpolate);
        $part1 || return $part1;
        my $str_regex = $part1->{"capture"};
        my $p = $part1->{"to"};
        my $modifiers = '';
        my $m = Perlito5::Grammar::ident($str, $p);
        if ($m) {
            $modifiers = Perlito5::Match::flat($m);
            $part1->{"to"} = $m->{"to"}
        }
        $part1->{"capture"} = Perlito5::AST::Apply::->new("code", "p5:qr", "arguments", [$str_regex, Perlito5::AST::Buf::->new("buf", $modifiers)], "namespace", '');
        return $part1
    }
    sub Perlito5::Grammar::String::qx_quote_parse {
        my $str = $_[0];
        my $pos = $_[1];
        my $delimiter = $str->[$pos - 1];
        my $open_delimiter = $delimiter;
        exists($pair{$delimiter}) && ($delimiter = $pair{$delimiter});
        my $m = Perlito5::Grammar::String::string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 0);
        if ($m) {;
            $m->{"capture"} = Perlito5::AST::Apply::->new("code", "qx", "arguments", [Perlito5::Match::flat($m)], "namespace", '')
        }
        return $m
    }
    sub Perlito5::Grammar::String::glob_quote_parse {
        my $str = $_[0];
        my $pos = $_[1];
        my $delimiter = $str->[$pos - 1];
        my $open_delimiter = $delimiter;
        exists($pair{$delimiter}) && ($delimiter = $pair{$delimiter});
        if ($str->[$pos] eq "<" && $str->[$pos + 1] eq ">" && $str->[$pos + 2] eq ">") {;
            return {"str" => $str, "from" => $pos, "to" => $pos + 3, "capture" => Perlito5::AST::Apply::->new("code", "readline", "arguments", [Perlito5::AST::Apply::->new("code", "<>", "arguments", [], "namespace", '', "bareword", 1)], "namespace", ''), }
        }
        if ($str->[$pos] eq ">") {;
            return {"str" => $str, "from" => $pos, "to" => $pos + 1, "capture" => Perlito5::AST::Apply::->new("code", "readline", "arguments", [], "namespace", ''), }
        }
        my $p = $pos;
        my $sigil = "::";
        if ($str->[$p] eq "\$") {
            $sigil = "\$";
            $p++
        }
        my $m_namespace = Perlito5::Grammar::optional_namespace_before_ident($str, $p);
        my $namespace = Perlito5::Match::flat($m_namespace);
        $p = $m_namespace->{"to"};
        my $m_name = Perlito5::Grammar::ident($str, $p);
        if ($m_name && $str->[$m_name->{"to"}] eq ">") {
            if ($sigil eq "::") {;
                return {"str" => $str, "from" => $pos, "to" => ($m_name->{"to"}) + 1, "capture" => Perlito5::AST::Apply::->new("code", "readline", "arguments", [Perlito5::AST::Apply::->new("code", Perlito5::Match::flat($m_name), "arguments", [], "namespace", $namespace, "bareword", 1)], "namespace", ''), }
            }
            return {"str" => $str, "from" => $pos, "to" => ($m_name->{"to"}) + 1, "capture" => Perlito5::AST::Apply::->new("code", "readline", "arguments", [Perlito5::AST::Var::->new("sigil", $sigil, "name", Perlito5::Match::flat($m_name), "namespace", $namespace)], "namespace", ''), }
        }
        my $m = Perlito5::Grammar::String::string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 1);
        if ($m) {;
            $m->{"capture"} = Perlito5::AST::Apply::->new("code", "glob", "arguments", [Perlito5::Match::flat($m)], "namespace", '')
        }
        return $m
    }
    sub Perlito5::Grammar::String::tr_quote_parse {
        my $str = $_[0];
        my $pos = $_[1];
        my $delimiter = $str->[$pos - 1];
        my $open_delimiter = $delimiter;
        my $closing_delimiter = $delimiter;
        exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
        my $interpolate = 2;
        $delimiter eq "'" && ($interpolate = 3);
        my $part1 = Perlito5::Grammar::String::string_interpolation_parse($str, $pos, $open_delimiter, $closing_delimiter, $interpolate);
        $part1 || return $part1;
        my $str_regex = Perlito5::Match::flat($part1);
        my $part2;
        my $m;
        my $p = $part1->{"to"};
        if (exists($pair{$delimiter})) {
            $m = Perlito5::Grammar::Space::opt_ws($str, $p);
            $p = $m->{"to"};
            $delimiter = $str->[$p];
            my $open_delimiter = $delimiter;
            $p++;
            $closing_delimiter = $delimiter;
            exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
            $interpolate = 2;
            $delimiter eq "'" && ($interpolate = 3);
            $part2 = Perlito5::Grammar::String::string_interpolation_parse($str, $p, $open_delimiter, $closing_delimiter, $interpolate);
            $part2 || return $part2
        }
        else {
            $part2 = Perlito5::Grammar::String::string_interpolation_parse($str, $p, $open_delimiter, $closing_delimiter, $interpolate);
            $part2 || return $part2
        }
        $p = $part2->{"to"};
        my $modifiers = '';
        $m = Perlito5::Grammar::ident($str, $p);
        if ($m) {
            $modifiers = Perlito5::Match::flat($m);
            $part2->{"to"} = $m->{"to"}
        }
        $part2->{"capture"} = Perlito5::AST::Apply::->new("code", "p5:tr", "arguments", [$str_regex, Perlito5::Match::flat($part2), Perlito5::AST::Buf::->new("buf", $modifiers), Perlito5::AST::Var::SCALAR_ARG()], "namespace", '');
        return $part2
    }
    sub Perlito5::Grammar::String::apply_quote_flags {
        (my $c, my $quote_flags) = @_;
        length($c) || return $c;
        if ($quote_flags->{"l"}) {
            $c = lcfirst($c);
            delete($quote_flags->{"l"})
        }
        if ($quote_flags->{"u"}) {
            $c = ucfirst($c);
            delete($quote_flags->{"u"})
        }
        $quote_flags->{"L"} && ($c = lc($c));
        $quote_flags->{"U"} && ($c = uc($c));
        $quote_flags->{"Q"} && ($c = quotemeta($c));
        return $c
    }
    sub Perlito5::Grammar::String::string_interpolation_parse {
        my $str = $_[0];
        my $pos = $_[1];
        my $open_delimiter = $_[2];
        my $delimiter = $_[3];
        my $interpolate = $_[4];
        my $quote_flags = $_[5] || {};
        my $interpolate_vars = ($interpolate == 1 || $interpolate == 2);
        my $p = $pos;
        my $balanced = $open_delimiter && exists($pair{$open_delimiter});
        my @args;
        my $buf = '';
        my $d1 = substr($delimiter, 0, 1);
        while ($p < @{$str} && !($str->[$p] eq $d1 && join('', @{$str}[$p .. ($p + length($delimiter)) - 1]) eq $delimiter)) {
            my $c = $str->[$p];
            my $c2 = $str->[$p + 1];
            my $m;
            my $more = '';
            if ($c eq "\\" && $c2 eq $delimiter) {
                $p++;
                $c = $c2
            }
            elsif ($balanced && $c eq "\\" && ($c2 eq $open_delimiter || $c2 eq $delimiter)) {
                $p++;
                $c = $c2
            }
            elsif ($balanced && $c eq $open_delimiter) {
                $buf .= $c;
                $p++;
                $m = Perlito5::Grammar::String::string_interpolation_parse($str, $p, $open_delimiter, $delimiter, $interpolate, $quote_flags);
                $more = $delimiter
            }
            elsif ($interpolate_vars && ($c eq "\$" || $c eq "\@")) {
                my $match = Perlito5::Grammar::String::double_quoted_var($str, $p, $delimiter, $interpolate);
                if ($match) {
                    my $ast = $match->{"capture"};
                    if ($quote_flags->{"l"}) {
                        $ast = Perlito5::AST::Apply::->new("namespace", '', "code", "lcfirst", "arguments", [$ast]);
                        delete($quote_flags->{"l"})
                    }
                    if ($quote_flags->{"u"}) {
                        $ast = Perlito5::AST::Apply::->new("namespace", '', "code", "ucfirst", "arguments", [$ast]);
                        delete($quote_flags->{"u"})
                    }
                    $quote_flags->{"L"} && ($ast = Perlito5::AST::Apply::->new("namespace", '', "code", "lc", "arguments", [$ast]));
                    $quote_flags->{"U"} && ($ast = Perlito5::AST::Apply::->new("namespace", '', "code", "uc", "arguments", [$ast]));
                    $quote_flags->{"Q"} && ($ast = Perlito5::AST::Apply::->new("namespace", '', "code", "quotemeta", "arguments", [$ast]));
                    $match->{"capture"} = $ast
                }
                $m = $match
            }
            elsif ($c eq "\\") {
                if ($interpolate) {
                    if ($c2 eq "E") {
                        my $flag_to_reset = $quote_flags->{"last_flag"};
                        if ($flag_to_reset) {
                            delete($quote_flags->{$flag_to_reset});
                            delete($quote_flags->{"last_flag"})
                        }
                        else {;
                            $quote_flags = {}
                        }
                        $p += 1;
                        $c = ''
                    }
                    elsif ($c2 eq "L") {
                        $quote_flags->{$c2} = 1;
                        delete($quote_flags->{"U"});
                        $quote_flags->{"last_flag"} = $c2;
                        $p += 1;
                        $c = ''
                    }
                    elsif ($c2 eq "U") {
                        $quote_flags->{$c2} = 1;
                        delete($quote_flags->{"L"});
                        $quote_flags->{"last_flag"} = $c2;
                        $p += 1;
                        $c = ''
                    }
                    elsif ($c2 eq "Q") {
                        $quote_flags->{$c2} = 1;
                        $quote_flags->{"last_flag"} = $c2;
                        $p += 1;
                        $c = ''
                    }
                    elsif ($c2 eq "l") {
                        $quote_flags->{"u"} || ($quote_flags->{$c2} = 1);
                        $p += 1;
                        $c = ''
                    }
                    elsif ($c2 eq "u") {
                        $quote_flags->{"l"} || ($quote_flags->{$c2} = 1);
                        $p += 1;
                        $c = ''
                    }
                }
                if ($c) {
                    if ($interpolate == 2) {;
                        $m = {"str" => $str, "from" => $p, "to" => $p + 2, "capture" => Perlito5::AST::Buf::->new("buf", ($str->[$p]) . ($str->[$p + 1])), }
                    }
                    elsif ($interpolate == 1) {;
                        $m = Perlito5::Grammar::String::double_quoted_unescape($str, $p)
                    }
                    else {;
                        $m = $c2 eq "\\" ? {"str" => $str, "from" => $p, "to" => $p + 2, "capture" => Perlito5::AST::Buf::->new("buf", "\\"), } : $c2 eq "'" ? {"str" => $str, "from" => $p, "to" => $p + 2, "capture" => Perlito5::AST::Buf::->new("buf", "'"), } : 0
                    }
                }
            }
            if ($m) {
                my $obj = Perlito5::Match::flat($m);
                if (ref($obj) eq "Perlito5::AST::Buf") {
                    $buf .= Perlito5::Grammar::String::apply_quote_flags($obj->{"buf"}, $quote_flags);
                    $obj = undef
                }
                if ($obj) {
                    if (length($buf)) {
                        push(@args, Perlito5::AST::Buf::->new("buf", $buf));
                        $buf = ''
                    }
                    push(@args, $obj)
                }
                $p = $m->{"to"};
                $buf .= $more
            }
            else {
                $p++;
                if ($c eq chr(10) || $c eq chr(13)) {
                    my $m = Perlito5::Grammar::String::here_doc($str, $p);
                    if ($p != $m->{"to"}) {;
                        $p = $m->{"to"}
                    }
                    else {;
                        $buf .= Perlito5::Grammar::String::apply_quote_flags($c, $quote_flags)
                    }
                }
                else {;
                    $buf .= Perlito5::Grammar::String::apply_quote_flags($c, $quote_flags)
                }
            }
        }
        if (length($buf)) {;
            push(@args, Perlito5::AST::Buf::->new("buf", $buf))
        }
        join('', @{$str}[$p .. ($p + length($delimiter)) - 1]) ne $delimiter && Perlito5::Compiler::error("Can't find string terminator '" . $delimiter . "' anywhere before EOF");
        $p += length($delimiter);
        my $ast;
        if (!@args) {;
            $ast = Perlito5::AST::Buf::->new("buf", '')
        }
        elsif (@args == 1 && ref($args[0]) eq "Perlito5::AST::Buf") {;
            $ast = $args[0]
        }
        else {
            @args == 1 && unshift(@args, Perlito5::AST::Buf::->new("buf", ''));
            $ast = Perlito5::AST::Apply::->new("namespace", '', "code", "list:<.>", "arguments", \@args, Perlito5::overloading_flag())
        }
        return {"str" => $str, "from" => $pos, "to" => $p, "capture" => $ast, }
    }
    our @Here_doc;
    sub Perlito5::Grammar::String::here_doc_wanted {
        my $str = $_[0];
        my $pos = $_[1];
        my $delimiter;
        my $type = "double_quote";
        my $indented = 0;
        my $p = $pos;
        if ($str->[$p] eq "<" && $str->[$p + 1] eq "<") {
            $p += 2;
            my $quote = $str->[$p];
            if ($quote eq "~") {
                $indented = 1;
                $p++;
                $quote = $str->[$p]
            }
            if ($quote eq "'" || $quote eq "\"") {
                $p += 1;
                my $m = Perlito5::Grammar::String::string_interpolation_parse($_[0], $p, $quote, $quote, 0);
                if ($m) {
                    $p = $m->{"to"};
                    $delimiter = Perlito5::Match::flat($m)->{"buf"};
                    $type = $quote eq "'" ? "single_quote" : "double_quote"
                }
            }
            else {
                $quote eq "\\" && ($p += 1);
                my $m = Perlito5::Grammar::ident($str, $p);
                if ($m) {
                    $p = $m->{"to"};
                    $delimiter = Perlito5::Match::flat($m);
                    $type = $quote eq "\\" ? "single_quote" : "double_quote"
                }
                else {
                    $Perlito5::WARNINGS && warn("Use of bare << to mean <<\"\" is deprecated");
                    $delimiter = '';
                    $type = "double_quote"
                }
            }
        }
        if (!defined($delimiter)) {;
            return 0
        }
        my $placeholder = Perlito5::AST::Apply::->new("code", "list:<.>", "namespace", '', "arguments", [Perlito5::AST::Apply::->new("code", "list:<.>", "namespace", '', "arguments", [])]);
        push(@Here_doc, [$type, $placeholder->{"arguments"}->[0]->{"arguments"}, $delimiter, $indented]);
        return {"str" => $str, "from" => $pos, "to" => $p, "capture" => ["term", $placeholder], }
    }
    sub Perlito5::Grammar::String::newline {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = ((do {
            my $tmp919 = $MATCH->{"to"};
            (((("
" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $m = $MATCH;
                if (!(("\x{d}" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) {;
                    $MATCH = $m
                }
                1
            }))) || ($MATCH->{"to"} = $tmp919, ((("\x{d}" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $m = $MATCH;
                if (!(("
" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) {;
                    $MATCH = $m
                }
                1
            })))
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::String::here_doc {
        my $str = $_[0];
        my $pos = $_[1];
        if (!@Here_doc) {;
            return {"str" => $str, "from" => $pos, "to" => $pos, }
        }
        my $p = $pos;
        my $here = shift(@Here_doc);
        my $type = $here->[0];
        my $result = $here->[1];
        my $delimiter = $here->[2];
        my $indented = $here->[3];
        while ($p < @{$str}) {
            my $spaces = '';
            my $p0 = $p;
            if ($indented) {
                while ($p < @{$str}) {
                    $str->[$p] ne " " && $str->[$p] ne "\x{9}" && last;
                    $p++
                }
                $spaces = join('', @{$str}[$p0 .. $p - 1])
            }
            if (join('', @{$str}[$p .. ($p + length($delimiter)) - 1]) eq $delimiter) {
                my $c = $str->[$p + length($delimiter)];
                if ($c eq '' || $c eq " " || $c eq "\x{9}" || $c eq chr(10) || $c eq chr(13)) {
                    my @here_string = split("
", join('', @{$str}[$pos .. $p - 1]), -1);
                    if (length($spaces)) {
                        my $l = length($spaces);
                        for my $i (0 .. $#here_string) {
                            if (substr($here_string[$i], 0, $l) eq $spaces) {;
                                $here_string[$i] = substr($here_string[$i], $l)
                            }
                            else {;
                                Perlito5::Compiler::error("Indentation on line " . $i . " of here-doc doesn't match delimiter")
                            }
                        }
                    }
                    if ($type eq "single_quote") {;
                        push(@{$result}, Perlito5::AST::Buf::->new("buf", join("
", @here_string)))
                    }
                    else {
                        my $m;
                        my $str = [split('', join("
", @here_string, $delimiter . "
"))];
                        $m = Perlito5::Grammar::String::string_interpolation_parse($str, 0, '', "
" . $delimiter . "
", 1);
                        if ($m) {;
                            push(@{$result}, Perlito5::Match::flat($m))
                        }
                        else {;
                            Perlito5::Compiler::error("Can't find string terminator \"" . $delimiter . "\" anywhere before EOF")
                        }
                    }
                    $p += length($delimiter);
                    my $m = Perlito5::Grammar::String::newline($str, $p);
                    if ($p >= @{$str} || $m) {
                        $m && ($p = $m->{"to"});
                        return {"str" => $str, "from" => $pos, "to" => $p - 1, }
                    }
                }
            }
            while ($p < @{$str} && ($str->[$p] ne chr(10) && $str->[$p] ne chr(13))) {;
                $p++
            }
            while ($p < @{$str} && ($str->[$p] eq chr(10) || $str->[$p] eq chr(13))) {;
                $p++
            }
        }
        Perlito5::Compiler::error("Can't find string terminator \"" . $delimiter . "\" anywhere before EOF")
    }
    sub Perlito5::Grammar::String::double_quoted_unescape {
        my $str = $_[0];
        my $pos = $_[1];
        my $c2 = $str->[$pos + 1];
        my $m;
        if (exists($escape_sequence{$c2})) {;
            $m = {"str" => $str, "from" => $pos, "to" => $pos + 2, "capture" => Perlito5::AST::Buf::->new("buf", chr($escape_sequence{$c2})), }
        }
        elsif ($c2 eq "c") {
            my $c3 = (ord(uc($str->[$pos + 2])) - ord("A")) + 1;
            $c3 < 0 && ($c3 = 128 + $c3);
            $m = {"str" => $str, "from" => $pos, "to" => $pos + 3, "capture" => Perlito5::AST::Buf::->new("buf", chr($c3)), }
        }
        elsif ($c2 eq "x") {
            if ($str->[$pos + 2] eq "{") {
                my $p = $pos + 3;
                $p++
                    while $p < @{$str} && $str->[$p] ne "}";
                my $hex_code = join('', @{$str}[$pos + 3 .. $p - 1]);
                $hex_code || ($hex_code = 0);
                my $tmp = oct("0x" . $hex_code);
                $m = {"str" => $str, "from" => $pos, "to" => $p + 1, "capture" => Perlito5::AST::Buf::->new("buf", chr($tmp)), }
            }
            else {
                my $p = $pos + 2;
                $hex{uc($str->[$p])} && $p++;
                $hex{uc($str->[$p])} && $p++;
                my $hex_code = join('', @{$str}[$pos + 2 .. $p - 1]);
                $hex_code || ($hex_code = 0);
                my $tmp = oct("0x" . $hex_code);
                $m = {"str" => $str, "from" => $pos, "to" => $p, "capture" => Perlito5::AST::Buf::->new("buf", chr($tmp)), }
            }
        }
        elsif (exists($octal{$c2})) {
            my $p = $pos + 1;
            $octal{$str->[$p]} && $p++;
            $octal{$str->[$p]} && $p++;
            $octal{$str->[$p]} && $p++;
            my $oct_code = join('', @{$str}[$pos + 1 .. $p - 1]);
            my $tmp = oct($oct_code);
            $m = {"str" => $str, "from" => $pos, "to" => $p, "capture" => Perlito5::AST::Buf::->new("buf", chr($tmp)), }
        }
        elsif ($c2 eq "N") {;
            if ($str->[$pos + 2] eq "{") {
                if ($str->[$pos + 3] eq "U" && $str->[$pos + 4] eq "+") {
                    my $p = $pos + 5;
                    $p++
                        while $p < @{$str} && $str->[$p] ne "}";
                    my $hex_code = join('', @{$str}[$pos + 5 .. $p - 1]);
                    $hex_code || ($hex_code = 0);
                    my $tmp = oct("0x" . $hex_code);
                    $m = {"str" => $str, "from" => $pos, "to" => $p + 1, "capture" => Perlito5::AST::Buf::->new("buf", chr($tmp)), }
                }
                else {
                    my $p = $pos + 3;
                    $p++
                        while $p < @{$str} && $str->[$p] ne "}";
                    my $name = join('', @{$str}[$pos + 3 .. $p - 1]);
                    (my $hex_code) = Perlito5::Grammar::String::get_unicode_table() =~ m/\n([0-9A-Z]+);$name;/;
                    !$hex_code && Perlito5::Compiler::error("Unknown charname '" . $name . "'");
                    my $tmp = oct("0x" . $hex_code);
                    $m = {"str" => $str, "from" => $pos, "to" => $p + 1, "capture" => Perlito5::AST::Buf::->new("buf", chr($tmp)), }
                }
            }
        }
        else {;
            $m = {"str" => $str, "from" => $pos, "to" => $pos + 2, "capture" => Perlito5::AST::Buf::->new("buf", $c2), }
        }
        return $m
    }
    sub Perlito5::Grammar::String::double_quoted_var_with_subscript {
        my $m_var = $_[0];
        my $interpolate = $_[1];
        my $str = $m_var->{"str"};
        my $pos = $m_var->{"to"};
        my $p = $pos;
        my $m_index;
        if ($str->[$p] eq "-" && $str->[$p + 1] eq ">" && $str->[$p + 2] eq "[") {
            $p += 3;
            $m_index = Perlito5::Grammar::Expression::list_parse($str, $p);
            $m_index || Perlito5::Compiler::error("syntax error");
            my $exp = $m_index->{"capture"};
            $p = $m_index->{"to"};
            ($exp eq "*undef*" || $str->[$p] ne "]") && Perlito5::Compiler::error("syntax error");
            $p++;
            $m_index->{"capture"} = Perlito5::AST::Call::->new("method", "postcircumfix:<[ ]>", "invocant", $m_var->{"capture"}, "arguments", $exp);
            $m_index->{"to"} = $p;
            return Perlito5::Grammar::String::double_quoted_var_with_subscript($m_index, $interpolate)
        }
        if ($str->[$p] eq "-" && $str->[$p + 1] eq ">" && $str->[$p + 2] eq "{") {
            $pos += 2;
            $m_index = Perlito5::Grammar::Expression::term_curly($str, $pos);
            $m_index || Perlito5::Compiler::error("syntax error");
            $m_index->{"capture"} = Perlito5::AST::Call::->new("method", "postcircumfix:<{ }>", "invocant", $m_var->{"capture"}, "arguments", Perlito5::Match::flat($m_index)->[2]->[0]);
            return Perlito5::Grammar::String::double_quoted_var_with_subscript($m_index, $interpolate)
        }
        if ($str->[$p] eq "[") {
            if ($interpolate == 2) {
                my $m = Perlito5::Grammar::Number::term_digit($str, $p + 1) || ($str->[$p + 1] eq "-" && Perlito5::Grammar::Number::term_digit($str, $p + 2)) || Perlito5::Grammar::Sigil::term_sigil($str, $p + 1);
                $m || return $m_var;
                $str->[$m->{"to"}] eq "]" || return $m_var
            }
            $p++;
            $m_index = Perlito5::Grammar::Expression::list_parse($str, $p);
            if ($m_index) {
                my $exp = $m_index->{"capture"};
                $p = $m_index->{"to"};
                if ($exp ne "*undef*" && $str->[$p] eq "]") {
                    $p++;
                    my $value = $m_var->{"capture"};
                    if (ref($value) eq "Perlito5::AST::Var") {;
                        $value->{"_real_sigil"} = "\@"
                    }
                    $m_index->{"capture"} = Perlito5::AST::Index::->new("obj", $value, "index_exp", $exp);
                    $m_index->{"to"} = $p;
                    return Perlito5::Grammar::String::double_quoted_var_with_subscript($m_index, $interpolate)
                }
            }
        }
        $m_index = Perlito5::Grammar::Expression::term_curly($str, $pos);
        if ($m_index) {
            my $value = $m_var->{"capture"};
            if (ref($value) eq "Perlito5::AST::Var") {;
                $value->{"_real_sigil"} = "%"
            }
            $m_index->{"capture"} = Perlito5::AST::Lookup::->new("obj", $value, "index_exp", Perlito5::Match::flat($m_index)->[2]->[0]);
            return Perlito5::Grammar::String::double_quoted_var_with_subscript($m_index, $interpolate)
        }
        return $m_var
    }
    sub Perlito5::Grammar::String::double_quoted_var {
        my $str = $_[0];
        my $pos = $_[1];
        my $delimiter = $_[2];
        my $interpolate = $_[3];
        my $c = $str->[$pos];
        my $c2 = $str->[$pos + 1];
        if ($c eq "\$" && $c2 eq ")") {;
            return 0
        }
        elsif ($c eq "\$" && $c2 eq "{") {
            my $m = Perlito5::Grammar::Sigil::term_sigil($str, $pos);
            $m || return $m;
            my $var = Perlito5::Match::flat($m)->[1];
            $m->{"capture"} = $var;
            return $m
        }
        elsif ($c eq "\$" && $c2 eq "\$" && !Perlito5::Grammar::word($str, $pos + 2)) {;
            return {"str" => $str, "capture" => Perlito5::AST::Var::->new("name", "\$", "sigil", "\$", "namespace", ''), "from" => $pos, "to" => $pos + 2, }
        }
        elsif ($c eq "\$" && join('', @{$str}[$pos + 1 .. $pos + length($delimiter)]) ne $delimiter) {
            my $m = Perlito5::Grammar::Sigil::term_sigil($str, $pos);
            $m || return $m;
            $m->{"capture"} = $m->{"capture"}->[1];
            return Perlito5::Grammar::String::double_quoted_var_with_subscript($m, $interpolate)
        }
        elsif ($c eq "\@" && join('', @{$str}[$pos + 1 .. $pos + length($delimiter)]) ne $delimiter && ($c2 lt 0 || $c2 gt 9)) {
            my $m = Perlito5::Grammar::Sigil::term_sigil($str, $pos);
            $m || return $m;
            $m->{"capture"} = $m->{"capture"}->[1];
            $m = Perlito5::Grammar::String::double_quoted_var_with_subscript($m, $interpolate);
            $m->{"capture"} = Perlito5::AST::Apply::->new("code", "join", "arguments", [Perlito5::AST::Var::->new("name", "\"", "sigil", "\$", "namespace", ''), $m->{"capture"}], "namespace", '');
            return $m
        }
        return 0
    }
    Perlito5::Grammar::Precedence::add_term("'", \&term_q_quote);
    Perlito5::Grammar::Precedence::add_term("\"", \&term_qq_quote);
    Perlito5::Grammar::Precedence::add_term("/", \&term_m_quote);
    Perlito5::Grammar::Precedence::add_term("<", \&term_glob);
    Perlito5::Grammar::Precedence::add_term("<<>>", \&term_glob);
    Perlito5::Grammar::Precedence::add_term("<<", \&here_doc_wanted);
    Perlito5::Grammar::Precedence::add_term("`", \&term_qx);
    Perlito5::Grammar::Precedence::add_term("m", \&term_m_quote);
    Perlito5::Grammar::Precedence::add_term("q", \&term_q_quote);
    Perlito5::Grammar::Precedence::add_term("qq", \&term_qq_quote);
    Perlito5::Grammar::Precedence::add_term("qw", \&term_qw_quote);
    Perlito5::Grammar::Precedence::add_term("qx", \&term_qx);
    Perlito5::Grammar::Precedence::add_term("qr", \&term_qr_quote);
    Perlito5::Grammar::Precedence::add_term("s", \&term_s_quote);
    Perlito5::Grammar::Precedence::add_term("tr", \&term_tr_quote);
    Perlito5::Grammar::Precedence::add_term("y", \&term_tr_quote);
    1
}
{
    package main;
    package Perlito5::Grammar::Sigil;
    my %special_var = ("\$_", '', "\$&", '', "\$`", '', "\$'", '', "\$+", '', "\@+", '', "%+", '', "\$.", '', "\$/", '', "\$|", '', "\$,", '', "\$\\", '', "\$\"", '', "\$;", '', "\$%", '', "\$=", '', "\$-", '', "\@-", '', "%-", '', "\$~", '', "\$^", '', "\$:", '', "\$?", '', "\$!", '', "%!", '', "\$\@", '', "\$\$", '', "\$<", '', "\$>", '', "\$(", '', "\$)", '', "\$[", '', "\$]", '', "\$}", '', "\@_", '', "*_", '', "*&", '', "*`", '', "*'", '', "*+", '', "*.", '', "*/", '', "*|", '', "*,", '', "*\\", '', "*\"", '', "*;", '', "*%", '', "*=", '', "*-", '', "*~", '', "*^", '', "*:", '', "*?", '', "*!", '', "*\@", '', "*\$", '', "*<", '', "*>", '', "*(", '', "*)", '', "*[", '', "*]", '', "*_", '', "**", '', "*#", '', "\$#+", '', "\$#-", '', "\$#_", '');
    sub Perlito5::Grammar::Sigil::term_special_var {
        my $str = $_[0];
        my $pos = $_[1];
        my $len = 0;
        my $s = ($str->[$pos]) . ($str->[$pos + 1]) . ($str->[$pos + 2]);
        if ($s eq "\$#[") {;
            $len = 2
        }
        elsif (exists($special_var{$s})) {;
            $len = length($s)
        }
        else {
            $s = ($str->[$pos]) . ($str->[$pos + 1]);
            if (exists($special_var{$s})) {;
                $len = 2
            }
        }
        if ($len) {
            my $c0 = $str->[($pos + $len) - 1];
            my $c1 = $str->[$pos + $len];
            if (($Perlito5::Grammar::is_var_sigil{$c0}) && ($Perlito5::Grammar::is_var_sigil{$c1} || $Perlito5::Grammar::is_ident_middle{$c1})) {}
            else {;
                return {"str" => $str, "from" => $pos, "to" => $pos + $len, "capture" => ["term", Perlito5::AST::Var::->new("sigil", substr($s, 0, $len - 1), "namespace", $special_var{$s}, "name", substr($s, $len - 1, 1), "_namespace", "main")], }
            }
        }
        return 0
    }
    my %sigil = ("\$", 1, "%", 1, "\@", 1, "&", 1, "*", 1);
    sub Perlito5::Grammar::Sigil::term_sigil {
        my $str = $_[0];
        my $pos = $_[1];
        my $c1 = $str->[$pos];
        exists($sigil{$c1}) || return;
        my $p = $pos + 1;
        my $sigil = $c1;
        if ($c1 eq "\$" && $str->[$pos + 1] eq "#") {
            $sigil = "\$#";
            $p++
        }
        my $m = Perlito5::Grammar::Space::opt_ws($str, $p);
        $p = $m->{"to"};
        my $p0 = $p;
        $c1 = $str->[$p];
        my $q = $p + 1;
        if ($c1 eq "{") {
            my $p = $q;
            $m = Perlito5::Grammar::Space::opt_ws($str, $p);
            $p = $m->{"to"};
            $m = Perlito5::Grammar::optional_namespace_before_ident($str, $p);
            if ($m) {
                my $namespace = Perlito5::Match::flat($m);
                my $pos = $m->{"to"};
                my $n = Perlito5::Grammar::var_name($str, $m->{"to"});
                my $name;
                if ($n) {
                    $name = Perlito5::Match::flat($n);
                    $pos = $n->{"to"}
                }
                if (($namespace || $name) && !(($namespace eq "CORE" || $namespace eq '') && ($name eq "sub"))) {
                    my $spc = Perlito5::Grammar::Space::opt_ws($str, $pos);
                    my $pos = $spc->{"to"};
                    if ($str->[$pos] eq "{" || $str->[$pos] eq "[" || $str->[$pos] eq "}") {
                        $m->{"capture"} = Perlito5::AST::Var::->new("sigil", $sigil, "namespace", $namespace, "name", $name);
                        $m->{"to"} = $spc->{"to"};
                        $m = Perlito5::Grammar::String::double_quoted_var_with_subscript($m);
                        $m->{"capture"} = ["term", $m->{"capture"}];
                        $spc = Perlito5::Grammar::Space::opt_ws($str, $m->{"to"});
                        my $p = $spc->{"to"};
                        if ($str->[$p] eq "}") {
                            $m->{"to"} = $p + 1;
                            return $m
                        }
                    }
                    elsif ($str->[$pos] eq "-" && $str->[$pos + 1] eq ">") {
                        my $spc = Perlito5::Grammar::Space::opt_ws($str, $pos + 2);
                        my $pos = $spc->{"to"};
                        if ($str->[$pos] eq "{" || $str->[$pos] eq "[") {
                            $m->{"capture"} = Perlito5::AST::Var::->new("sigil", $sigil, "namespace", ($namespace || $Perlito5::PKG_NAME), "name", $name);
                            $m->{"to"} = $spc->{"to"};
                            $m = Perlito5::Grammar::String::double_quoted_var_with_subscript($m);
                            $m->{"capture"} = ["term", $m->{"capture"}];
                            $spc = Perlito5::Grammar::Space::opt_ws($str, $m->{"to"});
                            my $p = $spc->{"to"};
                            if ($str->[$p] eq "}") {
                                $m->{"to"} = $p + 1;
                                return $m
                            }
                        }
                    }
                }
            }
            my $caret = Perlito5::Grammar::caret_char($str, $p);
            if ($caret) {
                my $p = $caret->{"to"};
                my $name = Perlito5::Match::flat($caret);
                $m = Perlito5::Grammar::var_name($str, $p);
                if ($m) {
                    $name = $name . Perlito5::Match::flat($m);
                    $p = $m->{"to"}
                }
                if ($str->[$p] eq "}") {
                    $caret->{"capture"} = ["term", Perlito5::AST::Var::->new("name", $name, "namespace", '', "sigil", $sigil)];
                    $caret->{"to"} = $p + 1;
                    return $caret
                }
            }
            my $special = $sigil . ($str->[$p]);
            if (exists($special_var{$special})) {
                my $m = Perlito5::Grammar::Space::opt_ws($str, $p + 1);
                my $p2 = $m->{"to"};
                my $c2 = $str->[$p2];
                if ($c2 eq "}") {
                    $m->{"to"} = $p2 + 1;
                    $m->{"capture"} = ["term", Perlito5::AST::Var::->new("sigil", $sigil, "namespace", '', "name", $str->[$p], ($sigil eq "\$#" ? ("_real_sigil", "\@") : ()), "_namespace", "main")];
                    return $m
                }
            }
            if ($str->[$p] eq "}") {;
                Perlito5::Compiler::error("syntax error")
            }
            $m = Perlito5::Grammar::block($str, $p0);
            if ($m) {
                my $ast = Perlito5::Match::flat($m);
                if (@{$ast->{"stmts"}} == 1 && (ref($ast->{"stmts"}->[0]) eq "Perlito5::AST::Apply" || ref($ast->{"stmts"}->[0]) eq "Perlito5::AST::Call" || ref($ast->{"stmts"}->[0]) eq "Perlito5::AST::Var" || ref($ast->{"stmts"}->[0]) eq "Perlito5::AST::Buf" || ref($ast->{"stmts"}->[0]) eq "Perlito5::AST::Index" || ref($ast->{"stmts"}->[0]) eq "Perlito5::AST::Lookup")) {
                    $m->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", "prefix:<" . $sigil . ">", "namespace", '', "arguments", [$ast->{"stmts"}->[0]], "_strict_refs", (${^H} & $Perlito5::STRICT_REFS))];
                    return $m
                }
                $m->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", "prefix:<" . $sigil . ">", "arguments", [Perlito5::AST::Apply::->new("code", "do", "namespace", '', "arguments", [$ast])], "_strict_refs", (${^H} & $Perlito5::STRICT_REFS))];
                return $m
            }
        }
        my $caret = Perlito5::Grammar::caret_char($str, $p);
        if ($caret) {
            my $name = Perlito5::Match::flat($caret);
            $caret->{"capture"} = ["term", Perlito5::AST::Var::->new("name", $name, "namespace", '', "sigil", $sigil)];
            return $caret
        }
        if ($c1 eq "\$") {
            my $m2 = Perlito5::Grammar::Space::ws($str, $p + 1);
            if (!$m2) {
                my $p2 = $p + 1;
                my $c2 = $str->[$p2];
                if ($c2 eq "_" || $c2 eq "\$" || !exists($special_var{"\$" . $c2})) {
                    $m = Perlito5::Grammar::Sigil::term_sigil($str, $p);
                    if ($m) {
                        $m->{"capture"} = ["term", Perlito5::AST::Apply::->new("arguments", [$m->{"capture"}->[1]], "code", "prefix:<" . $sigil . ">", "namespace", '', "_strict_refs", (${^H} & $Perlito5::STRICT_REFS))];
                        return $m
                    }
                }
            }
        }
        $m = Perlito5::Grammar::optional_namespace_before_ident($str, $p);
        if ($m) {
            my $namespace = Perlito5::Match::flat($m);
            my $n = Perlito5::Grammar::var_name($str, $m->{"to"});
            if ($n) {
                $n->{"capture"} = ["term", Perlito5::AST::Var::->new("sigil", $sigil, "namespace", $namespace, "name", Perlito5::Match::flat($n), ($sigil eq "\$#" ? ("_real_sigil", "\@") : ()))];
                return $n
            }
            if ($namespace) {
                $m->{"capture"} = ["term", Perlito5::AST::Var::->new("sigil", $sigil, "namespace", $namespace, "name", undef, ($sigil eq "\$#" ? ("_real_sigil", "\@") : ()))];
                return $m
            }
        }
        return Perlito5::Grammar::Sigil::term_special_var($str, $pos)
    }
    Perlito5::Grammar::Precedence::add_term("\$", \&term_sigil);
    Perlito5::Grammar::Precedence::add_term("\@", \&term_sigil);
    Perlito5::Grammar::Precedence::add_term("%", \&term_sigil);
    Perlito5::Grammar::Precedence::add_term("&", \&term_sigil);
    Perlito5::Grammar::Precedence::add_term("*", \&term_sigil);
    1
}
{
    package main;
    package Perlito5::Grammar::Use;
    our @Perlito_internal_lib_directory = ("Perlito5X", '');
    our %Perlito_internal_module;
    sub Perlito5::Grammar::Use::use_decl {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = ((do {
            my $tmp1030 = $MATCH->{"to"};
            ((("u" eq $str->[($MATCH->{"to"}) + 0]) && ("s" eq $str->[($MATCH->{"to"}) + 1]) && ("e" eq $str->[($MATCH->{"to"}) + 2]) && ($MATCH->{"to"} += 3))) || ($MATCH->{"to"} = $tmp1030, (("n" eq $str->[($MATCH->{"to"}) + 0]) && ("o" eq $str->[($MATCH->{"to"}) + 1]) && ($MATCH->{"to"} += 2)))
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Use::version_string {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = ((do {
            my $tmp1036 = $MATCH->{"to"};
            (((do {
                my $m2 = Perlito5::Grammar::Number::val_version($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::Number::val_version"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                $MATCH->{"capture"} = $MATCH->{"Perlito5::Grammar::Number::val_version"}->{"capture"};
                1
            }))) || ($MATCH->{"to"} = $tmp1036, ((do {
                my $m2 = Perlito5::Grammar::Number::term_digit($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::Number::term_digit"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $version = $MATCH->{"Perlito5::Grammar::Number::term_digit"}->{"capture"}->[1]->{"buf"} || $MATCH->{"Perlito5::Grammar::Number::term_digit"}->{"capture"}->[1]->{"int"} || $MATCH->{"Perlito5::Grammar::Number::term_digit"}->{"capture"}->[1]->{"num"};
                $MATCH->{"capture"} = Perlito5::AST::Buf::->new("buf", $version);
                1
            })))
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Use::term_require {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((("r" eq $str->[($MATCH->{"to"}) + 0]) && ("e" eq $str->[($MATCH->{"to"}) + 1]) && ("q" eq $str->[($MATCH->{"to"}) + 2]) && ("u" eq $str->[($MATCH->{"to"}) + 3]) && ("i" eq $str->[($MATCH->{"to"}) + 4]) && ("r" eq $str->[($MATCH->{"to"}) + 5]) && ("e" eq $str->[($MATCH->{"to"}) + 6]) && ($MATCH->{"to"} += 7)) && (do {
            my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $tmp1045 = $MATCH->{"to"};
            (((do {
                my $m2 = Perlito5::Grammar::Use::version_string($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"version_string"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $version = $MATCH->{"version_string"}->{"capture"};
                $version->{"is_version_string"} = 1;
                $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", "require", "namespace", '', "arguments", [$version])];
                1
            }))) || ($MATCH->{"to"} = $tmp1045, ((do {
                my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::full_ident"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $module_name = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::full_ident"});
                $Perlito5::PACKAGES->{$module_name} = 1;
                my $filename = Perlito5::Grammar::Use::modulename_to_filename($module_name);
                $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", "require", "namespace", '', "arguments", [Perlito5::AST::Buf::->new("buf", $filename)])];
                1
            })))
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Use::stmt_use {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $m2 = Perlito5::Grammar::Use::use_decl($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"use_decl"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $tmp1057 = $MATCH->{"to"};
            (((do {
                my $m2 = Perlito5::Grammar::Use::version_string($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"version_string"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $version = $MATCH->{"version_string"}->{"capture"}->{"buf"};
                Perlito5::test_perl_version($version);
                $MATCH->{"capture"} = Perlito5::Grammar::Block::ast_nop();
                1
            }))) || ($MATCH->{"to"} = $tmp1057, ((do {
                my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::full_ident"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $m = $MATCH;
                if (!((("-" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $m2 = Perlito5::Grammar::ident($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        if (exists($MATCH->{"Perlito5::Grammar::ident"})) {;
                            push(@{$MATCH->{"Perlito5::Grammar::ident"}}, $m2)
                        }
                        else {;
                            $MATCH->{"Perlito5::Grammar::ident"} = [$m2]
                        }
                        1
                    }
                    else {;
                        0
                    }
                }))) {;
                    $MATCH = $m
                }
                1
            }) && (do {
                my $m = $MATCH;
                if (!((do {
                    my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $m2 = Perlito5::Grammar::Use::version_string($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        if (exists($MATCH->{"version_string"})) {;
                            push(@{$MATCH->{"version_string"}}, $m2)
                        }
                        else {;
                            $MATCH->{"version_string"} = [$m2]
                        }
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $tmp = $MATCH;
                    $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
                    my $res = (("," eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1));
                    $MATCH = $tmp;
                    $res ? 0 : 1
                }))) {;
                    $MATCH = $m
                }
                1
            }) && (do {
                my $tmp1058 = $MATCH->{"to"};
                ((do {
                    my $m2 = Perlito5::Grammar::Expression::exp_parse($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Expression::exp_parse"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                })) || ($MATCH->{"to"} = $tmp1058, (do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }))
            }) && (do {
                my $version = $MATCH->{"version_string"}->[0]->{"capture"}->{"buf"};
                my $list = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::exp_parse"});
                if (ref($list) eq "Perlito5::AST::Buf") {;
                    $list = [$list->{"buf"}]
                }
                elsif ($list) {
                    Perlito5::Grammar::Scope::check_variable_declarations();
                    my $ast = Perlito5::AST::Block::->new("stmts", [Perlito5::AST::Apply::->new("code", "circumfix:<[ ]>", "arguments", [$list])]);
                    $list = Perlito5::Grammar::Block::eval_begin_block($ast)
                }
                else {;
                    $list = undef
                }
                my $full_ident = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::full_ident"});
                $Perlito5::PACKAGES->{$full_ident} = 1;
                my $use_decl = Perlito5::Match::flat($MATCH->{"use_decl"});
                if ($use_decl eq "use" && $full_ident eq "vars" && $list) {
                    for my $name (@{$list}) {;
                        $Perlito5::VARS{substr($name, 0, 1) . $Perlito5::PKG_NAME . "::" . substr($name, 1)} = 1
                    }
                    $MATCH->{"capture"} = Perlito5::Grammar::Block::ast_nop()
                }
                elsif ($use_decl eq "use" && $full_ident eq "subs" && $list) {
                    for my $name (@{$list}) {
                        my $glob = $Perlito5::PKG_NAME . "::" . $name;
                        if (!exists($Perlito5::PROTO->{$glob})) {;
                            $Perlito5::PROTO->{$glob} = undef
                        }
                    }
                    $MATCH->{"capture"} = Perlito5::Grammar::Block::ast_nop()
                }
                elsif ($use_decl eq "use" && $full_ident eq "constant") {
                    my @ast;
                    if ($list) {
                        my $name = shift(@{$list});
                        if (ref($name) eq "HASH") {;
                            for my $key (sort {;
                                $a cmp $b
                            } keys(%{$name})) {
                                my $code = "sub " . $key . " () { " . Perlito5::Dumper::_dumper($name->{$key}) . " }";
                                my $m = Perlito5::Grammar::Statement::statement_parse([split('', $code)], 0);
                                !$m && Perlito5::Compiler::error("not a valid constant: " . join(${"\""}, @{$list}));
                                push(@ast, $m->{"capture"})
                            }
                        }
                        else {
                            my $code = "sub " . $name . " () { (" . join(", ", map {;
                                Perlito5::Dumper::_dumper($_)
                            } @{$list}) . ") }";
                            my $m = Perlito5::Grammar::Statement::statement_parse([split('', $code)], 0);
                            !$m && Perlito5::Compiler::error("not a valid constant: " . join(${"\""}, @{$list}));
                            push(@ast, $m->{"capture"})
                        }
                    }
                    $MATCH->{"capture"} = Perlito5::AST::Block::->new("stmts", \@ast)
                }
                elsif ($Perlito5::EMIT_USE) {;
                    $MATCH->{"capture"} = Perlito5::AST::Apply::->new("code", "use", "special_arg", Perlito5::AST::Apply::->new("code", $full_ident, "bareword", 1, "arguments", []), "arguments", $list)
                }
                else {;
                    $MATCH->{"capture"} = Perlito5::Grammar::Use::parse_time_eval({"mod" => $full_ident, "code" => $use_decl, "arguments" => $list, })
                }
                1
            }))) || ($MATCH->{"to"} = $tmp1057, (do {
                Perlito5::Compiler::error("Syntax error");
                1
            }))
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Use::parse_time_eval {
        my $ast = shift;
        my $module_name = $ast->{"mod"};
        my $use_or_not = $ast->{"code"};
        my $arguments = $ast->{"arguments"};
        my $skip_import = defined($arguments) && @{$arguments} == 0;
        defined($arguments) || ($arguments = []);
        if ($Perlito5::EXPAND_USE) {
            my $caller = [$Perlito5::PKG_NAME, $Perlito5::FILE_NAME, $Perlito5::LINE_NUMBER], my $filename = Perlito5::Grammar::Use::modulename_to_filename($module_name);
            unshift(@Perlito5::CALLER, [$module_name]);
            Perlito5::Grammar::Use::require($filename);
            shift(@Perlito5::CALLER);
            if (!$skip_import) {
                if ($use_or_not eq "use") {
                    my $code = $module_name->can("import");
                    if (defined($code)) {
                        unshift(@Perlito5::CALLER, $caller);
                        eval {
                            $module_name->import(@{$arguments});
                            1
                        } or Perlito5::Compiler::error(${"\@"});
                        shift(@Perlito5::CALLER)
                    }
                }
                elsif ($use_or_not eq "no") {
                    my $code = $module_name->can("unimport");
                    if (defined($code)) {
                        unshift(@Perlito5::CALLER, $caller);
                        eval {
                            $module_name->unimport(@{$arguments});
                            1
                        } or Perlito5::Compiler::error(${"\@"});
                        shift(@Perlito5::CALLER)
                    }
                }
            }
        }
        else {
            Perlito5::Grammar::Use::bootstrapping_use($ast);
            Perlito5::Grammar::Use::emit_time_eval($ast)
        }
        return Perlito5::Grammar::Block::ast_nop()
    }
    sub Perlito5::Grammar::Use::emit_time_eval {
        my $ast = shift;
        if ($ast->{"mod"} eq "strict") {
            if ($ast->{"code"} eq "use") {;
                strict::->import()
            }
            elsif ($ast->{"code"} eq "no") {;
                strict::->unimport()
            }
        }
    }
    sub Perlito5::Grammar::Use::modulename_to_filename {
        my $s = shift;
        exists($Perlito_internal_module{$s}) && ($s = $Perlito_internal_module{$s});
        $s =~ s!::!/!g;
        return $s . ".pm"
    }
    sub Perlito5::Grammar::Use::filename_lookup {
        my $filename = shift;
        if (exists($INC{$filename})) {
            $INC{$filename} && return "done";
            Perlito5::Compiler::error("Compilation failed in require")
        }
        if (substr($filename, 0, 2) eq "./") {;
            if (-f $filename) {
                $INC{$filename} = $filename;
                return "todo"
            }
        }
        for my $prefix (@INC) {;
            for my $internal (@Perlito_internal_lib_directory) {
                my $realfilename = join("/", $prefix, ($internal ? $internal : ()), $filename);
                if (-f $realfilename) {
                    $INC{$filename} = $realfilename;
                    return "todo"
                }
            }
        }
        Perlito5::Compiler::error("Can't locate " . $filename . " in \@INC " . "(\@INC contains " . join(" ", @INC) . ").")
    }
    sub Perlito5::Grammar::Use::bootstrapping_use {
        my $stmt = shift;
        my $module_name = $stmt->{"mod"};
        my $filename = Perlito5::Grammar::Use::modulename_to_filename($module_name);
        Perlito5::Grammar::Use::filename_lookup($filename) eq "done" && return;
        local $Perlito5::FILE_NAME = $filename;
        local $Perlito5::LINE_NUMBER = 1;
        my $realfilename = $INC{$filename};
        open(FILE, "<", $realfilename) or Perlito5::Compiler::error("Cannot read " . $realfilename . ": " . ${"!"} . "
");
        local $/ = undef;
        my $source = <FILE>;
        close(FILE);
        local @Perlito5::BASE_SCOPE = (Perlito5::Grammar::Scope::->new_base_scope());
        local $Perlito5::CLOSURE_SCOPE = 0;
        local @Perlito5::SCOPE_STMT = ();
        local ${^H} = 0;
        local %{^H} = ();
        my $m = Perlito5::Grammar::exp_stmts($source, 0);
        $m->{"to"} != length($source) && Perlito5::Compiler::error("Syntax Error near ", $m->{"to"});
        if ($m->{"to"} != length($source)) {
            my $pos = ($m->{"to"}) - 10;
            $pos < 0 && ($pos = 0);
            print("* near: ", substr($source, $pos, 20), "
");
            print("* filename: " . $realfilename . "
");
            Perlito5::Compiler::error("Syntax Error")
        }
        push(@Perlito5::COMP_UNIT, Perlito5::AST::CompUnit::->new("name", "main", "body", Perlito5::Match::flat($m)));
        return
    }
    sub Perlito5::Grammar::Use::require {
        my $filename = shift;
        my $m2 = Perlito5::Grammar::Use::version_string([split('', $filename)], 0);
        if ($m2) {
            my $version = $m2->{"version_string"}->{"capture"}->{"buf"};
            Perlito5::test_perl_version($version);
            return 1
        }
        if (length($filename) > 3 && substr($filename, -3) eq ".pm") {
            my $module_name = substr($filename, 0, -3);
            $module_name =~ s!/!::!g;
            if (exists($Perlito_internal_module{$module_name})) {
                my $s = $Perlito_internal_module{$module_name};
                $s =~ s!::!/!g;
                $filename = $s . ".pm"
            }
        }
        Perlito5::Grammar::Use::filename_lookup($filename) eq "done" && return;
        my $source = Perlito5::Grammar::Use::slurp_file($filename);
        local $Perlito5::FILE_NAME = $filename;
        Perlito5::Grammar::Scope::check_variable_declarations();
        local @Perlito5::BASE_SCOPE = (Perlito5::Grammar::Scope::->new_base_scope());
        local $Perlito5::CLOSURE_SCOPE = 0;
        local @Perlito5::SCOPE_STMT = ();
        local ${^H} = 0;
        local %{^H} = ();
        my $m = Perlito5::Grammar::exp_stmts($source, 0);
        my $ast = Perlito5::AST::Block::->new("stmts", Perlito5::Match::flat($m));
        my $result = Perlito5::Grammar::Block::eval_begin_block($ast);
        if (${"\@"}) {
            $INC{$filename} = undef;
            Perlito5::Compiler::error(${"\@"})
        }
        elsif (!$result) {
            delete($INC{$filename});
            ${"\@"} && warn(${"\@"});
            Perlito5::Compiler::error($filename . " did not return true value")
        }
        else {;
            return $result
        }
    }
    sub Perlito5::Grammar::Use::slurp_file {
        my $filename = shift;
        eval {
            Perlito5::Grammar::Use::filename_lookup($filename);
            1
        } or do {
            $INC{$filename} = undef;
            ${"\@"} = '';
            ${"!"} = "No such file or directory";
            return "undef"
        };
        my $realfilename = $INC{$filename};
        Perlito5::Grammar::Use::slurp_source_file($realfilename)
    }
    sub Perlito5::Grammar::Use::slurp_source_file {
        my $realfilename = shift;
        open(FILE, "<", $realfilename) or Perlito5::Compiler::error("Cannot read " . $realfilename . ": " . ${"!"} . "
");
        binmode(FILE);
        local $/ = undef;
        my $source = <FILE>;
        close(FILE);
        my $charset = '';
        eval {
            my $c0 = substr($source, 0, 1);
            my $c1 = substr($source, 1, 1);
            my $c2 = substr($source, 2, 1);
            my $c3 = substr($source, 3, 1);
            if ($c0 eq "\x{ef}" && $c1 eq "\x{bb}" && $c2 eq "\x{bf}") {
                $charset = "UTF-8";
                $source = substr($source, 3)
            }
            elsif ($c0 eq "\x{fe}" && $c1 eq "\x{ff}") {
                $charset = "UTF-16BE";
                $source = substr($source, 2)
            }
            elsif ($c0 eq "\x{ff}" && $c1 eq "\x{fe}") {
                $charset = "UTF-16LE";
                $source = substr($source, 2)
            }
            elsif ($c0 eq "\x{0}" && $c1 ne "\x{0}" && $c2 eq "\x{0}" && $c3 ne "\x{0}") {;
                $charset = "UTF-16BE"
            }
            elsif ($c0 ne "\x{0}" && $c1 eq "\x{0}" && $c2 ne "\x{0}" && $c3 eq "\x{0}") {;
                $charset = "UTF-16LE"
            }
            $charset && ($source = Encode::decode($charset, $source));
            1
        } or warn("Source code charset '" . $charset . "' decoding failed: " . ${"\@"});
        return $source
    }
    Perlito5::Grammar::Statement::add_statement("no", \&stmt_use);
    Perlito5::Grammar::Statement::add_statement("use", \&stmt_use);
    Perlito5::Grammar::Precedence::add_term("require", \&term_require);
    1
}
{
    package main;
    package Perlito5::AST::CompUnit;
    sub Perlito5::AST::CompUnit::new {
        my $class = shift;
        my %args = @_;
        if ($args{"body"}) {
            my @body;
            for my $stmt (@{$args{"body"}}) {
                !defined($stmt) && next;
                ref($stmt) eq "Perlito5::AST::Apply" && $stmt->{"namespace"} eq "Perlito5" && $stmt->{"code"} eq "nop" && next;
                push(@body, $stmt)
            }
            $Perlito5::CODE_TOO_LARGE && (@body = Perlito5::Macro::split_code_too_large(@body));
            $args{"body"} = \@body
        }
        bless(\%args, $class)
    }
    sub Perlito5::AST::CompUnit::name {;
        $_[0]->{"name"}
    }
    sub Perlito5::AST::CompUnit::body {;
        $_[0]->{"body"}
    }
    package Perlito5::AST::Block;
    sub Perlito5::AST::Block::new {
        my $class = shift;
        my %args = @_;
        if ($args{"stmts"}) {
            my @stmts;
            for my $stmt (@{$args{"stmts"}}) {
                !defined($stmt) && next;
                ref($stmt) eq "Perlito5::AST::Apply" && $stmt->{"namespace"} eq "Perlito5" && $stmt->{"code"} eq "nop" && next;
                push(@stmts, $stmt)
            }
            $Perlito5::CODE_TOO_LARGE && (@stmts = Perlito5::Macro::split_code_too_large(@stmts));
            $args{"stmts"} = \@stmts
        }
        bless(\%args, $class)
    }
    sub Perlito5::AST::Block::sig {;
        $_[0]->{"sig"}
    }
    sub Perlito5::AST::Block::stmts {;
        $_[0]->{"stmts"}
    }
    package Perlito5::AST::Int;
    sub Perlito5::AST::Int::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::AST::Int::int {;
        $_[0]->{"int"}
    }
    sub Perlito5::AST::Int::value {;
        $_[0]->{"int"}
    }
    package Perlito5::AST::Num;
    sub Perlito5::AST::Num::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::AST::Num::num {;
        $_[0]->{"num"}
    }
    sub Perlito5::AST::Num::value {;
        $_[0]->{"num"}
    }
    package Perlito5::AST::Buf;
    sub Perlito5::AST::Buf::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::AST::Buf::buf {;
        $_[0]->{"buf"}
    }
    sub Perlito5::AST::Buf::value {;
        $_[0]->{"buf"}
    }
    package Perlito5::AST::Index;
    sub Perlito5::AST::Index::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::AST::Index::obj {;
        $_[0]->{"obj"}
    }
    sub Perlito5::AST::Index::index_exp {;
        $_[0]->{"index_exp"}
    }
    sub Perlito5::AST::Index::INDEX {
        (my $term, my $index) = @_;
        if (ref($term) eq "Perlito5::AST::Var" && $term->{"sigil"} eq "\@") {;
            return Perlito5::AST::Index::->new("obj", Perlito5::AST::Var::->new(%{$term}, "_real_sigil", $term->{"sigil"}, "sigil", "\$"), "index_exp", $index)
        }
        return Perlito5::AST::Call::->new("method", "postcircumfix:<[ ]>", "invocant", $term, "arguments", $index)
    }
    package Perlito5::AST::Lookup;
    sub Perlito5::AST::Lookup::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::AST::Lookup::obj {;
        $_[0]->{"obj"}
    }
    sub Perlito5::AST::Lookup::index_exp {;
        $_[0]->{"index_exp"}
    }
    sub Perlito5::AST::Lookup::autoquote {
        my $self = shift;
        my $index = shift;
        if ((ref($index) eq "Perlito5::AST::Apply") && $index->{"bareword"}) {
            my $full_name = ($index->{"namespace"} ? ($index->{"namespace"}) . "::" : '') . ($index->{"code"});
            if (!exists($Perlito5::PROTO->{$full_name})) {;
                return Perlito5::AST::Buf::->new("buf", $full_name)
            }
        }
        elsif ((ref($index) eq "Perlito5::AST::Apply") && ($index->code() eq "prefix:<->" || $index->code() eq "prefix:<+>")) {
            my $arg = $index->arguments()->[0];
            $arg && return Perlito5::AST::Apply::->new("code", $index->code(), "namespace", $index->namespace(), "arguments", [$self->autoquote($arg)])
        }
        elsif ((ref($index) eq "Perlito5::AST::Apply") && ($index->code() eq "list:<,>")) {
            my $obj = $self->obj();
            if ($obj->sigil() eq "\@") {;
                return $index
            }
            my $args = $index->arguments();
            return Perlito5::AST::Apply::->new("code", "join", "namespace", '', "arguments", [Perlito5::AST::Var::->new("name", ";", "namespace", '', "sigil", "\$"), map {;
                defined($_) ? $_ : Perlito5::AST::Buf::->new("buf", '')
            } @{$args}])
        }
        $index
    }
    sub Perlito5::AST::Lookup::LOOKUP {
        (my $term, my $index) = @_;
        if (ref($term) eq "Perlito5::AST::Var" && $term->{"sigil"} eq "%") {;
            return Perlito5::AST::Lookup::->new("obj", Perlito5::AST::Var::->new(%{$term}, "_real_sigil", $term->{"sigil"}, "sigil", "\$"), "index_exp", $index)
        }
        return Perlito5::AST::Call::->new("method", "postcircumfix:<{ }>", "invocant", $term, "arguments", $index)
    }
    package Perlito5::AST::Var;
    sub Perlito5::AST::Var::new {
        (my $class, my %args) = @_;
        my $var = bless(\%args, $class);
        push(@Perlito5::SCOPE_STMT, $var);
        return $var
    }
    sub Perlito5::AST::Var::sigil {;
        $_[0]->{"sigil"}
    }
    sub Perlito5::AST::Var::namespace {;
        $_[0]->{"namespace"}
    }
    sub Perlito5::AST::Var::name {;
        $_[0]->{"name"}
    }
    sub Perlito5::AST::Var::clone {
        my $self = shift;
        return bless({%{$self}, }, ref($self))
    }
    sub Perlito5::AST::Var::plain_name {
        my $self = shift;
        if ($self->namespace()) {;
            return $self->namespace() . "::" . $self->name()
        }
        return $self->name()
    }
    our %Special_var = ("ARGV", 1, "INC", 1, "ENV", 1, "SIG", 1, "_", 1);
    our %NonSpecial_var = map {;
        $_ => 1
    } ("A" .. "Z", "_", "a" .. "z");
    sub Perlito5::AST::Var::is_special_var {
        my $self = shift;
        my $c = substr($self->{"name"}, 0, 1);
        if ($Special_var{$self->{"name"}} || !$NonSpecial_var{$c}) {;
            return 1
        }
        0
    }
    sub Perlito5::AST::Var::SCALAR_ARG {;
        Perlito5::AST::Var::->new("sigil", "\$", "namespace", '', "name", "_", "_decl", "global", "_namespace", "main")
    }
    sub Perlito5::AST::Var::LIST_ARG {;
        Perlito5::AST::Var::->new("sigil", "\@", "namespace", '', "name", "_", "_decl", "global", "_namespace", "main")
    }
    sub Perlito5::AST::Var::LIST_ARG_INDEX {
        my $index = shift;
        Perlito5::AST::Index::INDEX(Perlito5::AST::Var::LIST_ARG(), Perlito5::AST::Int::->new("int", $index))
    }
    package Perlito5::AST::Call;
    sub Perlito5::AST::Call::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::AST::Call::invocant {;
        $_[0]->{"invocant"}
    }
    sub Perlito5::AST::Call::method {;
        $_[0]->{"method"}
    }
    sub Perlito5::AST::Call::arguments {;
        $_[0]->{"arguments"}
    }
    package Perlito5::AST::Apply;
    sub Perlito5::AST::Apply::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::AST::Apply::code {;
        $_[0]->{"code"}
    }
    sub Perlito5::AST::Apply::special_arg {;
        $_[0]->{"special_arg"}
    }
    sub Perlito5::AST::Apply::arguments {;
        $_[0]->{"arguments"}
    }
    sub Perlito5::AST::Apply::namespace {;
        $_[0]->{"namespace"}
    }
    sub Perlito5::AST::Apply::PUSH {
        (my $var, my $value) = @_;
        if (ref($var) eq "Perlito5::AST::Var" && $var->{"sigil"} eq "\@") {;
            return Perlito5::AST::Apply::->new("code", "push", "arguments", [$var, $value])
        }
        return Perlito5::AST::Apply::->new("code", "push", "arguments", [Perlito5::AST::Apply::->new("code", "prefix:<\@>", "arguments", [$var]), $value])
    }
    sub Perlito5::AST::Apply::UNDEF {;
        return Perlito5::AST::Apply::->new("arguments", [], "code", "undef", "namespace", '')
    }
    sub Perlito5::AST::Apply::value {
        my $self = shift;
        my $ref = ref($self);
        $ref eq "Perlito5::AST::Apply" && $self->{"code"} eq "undef" && return undef;
        die("can't take the Constant value() of Perlito5::AST::Apply '" . ($self->{"code"}) . "'")
    }
    package Perlito5::AST::If;
    sub Perlito5::AST::If::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::AST::If::cond {;
        $_[0]->{"cond"}
    }
    sub Perlito5::AST::If::body {;
        $_[0]->{"body"}
    }
    sub Perlito5::AST::If::otherwise {;
        $_[0]->{"otherwise"}
    }
    package Perlito5::AST::When;
    sub Perlito5::AST::When::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::AST::When::cond {;
        $_[0]->{"cond"}
    }
    sub Perlito5::AST::When::body {;
        $_[0]->{"body"}
    }
    package Perlito5::AST::While;
    sub Perlito5::AST::While::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::AST::While::init {;
        $_[0]->{"init"}
    }
    sub Perlito5::AST::While::cond {;
        $_[0]->{"cond"}
    }
    sub Perlito5::AST::While::continue {;
        $_[0]->{"continue"}
    }
    sub Perlito5::AST::While::body {;
        $_[0]->{"body"}
    }
    package Perlito5::AST::For;
    sub Perlito5::AST::For::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::AST::For::cond {;
        $_[0]->{"cond"}
    }
    sub Perlito5::AST::For::continue {;
        $_[0]->{"continue"}
    }
    sub Perlito5::AST::For::body {;
        $_[0]->{"body"}
    }
    sub Perlito5::AST::For::topic {;
        $_[0]->{"topic"}
    }
    package Perlito5::AST::Given;
    sub Perlito5::AST::Given::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::AST::Given::cond {;
        $_[0]->{"cond"}
    }
    sub Perlito5::AST::Given::body {;
        $_[0]->{"body"}
    }
    package Perlito5::AST::Decl;
    sub Perlito5::AST::Decl::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::AST::Decl::decl {;
        $_[0]->{"decl"}
    }
    sub Perlito5::AST::Decl::type {;
        $_[0]->{"type"}
    }
    sub Perlito5::AST::Decl::var {;
        $_[0]->{"var"}
    }
    sub Perlito5::AST::Decl::attributes {;
        $_[0]->{"attributes"}
    }
    package Perlito5::AST::Sub;
    sub Perlito5::AST::Sub::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::AST::Sub::name {;
        $_[0]->{"name"}
    }
    sub Perlito5::AST::Sub::sig {;
        $_[0]->{"sig"}
    }
    sub Perlito5::AST::Sub::block {;
        $_[0]->{"block"}
    }
    sub Perlito5::AST::Sub::attributes {;
        $_[0]->{"attributes"}
    }
    sub Perlito5::AST::Sub::is_named_sub {
        my $self = shift;
        (ref($self) eq "Perlito5::AST::Sub") && $self->{"name"}
    }
    sub Perlito5::AST::Sub::is_anon_sub {
        my $self = shift;
        (ref($self) eq "Perlito5::AST::Sub") && !$self->{"name"}
    }
    1
}
{
    package main;
    package Perlito5::Grammar::Scope;
    sub Perlito5::Grammar::Scope::new {;
        return {"block" => [], }
    }
    sub Perlito5::Grammar::Scope::new_base_scope {;
        return {"block" => [], }
    }
    sub Perlito5::Grammar::Scope::create_new_compile_time_scope {;
        push(@Perlito5::BASE_SCOPE, {"block" => [], "hint_scalar" => ${^H}, "hint_hash" => {%{^H}, }, })
    }
    sub Perlito5::Grammar::Scope::end_compile_time_scope {
        my $scope = pop(@Perlito5::BASE_SCOPE);
        ${^H} = $scope->{"hint_scalar"};
        %{^H} = %{$scope->{"hint_hash"} || {}}
    }
    sub Perlito5::Grammar::Scope::compile_time_glob_set {
        (my $glob, my $value, my $namespace) = @_;
        if (!ref($glob)) {
            if ($glob !~ m/::/) {;
                $glob = $namespace . "::" . $glob
            }
            my @parts = split("::", $glob);
            my $name = pop(@parts);
            Perlito5::AST::Var::->new("name", $name, "namespace", join("::", @parts), "sigil", "*", "_decl", "global");
            if (ref($value) eq "SCALAR") {;
                $Perlito5::VARS{"\$" . $glob} = 1
            }
            if (ref($value) eq "HASH") {;
                $Perlito5::VARS{"%" . $glob} = 1
            }
            if (ref($value) eq "ARRAY") {;
                $Perlito5::VARS{"\@" . $glob} = 1
            }
        }
        *{$glob} = $value
    }
    sub Perlito5::Grammar::Scope::lookup_variable {
        my $var = shift;
        my $scope = shift() // 0;
        $var->{"namespace"} && return $var;
        $var->{"_decl"} && return $var;
        my $look = Perlito5::Grammar::Scope::lookup_variable_inner($var, $scope);
        $look && return $look;
        ref($var) ne "Perlito5::AST::Var" && return;
        my $c = substr($var->{"name"}, 0, 1);
        if ($var->is_special_var()) {
            $var->{"_decl"} = "global";
            $var->{"_namespace"} = "main";
            return $var
        }
        if ($var->{"sigil"} eq "\$" && ($var->{"name"} eq "a" || $var->{"name"} eq "b")) {;
            if (!$var->{"_real_sigil"}) {
                $var->{"_decl"} = "global";
                $var->{"_namespace"} = $Perlito5::PKG_NAME;
                return $var
            }
        }
        return
    }
    sub Perlito5::Grammar::Scope::lookup_variable_inner {
        (my $var, my $scope) = @_;
        $scope > $#Perlito5::BASE_SCOPE && return;
        if ($scope < $#Perlito5::BASE_SCOPE) {
            my $look = Perlito5::Grammar::Scope::lookup_variable_inner($var, $scope + 1);
            $look && return $look
        }
        my $block = $Perlito5::BASE_SCOPE[$scope]->{"block"};
        if ((($Perlito5::BASE_SCOPE[$scope]->{"compacted"}) + 100) < @{$block}) {
            my %seen;
            my @out;
            my $start = $#{$block} - 500;
            $start < 1 && ($start = 1);
            for my $i ($start .. $#{$block}) {
                my $item = $block->[$i];
                my $s = join(":", map {;
                    $_ . "=" . ($item->{$_})
                } sort {;
                    $a cmp $b
                } keys(%{$item}));
                $seen{$s}++ || push(@out, $item)
            }
            $Perlito5::BASE_SCOPE[$scope]->{"block"} = [@{$block}[0 .. $start - 1], @out];
            $Perlito5::BASE_SCOPE[$scope]->{"compacted"} += 100
        }
        for my $item (reverse(@{$block})) {;
            if (ref($item) eq "Perlito5::AST::Var" && $item->{"_decl"} && $item->{"_decl"} ne "global" && $item->{"name"} eq $var->{"name"}) {
                my $sigil = $var->{"_real_sigil"} || $var->{"sigil"};
                my $item_sigil = $item->{"_real_sigil"} || $item->{"sigil"};
                if ($sigil eq $item_sigil) {;
                    return $item
                }
            }
        }
        return
    }
    sub Perlito5::Grammar::Scope::check_variable_declarations {
        for my $item (@Perlito5::SCOPE_STMT) {;
            if (ref($item) eq "Perlito5::AST::Var") {
                my $var = $item;
                my $look = Perlito5::Grammar::Scope::lookup_variable($var);
                if ($look) {
                    $look->{"_id"} && ($var->{"_id"} = $look->{"_id"});
                    $look->{"_decl"} && ($var->{"_decl"} = $look->{"_decl"});
                    $look->{"_namespace"} && ($var->{"_namespace"} = $look->{"_namespace"})
                }
                else {
                    if (${^H} & $Perlito5::STRICT_VARS) {
                        my $sigil = $var->{"_real_sigil"} || $var->{"sigil"};
                        if ($sigil ne "*" && $sigil ne "&") {
                            if (length($var->{"name"}) >= 2 && substr($var->{"name"}, -2) eq "::") {}
                            elsif ($Perlito5::VARS{$sigil . $Perlito5::PKG_NAME . "::" . ($var->{"name"})}) {}
                            else {;
                                Perlito5::Compiler::error("Global symbol \"" . $sigil . ($var->{"name"}) . "\"" . " requires explicit package name")
                            }
                        }
                    }
                    $var->{"_decl"} = "global";
                    $var->{"_namespace"} = $Perlito5::PKG_NAME
                }
                if ($var->{"name"} && ($var->{"namespace"} || $var->{"_namespace"})) {
                    my $compiletime_name;
                    if ($var->{"name"} lt "A" || $var->{"name"} eq "\\") {;
                        $compiletime_name = ($var->{"_real_sigil"} || $var->{"sigil"}) . ($var->{"name"})
                    }
                    else {;
                        $compiletime_name = ($var->{"_real_sigil"} || $var->{"sigil"}) . ($var->{"namespace"} || $var->{"_namespace"}) . "::" . ($var->{"name"}) . ($var->{"_decl"} eq "global" ? '' : $var->{"_id"} ? "_" . ($var->{"_id"}) : '')
                    }
                    $Perlito5::GLOBAL->{$compiletime_name} = {"value" => undef, "ast" => $var, }
                }
            }
        }
        push(@{$Perlito5::BASE_SCOPE[-1]->{"block"}}, @Perlito5::SCOPE_STMT);
        @Perlito5::SCOPE_STMT = ()
    }
    sub Perlito5::Grammar::Scope::get_snapshot {
        my @result;
        my $scope = shift() // 0;
        if ($scope < $#Perlito5::BASE_SCOPE) {
            my $look = Perlito5::Grammar::Scope::get_snapshot($scope + 1);
            unshift(@result, @{$look->{"block"}})
        }
        my $block = $Perlito5::BASE_SCOPE[$scope]->{"block"};
        for my $item (@{$block}) {;
            if (ref($item) eq "Perlito5::AST::Var" && $item->{"_decl"} && $item->{"_decl"} ne "global" && $item->{"_decl"} ne "local") {;
                unshift(@result, $item)
            }
        }
        return {"block" => \@result, }
    }
    1
}
{
    package main;
    package Perlito5::AST::CompUnit;
    {;
        sub Perlito5::AST::CompUnit::emit_begin_scratchpad {
            my $self = $_[0];
            return __PACKAGE__()->new(%{$self}, "body", [map {;
                defined($_) && $_->emit_begin_scratchpad()
            } @{$self->{"body"}}])
        }
    }
    package Perlito5::AST::Int;
    {;
        sub Perlito5::AST::Int::emit_begin_scratchpad {;
            return $_[0]
        }
    }
    package Perlito5::AST::Num;
    {;
        sub Perlito5::AST::Num::emit_begin_scratchpad {;
            return $_[0]
        }
    }
    package Perlito5::AST::Buf;
    {;
        sub Perlito5::AST::Buf::emit_begin_scratchpad {;
            return $_[0]
        }
    }
    package Perlito5::AST::Block;
    {;
        sub Perlito5::AST::Block::emit_begin_scratchpad {
            my $self = $_[0];
            return __PACKAGE__()->new(%{$self}, "stmts", [map {;
                defined($_) && $_->emit_begin_scratchpad()
            } @{$self->{"stmts"}}], ($self->{"continue"} ? ("continue", $self->{"continue"}->emit_begin_scratchpad()) : ()))
        }
    }
    package Perlito5::AST::Index;
    {;
        sub Perlito5::AST::Index::emit_begin_scratchpad {
            my $self = $_[0];
            return __PACKAGE__()->new(%{$self}, "obj", $self->{"obj"}->emit_begin_scratchpad(), "index_exp", $self->{"index_exp"}->emit_begin_scratchpad())
        }
    }
    package Perlito5::AST::Lookup;
    {;
        sub Perlito5::AST::Lookup::emit_begin_scratchpad {
            my $self = $_[0];
            return __PACKAGE__()->new(%{$self}, "obj", $self->{"obj"}->emit_begin_scratchpad(), "index_exp", $self->{"index_exp"}->emit_begin_scratchpad())
        }
    }
    package Perlito5::AST::Var;
    {
        sub Perlito5::AST::Var::emit_begin_scratchpad {
            my $self = $_[0];
            return $self
        }
        sub Perlito5::AST::Var::is_begin_scratchpad {
            (my $self) = @_;
            if (!$self->{"namespace"} && $Perlito5::BEGIN_SCRATCHPAD{$self->{"_id"} || ''}) {;
                return 1
            }
            return 0
        }
        sub Perlito5::AST::Var::to_begin_scratchpad {
            (my $self) = @_;
            if (!$self->{"namespace"} && $Perlito5::BEGIN_SCRATCHPAD{$self->{"_id"} || ''}) {;
                $self = __PACKAGE__()->new(%{$self}, "_decl", "global", "namespace", "Perlito5::BEGIN", "name", "_" . ($self->{"_id"}) . "_" . ($self->{"name"}))
            }
            return $self
        }
    }
    package Perlito5::AST::Call;
    {;
        sub Perlito5::AST::Call::emit_begin_scratchpad {
            my $self = $_[0];
            my $invocant = $self->{"invocant"}->emit_begin_scratchpad();
            my $arguments;
            if ($self->{"method"} eq "postcircumfix:<[ ]>") {;
                $arguments = $self->{"arguments"}->emit_begin_scratchpad()
            }
            elsif ($self->{"method"} eq "postcircumfix:<{ }>") {;
                $arguments = $self->{"arguments"}->emit_begin_scratchpad()
            }
            else {;
                $arguments = [map {;
                    $_->emit_begin_scratchpad()
                } @{$self->{"arguments"}}]
            }
            my $meth = $self->{"method"};
            if (ref($meth) eq "Perlito5::AST::Var") {;
                $meth = $meth->emit_begin_scratchpad()
            }
            return __PACKAGE__()->new(%{$self}, "method", $meth, "invocant", $invocant, "arguments", $arguments)
        }
    }
    package Perlito5::AST::Apply;
    {
        sub Perlito5::AST::Apply::emit_begin_scratchpad_args {
            my $self = $_[0];
            !$self->{"arguments"} && return ();
            return map {;
                $_->emit_begin_scratchpad()
            } @{$self->{"arguments"}}
        }
        sub Perlito5::AST::Apply::emit_begin_scratchpad {
            my $self = $_[0];
            my $code;
            if (ref($self->{"code"})) {;
                $code = $self->{"code"}->emit_begin_scratchpad()
            }
            else {;
                $code = $self->{"code"}
            }
            my $arguments;
            if (ref($self->{"arguments"})) {;
                $arguments = [map {;
                    $_->emit_begin_scratchpad()
                } @{$self->{"arguments"}}]
            }
            else {;
                $arguments = $self->{"arguments"}
            }
            if ($code eq "eval" && $self->{"_scope"}) {;
                $self->{"_scope"}->{"block"} = [grep {;
                    $_->{"_decl"} ne "global"
                } map {;
                    $_->emit_begin_scratchpad()
                } @{$self->{"_scope"}->{"block"}}]
            }
            if ($code eq "my") {
                my @arg;
                for my $var (@{$arguments}) {
                    if ($var->{"namespace"} && $var->{"namespace"} eq "Perlito5::BEGIN") {;
                        push(@arg, $var)
                    }
                    else {;
                        push(@arg, __PACKAGE__()->new("code", $code, "arguments", [$var]))
                    }
                }
                return __PACKAGE__()->new("code", "circumfix:<( )>", "arguments", \@arg)
            }
            return __PACKAGE__()->new(%{$self}, "code", $code, "arguments", $arguments)
        }
    }
    package Perlito5::AST::If;
    {;
        sub Perlito5::AST::If::emit_begin_scratchpad {
            my $self = $_[0];
            return __PACKAGE__()->new(%{$self}, "cond", $self->{"cond"}->emit_begin_scratchpad(), "body", $self->{"body"}->emit_begin_scratchpad(), "otherwise", $self->{"otherwise"}->emit_begin_scratchpad())
        }
    }
    package Perlito5::AST::When;
    {;
        sub Perlito5::AST::When::emit_begin_scratchpad {
            my $self = $_[0];
            return __PACKAGE__()->new(%{$self}, "cond", $self->{"cond"}->emit_begin_scratchpad(), "body", $self->{"body"}->emit_begin_scratchpad())
        }
    }
    package Perlito5::AST::While;
    {;
        sub Perlito5::AST::While::emit_begin_scratchpad {
            my $self = $_[0];
            return __PACKAGE__()->new(%{$self}, "cond", $self->{"cond"}->emit_begin_scratchpad(), "body", $self->{"body"}->emit_begin_scratchpad())
        }
    }
    package Perlito5::AST::For;
    {;
        sub Perlito5::AST::For::emit_begin_scratchpad {
            my $self = $_[0];
            my $cond;
            if (ref($self->{"cond"}) eq "ARRAY") {;
                $cond = [map {;
                    defined($_) ? $_->emit_begin_scratchpad() : $_
                } @{$self->{"cond"}}]
            }
            else {;
                $cond = $self->{"cond"}->emit_begin_scratchpad()
            }
            return __PACKAGE__()->new(%{$self}, "cond", $cond, "body", $self->{"body"}->emit_begin_scratchpad(), ($self->{"continue"} ? ("continue", $self->{"continue"}->emit_begin_scratchpad()) : ()))
        }
    }
    package Perlito5::AST::Decl;
    {;
        sub Perlito5::AST::Decl::emit_begin_scratchpad {
            my $self = $_[0];
            my $var = $self->{"var"}->emit_begin_scratchpad();
            if ($var->{"namespace"} && $var->{"namespace"} eq "Perlito5::BEGIN") {;
                return $var
            }
            return __PACKAGE__()->new(%{$self}, "var", $var)
        }
    }
    package Perlito5::AST::Sub;
    {;
        sub Perlito5::AST::Sub::emit_begin_scratchpad {
            my $self = $_[0];
            my @stmts;
            if (defined($self->{"block"})) {
                @stmts = @{$self->{"block"}->{"stmts"}};
                @stmts = map {;
                    $_->emit_begin_scratchpad()
                } @stmts;
                $self = __PACKAGE__()->new(%{$self}, ($self->{"block"} ? ("block", Perlito5::AST::Block::->new(%{$self->{"block"}}, "stmts", [@stmts])) : ()))
            }
            return $self
        }
    }
    1
}
{
    package main;
    package Perlito5::AST::CompUnit;
    {;
        sub Perlito5::AST::CompUnit::get_captures {;
            ()
        }
    }
    package Perlito5::AST::Int;
    {;
        sub Perlito5::AST::Int::get_captures {;
            ()
        }
    }
    package Perlito5::AST::Num;
    {;
        sub Perlito5::AST::Num::get_captures {;
            ()
        }
    }
    package Perlito5::AST::Buf;
    {;
        sub Perlito5::AST::Buf::get_captures {;
            ()
        }
    }
    package Perlito5::AST::Block;
    {;
        sub Perlito5::AST::Block::get_captures {
            (my $self) = @_;
            my @var;
            for my $stmt (@{$self->{"stmts"}}) {;
                push(@var, $stmt->get_captures())
            }
            return @var
        }
    }
    package Perlito5::AST::Index;
    {;
        sub Perlito5::AST::Index::get_captures {
            my $self = shift;
            my @var;
            push(@var, $self->{"obj"}->get_captures());
            push(@var, $self->{"index_exp"}->get_captures());
            return @var
        }
    }
    package Perlito5::AST::Lookup;
    {;
        sub Perlito5::AST::Lookup::get_captures {
            my $self = shift;
            my @var;
            push(@var, $self->{"obj"}->get_captures());
            push(@var, $self->{"index_exp"}->get_captures());
            return @var
        }
    }
    package Perlito5::AST::Var;
    {;
        sub Perlito5::AST::Var::get_captures {
            my $self = shift;
            if ($self->{"sigil"} eq "\$#") {;
                return Perlito5::AST::Var::->new(%{$self}, "sigil", "\@")
            }
            return ($self)
        }
    }
    package Perlito5::AST::Decl;
    {;
        sub Perlito5::AST::Decl::get_captures {;
            return {"dont" => $_[0]->{"var"}->{"_id"}, }
        }
    }
    package Perlito5::AST::Call;
    {;
        sub Perlito5::AST::Call::get_captures {
            my $self = shift;
            my @var;
            ref($self->{"method"}) && push(@var, $self->{"method"}->get_captures());
            push(@var, $self->{"invocant"}->get_captures());
            my $args = $self->{"arguments"};
            if ($args) {
                if (ref($args) eq "ARRAY") {;
                    push(@var, map {;
                        $_->get_captures()
                    } @{$args})
                }
                else {;
                    push(@var, $args->get_captures())
                }
            }
            return @var
        }
    }
    package Perlito5::AST::Apply;
    {;
        sub Perlito5::AST::Apply::get_captures {
            my $self = shift;
            my $code = $self->{"code"};
            my @var;
            ref($code) && push(@var, $code->get_captures());
            $self->{"arguments"} && push(@var, map {;
                $_->get_captures()
            } @{$self->{"arguments"}});
            ref($self->{"special_arg"}) && push(@var, $self->{"special_arg"}->get_captures());
            if ($code eq "eval" && $self->{"_scope"}) {;
                push(@var, @{$self->{"_scope"}->{"block"}})
            }
            if ($code eq "my" || $code eq "our" || $code eq "state") {;
                push(@var, (map {;
                    ref($_) eq "Perlito5::AST::Var" ? ({"dont" => $_->{"_id"}, }) : ()
                } @{$self->{"arguments"}}))
            }
            return @var
        }
    }
    package Perlito5::AST::If;
    {;
        sub Perlito5::AST::If::get_captures {
            my $self = shift;
            my @var;
            push(@var, $self->{"cond"}->get_captures());
            push(@var, $self->{"body"}->get_captures());
            push(@var, $self->{"otherwise"}->get_captures());
            return @var
        }
    }
    package Perlito5::AST::When;
    {;
        sub Perlito5::AST::When::get_captures {
            my $self = shift;
            my @var;
            push(@var, $self->{"cond"}->get_captures());
            push(@var, $self->{"body"}->get_captures());
            return @var
        }
    }
    package Perlito5::AST::While;
    {;
        sub Perlito5::AST::While::get_captures {
            my $self = shift;
            my @var;
            push(@var, $self->{"cond"}->get_captures());
            push(@var, $self->{"body"}->get_captures());
            return @var
        }
    }
    package Perlito5::AST::For;
    {;
        sub Perlito5::AST::For::get_captures {
            my $self = shift;
            my @var;
            my $body = ref($self->{"body"}) ne "Perlito5::AST::Block" ? [$self->{"body"}] : $self->{"body"}->{"stmts"};
            push(@var, map {;
                $_->get_captures()
            } grep {;
                defined($_)
            } @{$body}, $self->{"topic"}, (ref($self->{"cond"}) eq "ARRAY" ? @{$self->{"cond"}} : $self->{"cond"}));
            return @var
        }
    }
    package Perlito5::AST::Sub;
    {;
        sub Perlito5::AST::Sub::get_captures {
            my $self = shift;
            !$self->{"block"} && return;
            return $self->{"block"}->get_captures()
        }
    }
    1
}
{
    package main;
    package Perlito5::FoldConstant;
    sub Perlito5::FoldConstant::fold_constant {
        my $self = shift;
        my $ref = ref($self);
        ($ref eq "Perlito5::AST::Int" || $ref eq "Perlito5::AST::Num" || $ref eq "Perlito5::AST::Buf") && return $self;
        if ($ref eq "Perlito5::AST::Apply") {
            if ($self->{"code"} eq "infix:<+>") {
                my $arg0 = Perlito5::FoldConstant::fold_constant($self->{"arguments"}->[0]);
                my $arg1 = Perlito5::FoldConstant::fold_constant($self->{"arguments"}->[1]);
                if (Perlito5::FoldConstant::is_constant($arg0) && Perlito5::FoldConstant::is_constant($arg1)) {
                    my $v = $arg0->value() + $arg1->value();
                    if ($v == int($v)) {;
                        return Perlito5::AST::Int::->new("int", $v)
                    }
                    return Perlito5::AST::Num::->new("num", $v)
                }
            }
            if ($self->{"code"} eq "infix:<*>") {
                my $arg0 = Perlito5::FoldConstant::fold_constant($self->{"arguments"}->[0]);
                my $arg1 = Perlito5::FoldConstant::fold_constant($self->{"arguments"}->[1]);
                if (Perlito5::FoldConstant::is_constant($arg0) && Perlito5::FoldConstant::is_constant($arg1)) {
                    my $v = $arg0->value() * $arg1->value();
                    if ($v == int($v)) {;
                        return Perlito5::AST::Int::->new("int", $v)
                    }
                    return Perlito5::AST::Num::->new("num", $v)
                }
            }
            if ($self->{"code"} eq "infix:<!=>") {
                my $arg0 = Perlito5::FoldConstant::fold_constant($self->{"arguments"}->[0]);
                my $arg1 = Perlito5::FoldConstant::fold_constant($self->{"arguments"}->[1]);
                if (Perlito5::FoldConstant::is_constant($arg0) && Perlito5::FoldConstant::is_constant($arg1)) {
                    my $v = $arg0->value() != $arg1->value();
                    if ($v) {;
                        return Perlito5::AST::Int::->new("int", 1)
                    }
                    return Perlito5::AST::Apply::->UNDEF()
                }
            }
            if ($self->{"code"} eq "prefix:<!>") {
                my $arg0 = Perlito5::FoldConstant::fold_constant($self->{"arguments"}->[0]);
                if (Perlito5::FoldConstant::is_constant($arg0)) {
                    my $v = !$arg0->value();
                    if ($v) {;
                        return Perlito5::AST::Int::->new("int", 1)
                    }
                    return Perlito5::AST::Apply::->UNDEF()
                }
            }
            if (my $const = $Perlito5::CONSTANT{($self->{"namespace"}) . "::" . ($self->{"code"})}) {;
                return $const
            }
        }
        return $self
    }
    sub Perlito5::FoldConstant::is_constant {
        my $self = shift;
        my $ref = ref($self);
        return $ref eq "Perlito5::AST::Int" || $ref eq "Perlito5::AST::Num" || $ref eq "Perlito5::AST::Buf" || ($ref eq "Perlito5::AST::Apply" && $self->{"code"} eq "undef")
    }
    1
}
{
    package main;
    package Perlito5::Grammar::Block;
    our %Named_block = ("BEGIN", 1, "UNITCHECK", 1, "CHECK", 1, "INIT", 1, "END", 1, "AUTOLOAD", 1, "DESTROY", 1);
    sub Perlito5::Grammar::Block::block {
        my $str = $_[0];
        my $pos = $_[1];
        my $m = Perlito5::Grammar::Space::opt_ws($str, $pos);
        $pos = $m->{"to"};
        if ($str->[$pos] ne "{") {;
            return
        }
        $pos++;
        Perlito5::Grammar::Scope::check_variable_declarations();
        Perlito5::Grammar::Scope::create_new_compile_time_scope();
        $m = Perlito5::Grammar::exp_stmts($str, $pos);
        if (!$m) {;
            Perlito5::Compiler::error("syntax error")
        }
        $pos = $m->{"to"};
        my $capture = Perlito5::Match::flat($m);
        $m = Perlito5::Grammar::Space::opt_ws($str, $pos);
        $pos = $m->{"to"};
        if ($str->[$pos] ne "}") {;
            Perlito5::Compiler::error("syntax error")
        }
        $m->{"to"} = $pos + 1;
        $m->{"capture"} = Perlito5::AST::Block::->new("stmts", $capture, "sig", undef);
        Perlito5::Grammar::Scope::end_compile_time_scope();
        return $m
    }
    sub Perlito5::Grammar::Block::closure_block {
        my $str = $_[0];
        my $pos = $_[1];
        my $m = Perlito5::Grammar::Space::opt_ws($str, $pos);
        $pos = $m->{"to"};
        if ($str->[$pos] ne "{") {;
            return
        }
        $pos++;
        Perlito5::Grammar::Scope::check_variable_declarations();
        Perlito5::Grammar::Scope::create_new_compile_time_scope();
        local $Perlito5::CLOSURE_SCOPE = $#Perlito5::BASE_SCOPE;
        $m = Perlito5::Grammar::exp_stmts($str, $pos);
        if (!$m) {;
            Perlito5::Compiler::error("syntax error")
        }
        $pos = $m->{"to"};
        my $capture = Perlito5::Match::flat($m);
        $m = Perlito5::Grammar::Space::opt_ws($str, $pos);
        $pos = $m->{"to"};
        if ($str->[$pos] ne "}") {;
            Perlito5::Compiler::error("syntax error")
        }
        $m->{"to"} = $pos + 1;
        $m->{"capture"} = Perlito5::AST::Block::->new("stmts", $capture, "sig", undef);
        Perlito5::Grammar::Scope::end_compile_time_scope();
        return $m
    }
    sub Perlito5::Grammar::Block::eval_end_block {
        (my $block, my $phase) = @_;
        $block = Perlito5::AST::Block::->new("stmts", [Perlito5::AST::Sub::->new("attributes", [], "block", $block, "name", undef, "namespace", $Perlito5::PKG_NAME, "sig", undef, "pos", Perlito5::Compiler::compiler_pos())]);
        return Perlito5::Grammar::Block::eval_begin_block($block, "BEGIN")
    }
    sub Perlito5::Grammar::Block::eval_begin_block {
        my $block = shift;
        local ${^GLOBAL_PHASE};
        Perlito5::set_global_phase("BEGIN");
        my @captured = $block->get_captures();
        my %dont_capture = map {;
            $_->{"dont"} ? ($_->{"dont"}, 1) : ()
        } @captured;
        my %capture = map {;
            $_->{"dont"} ? () : $dont_capture{$_->{"_id"}} ? () : ($_->{"_decl"} eq "local" || $_->{"_decl"} eq "global" || $_->{"_decl"} eq "our" || $_->{"_decl"} eq '') ? () : ($_->{"_id"}, $_)
        } @captured;
        %Perlito5::BEGIN_SCRATCHPAD = (%Perlito5::BEGIN_SCRATCHPAD, %capture);
        $block = $block->emit_begin_scratchpad();
        $block = $block->emit_compile_time();
        local ${"\@"};
        my $result = Perlito5::Perl5::Runtime::eval_ast($block);
        if (${"\@"}) {;
            Perlito5::Compiler::error("Error in BEGIN block: " . ${"\@"})
        }
        return $result
    }
    sub Perlito5::Grammar::Block::opt_continue_block {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = ((do {
            my $tmp1316 = $MATCH->{"to"};
            (((do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (("c" eq $str->[($MATCH->{"to"}) + 0]) && ("o" eq $str->[($MATCH->{"to"}) + 1]) && ("n" eq $str->[($MATCH->{"to"}) + 2]) && ("t" eq $str->[($MATCH->{"to"}) + 3]) && ("i" eq $str->[($MATCH->{"to"}) + 4]) && ("n" eq $str->[($MATCH->{"to"}) + 5]) && ("u" eq $str->[($MATCH->{"to"}) + 6]) && ("e" eq $str->[($MATCH->{"to"}) + 7]) && ($MATCH->{"to"} += 8)) && (do {
                my $m2 = Perlito5::Grammar::Block::block($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"block"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"block"});
                $MATCH->{"capture"}->{"is_continue"} = 1;
                1
            }))) || ($MATCH->{"to"} = $tmp1316, (do {
                $MATCH->{"capture"} = Perlito5::AST::Block::->new("stmts", [], "sig", undef);
                1
            }))
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Block::anon_block {
        my $str = $_[0];
        my $pos = $_[1];
        my $p = $pos;
        local $Perlito5::BLOCK_HAS_SEMICOLON;
        my $m = Perlito5::Grammar::block($str, $p);
        !$m && return;
        $p = $m->{"to"};
        my $block = Perlito5::Match::flat($m);
        $m = Perlito5::Grammar::opt_continue_block($str, $p);
        $p = $m->{"to"};
        my $continue = Perlito5::Match::flat($m);
        my $v = $block;
        !$continue->{"is_continue"} && !$Perlito5::BLOCK_HAS_SEMICOLON && ($v = Perlito5::Grammar::Expression::block_or_hash($v));
        $m->{"capture"} = $v;
        if ($continue->{"is_continue"}) {;
            $m->{"capture"}->{"continue"} = $continue
        }
        return $m
    }
    sub Perlito5::Grammar::Block::ast_nop {;
        Perlito5::AST::Apply::->new("code", "nop", "namespace", "Perlito5", "arguments", [])
    }
    sub Perlito5::Grammar::Block::special_named_block {
        my $str = $_[0];
        my $pos = $_[1];
        my $p = $pos;
        my $block_name;
        my $m_name = Perlito5::Grammar::ident($str, $p);
        !$m_name && return;
        $p = $m_name->{"to"};
        $block_name = Perlito5::Match::flat($m_name);
        my $ws = Perlito5::Grammar::Space::opt_ws($str, $p);
        $p = $ws->{"to"};
        my $block_start = $p;
        my $m = Perlito5::Grammar::Block::closure_block($str, $p);
        !$m && return;
        $p = $m->{"to"};
        my $block = Perlito5::Match::flat($m);
        if ($block_name eq "INIT") {
            push(@Perlito5::INIT_BLOCK, Perlito5::Grammar::Block::eval_end_block($block, "INIT"));
            $m->{"capture"} = Perlito5::Grammar::Block::ast_nop()
        }
        elsif ($block_name eq "END") {
            unshift(@Perlito5::END_BLOCK, Perlito5::Grammar::Block::eval_end_block($block, "END"));
            $m->{"capture"} = Perlito5::Grammar::Block::ast_nop()
        }
        elsif ($block_name eq "CHECK") {
            unshift(@Perlito5::CHECK_BLOCK, Perlito5::Grammar::Block::eval_end_block($block, "CHECK"));
            $m->{"capture"} = Perlito5::Grammar::Block::ast_nop()
        }
        elsif ($block_name eq "UNITCHECK") {
            unshift(@Perlito5::UNITCHECK_BLOCK, Perlito5::Grammar::Block::eval_end_block($block, "UNITCHECK"));
            $m->{"capture"} = Perlito5::Grammar::Block::ast_nop()
        }
        elsif ($block_name eq "BEGIN") {
            local $Perlito5::PHASE = "BEGIN";
            Perlito5::Grammar::Block::eval_begin_block($block);
            $m->{"capture"} = Perlito5::Grammar::Block::ast_nop()
        }
        elsif ($block_name eq "AUTOLOAD" || $block_name eq "DESTROY") {
            my $sub = Perlito5::AST::Sub::->new("attributes", [], "block", $block, "name", $block_name, "namespace", $Perlito5::PKG_NAME, "sig", undef, "pos", Perlito5::Compiler::compiler_pos());
            my $full_name = ($sub->{"namespace"}) . "::" . ($sub->{"name"});
            $Perlito5::PROTO->{$full_name} = undef;
            $Perlito5::GLOBAL->{$full_name} = $sub;
            $block = Perlito5::AST::Block::->new("stmts", [$sub]);
            Perlito5::Grammar::Block::eval_begin_block($block, "BEGIN");
            $m->{"capture"} = Perlito5::Grammar::Block::ast_nop()
        }
        else {
            $m->{"capture"} = $block;
            $m->{"capture"}->{"name"} = $block_name
        }
        return $m
    }
    sub Perlito5::Grammar::Block::named_sub_def {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $m2 = Perlito5::Grammar::optional_namespace_before_ident($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::optional_namespace_before_ident"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::ident($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::ident"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Block::prototype_($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Block::prototype_"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Attribute::opt_attribute($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Attribute::opt_attribute"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $tmp1344 = $MATCH->{"to"};
            (((do {
                my $m2 = Perlito5::Grammar::Block::closure_block($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::Block::closure_block"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                $MATCH->{"_tmp"} = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Block::closure_block"});
                1
            }))) || ($MATCH->{"to"} = $tmp1344, ((do {
                my $m2 = Perlito5::Grammar::Statement::statement_parse($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (do {
                Perlito5::Compiler::error("Illegal declaration of subroutine '", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::ident"}), "'");
                1
            }))) || ($MATCH->{"to"} = $tmp1344, (do {
                $MATCH->{"_tmp"} = undef;
                1
            }))
        }) && (do {
            my $name = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::ident"});
            my $sig = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Block::prototype_"});
            $sig eq "*undef*" && ($sig = undef);
            my $attributes = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Attribute::opt_attribute"});
            (my $proto) = grep {;
                $_->[0] eq "prototype"
            } @{$attributes};
            if ($proto) {
                $attributes = [grep {;
                    $_->[0] ne "prototype"
                } @{$attributes}];
                $sig = $proto->[1]
            }
            my $namespace = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::optional_namespace_before_ident"});
            if ($name) {
                if (!$namespace) {;
                    $namespace = $name eq "_" ? "main" : $Perlito5::PKG_NAME
                }
                my $full_name = $namespace . "::" . $name;
                $Perlito5::PROTO->{$full_name} = $sig
            }
            my $sub = Perlito5::AST::Sub::->new("name", $name, "namespace", $namespace, "sig", $sig, "block", $MATCH->{"_tmp"}, "attributes", $attributes, "pos", Perlito5::Compiler::compiler_pos());
            if ($name && defined($sig) && $sig eq '' && $sub->{"block"} && @{$sub->{"block"}->{"stmts"}} == 1) {
                my $expr = $sub->{"block"}->{"stmts"}->[0];
                $expr = Perlito5::FoldConstant::fold_constant($expr);
                my $ref = ref($expr);
                if ($ref eq "Perlito5::AST::Int" || $ref eq "Perlito5::AST::Num" || $ref eq "Perlito5::AST::Buf") {;
                    $Perlito5::CONSTANT{$namespace . "::" . $name} = $expr
                }
            }
            if ($Perlito5::EXPAND_USE && $name) {
                my $full_name = $namespace . "::" . $name;
                my $block = Perlito5::AST::Block::->new("stmts", [$sub]);
                Perlito5::Grammar::Block::eval_begin_block($block, "BEGIN");
                $Perlito5::GLOBAL->{$full_name} = $sub;
                $sub = Perlito5::Grammar::Block::ast_nop();
                $MATCH->{"capture"} = $sub
            }
            else {;
                $MATCH->{"capture"} = $sub
            }
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Block::named_sub {
        my $str = $_[0];
        my $pos = $_[1];
        $str->[$pos] eq "s" && $str->[$pos + 1] eq "u" && $str->[$pos + 2] eq "b" || return;
        my $ws = Perlito5::Grammar::Space::ws($str, $pos + 3);
        $ws || return;
        my $p = $ws->{"to"};
        my $m_name = Perlito5::Grammar::ident($str, $p);
        $m_name || return;
        my $block_name = Perlito5::Match::flat($m_name);
        if (exists($Named_block{$block_name})) {;
            return Perlito5::Grammar::Block::special_named_block($str, $p)
        }
        return Perlito5::Grammar::Block::named_sub_def($str, $p)
    }
    sub Perlito5::Grammar::Block::term_anon_sub {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((("s" eq $str->[($MATCH->{"to"}) + 0]) && ("u" eq $str->[($MATCH->{"to"}) + 1]) && ("b" eq $str->[($MATCH->{"to"}) + 2]) && ($MATCH->{"to"} += 3)) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Block::anon_sub_def($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Block::anon_sub_def"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = ["term", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Block::anon_sub_def"})];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Block::term_do {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((("d" eq $str->[($MATCH->{"to"}) + 0]) && ("o" eq $str->[($MATCH->{"to"}) + 1]) && ($MATCH->{"to"} += 2)) && (do {
            my $m2 = Perlito5::Grammar::block($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::block"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", "do", "arguments", [Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::block"})])];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Block::args_sig {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = ((do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{"to"};
            while ((do {
                my $tmp1386 = $MATCH->{"to"};
                (((";" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1386, (("\\" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1386, (("[" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1386, (("]" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1386, (("*" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1386, (("+" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1386, (("\@" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1386, (("%" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1386, (("\$" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1386, (("&" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)))
            }) && ($last_match_null < 2)) {
                if ($to == $MATCH->{"to"}) {;
                    $last_match_null = $last_match_null + 1
                }
                else {;
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{"to"}
            }
            $MATCH = $m;
            $MATCH->{"to"} = $to;
            1
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Block::prototype_ {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = ((do {
            my $tmp1395 = $MATCH->{"to"};
            (((do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (("(" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (("_" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && ((")" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                $MATCH->{"capture"} = "_";
                1
            }))) || ($MATCH->{"to"} = $tmp1395, ((do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (("(" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $m2 = Perlito5::Grammar::Block::args_sig($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"args_sig"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && ((")" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                $MATCH->{"capture"} = '' . Perlito5::Match::flat($MATCH->{"args_sig"});
                1
            }))) || ($MATCH->{"to"} = $tmp1395, (do {
                $MATCH->{"capture"} = "*undef*";
                1
            }))
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Block::anon_sub_def {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $m2 = Perlito5::Grammar::Block::prototype_($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"prototype_"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Attribute::opt_attribute($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Attribute::opt_attribute"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Block::closure_block($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Block::closure_block"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $sig = Perlito5::Match::flat($MATCH->{"prototype_"});
            $sig eq "*undef*" && ($sig = undef);
            my $attributes = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Attribute::opt_attribute"});
            (my $proto) = grep {;
                $_->[0] eq "prototype"
            } @{$attributes};
            if ($proto) {
                $attributes = [grep {;
                    $_->[0] ne "prototype"
                } @{$attributes}];
                $sig = $proto->[1]
            }
            $MATCH->{"capture"} = Perlito5::AST::Sub::->new("name", undef, "namespace", undef, "sig", $sig, "block", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Block::closure_block"}), "attributes", $attributes, "pos", Perlito5::Compiler::compiler_pos());
            1
        })));
        $tmp ? $MATCH : undef
    }
    Perlito5::Grammar::Precedence::add_term("do", \&term_do);
    Perlito5::Grammar::Precedence::add_term("sub", \&term_anon_sub);
    Perlito5::Grammar::Statement::add_statement("{", \&anon_block);
    Perlito5::Grammar::Statement::add_statement("sub", \&named_sub);
    Perlito5::Grammar::Statement::add_statement($_, \&special_named_block)
        for keys(%Named_block);
    1
}
{
    package main;
    package Perlito5::Grammar::Space;
    my %line_index;
    sub Perlito5::Grammar::Space::count_line {
        my $pos = $_[0];
        $pos < $line_index{$Perlito5::FILE_NAME} && return;
        $line_index{$Perlito5::FILE_NAME} = $pos + 1;
        $Perlito5::LINE_NUMBER++
    }
    my %space = ("#", sub {
        my $m = Perlito5::Grammar::Space::to_eol($_[0], $_[1]);
        $m->{"to"}
    }, chr(9), sub {;
        $_[1]
    }, chr(10), sub {
        my $str = $_[0];
        my $pos = $_[1];
        Perlito5::Grammar::Space::count_line($pos);
        $str->[$pos] eq chr(13) && $pos++;
        my $m = Perlito5::Grammar::Space::start_of_line($_[0], $pos);
        $m->{"to"}
    }, chr(12), sub {;
        $_[1]
    }, chr(13), sub {
        my $str = $_[0];
        my $pos = $_[1];
        if ($str->[$pos] eq chr(10)) {
            Perlito5::Grammar::Space::count_line($pos);
            $pos++
        }
        my $m = Perlito5::Grammar::Space::start_of_line($_[0], $pos);
        $m->{"to"}
    }, chr(32), sub {;
        $_[1]
    });
    sub Perlito5::Grammar::Space::term_space {
        my $str = $_[0];
        my $pos = $_[1];
        my $p = $pos;
        my $sp = $space{$str->[$p]};
        while ($p <= @{$str} && $sp) {
            $p = $sp->($str, $p + 1);
            $sp = $space{$str->[$p]}
        }
        return {"str" => $str, "from" => $pos, "to" => $p, "capture" => ["space", " "], }
    }
    sub Perlito5::Grammar::Space::term_end {
        my $str = $_[0];
        my $p = $_[1];
        my $is_data = 0;
        my $s = join('', @{$str}[$p .. $p + 6]);
        if ($s eq "__END__" && $Perlito5::PKG_NAME eq "main") {
            $p = $p + 7;
            $is_data = 1
        }
        elsif ($s . ($str->[$p + 7]) eq "__DATA__") {
            $p = $p + 8;
            $is_data = 1
        }
        my $m = Perlito5::Grammar::Space::to_eol($str, $p);
        $p = $m->{"to"};
        if ($str->[$p] eq chr(10)) {
            Perlito5::Grammar::Space::count_line($p);
            $p++;
            $str->[$p] eq chr(13) && $p++
        }
        elsif ($str->[$p] eq chr(13)) {
            $p++;
            if ($str->[$p] eq chr(10)) {
                Perlito5::Grammar::Space::count_line($p);
                $p++
            }
        }
        if ($is_data) {
            my $source = join('', @{$str});
            my $len = length($source);
            $source =~ s/^.*\n#--START--\n# line 1//s;
            my $pos = ($p - $len) + length($source);
            $Perlito5::DATA_SECTION{$Perlito5::PKG_NAME} = {"pos" => $pos, "data" => $source, };
            my $pkg = $Perlito5::PKG_NAME;
            open(*{$pkg . "::DATA"}, "<", \$Perlito5::DATA_SECTION{$pkg}->{"data"});
            seek(*{$pkg . "::DATA"}, $Perlito5::DATA_SECTION{$pkg}->{"pos"}, 0)
        }
        return {"str" => $str, "from" => $_[1], "to" => scalar(@{$str}), "capture" => ["space", " "], }
    }
    sub Perlito5::Grammar::Space::stmt_end {
        my $ret = Perlito5::Grammar::Space::term_end(@_);
        $ret->{"capture"} = undef;
        return $ret
    }
    Perlito5::Grammar::Precedence::add_term("#", \&term_space);
    Perlito5::Grammar::Precedence::add_term(chr(9), \&term_space);
    Perlito5::Grammar::Precedence::add_term(chr(10), \&term_space);
    Perlito5::Grammar::Precedence::add_term(chr(12), \&term_space);
    Perlito5::Grammar::Precedence::add_term(chr(13), \&term_space);
    Perlito5::Grammar::Precedence::add_term(chr(32), \&term_space);
    Perlito5::Grammar::Precedence::add_term("__END__", \&term_end);
    Perlito5::Grammar::Precedence::add_term("__DATA__", \&term_end);
    Perlito5::Grammar::Statement::add_statement("__END__", \&stmt_end);
    Perlito5::Grammar::Statement::add_statement("__DATA__", \&stmt_end);
    sub Perlito5::Grammar::Space::to_eol {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = ((do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{"to"};
            while (((do {
                my $tmp = $MATCH;
                $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
                my $res = (do {
                    my $tmp1443 = $MATCH->{"to"};
                    ((("
" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1443, (("\x{d}" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)))
                });
                $MATCH = $tmp;
                $res ? 0 : 1
            }) && ('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"})) && ($last_match_null < 2)) {
                if ($to == $MATCH->{"to"}) {;
                    $last_match_null = $last_match_null + 1
                }
                else {;
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{"to"}
            }
            $MATCH = $m;
            $MATCH->{"to"} = $to;
            1
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Space::pod_pod_begin {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{"to"};
            while (((do {
                my $tmp = $MATCH;
                $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
                my $res = ((do {
                    my $tmp1454 = $MATCH->{"to"};
                    ((("
" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1454, (("\x{d}" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)))
                }) && (("=" eq $str->[($MATCH->{"to"}) + 0]) && ("c" eq $str->[($MATCH->{"to"}) + 1]) && ("u" eq $str->[($MATCH->{"to"}) + 2]) && ("t" eq $str->[($MATCH->{"to"}) + 3]) && ($MATCH->{"to"} += 4)));
                $MATCH = $tmp;
                $res ? 0 : 1
            }) && ('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"})) && ($last_match_null < 2)) {
                if ($to == $MATCH->{"to"}) {;
                    $last_match_null = $last_match_null + 1
                }
                else {;
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{"to"}
            }
            $MATCH = $m;
            $MATCH->{"to"} = $to;
            1
        }) && (do {
            my $tmp1455 = $MATCH->{"to"};
            (((do {
                my $tmp1456 = $MATCH->{"to"};
                ((("
" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1456, (("\x{d}" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)))
            }) && (("=" eq $str->[($MATCH->{"to"}) + 0]) && ("c" eq $str->[($MATCH->{"to"}) + 1]) && ("u" eq $str->[($MATCH->{"to"}) + 2]) && ("t" eq $str->[($MATCH->{"to"}) + 3]) && ($MATCH->{"to"} += 4)) && (do {
                my $m2 = Perlito5::Grammar::Space::to_eol($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }))) || ($MATCH->{"to"} = $tmp1455, 1)
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Space::pod_begin {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{"to"};
            while (((do {
                my $tmp = $MATCH;
                $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
                my $res = ((do {
                    my $tmp1470 = $MATCH->{"to"};
                    ((("
" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1470, (("\x{d}" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)))
                }) && (("=" eq $str->[($MATCH->{"to"}) + 0]) && ("e" eq $str->[($MATCH->{"to"}) + 1]) && ("n" eq $str->[($MATCH->{"to"}) + 2]) && ("d" eq $str->[($MATCH->{"to"}) + 3]) && ($MATCH->{"to"} += 4)));
                $MATCH = $tmp;
                $res ? 0 : 1
            }) && ('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"})) && ($last_match_null < 2)) {
                if ($to == $MATCH->{"to"}) {;
                    $last_match_null = $last_match_null + 1
                }
                else {;
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{"to"}
            }
            $MATCH = $m;
            $MATCH->{"to"} = $to;
            1
        }) && (do {
            my $tmp1471 = $MATCH->{"to"};
            (((do {
                my $tmp1472 = $MATCH->{"to"};
                ((("
" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1472, (("\x{d}" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)))
            }) && (("=" eq $str->[($MATCH->{"to"}) + 0]) && ("e" eq $str->[($MATCH->{"to"}) + 1]) && ("n" eq $str->[($MATCH->{"to"}) + 2]) && ("d" eq $str->[($MATCH->{"to"}) + 3]) && ($MATCH->{"to"} += 4)) && (do {
                my $m2 = Perlito5::Grammar::Space::to_eol($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }))) || ($MATCH->{"to"} = $tmp1471, 1)
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Space::start_of_line {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $m2 = Perlito5::Grammar::String::here_doc($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $tmp1486 = $MATCH->{"to"};
            (((("=" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $tmp1487 = $MATCH->{"to"};
                (((("p" eq $str->[($MATCH->{"to"}) + 0]) && ("o" eq $str->[($MATCH->{"to"}) + 1]) && ("d" eq $str->[($MATCH->{"to"}) + 2]) && ($MATCH->{"to"} += 3)) && (do {
                    my $m2 = Perlito5::Grammar::Space::pod_pod_begin($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }))) || ($MATCH->{"to"} = $tmp1487, ((("h" eq $str->[($MATCH->{"to"}) + 0]) && ("e" eq $str->[($MATCH->{"to"}) + 1]) && ("a" eq $str->[($MATCH->{"to"}) + 2]) && ("d" eq $str->[($MATCH->{"to"}) + 3]) && ($MATCH->{"to"} += 4)) && (do {
                    my $m2 = Perlito5::Grammar::Space::pod_pod_begin($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }))) || ($MATCH->{"to"} = $tmp1487, ((("i" eq $str->[($MATCH->{"to"}) + 0]) && ("t" eq $str->[($MATCH->{"to"}) + 1]) && ("e" eq $str->[($MATCH->{"to"}) + 2]) && ("m" eq $str->[($MATCH->{"to"}) + 3]) && ($MATCH->{"to"} += 4)) && (do {
                    my $m2 = Perlito5::Grammar::Space::pod_pod_begin($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }))) || ($MATCH->{"to"} = $tmp1487, ((("o" eq $str->[($MATCH->{"to"}) + 0]) && ("v" eq $str->[($MATCH->{"to"}) + 1]) && ("e" eq $str->[($MATCH->{"to"}) + 2]) && ("r" eq $str->[($MATCH->{"to"}) + 3]) && ($MATCH->{"to"} += 4)) && (do {
                    my $m2 = Perlito5::Grammar::Space::pod_pod_begin($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }))) || ($MATCH->{"to"} = $tmp1487, ((("b" eq $str->[($MATCH->{"to"}) + 0]) && ("a" eq $str->[($MATCH->{"to"}) + 1]) && ("c" eq $str->[($MATCH->{"to"}) + 2]) && ("k" eq $str->[($MATCH->{"to"}) + 3]) && ($MATCH->{"to"} += 4)) && (do {
                    my $m2 = Perlito5::Grammar::Space::pod_pod_begin($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }))) || ($MATCH->{"to"} = $tmp1487, ((("b" eq $str->[($MATCH->{"to"}) + 0]) && ("e" eq $str->[($MATCH->{"to"}) + 1]) && ("g" eq $str->[($MATCH->{"to"}) + 2]) && ("i" eq $str->[($MATCH->{"to"}) + 3]) && ("n" eq $str->[($MATCH->{"to"}) + 4]) && ($MATCH->{"to"} += 5)) && (do {
                    my $m2 = Perlito5::Grammar::Space::pod_begin($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }))) || ($MATCH->{"to"} = $tmp1487, ((("f" eq $str->[($MATCH->{"to"}) + 0]) && ("o" eq $str->[($MATCH->{"to"}) + 1]) && ("r" eq $str->[($MATCH->{"to"}) + 2]) && ($MATCH->{"to"} += 3)) && (do {
                    my $m2 = Perlito5::Grammar::Space::pod_begin($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }))) || ($MATCH->{"to"} = $tmp1487, ((("e" eq $str->[($MATCH->{"to"}) + 0]) && ("n" eq $str->[($MATCH->{"to"}) + 1]) && ("c" eq $str->[($MATCH->{"to"}) + 2]) && ("o" eq $str->[($MATCH->{"to"}) + 3]) && ("d" eq $str->[($MATCH->{"to"}) + 4]) && ("i" eq $str->[($MATCH->{"to"}) + 5]) && ("n" eq $str->[($MATCH->{"to"}) + 6]) && ("g" eq $str->[($MATCH->{"to"}) + 7]) && ($MATCH->{"to"} += 8)) && (do {
                    my $m2 = Perlito5::Grammar::Space::to_eol($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }))) || ($MATCH->{"to"} = $tmp1487, ((("c" eq $str->[($MATCH->{"to"}) + 0]) && ("u" eq $str->[($MATCH->{"to"}) + 1]) && ("t" eq $str->[($MATCH->{"to"}) + 2]) && ($MATCH->{"to"} += 3)) && (do {
                    my $m2 = Perlito5::Grammar::Space::to_eol($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                })))
            }))) || ($MATCH->{"to"} = $tmp1486, ((("#" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $last_match_null = 0;
                my $m = $MATCH;
                my $to = $MATCH->{"to"};
                while ((do {
                    my $tmp1488 = $MATCH->{"to"};
                    (((" " eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1488, (("\x{9}" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)))
                }) && ($last_match_null < 2)) {
                    if ($to == $MATCH->{"to"}) {;
                        $last_match_null = $last_match_null + 1
                    }
                    else {;
                        $last_match_null = 0
                    }
                    $m = $MATCH;
                    $to = $MATCH->{"to"}
                }
                $MATCH = $m;
                $MATCH->{"to"} = $to;
                1
            }) && (("l" eq $str->[($MATCH->{"to"}) + 0]) && ("i" eq $str->[($MATCH->{"to"}) + 1]) && ("n" eq $str->[($MATCH->{"to"}) + 2]) && ("e" eq $str->[($MATCH->{"to"}) + 3]) && ($MATCH->{"to"} += 4)) && (do {
                my $last_match_null = 0;
                my $m = $MATCH;
                my $to = $MATCH->{"to"};
                my $count = 0;
                while ((do {
                    my $tmp1489 = $MATCH->{"to"};
                    (((" " eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1489, (("\x{9}" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)))
                }) && ($last_match_null < 2)) {
                    if ($to == $MATCH->{"to"}) {;
                        $last_match_null = $last_match_null + 1
                    }
                    else {;
                        $last_match_null = 0
                    }
                    $m = $MATCH;
                    $to = $MATCH->{"to"};
                    $count = $count + 1
                }
                $MATCH = $m;
                $MATCH->{"to"} = $to;
                $count > 0
            }) && (do {
                my $m2 = Perlito5::Grammar::Number::digits($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::Number::digits"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $last_match_null = 0;
                my $m = $MATCH;
                my $to = $MATCH->{"to"};
                while ((do {
                    my $tmp1490 = $MATCH->{"to"};
                    (((" " eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1490, (("\x{9}" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)))
                }) && ($last_match_null < 2)) {
                    if ($to == $MATCH->{"to"}) {;
                        $last_match_null = $last_match_null + 1
                    }
                    else {;
                        $last_match_null = 0
                    }
                    $m = $MATCH;
                    $to = $MATCH->{"to"}
                }
                $MATCH = $m;
                $MATCH->{"to"} = $to;
                1
            }) && (do {
                my $m2 = Perlito5::Grammar::Space::to_eol($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (do {
                $Perlito5::LINE_NUMBER = 0 + Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Number::digits"});
                1
            }))) || ($MATCH->{"to"} = $tmp1486, 1)
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Space::ws {
        my $str = $_[0];
        my $pos = $_[1];
        my $p = $pos;
        my $sp = $space{$str->[$p]};
        while ($p <= @{$str} && $sp) {
            $p = $sp->($str, $p + 1);
            $sp = $space{$str->[$p]}
        }
        if ($p == $pos) {;
            return
        }
        return {"str" => $str, "from" => $pos, "to" => $p, }
    }
    sub Perlito5::Grammar::Space::opt_ws {
        my $str = $_[0];
        my $pos = $_[1];
        my $p = $pos;
        my $sp = $space{$str->[$p]};
        while ($p <= @{$str} && $sp) {
            $p = $sp->($str, $p + 1);
            $sp = $space{$str->[$p]}
        }
        return {"str" => $_[0], "from" => $pos, "to" => $p, }
    }
    1
}
{
    package main;
    package Perlito5::Grammar::Print;
    our %Print = ("print", 1, "printf", 1, "say", 1, "exec", 1, "system", 1);
    sub Perlito5::Grammar::Print::print_decl {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = ((do {
            my $tmp1531 = $MATCH->{"to"};
            ((("p" eq $str->[($MATCH->{"to"}) + 0]) && ("r" eq $str->[($MATCH->{"to"}) + 1]) && ("i" eq $str->[($MATCH->{"to"}) + 2]) && ("n" eq $str->[($MATCH->{"to"}) + 3]) && ("t" eq $str->[($MATCH->{"to"}) + 4]) && ("f" eq $str->[($MATCH->{"to"}) + 5]) && ($MATCH->{"to"} += 6))) || ($MATCH->{"to"} = $tmp1531, (("p" eq $str->[($MATCH->{"to"}) + 0]) && ("r" eq $str->[($MATCH->{"to"}) + 1]) && ("i" eq $str->[($MATCH->{"to"}) + 2]) && ("n" eq $str->[($MATCH->{"to"}) + 3]) && ("t" eq $str->[($MATCH->{"to"}) + 4]) && ($MATCH->{"to"} += 5))) || ($MATCH->{"to"} = $tmp1531, (("s" eq $str->[($MATCH->{"to"}) + 0]) && ("a" eq $str->[($MATCH->{"to"}) + 1]) && ("y" eq $str->[($MATCH->{"to"}) + 2]) && ($MATCH->{"to"} += 3))) || ($MATCH->{"to"} = $tmp1531, (("e" eq $str->[($MATCH->{"to"}) + 0]) && ("x" eq $str->[($MATCH->{"to"}) + 1]) && ("e" eq $str->[($MATCH->{"to"}) + 2]) && ("c" eq $str->[($MATCH->{"to"}) + 3]) && ($MATCH->{"to"} += 4))) || ($MATCH->{"to"} = $tmp1531, (("s" eq $str->[($MATCH->{"to"}) + 0]) && ("y" eq $str->[($MATCH->{"to"}) + 1]) && ("s" eq $str->[($MATCH->{"to"}) + 2]) && ("t" eq $str->[($MATCH->{"to"}) + 3]) && ("e" eq $str->[($MATCH->{"to"}) + 4]) && ("m" eq $str->[($MATCH->{"to"}) + 5]) && ($MATCH->{"to"} += 6)))
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Print::the_object {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $tmp1537 = $MATCH->{"to"};
            (((do {
                my $tmp = $MATCH;
                $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
                my $res = (("\$" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1));
                $MATCH = $tmp;
                $res ? 1 : 0
            }) && (do {
                my $m2 = Perlito5::Grammar::Sigil::term_sigil($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::Sigil::term_sigil"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $tmp = $MATCH;
                $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
                my $res = (("+" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1));
                $MATCH = $tmp;
                $res ? 0 : 1
            }) && (do {
                $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Sigil::term_sigil"})->[1];
                1
            }))) || ($MATCH->{"to"} = $tmp1537, ((do {
                my $tmp = $MATCH;
                $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
                my $res = (("{" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1));
                $MATCH = $tmp;
                $res ? 1 : 0
            }) && (do {
                my $m2 = Perlito5::Grammar::Block::block($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::Block::block"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Block::block"});
                1
            }))) || ($MATCH->{"to"} = $tmp1537, ((do {
                my $m2 = Perlito5::Grammar::Print::typeglob($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"typeglob"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"typeglob"});
                1
            })))
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $tmp = $MATCH;
            $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
            my $res = (do {
                my $tmp1538 = $MATCH->{"to"};
                ((("," eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1538, (("?" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1538, (("-" eq $str->[($MATCH->{"to"}) + 0]) && (">" eq $str->[($MATCH->{"to"}) + 1]) && ($MATCH->{"to"} += 2))) || ($MATCH->{"to"} = $tmp1538, (("[" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1538, (("{" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)))
            });
            $MATCH = $tmp;
            $res ? 0 : 1
        }) && (do {
            my $pos = $MATCH->{"to"};
            my $s = $str->[$pos];
            if ($s eq "+") {
                my $m = Perlito5::Grammar::Space::ws($MATCH->{"str"}, $pos + 1);
                if ($m) {;
                    return
                }
            }
            else {
                my $m = Perlito5::Grammar::Precedence::op_parse($MATCH->{"str"}, $pos, 1);
                my $next_op = $m ? Perlito5::Match::flat($m)->[1] : '';
                my $is_infix = Perlito5::Grammar::Precedence::is_fixity_type("infix", $next_op);
                $is_infix && $next_op ne "<<" && return
            }
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Print::typeglob {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $m2 = Perlito5::Grammar::Print::typeglob_bareword($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"typeglob_bareword"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $tmp = $MATCH;
            $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
            my $res = (("(" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1));
            $MATCH = $tmp;
            $res ? 0 : 1
        }) && (do {
            $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"typeglob_bareword"});
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Print::typeglob_bareword {
        my $str = $_[0];
        my $pos = $_[1];
        my $p = $pos;
        my $m_namespace = Perlito5::Grammar::optional_namespace_before_ident($str, $p);
        my $namespace = Perlito5::Match::flat($m_namespace);
        $p = $m_namespace->{"to"};
        my $m_name = Perlito5::Grammar::ident($str, $p);
        if (!$m_name) {
            if ($namespace) {
                $m_namespace->{"capture"} = Perlito5::AST::Var::->new("sigil", "::", "name", '', "namespace", $namespace);
                return $m_namespace
            }
            return
        }
        my $name = Perlito5::Match::flat($m_name);
        $p = $m_name->{"to"};
        my $s = $str->[$p];
        my $s2 = $s . ($str->[$p + 1]);
        if ($s2 eq "::") {
            $m_name->{"to"} = $p + 2;
            $m_name->{"capture"} = Perlito5::AST::Var::->new("sigil", "::", "name", '', "namespace", $namespace . "::" . $name);
            return $m_name
        }
        my $effective_name = ($namespace || $Perlito5::PKG_NAME) . "::" . $name;
        if (exists($Perlito5::PROTO->{$effective_name}) || exists(&{$effective_name})) {;
            return
        }
        if ((!$namespace || $namespace eq "CORE") && exists($Perlito5::CORE_PROTO->{"CORE::" . $name})) {;
            return
        }
        my $full_name = $name;
        $namespace && ($full_name = $namespace . "::" . $name);
        $m_name->{"capture"} = Perlito5::AST::Var::->new("sigil", "::", "name", '', "namespace", $full_name);
        return $m_name
    }
    sub Perlito5::Grammar::Print::print_ast {
        (my $decl, my $the_object, my $expr) = @_;
        Perlito5::AST::Apply::->new("namespace", '', "code", $decl, "special_arg", $the_object, "arguments", $expr)
    }
    sub Perlito5::Grammar::Print::term_print {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $m2 = Perlito5::Grammar::Print::print_decl($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"print_decl"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $tmp1584 = $MATCH->{"to"};
            (((("(" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (do {
                $MATCH->{"_scope"} = $#Perlito5::SCOPE_STMT;
                1
            }) && (do {
                my $tmp1585 = $MATCH->{"to"};
                (((do {
                    my $m2 = Perlito5::Grammar::Print::the_object($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"the_object"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Expression::list_parse"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }))) || ($MATCH->{"to"} = $tmp1585, (do {
                    $#Perlito5::SCOPE_STMT = $MATCH->{"_scope"};
                    return;
                    1
                }))
            }) && ((")" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $list = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::list_parse"});
                !ref($list) && return;
                $MATCH->{"capture"} = ["term", Perlito5::Grammar::Print::print_ast(Perlito5::Match::flat($MATCH->{"print_decl"}), Perlito5::Match::flat($MATCH->{"the_object"}), Perlito5::Grammar::Expression::expand_list($list))];
                1
            }))) || ($MATCH->{"to"} = $tmp1584, ((do {
                $MATCH->{"_scope"} = $#Perlito5::SCOPE_STMT;
                1
            }) && (do {
                my $tmp1586 = $MATCH->{"to"};
                (((do {
                    my $m2 = Perlito5::Grammar::Print::the_object($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"the_object"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Expression::list_parse"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }))) || ($MATCH->{"to"} = $tmp1586, (do {
                    $#Perlito5::SCOPE_STMT = $MATCH->{"_scope"};
                    return;
                    1
                }))
            }) && (do {
                my $list = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::list_parse"});
                !ref($list) && return;
                $MATCH->{"capture"} = ["term", Perlito5::Grammar::Print::print_ast(Perlito5::Match::flat($MATCH->{"print_decl"}), Perlito5::Match::flat($MATCH->{"the_object"}), Perlito5::Grammar::Expression::expand_list($list))];
                1
            })))
        })));
        $tmp ? $MATCH : undef
    }
    Perlito5::Grammar::Precedence::add_term("print", \&term_print);
    Perlito5::Grammar::Precedence::add_term("printf", \&term_print);
    Perlito5::Grammar::Precedence::add_term("say", \&term_print);
    Perlito5::Grammar::Precedence::add_term("exec", \&term_print);
    Perlito5::Grammar::Precedence::add_term("system", \&term_print);
    1
}
{
    package main;
    package Perlito5::Grammar::Map;
    sub Perlito5::Grammar::Map::map_or_grep {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = ((do {
            my $tmp1603 = $MATCH->{"to"};
            ((("m" eq $str->[($MATCH->{"to"}) + 0]) && ("a" eq $str->[($MATCH->{"to"}) + 1]) && ("p" eq $str->[($MATCH->{"to"}) + 2]) && ($MATCH->{"to"} += 3))) || ($MATCH->{"to"} = $tmp1603, (("g" eq $str->[($MATCH->{"to"}) + 0]) && ("r" eq $str->[($MATCH->{"to"}) + 1]) && ("e" eq $str->[($MATCH->{"to"}) + 2]) && ("p" eq $str->[($MATCH->{"to"}) + 3]) && ($MATCH->{"to"} += 4)))
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Map::term_map_or_grep {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $m2 = Perlito5::Grammar::Map::map_or_grep($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"map_or_grep"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $tmp1609 = $MATCH->{"to"};
            (((do {
                my $m2 = Perlito5::Grammar::block($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::block"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::Expression::list_parse"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", Perlito5::Match::flat($MATCH->{"map_or_grep"}), "special_arg", $MATCH->{"Perlito5::Grammar::block"}->{"capture"}, "arguments", Perlito5::Grammar::Expression::expand_list($MATCH->{"Perlito5::Grammar::Expression::list_parse"}->{"capture"}), "namespace", '')];
                1
            }))) || ($MATCH->{"to"} = $tmp1609, ((("(" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $m2 = Perlito5::Grammar::block($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::block"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::Expression::list_parse"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && ((")" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", Perlito5::Match::flat($MATCH->{"map_or_grep"}), "special_arg", $MATCH->{"Perlito5::Grammar::block"}->{"capture"}, "arguments", Perlito5::Grammar::Expression::expand_list($MATCH->{"Perlito5::Grammar::Expression::list_parse"}->{"capture"}), "namespace", '')];
                1
            })))
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Map::non_core_ident {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::full_ident"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $name = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::full_ident"});
            (exists($Perlito5::CORE_PROTO->{$name}) || exists($Perlito5::CORE_PROTO->{"CORE::" . $name})) && return;
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Map::term_sort {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((("s" eq $str->[($MATCH->{"to"}) + 0]) && ("o" eq $str->[($MATCH->{"to"}) + 1]) && ("r" eq $str->[($MATCH->{"to"}) + 2]) && ("t" eq $str->[($MATCH->{"to"}) + 3]) && ($MATCH->{"to"} += 4)) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $tmp1628 = $MATCH->{"to"};
            (((("(" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $tmp1629 = $MATCH->{"to"};
                (((do {
                    my $m2 = Perlito5::Grammar::Map::non_core_ident($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Map::non_core_ident"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $name = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Map::non_core_ident"});
                    $MATCH->{"_tmp"} = $name;
                    1
                }))) || ($MATCH->{"to"} = $tmp1629, ((do {
                    my $m2 = Perlito5::Grammar::block($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::block"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{"_tmp"} = $MATCH->{"Perlito5::Grammar::block"}->{"capture"};
                    1
                }))) || ($MATCH->{"to"} = $tmp1629, ((do {
                    my $tmp = $MATCH;
                    $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
                    my $res = (("\$" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1));
                    $MATCH = $tmp;
                    $res ? 1 : 0
                }) && (do {
                    my $m2 = Perlito5::Grammar::Sigil::term_sigil($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Sigil::term_sigil"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $var = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Sigil::term_sigil"})->[1];
                    ref($var) ne "Perlito5::AST::Var" && return;
                    $MATCH->{"_tmp"} = $var;
                    1
                })))
            }) && (do {
                my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::Expression::list_parse"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && ((")" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", "sort", "special_arg", $MATCH->{"_tmp"}, "arguments", Perlito5::Grammar::Expression::expand_list($MATCH->{"Perlito5::Grammar::Expression::list_parse"}->{"capture"}), "namespace", '')];
                1
            }))) || ($MATCH->{"to"} = $tmp1628, ((do {
                my $tmp1630 = $MATCH->{"to"};
                (((do {
                    my $m2 = Perlito5::Grammar::block($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::block"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{"_tmp"} = $MATCH->{"Perlito5::Grammar::block"}->{"capture"};
                    1
                }))) || ($MATCH->{"to"} = $tmp1630, ((do {
                    my $m2 = Perlito5::Grammar::Map::non_core_ident($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Map::non_core_ident"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $name = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Map::non_core_ident"});
                    $MATCH->{"_tmp"} = $name;
                    1
                }))) || ($MATCH->{"to"} = $tmp1630, ((do {
                    my $tmp = $MATCH;
                    $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
                    my $res = (("\$" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1));
                    $MATCH = $tmp;
                    $res ? 1 : 0
                }) && (do {
                    my $m2 = Perlito5::Grammar::Sigil::term_sigil($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Sigil::term_sigil"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $var = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Sigil::term_sigil"})->[1];
                    ref($var) ne "Perlito5::AST::Var" && return;
                    $MATCH->{"_tmp"} = $var;
                    1
                }))) || ($MATCH->{"to"} = $tmp1630, (do {
                    $MATCH->{"_tmp"} = Perlito5::AST::Block::->new("stmts", [Perlito5::AST::Apply::->new("code", "infix:<cmp>", "arguments", [Perlito5::AST::Var::->new("name", "a", "namespace", $Perlito5::PKG, "sigil", "\$"), Perlito5::AST::Var::->new("name", "b", "namespace", $Perlito5::PKG, "sigil", "\$")])]);
                    1
                }))
            }) && (do {
                my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::Expression::list_parse"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", "sort", "special_arg", $MATCH->{"_tmp"}, "arguments", Perlito5::Grammar::Expression::expand_list($MATCH->{"Perlito5::Grammar::Expression::list_parse"}->{"capture"}), "namespace", '')];
                1
            })))
        })));
        $tmp ? $MATCH : undef
    }
    Perlito5::Grammar::Precedence::add_term("map", \&term_map_or_grep);
    Perlito5::Grammar::Precedence::add_term("grep", \&term_map_or_grep);
    Perlito5::Grammar::Precedence::add_term("sort", \&term_sort);
    1
}
{
    package main;
    package Perlito5::Grammar::Number;
    sub Perlito5::Grammar::Number::term_digit {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = ((do {
            my $tmp1657 = $MATCH->{"to"};
            (((do {
                my $m2 = Perlito5::Grammar::Number::val_octal($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::Number::val_octal"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                $MATCH->{"capture"} = ["term", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Number::val_octal"})];
                1
            }))) || ($MATCH->{"to"} = $tmp1657, ((do {
                my $m2 = Perlito5::Grammar::Number::val_vstring($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::Number::val_vstring"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                $MATCH->{"capture"} = ["term", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Number::val_vstring"})];
                1
            }))) || ($MATCH->{"to"} = $tmp1657, ((do {
                my $m2 = Perlito5::Grammar::Number::val_num($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::Number::val_num"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                $MATCH->{"capture"} = ["term", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Number::val_num"})];
                1
            })))
        }));
        $tmp ? $MATCH : undef
    }
    Perlito5::Grammar::Precedence::add_term($_, \&term_digit)
        for ".", 0 .. 9;
    sub Perlito5::Grammar::Number::digit {
        my $str = $_[0];
        my $pos = $_[1];
        $str->[$pos] ge 0 && $str->[$pos] le 9 ? {"str" => $str, "from" => $pos, "to" => $pos + 1, } : 0
    }
    sub Perlito5::Grammar::Number::octal_digit {
        my $str = $_[0];
        my $pos = $_[1];
        $str->[$pos] ge 0 && $str->[$pos] le 7 ? {"str" => $str, "from" => $pos, "to" => $pos + 1, } : 0
    }
    sub Perlito5::Grammar::Number::hex_digit {
        my $str = $_[0];
        my $pos = $_[1];
        (($str->[$pos] ge 0 && $str->[$pos] le 9) || ($str->[$pos] ge "A" && $str->[$pos] le "F") || ($str->[$pos] ge "a" && $str->[$pos] le "f")) ? {"str" => $str, "from" => $pos, "to" => $pos + 1, } : 0
    }
    sub Perlito5::Grammar::Number::exponent {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $tmp1672 = $MATCH->{"to"};
            ((("e" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1672, (("E" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)))
        }) && (do {
            my $tmp1673 = $MATCH->{"to"};
            ((("+" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1673, (("-" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1673, 1)
        }) && (do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{"to"};
            my $count = 0;
            while ((do {
                my $tmp1674 = $MATCH->{"to"};
                ((("_" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1674, (do {
                    my $m2 = Perlito5::Grammar::Number::digit($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }))
            }) && ($last_match_null < 2)) {
                if ($to == $MATCH->{"to"}) {;
                    $last_match_null = $last_match_null + 1
                }
                else {;
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{"to"};
                $count = $count + 1
            }
            $MATCH = $m;
            $MATCH->{"to"} = $to;
            $count > 0
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Number::val_num {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $tmp1687 = $MATCH->{"to"};
            (((("." eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $m2 = Perlito5::Grammar::Number::digit($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $last_match_null = 0;
                my $m = $MATCH;
                my $to = $MATCH->{"to"};
                while ((do {
                    my $tmp1688 = $MATCH->{"to"};
                    ((("_" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1688, (do {
                        my $m2 = Perlito5::Grammar::Number::digit($str, $MATCH->{"to"});
                        if ($m2) {
                            $MATCH->{"to"} = $m2->{"to"};
                            1
                        }
                        else {;
                            0
                        }
                    }))
                }) && ($last_match_null < 2)) {
                    if ($to == $MATCH->{"to"}) {;
                        $last_match_null = $last_match_null + 1
                    }
                    else {;
                        $last_match_null = 0
                    }
                    $m = $MATCH;
                    $to = $MATCH->{"to"}
                }
                $MATCH = $m;
                $MATCH->{"to"} = $to;
                1
            }) && (do {
                my $m = $MATCH;
                if (!(do {
                    my $m2 = Perlito5::Grammar::Number::exponent($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                })) {;
                    $MATCH = $m
                }
                1
            }))) || ($MATCH->{"to"} = $tmp1687, ((do {
                my $m2 = Perlito5::Grammar::Number::digit($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $last_match_null = 0;
                my $m = $MATCH;
                my $to = $MATCH->{"to"};
                while ((do {
                    my $tmp1689 = $MATCH->{"to"};
                    ((("_" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1689, (do {
                        my $m2 = Perlito5::Grammar::Number::digit($str, $MATCH->{"to"});
                        if ($m2) {
                            $MATCH->{"to"} = $m2->{"to"};
                            1
                        }
                        else {;
                            0
                        }
                    }))
                }) && ($last_match_null < 2)) {
                    if ($to == $MATCH->{"to"}) {;
                        $last_match_null = $last_match_null + 1
                    }
                    else {;
                        $last_match_null = 0
                    }
                    $m = $MATCH;
                    $to = $MATCH->{"to"}
                }
                $MATCH = $m;
                $MATCH->{"to"} = $to;
                1
            }) && (do {
                my $tmp1690 = $MATCH->{"to"};
                ((do {
                    my $m2 = Perlito5::Grammar::Number::exponent($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                })) || ($MATCH->{"to"} = $tmp1690, ((("." eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $tmp = $MATCH;
                    $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
                    my $res = (("." eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1));
                    $MATCH = $tmp;
                    $res ? 0 : 1
                }) && (do {
                    my $last_match_null = 0;
                    my $m = $MATCH;
                    my $to = $MATCH->{"to"};
                    while ((do {
                        my $tmp1691 = $MATCH->{"to"};
                        ((("_" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1691, (do {
                            my $m2 = Perlito5::Grammar::Number::digit($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                1
                            }
                            else {;
                                0
                            }
                        }))
                    }) && ($last_match_null < 2)) {
                        if ($to == $MATCH->{"to"}) {;
                            $last_match_null = $last_match_null + 1
                        }
                        else {;
                            $last_match_null = 0
                        }
                        $m = $MATCH;
                        $to = $MATCH->{"to"}
                    }
                    $MATCH = $m;
                    $MATCH->{"to"} = $to;
                    1
                }) && (do {
                    my $m = $MATCH;
                    if (!(do {
                        my $m2 = Perlito5::Grammar::Number::exponent($str, $MATCH->{"to"});
                        if ($m2) {
                            $MATCH->{"to"} = $m2->{"to"};
                            1
                        }
                        else {;
                            0
                        }
                    })) {;
                        $MATCH = $m
                    }
                    1
                }))) || ($MATCH->{"to"} = $tmp1690, (do {
                    my $s = Perlito5::Match::flat($MATCH);
                    $s =~ s/_//g;
                    $MATCH->{"capture"} = Perlito5::AST::Int::->new("int", $s);
                    return $MATCH;
                    1
                }))
            })))
        }) && (do {
            my $s = Perlito5::Match::flat($MATCH);
            $s =~ s/_//g;
            $MATCH->{"capture"} = Perlito5::AST::Num::->new("num", $s);
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Number::digits {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = ((do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{"to"};
            my $count = 0;
            while ((do {
                my $m2 = Perlito5::Grammar::Number::digit($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && ($last_match_null < 2)) {
                if ($to == $MATCH->{"to"}) {;
                    $last_match_null = $last_match_null + 1
                }
                else {;
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{"to"};
                $count = $count + 1
            }
            $MATCH = $m;
            $MATCH->{"to"} = $to;
            $count > 0
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Number::digits_underscore {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $m2 = Perlito5::Grammar::Number::digit($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{"to"};
            while ((do {
                my $tmp1733 = $MATCH->{"to"};
                ((("_" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1733, (do {
                    my $m2 = Perlito5::Grammar::Number::digit($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }))
            }) && ($last_match_null < 2)) {
                if ($to == $MATCH->{"to"}) {;
                    $last_match_null = $last_match_null + 1
                }
                else {;
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{"to"}
            }
            $MATCH = $m;
            $MATCH->{"to"} = $to;
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Number::hex_digits_underscore {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = ((do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{"to"};
            my $count = 0;
            while ((do {
                my $tmp1744 = $MATCH->{"to"};
                ((("_" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1744, (do {
                    my $m2 = Perlito5::Grammar::Number::hex_digit($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }))
            }) && ($last_match_null < 2)) {
                if ($to == $MATCH->{"to"}) {;
                    $last_match_null = $last_match_null + 1
                }
                else {;
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{"to"};
                $count = $count + 1
            }
            $MATCH = $m;
            $MATCH->{"to"} = $to;
            $count > 0
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Number::hex_digits_underscore2 {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $m2 = Perlito5::Grammar::Number::hex_digit($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{"to"};
            while ((do {
                my $tmp1755 = $MATCH->{"to"};
                ((("_" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1755, (do {
                    my $m2 = Perlito5::Grammar::Number::hex_digit($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }))
            }) && ($last_match_null < 2)) {
                if ($to == $MATCH->{"to"}) {;
                    $last_match_null = $last_match_null + 1
                }
                else {;
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{"to"}
            }
            $MATCH = $m;
            $MATCH->{"to"} = $to;
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Number::hex_exponent {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $tmp1766 = $MATCH->{"to"};
            ((("+" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1766, (("-" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1766, 1)
        }) && (do {
            my $m2 = Perlito5::Grammar::Number::hex_digits_underscore($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Number::val_octal {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = ((((0 eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $tmp1773 = $MATCH->{"to"};
            (((do {
                my $tmp1774 = $MATCH->{"to"};
                ((("x" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1774, (("X" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)))
            }) && (do {
                my $tmp1775 = $MATCH->{"to"};
                (((do {
                    my $tmp1776 = $MATCH->{"to"};
                    (((("." eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                        my $last_match_null = 0;
                        my $m = $MATCH;
                        my $to = $MATCH->{"to"};
                        my $count = 0;
                        while ((do {
                            my $m2 = Perlito5::Grammar::Number::hex_digits_underscore2($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                if (exists($MATCH->{"Perlito5::Grammar::Number::hex_digits_underscore2"})) {;
                                    push(@{$MATCH->{"Perlito5::Grammar::Number::hex_digits_underscore2"}}, $m2)
                                }
                                else {;
                                    $MATCH->{"Perlito5::Grammar::Number::hex_digits_underscore2"} = [$m2]
                                }
                                1
                            }
                            else {;
                                0
                            }
                        }) && ($last_match_null < 2)) {
                            if ($to == $MATCH->{"to"}) {;
                                $last_match_null = $last_match_null + 1
                            }
                            else {;
                                $last_match_null = 0
                            }
                            $m = $MATCH;
                            $to = $MATCH->{"to"};
                            $count = $count + 1
                        }
                        $MATCH = $m;
                        $MATCH->{"to"} = $to;
                        $count > 0
                    }))) || ($MATCH->{"to"} = $tmp1776, ((do {
                        my $last_match_null = 0;
                        my $m = $MATCH;
                        my $to = $MATCH->{"to"};
                        my $count = 0;
                        while ((do {
                            my $m2 = Perlito5::Grammar::Number::hex_digits_underscore($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                if (exists($MATCH->{"Perlito5::Grammar::Number::hex_digits_underscore"})) {;
                                    push(@{$MATCH->{"Perlito5::Grammar::Number::hex_digits_underscore"}}, $m2)
                                }
                                else {;
                                    $MATCH->{"Perlito5::Grammar::Number::hex_digits_underscore"} = [$m2]
                                }
                                1
                            }
                            else {;
                                0
                            }
                        }) && ($last_match_null < 2)) {
                            if ($to == $MATCH->{"to"}) {;
                                $last_match_null = $last_match_null + 1
                            }
                            else {;
                                $last_match_null = 0
                            }
                            $m = $MATCH;
                            $to = $MATCH->{"to"};
                            $count = $count + 1
                        }
                        $MATCH = $m;
                        $MATCH->{"to"} = $to;
                        $count > 0
                    }) && (do {
                        my $tmp1777 = $MATCH->{"to"};
                        (((("." eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                            my $m = $MATCH;
                            if (!(do {
                                my $m2 = Perlito5::Grammar::Number::hex_digits_underscore2($str, $MATCH->{"to"});
                                if ($m2) {
                                    $MATCH->{"to"} = $m2->{"to"};
                                    if (exists($MATCH->{"Perlito5::Grammar::Number::hex_digits_underscore2"})) {;
                                        push(@{$MATCH->{"Perlito5::Grammar::Number::hex_digits_underscore2"}}, $m2)
                                    }
                                    else {;
                                        $MATCH->{"Perlito5::Grammar::Number::hex_digits_underscore2"} = [$m2]
                                    }
                                    1
                                }
                                else {;
                                    0
                                }
                            })) {;
                                $MATCH = $m
                            }
                            1
                        }))) || ($MATCH->{"to"} = $tmp1777, 1)
                    })))
                }) && (do {
                    my $tmp1778 = $MATCH->{"to"};
                    ((("p" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1778, (("P" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)))
                }) && (do {
                    my $m2 = Perlito5::Grammar::Number::hex_exponent($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"hex_exponent"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $h1 = $MATCH->{"Perlito5::Grammar::Number::hex_digits_underscore"};
                    my $h2 = $MATCH->{"Perlito5::Grammar::Number::hex_digits_underscore2"};
                    my $h3 = Perlito5::Match::flat($MATCH->{"hex_exponent"});
                    if ($h1 && @{$h1}) {;
                        $h1 = Perlito5::Match::flat($h1->[0])
                    }
                    else {;
                        $h1 = 0
                    }
                    if ($h2 && @{$h2}) {;
                        $h2 = Perlito5::Match::flat($h2->[0])
                    }
                    else {;
                        $h2 = 0
                    }
                    $h1 =~ s/_//g;
                    $h2 =~ s/_//g;
                    $h3 =~ s/_//g;
                    my $mul = 1;
                    my $sig = substr($h3, 0, 1);
                    if ($sig eq "+" || $sig eq "-") {
                        $mul = $sig . 1;
                        $h3 = substr($h3, 1)
                    }
                    $h1 = hex($h1);
                    if (length($h2)) {;
                        $h2 = hex($h2) / (16**length($h2))
                    }
                    else {;
                        $h2 = 0
                    }
                    $h3 = hex($h3);
                    $MATCH->{"capture"} = Perlito5::AST::Num::->new("num", ($h1 + $h2) * (2**($mul * $h3)));
                    return $MATCH;
                    1
                }))) || ($MATCH->{"to"} = $tmp1775, (do {
                    my $last_match_null = 0;
                    my $m = $MATCH;
                    my $to = $MATCH->{"to"};
                    my $count = 0;
                    while ((do {
                        my $m2 = Perlito5::Grammar::Number::hex_digits_underscore($str, $MATCH->{"to"});
                        if ($m2) {
                            $MATCH->{"to"} = $m2->{"to"};
                            if (exists($MATCH->{"Perlito5::Grammar::Number::hex_digits_underscore"})) {;
                                push(@{$MATCH->{"Perlito5::Grammar::Number::hex_digits_underscore"}}, $m2)
                            }
                            else {;
                                $MATCH->{"Perlito5::Grammar::Number::hex_digits_underscore"} = [$m2]
                            }
                            1
                        }
                        else {;
                            0
                        }
                    }) && ($last_match_null < 2)) {
                        if ($to == $MATCH->{"to"}) {;
                            $last_match_null = $last_match_null + 1
                        }
                        else {;
                            $last_match_null = 0
                        }
                        $m = $MATCH;
                        $to = $MATCH->{"to"};
                        $count = $count + 1
                    }
                    $MATCH = $m;
                    $MATCH->{"to"} = $to;
                    $count > 0
                }))
            }))) || ($MATCH->{"to"} = $tmp1773, ((do {
                my $tmp1779 = $MATCH->{"to"};
                ((("b" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1779, (("B" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)))
            }) && (do {
                my $last_match_null = 0;
                my $m = $MATCH;
                my $to = $MATCH->{"to"};
                my $count = 0;
                while ((do {
                    my $tmp1780 = $MATCH->{"to"};
                    ((("_" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1780, ((0 eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1780, ((1 eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)))
                }) && ($last_match_null < 2)) {
                    if ($to == $MATCH->{"to"}) {;
                        $last_match_null = $last_match_null + 1
                    }
                    else {;
                        $last_match_null = 0
                    }
                    $m = $MATCH;
                    $to = $MATCH->{"to"};
                    $count = $count + 1
                }
                $MATCH = $m;
                $MATCH->{"to"} = $to;
                $count > 0
            }))) || ($MATCH->{"to"} = $tmp1773, (do {
                my $last_match_null = 0;
                my $m = $MATCH;
                my $to = $MATCH->{"to"};
                my $count = 0;
                while ((do {
                    my $tmp1781 = $MATCH->{"to"};
                    ((("_" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp1781, (do {
                        my $m2 = Perlito5::Grammar::Number::octal_digit($str, $MATCH->{"to"});
                        if ($m2) {
                            $MATCH->{"to"} = $m2->{"to"};
                            1
                        }
                        else {;
                            0
                        }
                    }))
                }) && ($last_match_null < 2)) {
                    if ($to == $MATCH->{"to"}) {;
                        $last_match_null = $last_match_null + 1
                    }
                    else {;
                        $last_match_null = 0
                    }
                    $m = $MATCH;
                    $to = $MATCH->{"to"};
                    $count = $count + 1
                }
                $MATCH = $m;
                $MATCH->{"to"} = $to;
                $count > 0
            }))
        }) && (do {
            $MATCH->{"capture"} = Perlito5::AST::Int::->new("int", oct(lc(Perlito5::Match::flat($MATCH))));
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Number::val_int {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $m2 = Perlito5::Grammar::Number::digits_underscore($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $s = Perlito5::Match::flat($MATCH);
            $s =~ s/_//g;
            $MATCH->{"capture"} = Perlito5::AST::Int::->new("int", $s);
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Number::val_vstring {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $m2 = Perlito5::Grammar::Number::val_int($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"val_int"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{"to"};
            my $count = 0;
            while (((("." eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $m2 = Perlito5::Grammar::Number::digits_underscore($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    if (exists($MATCH->{"digits_underscore"})) {;
                        push(@{$MATCH->{"digits_underscore"}}, $m2)
                    }
                    else {;
                        $MATCH->{"digits_underscore"} = [$m2]
                    }
                    1
                }
                else {;
                    0
                }
            })) && ($last_match_null < 2)) {
                if ($to == $MATCH->{"to"}) {;
                    $last_match_null = $last_match_null + 1
                }
                else {;
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{"to"};
                $count = $count + 1
            }
            $MATCH = $m;
            $MATCH->{"to"} = $to;
            $count > 0
        }) && (do {
            my @parts = map {;
                Perlito5::Match::flat($_)
            } @{$MATCH->{"digits_underscore"}};
            @parts < 2 && return;
            $MATCH->{"capture"} = Perlito5::AST::Buf::->new("is_vstring", 1, "buf", join('', map {;
                chr($_)
            } $MATCH->{"val_int"}->{"capture"}->{"int"}, @parts));
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Number::val_version {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((("v" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $m2 = Perlito5::Grammar::Number::val_int($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"val_int"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $tmp = $MATCH;
            $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
            my $res = ((do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (("(" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)));
            $MATCH = $tmp;
            $res ? 0 : 1
        }) && (do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{"to"};
            while (((("." eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $m2 = Perlito5::Grammar::Number::digits_underscore($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    if (exists($MATCH->{"digits_underscore"})) {;
                        push(@{$MATCH->{"digits_underscore"}}, $m2)
                    }
                    else {;
                        $MATCH->{"digits_underscore"} = [$m2]
                    }
                    1
                }
                else {;
                    0
                }
            })) && ($last_match_null < 2)) {
                if ($to == $MATCH->{"to"}) {;
                    $last_match_null = $last_match_null + 1
                }
                else {;
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{"to"}
            }
            $MATCH = $m;
            $MATCH->{"to"} = $to;
            1
        }) && (do {
            my @parts = map {;
                Perlito5::Match::flat($_)
            } @{$MATCH->{"digits_underscore"}};
            $MATCH->{"capture"} = Perlito5::AST::Buf::->new("buf", join('', map {;
                chr($_)
            } $MATCH->{"val_int"}->{"capture"}->{"int"}, @parts));
            1
        })));
        $tmp ? $MATCH : undef
    }
    1
}
{
    package main;
    package Perlito5::Grammar;
    our %is_ident_start = map {;
        $_ => 1
    } ("a" .. "z", "A" .. "Z", "_");
    our %is_ident_middle = map {;
        $_ => 1
    } ("a" .. "z", "A" .. "Z", 0 .. 9, "_");
    our %is_var_sigil = map {;
        $_ => 1
    } ("\$", "%", "\@", "&", "*");
    sub Perlito5::Grammar::word {
        my $str = $_[0];
        my $pos = $_[1];
        $is_ident_middle{$str->[$pos]} || return;
        return {"str" => $str, "from" => $pos, "to" => $pos + 1, }
    }
    sub Perlito5::Grammar::var_sigil {
        my $str = $_[0];
        my $pos = $_[1];
        $is_var_sigil{$str->[$pos]} || return;
        return {"str" => $str, "from" => $pos, "to" => $pos + 1, }
    }
    sub Perlito5::Grammar::ident {
        my $str = $_[0];
        my $pos = $_[1];
        $is_ident_start{$str->[$pos]} || return;
        $pos++;
        while ($is_ident_middle{$str->[$pos]}) {;
            $pos++
        }
        ($pos - $_[1]) > 251 && die("Identifier too long");
        return {"str" => $str, "from" => $_[1], "to" => $pos, }
    }
    sub Perlito5::Grammar::caret_char {
        my $str = $_[0];
        my $pos = $_[1];
        my $c = $str->[$pos];
        if ($c eq "^") {
            $pos++;
            $c = $str->[$pos];
            ($c lt "A" || $c gt "Z") && return 0;
            $c = chr((ord($c) - ord("A")) + 1)
        }
        elsif (Perlito5::Grammar::Space::ws($_[0], $pos)) {;
            return
        }
        ($c lt "\x{1}" || $c gt "\x{1a}") && return;
        return {"str" => $str, "from" => $_[1], "to" => $pos + 1, "capture" => $c, }
    }
    sub Perlito5::Grammar::full_ident {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $m2 = Perlito5::Grammar::ident($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{"to"};
            while ((((":" eq $str->[($MATCH->{"to"}) + 0]) && (":" eq $str->[($MATCH->{"to"}) + 1]) && ($MATCH->{"to"} += 2)) && (do {
                my $m2 = Perlito5::Grammar::ident($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            })) && ($last_match_null < 2)) {
                if ($to == $MATCH->{"to"}) {;
                    $last_match_null = $last_match_null + 1
                }
                else {;
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{"to"}
            }
            $MATCH = $m;
            $MATCH->{"to"} = $to;
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::namespace_before_ident {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $m2 = Perlito5::Grammar::ident($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $tmp = $MATCH;
            $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
            my $res = ((":" eq $str->[($MATCH->{"to"}) + 0]) && (":" eq $str->[($MATCH->{"to"}) + 1]) && ($MATCH->{"to"} += 2));
            $MATCH = $tmp;
            $res ? 1 : 0
        }) && (do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{"to"};
            while ((((":" eq $str->[($MATCH->{"to"}) + 0]) && (":" eq $str->[($MATCH->{"to"}) + 1]) && ($MATCH->{"to"} += 2)) && (do {
                my $m2 = Perlito5::Grammar::ident($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $tmp = $MATCH;
                $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
                my $res = ((":" eq $str->[($MATCH->{"to"}) + 0]) && (":" eq $str->[($MATCH->{"to"}) + 1]) && ($MATCH->{"to"} += 2));
                $MATCH = $tmp;
                $res ? 1 : 0
            })) && ($last_match_null < 2)) {
                if ($to == $MATCH->{"to"}) {;
                    $last_match_null = $last_match_null + 1
                }
                else {;
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{"to"}
            }
            $MATCH = $m;
            $MATCH->{"to"} = $to;
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::optional_namespace_before_ident {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = ((do {
            my $tmp1891 = $MATCH->{"to"};
            (((do {
                my $m2 = Perlito5::Grammar::namespace_before_ident($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"namespace_before_ident"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $last_match_null = 0;
                my $m = $MATCH;
                my $to = $MATCH->{"to"};
                while (((":" eq $str->[($MATCH->{"to"}) + 0]) && (":" eq $str->[($MATCH->{"to"}) + 1]) && ($MATCH->{"to"} += 2)) && ($last_match_null < 2)) {
                    if ($to == $MATCH->{"to"}) {;
                        $last_match_null = $last_match_null + 1
                    }
                    else {;
                        $last_match_null = 0
                    }
                    $m = $MATCH;
                    $to = $MATCH->{"to"}
                }
                $MATCH = $m;
                $MATCH->{"to"} = $to;
                1
            }) && (do {
                $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"namespace_before_ident"});
                1
            }))) || ($MATCH->{"to"} = $tmp1891, (((":" eq $str->[($MATCH->{"to"}) + 0]) && (":" eq $str->[($MATCH->{"to"}) + 1]) && ($MATCH->{"to"} += 2)) && (do {
                my $m2 = Perlito5::Grammar::optional_namespace_before_ident($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"optional_namespace_before_ident"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $name = Perlito5::Match::flat($MATCH->{"optional_namespace_before_ident"});
                $MATCH->{"capture"} = "main";
                $name ne '' && ($MATCH->{"capture"} .= "::" . $name);
                1
            }))) || ($MATCH->{"to"} = $tmp1891, (1 && (do {
                $MATCH->{"capture"} = '';
                1
            })))
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::exp_stmts2 {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $m2 = Perlito5::Grammar::exp_stmts($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"exp_stmts"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"exp_stmts"});
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::exp {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $m2 = Perlito5::Grammar::Expression::exp_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Expression::exp_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::exp_parse"});
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::exp2 {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $m2 = Perlito5::Grammar::Expression::exp_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Expression::exp_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::exp_parse"});
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::opt_type {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = ((do {
            my $tmp1918 = $MATCH->{"to"};
            (((do {
                my $m = $MATCH;
                if (!((":" eq $str->[($MATCH->{"to"}) + 0]) && (":" eq $str->[($MATCH->{"to"}) + 1]) && ($MATCH->{"to"} += 2))) {;
                    $MATCH = $m
                }
                1
            }) && (do {
                my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"full_ident"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"full_ident"});
                1
            }))) || ($MATCH->{"to"} = $tmp1918, (1 && (do {
                $MATCH->{"capture"} = '';
                1
            })))
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::var_name {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = ((do {
            my $tmp1926 = $MATCH->{"to"};
            ((do {
                my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"full_ident"} = $m2;
                    1
                }
                else {;
                    0
                }
            })) || ($MATCH->{"to"} = $tmp1926, (do {
                my $m2 = Perlito5::Grammar::Number::digits($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::Number::digits"} = $m2;
                    1
                }
                else {;
                    0
                }
            }))
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::var_ident {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $m2 = Perlito5::Grammar::var_sigil($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"var_sigil"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::optional_namespace_before_ident($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"optional_namespace_before_ident"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::var_name($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"var_name"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = Perlito5::AST::Var::->new("sigil", Perlito5::Match::flat($MATCH->{"var_sigil"}), "namespace", Perlito5::Match::flat($MATCH->{"optional_namespace_before_ident"}), "name", Perlito5::Match::flat($MATCH->{"var_name"}));
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::block {;
        Perlito5::Grammar::Block::block(@_)
    }
    sub Perlito5::Grammar::block2 {;
        Perlito5::Grammar::Block::block(@_)
    }
    sub Perlito5::Grammar::opt_continue_block {;
        Perlito5::Grammar::Block::opt_continue_block(@_)
    }
    my @PKG;
    sub Perlito5::Grammar::exp_stmts {
        my $str = $_[0];
        my $pos = $_[1] // 0;
        if (!ref($str)) {;
            $str = [split('', $str)]
        }
        push(@PKG, $Perlito5::PKG_NAME);
        if ($pos == 0) {
            my $m = Perlito5::Grammar::Space::start_of_line($str, $pos);
            $pos = $m->{"to"}
        }
        my $has_semicolon;
        my @stmts;
        my $m = Perlito5::Grammar::Space::opt_ws($str, $pos);
        $pos = $m->{"to"};
        while ($m) {
            if ($str->[$pos] eq ";") {
                $has_semicolon = 1;
                $m = Perlito5::Grammar::Space::opt_ws($str, $pos + 1);
                $pos = $m->{"to"}
            }
            else {
                $m = Perlito5::Grammar::Statement::statement_parse($str, $pos);
                if ($m) {
                    push(@stmts, $m->{"capture"});
                    $pos = $m->{"to"};
                    if ($str->[$pos] eq ";") {
                        $has_semicolon = 1;
                        $pos = $pos + 1
                    }
                    $m = Perlito5::Grammar::Space::opt_ws($str, $pos);
                    $pos = $m->{"to"}
                }
            }
        }
        my $stmts = \@stmts;
        if (@Perlito5::GOTO) {;
            $stmts = Perlito5::Macro::rewrite_goto($stmts)
        }
        $Perlito5::PKG_NAME = pop(@PKG);
        $Perlito5::BLOCK_HAS_SEMICOLON ||= $has_semicolon;
        return {"str" => $str, "to" => $pos, "capture" => $stmts, }
    }
}
{
    package main;
    package Perlito5::Grammar::Expression;
    sub Perlito5::Grammar::Expression::term_pos {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((("p" eq $str->[($MATCH->{"to"}) + 0]) && ("o" eq $str->[($MATCH->{"to"}) + 1]) && ("s" eq $str->[($MATCH->{"to"}) + 2]) && ($MATCH->{"to"} += 3)) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $tmp1949 = $MATCH->{"to"};
            (((do {
                my $tmp = $MATCH;
                $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
                my $res = (("\$" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1));
                $MATCH = $tmp;
                $res ? 1 : 0
            }) && (do {
                my $m2 = Perlito5::Grammar::Expression::argument_parse($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"argument_parse"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $args = Perlito5::Match::flat($MATCH->{"argument_parse"});
                $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", "pos", "arguments", $args eq "*undef*" ? [Perlito5::AST::Var::SCALAR_ARG()] : [$args])];
                1
            }))) || ($MATCH->{"to"} = $tmp1949, ((do {
                my $tmp = $MATCH;
                $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
                my $res = (("(" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1));
                $MATCH = $tmp;
                $res ? 0 : 1
            }) && (do {
                $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", "pos", "arguments", [Perlito5::AST::Var::SCALAR_ARG()], "bareword", 1)];
                1
            })))
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Expression::declarator {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = ((do {
            my $tmp1962 = $MATCH->{"to"};
            ((("m" eq $str->[($MATCH->{"to"}) + 0]) && ("y" eq $str->[($MATCH->{"to"}) + 1]) && ($MATCH->{"to"} += 2))) || ($MATCH->{"to"} = $tmp1962, (("s" eq $str->[($MATCH->{"to"}) + 0]) && ("t" eq $str->[($MATCH->{"to"}) + 1]) && ("a" eq $str->[($MATCH->{"to"}) + 2]) && ("t" eq $str->[($MATCH->{"to"}) + 3]) && ("e" eq $str->[($MATCH->{"to"}) + 4]) && ($MATCH->{"to"} += 5))) || ($MATCH->{"to"} = $tmp1962, (("o" eq $str->[($MATCH->{"to"}) + 0]) && ("u" eq $str->[($MATCH->{"to"}) + 1]) && ("r" eq $str->[($MATCH->{"to"}) + 2]) && ($MATCH->{"to"} += 3)))
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Expression::term_declarator {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $m2 = Perlito5::Grammar::Expression::declarator($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"declarator"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $tmp1968 = $MATCH->{"to"};
            (((do {
                my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $tmp1969 = $MATCH->{"to"};
                (((do {
                    my $m2 = Perlito5::Grammar::Block::named_sub($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Block::named_sub"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $sub = $MATCH->{"Perlito5::Grammar::Block::named_sub"}->{"capture"};
                    $sub->{"decl"} = Perlito5::Match::flat($MATCH->{"declarator"});
                    $MATCH->{"capture"} = ["term", $sub];
                    return $MATCH;
                    1
                }))) || ($MATCH->{"to"} = $tmp1969, (do {
                    my $m2 = Perlito5::Grammar::opt_type($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::opt_type"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }))
            }))) || ($MATCH->{"to"} = $tmp1968, 1)
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $tmp1970 = $MATCH->{"to"};
            (((do {
                my $m2 = Perlito5::Grammar::var_ident($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::var_ident"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $m2 = Perlito5::Grammar::Attribute::opt_attribute($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::Attribute::opt_attribute"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $declarator = Perlito5::Match::flat($MATCH->{"declarator"});
                my $type = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::opt_type"});
                $type && !$Perlito5::PACKAGES->{$type} && Perlito5::Compiler::error("No such class " . $type);
                my $var = $MATCH->{"Perlito5::Grammar::var_ident"}->{"capture"};
                $var->{"namespace"} && Perlito5::Compiler::error("No package name allowed for variable " . ($var->{"sigil"}) . ($var->{"name"}) . " in \"" . $declarator . "\"");
                $var->{"_decl"} = $declarator;
                $var->{"_id"} = $Perlito5::ID++;
                $declarator eq "our" && ($var->{"_namespace"} = $Perlito5::PKG_NAME);
                my $decl = Perlito5::AST::Decl::->new("decl", $declarator, "type", $type, "var", $var, "attributes", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Attribute::opt_attribute"}));
                $MATCH->{"capture"} = ["term", $decl];
                1
            }))) || ($MATCH->{"to"} = $tmp1970, ((("(" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $m2 = Perlito5::Grammar::Expression::paren_parse($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"paren_parse"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && ((")" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $m2 = Perlito5::Grammar::Attribute::opt_attribute($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::Attribute::opt_attribute"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $declarator = Perlito5::Match::flat($MATCH->{"declarator"});
                my $type = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::opt_type"});
                my $arg = Perlito5::Grammar::Expression::expand_list(Perlito5::Match::flat($MATCH->{"paren_parse"}));
                my $attributes = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Attribute::opt_attribute"});
                $type && !$Perlito5::PACKAGES->{$type} && Perlito5::Compiler::error("No such class " . $type);
                my @out;
                for my $var (@{$arg}) {
                    if (ref($var) eq "Perlito5::AST::Apply" && $var->{"code"} eq "undef") {;
                        push(@out, $var)
                    }
                    else {
                        my $decl = Perlito5::AST::Decl::->new("decl", $declarator, "type", $type, "var", $var, "attributes", $attributes);
                        $var->{"_decl"} = $declarator;
                        $var->{"_id"} = $Perlito5::ID++;
                        $declarator eq "our" && ($var->{"_namespace"} = $Perlito5::PKG_NAME);
                        push(@out, $decl)
                    }
                }
                $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", "circumfix:<( )>", "namespace", '', "arguments", \@out, "proto", undef)];
                1
            })))
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Expression::operator_with_paren {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = ((do {
            my $tmp1999 = $MATCH->{"to"};
            ((("c" eq $str->[($MATCH->{"to"}) + 0]) && ("h" eq $str->[($MATCH->{"to"}) + 1]) && ("o" eq $str->[($MATCH->{"to"}) + 2]) && ("m" eq $str->[($MATCH->{"to"}) + 3]) && ("p" eq $str->[($MATCH->{"to"}) + 4]) && ($MATCH->{"to"} += 5))) || ($MATCH->{"to"} = $tmp1999, (("c" eq $str->[($MATCH->{"to"}) + 0]) && ("h" eq $str->[($MATCH->{"to"}) + 1]) && ("o" eq $str->[($MATCH->{"to"}) + 2]) && ("p" eq $str->[($MATCH->{"to"}) + 3]) && ($MATCH->{"to"} += 4)))
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Expression::term_operator_with_paren {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $m2 = Perlito5::Grammar::Expression::operator_with_paren($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"operator_with_paren"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (("(" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $m2 = Perlito5::Grammar::Expression::paren_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"paren_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && ((")" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
            $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", Perlito5::Match::flat($MATCH->{"operator_with_paren"}), "arguments", Perlito5::Grammar::Expression::expand_list(Perlito5::Match::flat($MATCH->{"paren_parse"})), "namespace", '')];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Expression::term_local {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((("l" eq $str->[($MATCH->{"to"}) + 0]) && ("o" eq $str->[($MATCH->{"to"}) + 1]) && ("c" eq $str->[($MATCH->{"to"}) + 2]) && ("a" eq $str->[($MATCH->{"to"}) + 3]) && ("l" eq $str->[($MATCH->{"to"}) + 4]) && ($MATCH->{"to"} += 5)) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $tmp2012 = $MATCH->{"to"};
            (((do {
                my $m2 = Perlito5::Grammar::Sigil::term_sigil($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::Sigil::term_sigil"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $declarator = "local";
                my $type = '';
                $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Sigil::term_sigil"})->[1];
                $MATCH = Perlito5::Grammar::String::double_quoted_var_with_subscript($MATCH);
                my $var = $MATCH->{"capture"};
                my $look = Perlito5::Grammar::Scope::lookup_variable($var);
                if ($look && ($look->{"_decl"} eq "my" || $look->{"_decl"} eq "state")) {;
                    Perlito5::Compiler::error("Can't localize lexical variable " . ($var->{"sigil"}) . ($var->{"name"}))
                }
                $var->{"_id"} = $Perlito5::ID++;
                $var->{"_decl"} = $declarator;
                !$var->{"namespace"} && !$var->{"_namespace"} && ($var->{"_namespace"} = $Perlito5::PKG_NAME);
                my $decl = Perlito5::AST::Decl::->new("decl", $declarator, "type", $type, "var", $var);
                $MATCH->{"capture"} = ["term", $decl];
                1
            }))) || ($MATCH->{"to"} = $tmp2012, ((("(" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $m2 = Perlito5::Grammar::Expression::paren_parse($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"paren_parse"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && ((")" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $declarator = "local";
                my $type = undef;
                my $arg = Perlito5::Grammar::Expression::expand_list(Perlito5::Match::flat($MATCH->{"paren_parse"}));
                my $attributes = [];
                my @out;
                for my $var (@{$arg}) {
                    if (ref($var) eq "Perlito5::AST::Apply" && $var->{"code"} eq "undef") {;
                        push(@out, $var)
                    }
                    else {
                        my $decl = Perlito5::AST::Decl::->new("decl", $declarator, "type", $type, "var", $var, "attributes", $attributes);
                        $var->{"_decl"} = $declarator;
                        $var->{"_id"} = $Perlito5::ID++;
                        !$var->{"namespace"} && !$var->{"_namespace"} && ($var->{"_namespace"} = $Perlito5::PKG_NAME);
                        push(@out, $decl)
                    }
                }
                $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", "circumfix:<( )>", "namespace", '', "arguments", \@out, "proto", undef)];
                1
            })))
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Expression::term_return {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((("r" eq $str->[($MATCH->{"to"}) + 0]) && ("e" eq $str->[($MATCH->{"to"}) + 1]) && ("t" eq $str->[($MATCH->{"to"}) + 2]) && ("u" eq $str->[($MATCH->{"to"}) + 3]) && ("r" eq $str->[($MATCH->{"to"}) + 4]) && ("n" eq $str->[($MATCH->{"to"}) + 5]) && ($MATCH->{"to"} += 6)) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"list_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $args = Perlito5::Match::flat($MATCH->{"list_parse"});
            $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", "return", "arguments", $args eq "*undef*" ? [] : [$args], "namespace", '', "bareword", $args eq "*undef*" ? 1 : 0)];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Expression::term_file_test {
        (my $str, my $pos) = @_;
        my $code = ($str->[$pos]) . ($str->[$pos + 1]);
        $pos += 2;
        my $spc = Perlito5::Grammar::Space::ws($str, $pos);
        if ($spc) {;
            $pos = $spc->{"to"}
        }
        my $arg = Perlito5::Grammar::Expression::argument_parse($str, $pos);
        if ($arg) {
            my $argument = Perlito5::Match::flat($arg);
            if (ref($argument) eq "Perlito5::AST::Apply" && ($argument->{"code"} =~ m/^prefix:<-\w>$/ || $argument->{"code"} eq "infix:<&&>")) {
                my $op2 = $argument;
                my $file = $op2->{"arguments"}->[0];
                $arg->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", "infix:<&&>", "namespace", '', "arguments", [$op2, Perlito5::AST::Apply::->new("code", "prefix:<" . $code . ">", "arguments", [Perlito5::AST::Var::->new("_decl", "global", "_namespace", "main", "name", "_", "namespace", '', "sigil", "*")], "namespace", '', "bareword", 0)])]
            }
            else {
                if ($argument eq "*undef*") {
                    if ($code eq "-t") {;
                        $argument = Perlito5::AST::Var::->new("_decl", "global", "_namespace", "main", "name", "STDIN", "namespace", '', "sigil", "*")
                    }
                    else {;
                        $argument = Perlito5::AST::Var::SCALAR_ARG()
                    }
                }
                $arg->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", "prefix:<" . $code . ">", "arguments", $argument eq "*undef*" ? [] : [$argument], "namespace", '', "bareword", 0)]
            }
        }
        return $arg
    }
    sub Perlito5::Grammar::Expression::next_last_redo {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = ((do {
            my $tmp2048 = $MATCH->{"to"};
            ((("n" eq $str->[($MATCH->{"to"}) + 0]) && ("e" eq $str->[($MATCH->{"to"}) + 1]) && ("x" eq $str->[($MATCH->{"to"}) + 2]) && ("t" eq $str->[($MATCH->{"to"}) + 3]) && ($MATCH->{"to"} += 4))) || ($MATCH->{"to"} = $tmp2048, (("l" eq $str->[($MATCH->{"to"}) + 0]) && ("a" eq $str->[($MATCH->{"to"}) + 1]) && ("s" eq $str->[($MATCH->{"to"}) + 2]) && ("t" eq $str->[($MATCH->{"to"}) + 3]) && ($MATCH->{"to"} += 4))) || ($MATCH->{"to"} = $tmp2048, (("r" eq $str->[($MATCH->{"to"}) + 0]) && ("e" eq $str->[($MATCH->{"to"}) + 1]) && ("d" eq $str->[($MATCH->{"to"}) + 2]) && ("o" eq $str->[($MATCH->{"to"}) + 3]) && ($MATCH->{"to"} += 4))) || ($MATCH->{"to"} = $tmp2048, (("g" eq $str->[($MATCH->{"to"}) + 0]) && ("o" eq $str->[($MATCH->{"to"}) + 1]) && ("t" eq $str->[($MATCH->{"to"}) + 2]) && ("o" eq $str->[($MATCH->{"to"}) + 3]) && ($MATCH->{"to"} += 4)))
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Expression::term_next_last_redo {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $m2 = Perlito5::Grammar::Expression::next_last_redo($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"next_last_redo"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Expression::next_last_redo_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"next_last_redo_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $code = Perlito5::Match::flat($MATCH->{"next_last_redo"});
            my $args = Perlito5::Match::flat($MATCH->{"next_last_redo_parse"});
            my $ast = Perlito5::AST::Apply::->new("code", $code, "arguments", $args eq "*undef*" ? [] : [$args], "namespace", '', "bareword", $args eq "*undef*" ? 1 : 0);
            $MATCH->{"capture"} = ["term", $ast];
            if ($code eq "goto") {
                !@{$ast->{"arguments"}} && Perlito5::Compiler::error("goto must have label");
                push(@Perlito5::GOTO, $ast)
            }
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Expression::term_scalar {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((("s" eq $str->[($MATCH->{"to"}) + 0]) && ("c" eq $str->[($MATCH->{"to"}) + 1]) && ("a" eq $str->[($MATCH->{"to"}) + 2]) && ("l" eq $str->[($MATCH->{"to"}) + 3]) && ("a" eq $str->[($MATCH->{"to"}) + 4]) && ("r" eq $str->[($MATCH->{"to"}) + 5]) && ($MATCH->{"to"} += 6)) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $tmp2064 = $MATCH->{"to"};
            (((("(" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $m2 = Perlito5::Grammar::Expression::paren_parse($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"paren_parse"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && ((")" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $args = Perlito5::Match::flat($MATCH->{"paren_parse"});
                $args eq "*undef*" && Perlito5::Compiler::error("Not enough arguments for scalar");
                $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", "scalar", "arguments", Perlito5::Grammar::Expression::expand_list($args), "namespace", '', "bareword", 0)];
                1
            }))) || ($MATCH->{"to"} = $tmp2064, ((do {
                my $m2 = Perlito5::Grammar::Expression::argument_parse($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"argument_parse"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $args = Perlito5::Match::flat($MATCH->{"argument_parse"});
                my $op = Perlito5::Match::flat($MATCH->{"unary_op"});
                $args eq "*undef*" && Perlito5::Compiler::error("Not enough arguments for scalar");
                $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", "scalar", "arguments", $args eq "*undef*" ? [] : [$args], "namespace", '', "bareword", $args eq "*undef*" ? 1 : 0)];
                1
            })))
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Expression::unary_op {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = ((do {
            my $tmp2076 = $MATCH->{"to"};
            ((("s" eq $str->[($MATCH->{"to"}) + 0]) && ("h" eq $str->[($MATCH->{"to"}) + 1]) && ("i" eq $str->[($MATCH->{"to"}) + 2]) && ("f" eq $str->[($MATCH->{"to"}) + 3]) && ("t" eq $str->[($MATCH->{"to"}) + 4]) && ($MATCH->{"to"} += 5))) || ($MATCH->{"to"} = $tmp2076, (("p" eq $str->[($MATCH->{"to"}) + 0]) && ("o" eq $str->[($MATCH->{"to"}) + 1]) && ("p" eq $str->[($MATCH->{"to"}) + 2]) && ($MATCH->{"to"} += 3)))
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Expression::term_unary {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $m2 = Perlito5::Grammar::Expression::unary_op($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"unary_op"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $tmp2082 = $MATCH->{"to"};
            (((("(" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $m2 = Perlito5::Grammar::Expression::paren_parse($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"paren_parse"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && ((")" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $args = Perlito5::Match::flat($MATCH->{"paren_parse"});
                my $op = Perlito5::Match::flat($MATCH->{"unary_op"});
                $op eq "scalar" && $args eq "*undef*" && Perlito5::Compiler::error("Not enough arguments for " . $op);
                $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", $op, "arguments", Perlito5::Grammar::Expression::expand_list($args), "namespace", '', "bareword", 0)];
                1
            }))) || ($MATCH->{"to"} = $tmp2082, ((do {
                my $tmp = $MATCH;
                $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
                my $res = (("-" eq $str->[($MATCH->{"to"}) + 0]) && (">" eq $str->[($MATCH->{"to"}) + 1]) && ($MATCH->{"to"} += 2));
                $MATCH = $tmp;
                $res ? 1 : 0
            }) && (do {
                my $op = Perlito5::Match::flat($MATCH->{"unary_op"});
                $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", $op, "arguments", [], "namespace", '', "bareword", 1)];
                1
            }))) || ($MATCH->{"to"} = $tmp2082, ((do {
                my $m2 = Perlito5::Grammar::Expression::argument_parse($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"argument_parse"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $args = Perlito5::Match::flat($MATCH->{"argument_parse"});
                my $op = Perlito5::Match::flat($MATCH->{"unary_op"});
                $op eq "scalar" && $args eq "*undef*" && Perlito5::Compiler::error("Not enough arguments for " . $op);
                $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", $op, "arguments", $args eq "*undef*" ? [] : [$args], "namespace", '', "bareword", $args eq "*undef*" ? 1 : 0)];
                1
            })))
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Expression::term_eval {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((("e" eq $str->[($MATCH->{"to"}) + 0]) && ("v" eq $str->[($MATCH->{"to"}) + 1]) && ("a" eq $str->[($MATCH->{"to"}) + 2]) && ("l" eq $str->[($MATCH->{"to"}) + 3]) && ($MATCH->{"to"} += 4)) && (do {
            my $m2 = Perlito5::Grammar::block($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::block"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", "eval", "arguments", [Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::block"})], "namespace", '')];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Expression::term_not {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((("n" eq $str->[($MATCH->{"to"}) + 0]) && ("o" eq $str->[($MATCH->{"to"}) + 1]) && ("t" eq $str->[($MATCH->{"to"}) + 2]) && ($MATCH->{"to"} += 3)) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (("(" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $m2 = Perlito5::Grammar::Expression::paren_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"paren_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && ((")" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
            $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", "prefix:<not>", "arguments", Perlito5::Grammar::Expression::expand_list(Perlito5::Match::flat($MATCH->{"paren_parse"})), "namespace", '')];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Expression::term_core {
        my $str = shift;
        my $pos = shift;
        my $tok = join('', @{$str}[$pos .. $pos + 20]);
        length($tok) < 7 && return;
        substr($tok, 0, 6) ne "CORE::" && return;
        substr($tok, 6, 1) !~ m/\w/ && return;
        $tok = substr($tok, 6);
        $pos += 6;
        package Perlito5::Grammar::Precedence;
        for my $len (@Term_chars) {
            my $term = substr($tok, 0, $len);
            if (exists($Term{$term})) {
                my $c1 = $str->[($pos + $len) - 1];
                my $c2 = $str->[$pos + $len];
                if (is_num($c1) || !is_ident_middle($c1) || !is_ident_middle($c2)) {
                    my $m = $Term{$term}->($str, $pos);
                    if ($m) {
                        my $node = $m->{"capture"}->[1];
                        $node->{"namespace"} = "CORE";
                        return $m
                    }
                }
            }
        }
        return
    }
    Perlito5::Grammar::Precedence::add_term("my", \&term_declarator);
    Perlito5::Grammar::Precedence::add_term("our", \&term_declarator);
    Perlito5::Grammar::Precedence::add_term("eval", \&term_eval);
    Perlito5::Grammar::Precedence::add_term("state", \&term_declarator);
    Perlito5::Grammar::Precedence::add_term("local", \&term_local);
    Perlito5::Grammar::Precedence::add_term("return", \&term_return);
    Perlito5::Grammar::Precedence::add_term("pos", \&term_pos);
    Perlito5::Grammar::Precedence::add_term("chomp", \&term_operator_with_paren);
    Perlito5::Grammar::Precedence::add_term("chop", \&term_operator_with_paren);
    Perlito5::Grammar::Precedence::add_term("next", \&term_next_last_redo);
    Perlito5::Grammar::Precedence::add_term("last", \&term_next_last_redo);
    Perlito5::Grammar::Precedence::add_term("redo", \&term_next_last_redo);
    Perlito5::Grammar::Precedence::add_term("goto", \&term_next_last_redo);
    Perlito5::Grammar::Precedence::add_term("shift", \&term_unary);
    Perlito5::Grammar::Precedence::add_term("pop", \&term_unary);
    Perlito5::Grammar::Precedence::add_term("scalar", \&term_scalar);
    Perlito5::Grammar::Precedence::add_term("not", \&term_not);
    Perlito5::Grammar::Precedence::add_term($_, \&term_file_test)
        for "-r", "-w", "-x", "-o", "-R", "-W", "-X", "-O", "-e", "-z", "-s", "-f", "-d", "-l", "-p", "-S", "-b", "-c", "-t", "-u", "-g", "-k", "-T", "-B", "-M", "-A", "-C";
    Perlito5::Grammar::Precedence::add_term("CORE", \&term_core);
    1
}
{
    package main;
    package Perlito5::Regex;
    sub Perlito5::Regex::extract_character {
        (my $range) = @_;
        if ($range->[0] ne "\\") {;
            return shift(@{$range})
        }
        my $res = Perlito5::Grammar::String::double_quoted_unescape($range, 0);
        my $to = $res->{"to"};
        my $char = $res->{"capture"}->{"buf"};
        shift(@{$range})
            for 1 .. $to;
        return $char
    }
    sub Perlito5::Regex::expand_character_range {
        my @range = split(m//, shift);
        my @out;
        while (@range) {
            push(@out, Perlito5::Regex::extract_character(\@range));
            if (@range >= 2 && $range[0] eq "-") {
                shift(@range);
                my $first = pop(@out);
                my $last = Perlito5::Regex::extract_character(\@range);
                push(@out, map {;
                    chr($_)
                } (ord($first) .. ord($last)))
            }
        }
        return join('', @out)
    }
    1
}
{
    package main;
    package Perlito5;
    our @PERL_VERSION = (5, 26, 0);
    defined(${^O}) || (${^O} = "perlito5");
    defined($/) || ($/ = chr(10));
    defined(${"\""}) || (${"\""} = " ");
    defined(${","}) || (${","} = undef);
    defined(${"!"}) || (${"!"} = '');
    defined(${";"}) || (${";"} = chr(28));
    defined(${"?"}) || (${"?"} = 0);
    ${"]"} || (${"]"} = sprintf("%d.%03d%03d", @PERL_VERSION));
    defined(${^V}) || (${^V} = bless({"original" => "v" . join(".", @PERL_VERSION), "qv" => 1, "version" => [@PERL_VERSION], }, "version"));
    ${^H} = 0;
    %{^H} = ();
    our $EXPAND_USE = 1;
    our $EMIT_USE = 0;
    our $WARNINGS = 0;
    our $UTF8 = 0;
    our $BYTES = 0;
    our @CALLER = ();
    our %DATA_SECTION = ();
    our $PKG_NAME = '';
    our $LINE_NUMBER = 0;
    our $FILE_NAME = '';
    our $GLOBAL = {};
    our @BASE_SCOPE = (Perlito5::Grammar::Scope::->new_base_scope());
    our $CLOSURE_SCOPE = 0;
    our @SCOPE_STMT = ();
    our @END_BLOCK = ();
    our @INIT_BLOCK = ();
    our @CHECK_BLOCK = ();
    our @UNITCHECK_BLOCK = ();
    our %BEGIN_SCRATCHPAD = ();
    our $PROTO = {};
    our %VARS = ();
    our @ANNOTATION;
    sub Perlito5::set_global_phase {
        my $phase = shift;
        local ${"\@"};
        eval {;
            ${^GLOBAL_PHASE} = $phase
        }
    }
    our $ID = 100;
    our $PACKAGES = {"STDERR" => 1, "STDOUT" => 1, "STDIN" => 1, "main" => 1, "strict" => 1, "warnings" => 1, "utf8" => 1, "bytes" => 1, "encoding" => 1, "UNIVERSAL" => 1, "CORE" => 1, "CORE::GLOBAL" => 1, "Perlito5::IO" => 1, };
    push(@INC, $_)
        for split(":", ($ENV{"PERL5LIB"} || ''));
    $Perlito5::INTEGER = 1;
    $Perlito5::HINT_NO_AMAGIC = 16777216;
    %Perlito5::Integer = ("%", 1, ">>", 1, "<<", 1, "^", 1, "&", 1, "|", 1, "+", 1, "-", 1, "*", 1, "/", 1, "%=", 1, ">>=", 1, "<<=", 1, "^=", 1, "&=", 1, "|=", 1, "+=", 1, "-=", 1, "*=", 1, "/=", 1, "==", 1, "!=", 1, ">", 1, ">=", 1, "<", 1, "<=", 1, "<=>", 1);
    our $SPECIAL_VAR = {"\$_" => "ARG", "\$&" => "\$MATCH", "\$`" => "\$PREMATCH", "\$'" => "\$POSTMATCH", "\$+" => "\$LAST_PAREN_MATCH", "\@+" => "\@LAST_MATCH_END", "%+" => "%LAST_PAREN_MATCH", "\@-" => "\@LAST_MATCH_START", "\$|" => "autoflush", "\$/" => "\$RS", "\@_" => "\@ARG", "< \$" => "\$EUID", "\$." => "\$NR", "< \$< " => "\$UID", "\$(" => "\$GID", "\$#" => undef, "\$\@" => "\$EVAL_ERROR", "\$=" => "\$FORMAT_LINES_PER_PAGE", "\$," => "\$OFS", "\$?" => "\$CHILD_ERROR", "\$*" => undef, "\$[" => undef, "\$\$" => "\$PID", "%-" => undef, "\$~" => "\$FORMAT_NAME", "\$-" => "\$FORMAT_LINES_LEFT", "\$&" => "\$MATCH", "\$%" => "\$FORMAT_PAGE_NUMBER", "\$)" => "\$EGID", "\$]" => undef, "\$!" => "\$ERRNO", "\$;" => "\$SUBSEP", "\$\\" => "\$ORS", "%!" => undef, "\$\"" => "\$LIST_SEPARATOR", "\$_" => "\$ARG", "\$:" => "FORMAT_LINE_BREAK_CHARACTERS", };
    our $CORE_OVERRIDABLE = {"__FILE__" => 1, "__LINE__" => 1, "__PACKAGE__" => 1, "abs" => 1, "accept" => 1, "alarm" => 1, "and" => 1, "atan2" => 1, "bind" => 1, "binmode" => 1, "bless" => 1, "break" => 1, "caller" => 1, "chdir" => 1, "chmod" => 1, "chomp" => 1, "chop" => 1, "chown" => 1, "chr" => 1, "chroot" => 1, "close" => 1, "closedir" => 1, "cmp" => 1, "connect" => 1, "continue" => 1, "cos" => 1, "crypt" => 1, "dbmclose" => 1, "dbmopen" => 1, "default" => 1, "die" => 1, "do" => 1, "dump" => 1, "each" => 1, "endgrent" => 1, "endhostent" => 1, "endnetent" => 1, "endprotoent" => 1, "endpwent" => 1, "endservent" => 1, "eof" => 1, "exec" => 1, "exit" => 1, "exp" => 1, "fc" => 1, "fcntl" => 1, "fileno" => 1, "flock" => 1, "fork" => 1, "formline" => 1, "getc" => 1, "getgrent" => 1, "getgrgid" => 1, "getgrnam" => 1, "gethostbyaddr" => 1, "gethostbyname" => 1, "gethostent" => 1, "getlogin" => 1, "getnetbyaddr" => 1, "getnetbyname" => 1, "getnetent" => 1, "getpeername" => 1, "getpgrp" => 1, "getppid" => 1, "getpriority" => 1, "getprotobyname" => 1, "getprotobynumber" => 1, "getprotoent" => 1, "getpwent" => 1, "getpwnam" => 1, "getpwuid" => 1, "getservbyname" => 1, "getservbyport" => 1, "getservent" => 1, "getsockname" => 1, "getsockopt" => 1, "given" => 1, "glob" => 1, "gmtime" => 1, "hex" => 1, "index" => 1, "int" => 1, "ioctl" => 1, "join" => 1, "keys" => 1, "kill" => 1, "lc" => 1, "lcfirst" => 1, "length" => 1, "link" => 1, "listen" => 1, "localtime" => 1, "lock" => 1, "log" => 1, "lstat" => 1, "mkdir" => 1, "msgctl" => 1, "msgget" => 1, "msgrcv" => 1, "msgsnd" => 1, "not" => 1, "oct" => 1, "open" => 1, "opendir" => 1, "or" => 1, "ord" => 1, "pack" => 1, "pipe" => 1, "pop" => 1, "push" => 1, "quotemeta" => 1, "rand" => 1, "read" => 1, "readdir" => 1, "readline" => 1, "readlink" => 1, "readpipe" => 1, "recv" => 1, "ref" => 1, "rename" => 1, "require" => 1, "reset" => 1, "reverse" => 1, "rewinddir" => 1, "rindex" => 1, "rmdir" => 1, "say" => 1, "seek" => 1, "seekdir" => 1, "select" => 1, "semctl" => 1, "semget" => 1, "semop" => 1, "send" => 1, "setgrent" => 1, "sethostent" => 1, "setnetent" => 1, "setpgrp" => 1, "setpriority" => 1, "setprotoent" => 1, "setpwent" => 1, "setservent" => 1, "setsockopt" => 1, "shift" => 1, "shmctl" => 1, "shmget" => 1, "shmread" => 1, "shmwrite" => 1, "shutdown" => 1, "sin" => 1, "sleep" => 1, "socket" => 1, "socketpair" => 1, "splice" => 1, "sprintf" => 1, "sqrt" => 1, "srand" => 1, "stat" => 1, "state" => 1, "substr" => 1, "symlink" => 1, "syscall" => 1, "sysopen" => 1, "sysread" => 1, "sysseek" => 1, "system" => 1, "syswrite" => 1, "tell" => 1, "telldir" => 1, "tie" => 1, "tied" => 1, "time" => 1, "times" => 1, "truncate" => 1, "uc" => 1, "ucfirst" => 1, "umask" => 1, "unlink" => 1, "unpack" => 1, "unshift" => 1, "untie" => 1, "utime" => 1, "values" => 1, "vec" => 1, "wait" => 1, "waitpid" => 1, "wantarray" => 1, "warn" => 1, "when" => 1, "write" => 1, "xor" => 1, };
    our $CORE_GLOBAL_OVERRIDABLE = {"__FILE__" => 1, "__LINE__" => 1, "__PACKAGE__" => 1, "abs" => 1, "accept" => 1, "alarm" => 1, "and" => 1, "atan2" => 1, "bind" => 1, "binmode" => 1, "bless" => 1, "caller" => 1, "chdir" => 1, "chmod" => 1, "chomp" => 1, "chop" => 1, "chown" => 1, "chr" => 1, "chroot" => 1, "close" => 1, "closedir" => 1, "cmp" => 1, "connect" => 1, "continue" => 1, "cos" => 1, "crypt" => 1, "dbmclose" => 1, "dbmopen" => 1, "die" => 1, "do" => 1, "dump" => 1, "each" => 1, "endgrent" => 1, "endhostent" => 1, "endnetent" => 1, "endprotoent" => 1, "endpwent" => 1, "endservent" => 1, "eof" => 1, "exec" => 1, "exit" => 1, "exp" => 1, "fcntl" => 1, "fileno" => 1, "flock" => 1, "fork" => 1, "formline" => 1, "getc" => 1, "getgrent" => 1, "getgrgid" => 1, "getgrnam" => 1, "gethostbyaddr" => 1, "gethostbyname" => 1, "gethostent" => 1, "getlogin" => 1, "getnetbyaddr" => 1, "getnetbyname" => 1, "getnetent" => 1, "getpeername" => 1, "getpgrp" => 1, "getppid" => 1, "getpriority" => 1, "getprotobyname" => 1, "getprotobynumber" => 1, "getprotoent" => 1, "getpwent" => 1, "getpwnam" => 1, "getpwuid" => 1, "getservbyname" => 1, "getservbyport" => 1, "getservent" => 1, "getsockname" => 1, "getsockopt" => 1, "glob" => 1, "gmtime" => 1, "hex" => 1, "index" => 1, "int" => 1, "ioctl" => 1, "join" => 1, "keys" => 1, "kill" => 1, "lc" => 1, "lcfirst" => 1, "length" => 1, "link" => 1, "listen" => 1, "localtime" => 1, "lock" => 1, "log" => 1, "lstat" => 1, "mkdir" => 1, "msgctl" => 1, "msgget" => 1, "msgrcv" => 1, "msgsnd" => 1, "not" => 1, "oct" => 1, "open" => 1, "opendir" => 1, "or" => 1, "ord" => 1, "pack" => 1, "pipe" => 1, "pop" => 1, "push" => 1, "quotemeta" => 1, "rand" => 1, "read" => 1, "readdir" => 1, "readline" => 1, "readlink" => 1, "readpipe" => 1, "recv" => 1, "ref" => 1, "rename" => 1, "require" => 1, "reset" => 1, "reverse" => 1, "rewinddir" => 1, "rindex" => 1, "rmdir" => 1, "seek" => 1, "seekdir" => 1, "select" => 1, "semctl" => 1, "semget" => 1, "semop" => 1, "send" => 1, "setgrent" => 1, "sethostent" => 1, "setnetent" => 1, "setpgrp" => 1, "setpriority" => 1, "setprotoent" => 1, "setpwent" => 1, "setservent" => 1, "setsockopt" => 1, "shift" => 1, "shmctl" => 1, "shmget" => 1, "shmread" => 1, "shmwrite" => 1, "shutdown" => 1, "sin" => 1, "sleep" => 1, "socket" => 1, "socketpair" => 1, "splice" => 1, "sprintf" => 1, "sqrt" => 1, "srand" => 1, "stat" => 1, "substr" => 1, "symlink" => 1, "syscall" => 1, "sysopen" => 1, "sysread" => 1, "sysseek" => 1, "system" => 1, "syswrite" => 1, "tell" => 1, "telldir" => 1, "tie" => 1, "tied" => 1, "time" => 1, "times" => 1, "truncate" => 1, "uc" => 1, "ucfirst" => 1, "umask" => 1, "unlink" => 1, "unpack" => 1, "unshift" => 1, "untie" => 1, "utime" => 1, "values" => 1, "vec" => 1, "wait" => 1, "waitpid" => 1, "wantarray" => 1, "warn" => 1, "write" => 1, "xor" => 1, };
    our $CORE_PROTO = {"CORE::abs" => "_", "CORE::accept" => "**", "CORE::alarm" => "_", "CORE::atan2" => "\$\$", "CORE::bind" => "*\$", "CORE::binmode" => "*;\$", "CORE::bless" => "\$;\$", "CORE::break" => '', "CORE::caller" => ";\$", "CORE::chdir" => ";\$", "CORE::chmod" => "\@", "CORE::chomp" => "_", "CORE::chop" => "_", "CORE::chown" => "\@", "CORE::chr" => "_", "CORE::chroot" => "_", "CORE::close" => ";*", "CORE::closedir" => "*", "CORE::connect" => "*\$", "CORE::continue" => '', "CORE::cos" => "_", "CORE::crypt" => "\$\$", "CORE::dbmclose" => "\\%", "CORE::dbmopen" => "\\%\$\$", "CORE::default" => undef, "CORE::defined" => "_", "CORE::delete" => "\$", "CORE::die" => "\@", "CORE::do" => undef, "CORE::dump" => '', "CORE::each" => "+", "CORE::endgrent" => '', "CORE::endhostent" => '', "CORE::endnetent" => '', "CORE::endprotoent" => '', "CORE::endpwent" => '', "CORE::endservent" => '', "CORE::eof" => ";*", "CORE::eval" => "_", "CORE::exec" => undef, "CORE::exists" => "\$", "CORE::exit" => ";\$", "CORE::exp" => "_", "CORE::fc" => "_", "CORE::fcntl" => "*\$\$", "CORE::fileno" => "*", "CORE::flock" => "*\$", "CORE::fork" => '', "CORE::format" => undef, "CORE::formline" => "\$\@", "CORE::getc" => ";*", "CORE::getgrent" => '', "CORE::getgrgid" => "\$", "CORE::getgrnam" => "\$", "CORE::gethostbyaddr" => "\$\$", "CORE::gethostbyname" => "\$", "CORE::gethostent" => '', "CORE::getlogin" => '', "CORE::getnetbyaddr" => "\$\$", "CORE::getnetbyname" => "\$", "CORE::getnetent" => '', "CORE::getpeername" => "*", "CORE::getpgrp" => ";\$", "CORE::getppid" => '', "CORE::getpriority" => "\$\$", "CORE::getprotobyname" => "\$", "CORE::getprotobynumber" => "\$", "CORE::getprotoent" => '', "CORE::getpwent" => '', "CORE::getpwnam" => "\$", "CORE::getpwuid" => "\$", "CORE::getservbyname" => "\$\$", "CORE::getservbyport" => "\$\$", "CORE::getservent" => '', "CORE::getsockname" => "*", "CORE::getsockopt" => "*\$\$", "CORE::given" => undef, "CORE::glob" => undef, "CORE::gmtime" => ";\$", "CORE::goto" => undef, "CORE::grep" => undef, "CORE::hex" => "_", "CORE::index" => "\$\$;\$", "CORE::int" => "_", "CORE::ioctl" => "*\$\$", "CORE::join" => "\$\@", "CORE::keys" => "+", "CORE::kill" => "\@", "CORE::last" => undef, "CORE::lc" => "_", "CORE::lcfirst" => "_", "CORE::length" => "_", "CORE::link" => "\$\$", "CORE::listen" => "*\$", "CORE::local" => undef, "CORE::localtime" => ";\$", "CORE::lock" => "\\\$", "CORE::log" => "_", "CORE::lstat" => "*", "CORE::map" => undef, "CORE::mkdir" => "_;\$", "CORE::msgctl" => "\$\$\$", "CORE::msgget" => "\$\$", "CORE::msgrcv" => "\$\$\$\$\$", "CORE::msgsnd" => "\$\$\$", "CORE::my" => undef, "CORE::next" => undef, "CORE::no" => undef, "CORE::oct" => "_", "CORE::open" => "*;\$\@", "CORE::opendir" => "*\$", "CORE::ord" => "_", "CORE::our" => undef, "CORE::pack" => "\$\@", "CORE::pack" => "\$\@", "CORE::package" => undef, "CORE::pipe" => "**", "CORE::pop" => ";+", "CORE::pos" => undef, "CORE::print" => undef, "CORE::printf" => "\$\@", "CORE::prototype" => undef, "CORE::push" => "+\@", "CORE::quotemeta" => "_", "CORE::rand" => ";\$", "CORE::read" => "*\\\$\$;\$", "CORE::readdir" => "*", "CORE::readline" => ";*", "CORE::readlink" => "_", "CORE::readpipe" => "_", "CORE::recv" => "*\\\$\$\$", "CORE::redo" => undef, "CORE::ref" => "_", "CORE::rename" => "\$\$", "CORE::require" => undef, "CORE::reset" => ";\$", "CORE::return" => undef, "CORE::reverse" => "\@", "CORE::rewinddir" => "*", "CORE::rindex" => "\$\$;\$", "CORE::rmdir" => "_", "CORE::say" => undef, "CORE::scalar" => undef, "CORE::seek" => "*\$\$", "CORE::seekdir" => "*\$", "CORE::select" => ";*", "CORE::semctl" => "\$\$\$\$", "CORE::semget" => "\$\$\$", "CORE::semop" => "\$\$", "CORE::send" => "*\$\$;\$", "CORE::setgrent" => '', "CORE::sethostent" => "\$", "CORE::setnetent" => "\$", "CORE::setpgrp" => ";\$\$", "CORE::setpriority" => "\$\$\$", "CORE::setprotoent" => "\$", "CORE::setpwent" => '', "CORE::setservent" => "\$", "CORE::setsockopt" => "*\$\$\$", "CORE::shift" => ";+", "CORE::shmctl" => "\$\$\$", "CORE::shmget" => "\$\$\$", "CORE::shmread" => "\$\$\$\$", "CORE::shmwrite" => "\$\$\$\$", "CORE::shutdown" => "*\$", "CORE::sin" => "_", "CORE::sleep" => ";\$", "CORE::socket" => "*\$\$\$", "CORE::socketpair" => "**\$\$\$", "CORE::sort" => undef, "CORE::splice" => "+;\$\$\@", "CORE::split" => undef, "CORE::sprintf" => "\$\@", "CORE::sqrt" => "_", "CORE::srand" => ";\$", "CORE::stat" => "*", "CORE::state" => undef, "CORE::study" => undef, "CORE::sub" => undef, "CORE::substr" => "\$\$;\$\$", "CORE::symlink" => "\$\$", "CORE::syscall" => "\$\@", "CORE::sysopen" => "*\$\$;\$", "CORE::sysread" => "*\\\$\$;\$", "CORE::sysseek" => "*\$\$", "CORE::system" => undef, "CORE::syswrite" => "*\$;\$\$", "CORE::tell" => ";*", "CORE::telldir" => "*", "CORE::tie" => "\\[\$\@%]\$;\@", "CORE::tied" => undef, "CORE::time" => '', "CORE::times" => '', "CORE::truncate" => "\$\$", "CORE::uc" => "_", "CORE::ucfirst" => "_", "CORE::umask" => ";\$", "CORE::undef" => ";\$", "CORE::unlink" => "\@", "CORE::unpack" => "\$;\$", "CORE::unshift" => "+\@", "CORE::untie" => undef, "CORE::use" => undef, "CORE::utime" => "\@", "CORE::values" => "+", "CORE::vec" => "\$\$\$", "CORE::wait" => '', "CORE::waitpid" => "\$\$", "CORE::wantarray" => '', "CORE::warn" => "\@", "CORE::when" => undef, "CORE::write" => ";*", "CORE::m" => undef, "CORE::q" => undef, "CORE::qq" => undef, "CORE::qw" => undef, "CORE::qx" => undef, "CORE::qr" => undef, "CORE::s" => undef, "CORE::tr" => undef, "CORE::y" => undef, "CORE::if" => undef, "CORE::unless" => undef, "CORE::when" => undef, "CORE::for" => undef, "CORE::foreach" => undef, "CORE::while" => undef, "CORE::given" => undef, "CORE::and" => undef, "CORE::or" => undef, "CORE::xor" => undef, "CORE::not" => undef, "CORE::cmp" => undef, "CORE::__FILE__" => '', "CORE::__LINE__" => '', "CORE::__PACKAGE__" => '', "CORE::__END__" => undef, "CORE::__DATA__" => undef, };
    sub Perlito5::test_perl_version {
        my $version = shift;
        $version =~ s/^v//;
        if ($version && ord(substr($version, 0, 1)) < 10) {
            my @v = split(m//, $version);
            push(@v, chr(0))
                while @v < 3;
            $version = sprintf("%d.%03d%03d", map {;
                ord($_)
            } @v)
        }
        else {
            my @v = split(m/\./, $version);
            $v[1] = $v[1] . 0
                while length($v[1]) < 3;
            $version = join(".", @v)
        }
        if ($version gt ${"]"}) {;
            die("Perl v" . $version . " required--this is only v" . ${"]"})
        }
    }
    sub Perlito5::get_label {;
        "tmp" . ($Perlito5::ID++)
    }
    sub Perlito5::overloading_flag {
        my $no_overloading;
        if (${^H} & $Perlito5::HINT_NO_AMAGIC) {;
            $no_overloading = 1
        }
        return ($no_overloading ? ("_no_overloading", 1) : ())
    }
    sub Perlito5::integer_flag {
        my $op = shift;
        my $is_integer;
        if ((${^H} & $Perlito5::INTEGER) && $Perlito5::Integer{$op}) {;
            $is_integer = 1
        }
        return ($is_integer ? ("_integer", 1) : ())
    }
    1
}
{
    package main;
    package Perlito5::AST::CompUnit;
    {;
        sub Perlito5::AST::CompUnit::emit_compile_time {
            my $self = $_[0];
            return __PACKAGE__()->new(%{$self}, "body", [map {;
                defined($_) && $_->emit_compile_time()
            } @{$self->{"body"}}])
        }
    }
    package Perlito5::AST::Int;
    {;
        sub Perlito5::AST::Int::emit_compile_time {;
            return $_[0]
        }
    }
    package Perlito5::AST::Num;
    {;
        sub Perlito5::AST::Num::emit_compile_time {;
            return $_[0]
        }
    }
    package Perlito5::AST::Buf;
    {;
        sub Perlito5::AST::Buf::emit_compile_time {;
            return $_[0]
        }
    }
    package Perlito5::AST::Block;
    {;
        sub Perlito5::AST::Block::emit_compile_time {
            my $self = $_[0];
            return __PACKAGE__()->new(%{$self}, "stmts", [map {;
                defined($_) && $_->emit_compile_time()
            } @{$self->{"stmts"}}], ($self->{"continue"} ? ("continue", $self->{"continue"}->emit_compile_time()) : ()))
        }
    }
    package Perlito5::AST::Index;
    {;
        sub Perlito5::AST::Index::emit_compile_time {
            my $self = $_[0];
            return __PACKAGE__()->new(%{$self}, "obj", $self->{"obj"}->emit_compile_time(), "index_exp", $self->{"index_exp"}->emit_compile_time())
        }
    }
    package Perlito5::AST::Lookup;
    {;
        sub Perlito5::AST::Lookup::emit_compile_time {
            my $self = $_[0];
            return __PACKAGE__()->new(%{$self}, "obj", $self->{"obj"}->emit_compile_time(), "index_exp", $self->{"index_exp"}->emit_compile_time())
        }
    }
    package Perlito5::AST::Var;
    {;
        sub Perlito5::AST::Var::emit_compile_time {
            my $self = $_[0];
            return $self
        }
    }
    package Perlito5::AST::Call;
    {;
        sub Perlito5::AST::Call::emit_compile_time {
            my $self = $_[0];
            my $invocant = $self->{"invocant"}->emit_compile_time();
            my $arguments;
            if ($self->{"method"} eq "postcircumfix:<[ ]>") {;
                $arguments = $self->{"arguments"}->emit_compile_time()
            }
            elsif ($self->{"method"} eq "postcircumfix:<{ }>") {;
                $arguments = $self->{"arguments"}->emit_compile_time()
            }
            else {;
                $arguments = [map {;
                    $_->emit_compile_time()
                } @{$self->{"arguments"}}]
            }
            my $meth = $self->{"method"};
            if (ref($meth) eq "Perlito5::AST::Var") {;
                $meth = $meth->emit_compile_time()
            }
            return __PACKAGE__()->new(%{$self}, "method", $meth, "invocant", $invocant, "arguments", $arguments)
        }
    }
    package Perlito5::AST::Apply;
    {
        sub Perlito5::AST::Apply::emit_compile_time_args {
            my $self = $_[0];
            !$self->{"arguments"} && return ();
            return map {;
                $_->emit_compile_time()
            } @{$self->{"arguments"}}
        }
        sub Perlito5::AST::Apply::emit_compile_time {
            my $self = $_[0];
            my $code;
            if (ref($self->{"code"})) {;
                $code = $self->{"code"}->emit_compile_time()
            }
            else {;
                $code = $self->{"code"}
            }
            my $arguments;
            if (ref($self->{"arguments"})) {;
                $arguments = [map {;
                    $_->emit_compile_time()
                } @{$self->{"arguments"}}]
            }
            else {;
                $arguments = $self->{"arguments"}
            }
            my $special_arg;
            if (ref($self->{"special_arg"})) {;
                $special_arg = $self->{"special_arg"}->emit_compile_time()
            }
            else {;
                $special_arg = $self->{"special_arg"}
            }
            if ($self->{"code"} eq "infix:<=>") {
                my $arg = $self->{"arguments"}->[0];
                if (ref($arg) eq "Perlito5::AST::Apply" && $arg->{"code"} eq "prefix:<*>") {;
                    return Perlito5::AST::Apply::->new("code", "compile_time_glob_set", "namespace", "Perlito5::Grammar::Scope", "arguments", [$arg->{"arguments"}->[0]->emit_compile_time(), $self->{"arguments"}->[1]->emit_compile_time(), Perlito5::AST::Buf::->new("buf", $Perlito5::PKG_NAME)])
                }
                elsif (ref($arg) eq "Perlito5::AST::Var" && $arg->{"sigil"} eq "*") {;
                    return Perlito5::AST::Apply::->new("code", "compile_time_glob_set", "namespace", "Perlito5::Grammar::Scope", "arguments", [Perlito5::AST::Buf::->new("buf", ($arg->{"namespace"} || $arg->{"_namespace"}) . "::" . ($arg->{"name"})), $self->{"arguments"}->[1]->emit_compile_time(), Perlito5::AST::Buf::->new("buf", $Perlito5::PKG_NAME)])
                }
            }
            if ($self->{"code"} eq "eval") {
                my $args = $self->{"arguments"};
                if (@{$args} && !$args->[0]->isa("Perlito5::AST::Block")) {;
                    return $self
                }
            }
            if ($self->{"code"} eq "require" && !$self->{"namespace"}) {;
                return Perlito5::AST::Apply::->new(%{$self}, "namespace", "Perlito5::Grammar::Use")
            }
            return __PACKAGE__()->new(%{$self}, "code", $code, "arguments", $arguments, ($special_arg ? ("special_arg", $special_arg) : ()))
        }
    }
    package Perlito5::AST::If;
    {;
        sub Perlito5::AST::If::emit_compile_time {
            my $self = $_[0];
            return __PACKAGE__()->new(%{$self}, "cond", $self->{"cond"}->emit_compile_time(), "body", $self->{"body"}->emit_compile_time(), "otherwise", $self->{"otherwise"}->emit_compile_time())
        }
    }
    package Perlito5::AST::When;
    {;
        sub Perlito5::AST::When::emit_compile_time {
            my $self = $_[0];
            return __PACKAGE__()->new(%{$self}, "cond", $self->{"cond"}->emit_compile_time(), "body", $self->{"body"}->emit_compile_time())
        }
    }
    package Perlito5::AST::While;
    {;
        sub Perlito5::AST::While::emit_compile_time {
            my $self = $_[0];
            return __PACKAGE__()->new(%{$self}, "cond", $self->{"cond"}->emit_compile_time(), "body", $self->{"body"}->emit_compile_time())
        }
    }
    package Perlito5::AST::For;
    {;
        sub Perlito5::AST::For::emit_compile_time {
            my $self = $_[0];
            my $cond;
            if (ref($self->{"cond"}) eq "ARRAY") {;
                $cond = [map {;
                    defined($_) ? $_->emit_compile_time() : $_
                } @{$self->{"cond"}}]
            }
            else {;
                $cond = $self->{"cond"}->emit_compile_time()
            }
            return __PACKAGE__()->new(%{$self}, "cond", $cond, "body", $self->{"body"}->emit_compile_time(), ($self->{"continue"} ? ("continue", $self->{"continue"}->emit_compile_time()) : ()))
        }
    }
    package Perlito5::AST::Decl;
    {;
        sub Perlito5::AST::Decl::emit_compile_time {
            my $self = $_[0];
            return __PACKAGE__()->new(%{$self}, "var", $self->{"var"}->emit_compile_time())
        }
    }
    package Perlito5::AST::Sub;
    {;
        sub Perlito5::AST::Sub::emit_compile_time {
            my $self = $_[0];
            my @stmts;
            if (defined($self->{"block"})) {
                if ($self->{"name"}) {
                    local $Perlito5::PKG_NAME = $self->{"namespace"};
                    return Perlito5::AST::Apply::->new("code", "infix:<=>", "namespace", '', "arguments", [Perlito5::AST::Var::->new("sigil", "*", "_decl", "global", "namespace", $self->{"namespace"}, "name", $self->{"name"}), Perlito5::AST::Sub::->new(%{$self}, "namespace", undef, "name", undef)->emit_compile_time()])
                }
                @stmts = @{$self->{"block"}->{"stmts"}};
                @stmts = map {;
                    $_->emit_compile_time()
                } @stmts;
                {
                    my @captured;
                    for my $stmt (@{$self->{"block"}->{"stmts"}}) {;
                        push(@captured, $stmt->get_captures())
                    }
                    my %dont_capture = map {;
                        $_->{"dont"} ? ($_->{"dont"}, 1) : ()
                    } @captured;
                    my %capture = map {;
                        $_->{"dont"} ? () : $dont_capture{$_->{"_id"}} ? () : ($_->{"_decl"} eq "local" || $_->{"_decl"} eq "global" || $_->{"_decl"} eq '') ? () : ($_->{"_id"}, $_)
                    } @captured;
                    my $code = __PACKAGE__()->new(%{$self});
                    my $id = Perlito5::get_label();
                    $Perlito5::BEGIN_SUBS{$id} = $code;
                    $Perlito5::BEGIN_LEXICALS{$_} = $capture{$_}
                        for keys(%capture);
                    if (!@stmts) {;
                        unshift(@stmts, Perlito5::AST::Apply::->new("code", "return", "arguments", []))
                    }
                    unshift(@stmts, Perlito5::AST::Apply::->new("code", "infix:<&&>", "arguments", [Perlito5::AST::Var::LIST_ARG(), Perlito5::AST::Apply::->new("code", "infix:<&&>", "arguments", [Perlito5::AST::Apply::->new("code", "infix:<eq>", "arguments", [Perlito5::AST::Apply::->new("arguments", [Perlito5::AST::Var::LIST_ARG_INDEX(0)], "code", "ref"), Perlito5::AST::Buf::->new("buf", "Perlito5::dump")]), Perlito5::AST::Apply::->new("code", "return", "arguments", [Perlito5::AST::Apply::->new("code", "circumfix:<{ }>", "arguments", [Perlito5::AST::Buf::->new("buf", "__SUB__"), Perlito5::AST::Buf::->new("buf", $id), Perlito5::AST::Buf::->new("buf", "__PKG__"), Perlito5::AST::Buf::->new("buf", $Perlito5::PKG_NAME), map {;
                        (Perlito5::AST::Buf::->new("buf", $_), Perlito5::AST::Apply::->new("code", "prefix:<\\>", "arguments", [$capture{$_}]))
                    } sort {;
                        $a cmp $b
                    } keys(%capture)])])])]))
                }
                $self = __PACKAGE__()->new(%{$self}, ($self->{"block"} ? ("block", Perlito5::AST::Block::->new(%{$self->{"block"}}, "stmts", [@stmts])) : ()))
            }
            return $self
        }
    }
    1
}
{
    package main;
    package Perlito5::DumpToAST;
    sub Perlito5::DumpToAST::dump_to_ast {
        (my $obj, my $seen, my $pos) = @_;
        !defined($obj) && return Perlito5::AST::Apply::->new("code", "undef", "arguments", []);
        my $ref = ref($obj);
        if (!$ref) {
            if (0 + $obj eq $obj) {
                int($obj) == $obj && return Perlito5::AST::Int::->new("int", $obj);
                return Perlito5::AST::Num::->new("num", $obj)
            }
            return Perlito5::AST::Buf::->new("buf", $obj)
        }
        my $as_string = '' . $obj;
        $seen->{$as_string} && return $seen->{$as_string};
        $seen->{$as_string} = $pos;
        if ($ref eq "ARRAY") {
            my @out;
            for my $i (0 .. $#{$obj}) {
                my $here = Perlito5::AST::Index::INDEX($pos, Perlito5::AST::Int::->new("int", $i));
                push(@out, Perlito5::DumpToAST::dump_to_ast($obj->[$i], $seen, $here))
            }
            return Perlito5::AST::Apply::->new("code", "circumfix:<[ ]>", "arguments", \@out)
        }
        elsif ($ref eq "HASH") {
            my @out;
            for my $i (sort {;
                $a cmp $b
            } keys(%{$obj})) {
                my $here = Perlito5::AST::Lookup::LOOKUP($pos, Perlito5::AST::Buf::->new("buf", $i));
                push(@out, Perlito5::AST::Apply::->new("code", "infix:<=>>", "arguments", [Perlito5::AST::Buf::->new("buf", $i), Perlito5::DumpToAST::dump_to_ast($obj->{$i}, $seen, $here)]))
            }
            return Perlito5::AST::Apply::->new("code", "circumfix:<{ }>", "arguments", \@out)
        }
        elsif ($ref eq "SCALAR" || $ref eq "REF") {
            my $here = Perlito5::AST::Apply::->new("code", "prefix:<\$>", "arguments", [$pos]);
            return Perlito5::AST::Apply::->new("code", "prefix:<\\>", "arguments", [Perlito5::DumpToAST::dump_to_ast(${$obj}, $seen, $here)])
        }
        elsif ($ref eq "CODE") {
            my $closure_flag = bless({}, "Perlito5::dump");
            my $captures = $obj->($closure_flag) // {};
            my @vars;
            my $ast;
            my $source;
            my $sub_name;
            my $package = $captures->{"__PKG__"};
            my $current_package = "main";
            for my $var_id (sort {;
                $a cmp $b
            } keys(%{$captures})) {
                $var_id eq "__PKG__" && next;
                $Perlito5::BEGIN_SCRATCHPAD{$var_id} && next;
                if ($var_id eq "__SUB__") {
                    my $sub_id = $captures->{$var_id};
                    $ast = $Perlito5::BEGIN_SUBS{$sub_id};
                    $ast->{"name"} && ($sub_name = ($ast->{"namespace"}) . "::" . ($ast->{"name"}));
                    $source = $ast
                }
                else {
                    my $var = $Perlito5::BEGIN_LEXICALS{$var_id};
                    $var = Perlito5::AST::Var::->new(%{$var}, "sigil", $var->{"_real_sigil"} || $var->{"sigil"});
                    my $decl = $var->{"_decl"} || "my";
                    if ($decl eq "our") {
                        my $var_namespace = $var->{"_namespace"} || $var->{"namespace"};
                        if ($var_namespace ne $current_package) {
                            push(@vars, Perlito5::AST::Apply::->new("code", "package", "namespace", $var_namespace, "arguments", []));
                            $current_package = $var_namespace
                        }
                        push(@vars, Perlito5::AST::Decl::->new("attributes", [], "decl", $decl, "type", '', "var", $var))
                    }
                    else {;
                        push(@vars, Perlito5::AST::Apply::->new("code", "infix:<=>", "arguments", [Perlito5::AST::Decl::->new("attributes", [], "decl", $decl, "type", '', "var", $var), Perlito5::DumpToAST::dump_to_ast_deref($captures->{$var_id}, $seen, $pos)]))
                    }
                }
            }
            if ($package ne $current_package) {
                push(@vars, Perlito5::AST::Apply::->new("code", "package", "namespace", $package, "arguments", []));
                $current_package = $package
            }
            return Perlito5::AST::Apply::->new("code", "do", "arguments", [Perlito5::AST::Block::->new("stmts", [@vars, $source])])
        }
        elsif ($ref eq "Regexp") {
            my $regex = '' . $ref;
            return Perlito5::AST::Apply::->new("code", "p5:qr", "arguments", [Perlito5::AST::Buf::->new("buf", $regex), Perlito5::AST::Buf::->new("buf", '')])
        }
        local ${"\@"} = '';
        my $res = eval {
            my @out;
            for my $i (0 .. $#{$obj}) {
                my $here = Perlito5::AST::Index::INDEX($pos, Perlito5::AST::Int::->new("int", $i));
                push(@out, Perlito5::DumpToAST::dump_to_ast($obj->[$i], $seen, $here))
            }
            return Perlito5::AST::Apply::->new("code", "bless", "arguments", [Perlito5::AST::Apply::->new("code", "circumfix:<[ ]>", "arguments", \@out), Perlito5::AST::Buf::->new("buf", $ref)])
        };
        $res && return $res;
        $res = eval {;
            return Perlito5::AST::Apply::->new("code", "bless", "arguments", [Perlito5::AST::Apply::->new("code", "prefix:<\\>", "arguments", [Perlito5::DumpToAST::dump_to_ast(${$obj})])])
        };
        $res && return $res;
        my @out;
        for my $i (sort {;
            $a cmp $b
        } keys(%{$obj})) {
            my $here = Perlito5::AST::Lookup::LOOKUP($pos, Perlito5::AST::Buf::->new("buf", $i));
            push(@out, Perlito5::AST::Apply::->new("code", "infix:<=>>", "arguments", [Perlito5::AST::Buf::->new("buf", $i), Perlito5::DumpToAST::dump_to_ast($obj->{$i}, $seen, $here)]))
        }
        return Perlito5::AST::Apply::->new("code", "bless", "arguments", [Perlito5::AST::Apply::->new("code", "circumfix:<{ }>", "arguments", \@out), Perlito5::AST::Buf::->new("buf", $ref)])
    }
    sub Perlito5::DumpToAST::dump_to_ast_deref {
        (my $obj, my $seen, my $pos) = @_;
        my $ref = ref($obj);
        !$ref && return Perlito5::DumpToAST::dump_to_ast(@_);
        if ($ref eq "ARRAY") {
            @{$obj} || return "()";
            my @out;
            for my $i (0 .. $#{$obj}) {
                my $here = Perlito5::AST::Index::INDEX($pos, Perlito5::AST::Int::->new("int", $i));
                push(@out, Perlito5::DumpToAST::dump_to_ast($obj->[$i], $seen, $here))
            }
            return Perlito5::AST::Apply::->new("code", "circumfix:<( )>", "arguments", \@out)
        }
        elsif ($ref eq "HASH") {
            keys(%{$obj}) || return "()";
            my @out;
            for my $i (sort {;
                $a cmp $b
            } keys(%{$obj})) {
                my $here = Perlito5::AST::Lookup::LOOKUP($pos, Perlito5::AST::Buf::->new("buf", $i));
                push(@out, Perlito5::AST::Apply::->new("code", "infix:<=>>", "arguments", [Perlito5::AST::Buf::->new("buf", $i), Perlito5::DumpToAST::dump_to_ast($obj->{$i}, $seen, $here)]))
            }
            return Perlito5::AST::Apply::->new("code", "circumfix:<( )>", "arguments", \@out)
        }
        elsif ($ref eq "SCALAR" || $ref eq "REF") {
            my $here = Perlito5::AST::Apply::->new("code", "prefix:<\$>", "arguments", [$pos]);
            return Perlito5::DumpToAST::dump_to_ast(${$obj}, $seen, $here)
        }
        return Perlito5::DumpToAST::dump_to_ast($obj, $seen, $pos)
    }
    1
}
{
    package main;
    package Perlito5::CompileTime::Dumper;
    sub Perlito5::CompileTime::Dumper::_dump_AST_from_scope {
        (my $name, my $item, my $vars, my $dumper_seen) = @_;
        my $sigil = substr($name, 0, 1);
        if (ref($item) eq "Perlito5::AST::Sub" && $item->{"name"}) {;
            return
        }
        if (substr($name, 7, 1) lt "A") {;
            $name = $sigil . "{" . Perlito5::Dumper::escape_string(substr($name, 1)) . "}"
        }
        my $ast = $item->{"ast"};
        if (ref($ast) eq "Perlito5::AST::Var" && $ast->{"_decl"} eq "our") {
            $ast = Perlito5::AST::Var::->new(%{$ast}, "sigil", $ast->{"_real_sigil"} || $ast->{"sigil"}, "namespace", $ast->{"namespace"} || $ast->{"_namespace"}, "decl", "global");
            $name = ($ast->{"sigil"}) . ($ast->{"namespace"}) . "::" . ($ast->{"name"})
        }
        my $bareword = substr($name, 1);
        if (ref($ast) eq "Perlito5::AST::Var" && $sigil eq "\$") {
            my $value = ${$bareword};
            !defined($value) && return;
            push(@{$vars}, Perlito5::AST::Apply::->new("code", "infix:<=>", "arguments", [$ast, Perlito5::DumpToAST::dump_to_ast($value, $dumper_seen, $ast)]))
        }
        elsif (ref($ast) eq "Perlito5::AST::Var" && $sigil eq "\@") {
            substr($bareword, 0, 2) eq "{'" && ($bareword = substr($bareword, 2, -2));
            my $value = \@{$bareword};
            push(@{$vars}, Perlito5::AST::Apply::->new("code", "infix:<=>", "arguments", [Perlito5::AST::Var::->new(%{$ast}, "sigil", "*"), Perlito5::DumpToAST::dump_to_ast($value, $dumper_seen, $ast)]))
        }
        elsif (ref($ast) eq "Perlito5::AST::Var" && $sigil eq "%") {
            my $value = \%{$bareword};
            push(@{$vars}, Perlito5::AST::Apply::->new("code", "infix:<=>", "arguments", [Perlito5::AST::Var::->new(%{$ast}, "sigil", "*"), Perlito5::DumpToAST::dump_to_ast($value, $dumper_seen, $ast)]))
        }
        elsif (ref($ast) eq "Perlito5::AST::Var" && $sigil eq "*") {
            substr($bareword, 0, 2) eq "{'" && ($bareword = substr($bareword, 2, -2));
            if (exists(&{$bareword})) {
                my $value = \&{$bareword};
                push(@{$vars}, Perlito5::AST::Apply::->new("code", "infix:<=>", "arguments", [Perlito5::AST::Var::->new(%{$ast}, "sigil", "*"), Perlito5::DumpToAST::dump_to_ast($value, $dumper_seen, $ast)]))
            }
            if (defined(${$bareword})) {
                my $value = \${$bareword};
                push(@{$vars}, Perlito5::AST::Apply::->new("code", "infix:<=>", "arguments", [Perlito5::AST::Var::->new(%{$ast}, "sigil", "*"), Perlito5::DumpToAST::dump_to_ast($value, $dumper_seen, $ast)]))
            }
            if (@{$bareword}) {
                my $value = \@{$bareword};
                push(@{$vars}, Perlito5::AST::Apply::->new("code", "infix:<=>", "arguments", [Perlito5::AST::Var::->new(%{$ast}, "sigil", "*"), Perlito5::DumpToAST::dump_to_ast($value, $dumper_seen, $ast)]))
            }
            if (keys(%{$bareword})) {
                my $value = \%{$bareword};
                push(@{$vars}, Perlito5::AST::Apply::->new("code", "infix:<=>", "arguments", [Perlito5::AST::Var::->new(%{$ast}, "sigil", "*"), Perlito5::DumpToAST::dump_to_ast($value, $dumper_seen, $ast)]))
            }
        }
    }
    sub Perlito5::CompileTime::Dumper::emit_globals_after_BEGIN {
        my $scope = shift() // $Perlito5::GLOBAL;
        my $vars = [];
        my $seen = {};
        my $dumper_seen = {};
        my $tab = '';
        delete($scope->{"%main::ENV"});
        delete($scope->{"\$main::]"});
        delete($scope->{"\$main::ARGV"});
        delete($scope->{"\@main::_"});
        local $_;
        my @dump_these = ("\$main::0", "\$main::a", "\$main::b", "\$main::_", "%main::INC", "\@Perlito5::END_BLOCK", "\@Perlito5::INIT_BLOCK", "%Perlito5::DATA_SECTION", "%Perlito5::BEGIN_SCRATCHPAD");
        for my $pkg (keys(%{$Perlito5::PACKAGES})) {;
            push(@dump_these, "\@" . $pkg . "::ISA")
        }
        DUMP:
        for my $v (@dump_these) {
            (my $sigil, my $namespace, my $name) = $v =~ m/^([\$\@%])(\w+)::(.*)$/;
            if ($sigil eq "\@" && @{$namespace . "::" . $name} == 0) {;
                next(DUMP)
            }
            if ($sigil eq "%" && keys(%{$namespace . "::" . $name}) == 0) {;
                next(DUMP)
            }
            $scope->{$v} //= {"ast" => Perlito5::AST::Var::->new("name", $name, "sigil", $sigil, "_decl", "global", "namespace", $namespace), "value" => ($sigil eq "\$" ? \${$namespace . "::" . $name} : $sigil eq "\@" ? \@{$namespace . "::" . $name} : $sigil eq "%" ? \%{$namespace . "::" . $name} : undef), }
        }
        for my $id (keys(%Perlito5::BEGIN_SCRATCHPAD)) {
            my $ast = $Perlito5::BEGIN_SCRATCHPAD{$id};
            my $sigil = $ast->{"_real_sigil"} || $ast->{"sigil"};
            if (!$ast->{"namespace"}) {
                $ast->{"namespace"} = "Perlito5::BEGIN";
                $ast->{"name"} = "_" . $id . "_" . ($ast->{"name"})
            }
            my $fullname = ($ast->{"namespace"}) . "::" . ($ast->{"name"});
            if ($sigil eq "\$") {;
                $scope->{$sigil . $fullname} //= {"ast" => $ast, "value" => \${$fullname}, }
            }
            elsif ($sigil eq "\@") {;
                $scope->{$sigil . $fullname} //= {"ast" => $ast, "value" => \@{$fullname}, }
            }
            elsif ($sigil eq "%") {;
                $scope->{$sigil . $fullname} //= {"ast" => $ast, "value" => \%{$fullname}, }
            }
        }
        my $vars = [];
        my $dumper_seen = {};
        for my $fullname (sort {;
            $a cmp $b
        } keys(%{$Perlito5::PROTO})) {
            my $proto = $Perlito5::PROTO->{$fullname};
            my @parts = split("::", $fullname);
            my $name = pop(@parts);
            push(@{$vars}, Perlito5::AST::Sub::->new("namespace", join("::", @parts), "sig", $proto, "name", $name, "block", undef, "attributes", []))
        }
        for my $name (sort {;
            $a cmp $b
        } keys(%{$scope})) {
            my $item = $scope->{$name};
            Perlito5::CompileTime::Dumper::_dump_AST_from_scope($name, $item, $vars, $dumper_seen)
        }
        return $vars
    }
    1
}
{
    package main;
    package Perlito5::Compiler;
    sub Perlito5::Compiler::compiler_name {;
        "Perlito5"
    }
    sub Perlito5::Compiler::do_not_edit {
        my $prefix = shift;
        return $prefix . " Do not edit this file - Generated by " . Perlito5::Compiler::compiler_name() . (" " . $Perlito5::VERSION . "
")
    }
    sub Perlito5::Compiler::error {;
        die(join('', @_) . " at " . $Perlito5::FILE_NAME . " line " . $Perlito5::LINE_NUMBER . "
")
    }
    sub Perlito5::Compiler::compiler_pos {;
        return {"file" => $Perlito5::FILE_NAME, "line" => $Perlito5::LINE_NUMBER, }
    }
    1
}
{
    package main;
    package Perlito5::Grammar::Regex6;
    sub Perlito5::Grammar::Regex6::term_token {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((("t" eq $str->[($MATCH->{"to"}) + 0]) && ("o" eq $str->[($MATCH->{"to"}) + 1]) && ("k" eq $str->[($MATCH->{"to"}) + 2]) && ("e" eq $str->[($MATCH->{"to"}) + 3]) && ("n" eq $str->[($MATCH->{"to"}) + 4]) && ($MATCH->{"to"} += 5)) && (do {
            my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::ident($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::ident"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (("{" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $m2 = Perlito5::Grammar::Regex6::rule($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Regex6::rule"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (("}" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $source = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::ident"}) . "{ " . "my \$str     = \$_[0]; " . "my \$pos     = \$_[1]; " . "my \$MATCH = { str => \$str, from => \$pos, to => \$pos }; " . "my \$tmp = ( " . Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Regex6::rule"})->emit_perl5() . "); " . "\$tmp ? \$MATCH : undef; " . "}";
            $source = [split(m//, $source)];
            my $ast = Perlito5::Grammar::Block::named_sub_def($source, 0);
            $MATCH->{"capture"} = ["term", Perlito5::Match::flat($ast)];
            1
        })));
        $tmp ? $MATCH : undef
    }
    Perlito5::Grammar::Precedence::add_term("token", \&term_token);
    sub Perlito5::Grammar::Regex6::any {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"}));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Regex6::literal {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = ((do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{"to"};
            while ((do {
                my $tmp2293 = $MATCH->{"to"};
                (((("\\" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && ('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"}))) || ($MATCH->{"to"} = $tmp2293, ((do {
                    my $tmp = $MATCH;
                    $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
                    my $res = (("'" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1));
                    $MATCH = $tmp;
                    $res ? 0 : 1
                }) && ('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"})))
            }) && ($last_match_null < 2)) {
                if ($to == $MATCH->{"to"}) {;
                    $last_match_null = $last_match_null + 1
                }
                else {;
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{"to"}
            }
            $MATCH = $m;
            $MATCH->{"to"} = $to;
            1
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Regex6::metasyntax_exp {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = ((do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{"to"};
            my $count = 0;
            while (((do {
                my $tmp = $MATCH;
                $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
                my $res = ((">" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1));
                $MATCH = $tmp;
                $res ? 0 : 1
            }) && ('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"})) && ($last_match_null < 2)) {
                if ($to == $MATCH->{"to"}) {;
                    $last_match_null = $last_match_null + 1
                }
                else {;
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{"to"};
                $count = $count + 1
            }
            $MATCH = $m;
            $MATCH->{"to"} = $to;
            $count > 0
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Regex6::string_code {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = ((do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{"to"};
            my $count = 0;
            while ((do {
                my $tmp2314 = $MATCH->{"to"};
                (((("\\" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && ('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"}))) || ($MATCH->{"to"} = $tmp2314, ((("'" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $m2 = Perlito5::Grammar::Regex6::literal($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (("'" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)))) || ($MATCH->{"to"} = $tmp2314, ((("{" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $m2 = Perlito5::Grammar::Regex6::string_code($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (("}" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)))) || ($MATCH->{"to"} = $tmp2314, ((do {
                    my $tmp = $MATCH;
                    $MATCH = {"from" => $tmp->{"to"}, "to" => $tmp->{"to"}, };
                    my $res = (("}" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1));
                    $MATCH = $tmp;
                    $res ? 0 : 1
                }) && ('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"})))
            }) && ($last_match_null < 2)) {
                if ($to == $MATCH->{"to"}) {;
                    $last_match_null = $last_match_null + 1
                }
                else {;
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{"to"};
                $count = $count + 1
            }
            $MATCH = $m;
            $MATCH->{"to"} = $to;
            $count > 0
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Regex6::parsed_code {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $m2 = Perlito5::Grammar::Regex6::string_code($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = Perlito5::Match::flat($MATCH);
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Regex6::rule_term {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = ((do {
            my $tmp2333 = $MATCH->{"to"};
            (((("<" eq $str->[($MATCH->{"to"}) + 0]) && ("b" eq $str->[($MATCH->{"to"}) + 1]) && ("e" eq $str->[($MATCH->{"to"}) + 2]) && ("f" eq $str->[($MATCH->{"to"}) + 3]) && ("o" eq $str->[($MATCH->{"to"}) + 4]) && ("r" eq $str->[($MATCH->{"to"}) + 5]) && ("e" eq $str->[($MATCH->{"to"}) + 6]) && ($MATCH->{"to"} += 7)) && (do {
                my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $m2 = Perlito5::Grammar::Regex6::rule($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"rule"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && ((">" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                $MATCH->{"capture"} = Perlito5::Rul::Before::->new("rule_exp", Perlito5::Match::flat($MATCH->{"rule"}));
                1
            }))) || ($MATCH->{"to"} = $tmp2333, ((("<" eq $str->[($MATCH->{"to"}) + 0]) && ("!" eq $str->[($MATCH->{"to"}) + 1]) && ("b" eq $str->[($MATCH->{"to"}) + 2]) && ("e" eq $str->[($MATCH->{"to"}) + 3]) && ("f" eq $str->[($MATCH->{"to"}) + 4]) && ("o" eq $str->[($MATCH->{"to"}) + 5]) && ("r" eq $str->[($MATCH->{"to"}) + 6]) && ("e" eq $str->[($MATCH->{"to"}) + 7]) && ($MATCH->{"to"} += 8)) && (do {
                my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $m2 = Perlito5::Grammar::Regex6::rule($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"rule"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && ((">" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                $MATCH->{"capture"} = Perlito5::Rul::NotBefore::->new("rule_exp", Perlito5::Match::flat($MATCH->{"rule"}));
                1
            }))) || ($MATCH->{"to"} = $tmp2333, ((("'" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $m2 = Perlito5::Grammar::Regex6::literal($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"literal"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (("'" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                $MATCH->{"capture"} = Perlito5::Rul::Constant::->new("constant", Perlito5::Match::flat($MATCH->{"literal"}));
                1
            }))) || ($MATCH->{"to"} = $tmp2333, ((("<" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $tmp2334 = $MATCH->{"to"};
                (((("." eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $m2 = Perlito5::Grammar::Regex6::metasyntax_exp($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"metasyntax_exp"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && ((">" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    $MATCH->{"capture"} = Perlito5::Rul::Subrule::->new("metasyntax", Perlito5::Match::flat($MATCH->{"metasyntax_exp"}), "captures", 0);
                    1
                }))) || ($MATCH->{"to"} = $tmp2334, ((do {
                    my $m2 = Perlito5::Grammar::Regex6::metasyntax_exp($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"metasyntax_exp"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && ((">" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    $MATCH->{"capture"} = Perlito5::Rul::Subrule::->new("metasyntax", Perlito5::Match::flat($MATCH->{"metasyntax_exp"}), "captures", 1);
                    1
                })))
            }))) || ($MATCH->{"to"} = $tmp2333, ((("{" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $m2 = Perlito5::Grammar::Regex6::parsed_code($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"parsed_code"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (("}" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                $MATCH->{"capture"} = Perlito5::Rul::Block::->new("closure", Perlito5::Match::flat($MATCH->{"parsed_code"}));
                1
            }))) || ($MATCH->{"to"} = $tmp2333, ((("\\" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $tmp2335 = $MATCH->{"to"};
                (((("c" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $m2 = Perlito5::Grammar::Number::digits($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Number::digits"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{"capture"} = Perlito5::Rul::Constant::->new("constant", chr(Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Number::digits"})));
                    1
                }))) || ($MATCH->{"to"} = $tmp2335, ((do {
                    my $m2 = Perlito5::Grammar::Regex6::any($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"any"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{"capture"} = Perlito5::Rul::SpecialChar::->new("char", Perlito5::Match::flat($MATCH->{"any"}));
                    1
                })))
            }))) || ($MATCH->{"to"} = $tmp2333, ((("." eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                $MATCH->{"capture"} = Perlito5::Rul::Dot::->new();
                1
            }))) || ($MATCH->{"to"} = $tmp2333, ((("[" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $m2 = Perlito5::Grammar::Regex6::rule($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"rule"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (("]" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"rule"});
                1
            })))
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Regex6::quant_exp {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = ((do {
            my $tmp2354 = $MATCH->{"to"};
            ((("?" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp2354, (("*" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp2354, (("+" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)))
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Regex6::quantifier {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Space::opt_ws"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Regex6::rule_term($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"rule_term"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Space::opt_ws"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $tmp2360 = $MATCH->{"to"};
            (((do {
                my $m2 = Perlito5::Grammar::Regex6::quant_exp($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"quant_exp"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::Space::opt_ws"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                $MATCH->{"capture"} = Perlito5::Rul::Quantifier::->new("term", Perlito5::Match::flat($MATCH->{"rule_term"}), "quant", Perlito5::Match::flat($MATCH->{"quant_exp"}));
                1
            }))) || ($MATCH->{"to"} = $tmp2360, (do {
                $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"rule_term"});
                1
            }))
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Regex6::concat_list {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = ((do {
            my $tmp2371 = $MATCH->{"to"};
            (((do {
                my $m2 = Perlito5::Grammar::Regex6::quantifier($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"quantifier"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $tmp2372 = $MATCH->{"to"};
                (((do {
                    my $m2 = Perlito5::Grammar::Regex6::concat_list($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"concat_list"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{"capture"} = [Perlito5::Match::flat($MATCH->{"quantifier"}), @{Perlito5::Match::flat($MATCH->{"concat_list"})}];
                    1
                }))) || ($MATCH->{"to"} = $tmp2372, (do {
                    $MATCH->{"capture"} = [Perlito5::Match::flat($MATCH->{"quantifier"})];
                    1
                }))
            }))) || ($MATCH->{"to"} = $tmp2371, (do {
                $MATCH->{"capture"} = [];
                1
            }))
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Regex6::concat_exp {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $m2 = Perlito5::Grammar::Regex6::concat_list($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"concat_list"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = Perlito5::Rul::Concat::->new("concat", Perlito5::Match::flat($MATCH->{"concat_list"}));
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Regex6::or_list_exp {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = ((do {
            my $tmp2386 = $MATCH->{"to"};
            (((do {
                my $m2 = Perlito5::Grammar::Regex6::concat_exp($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"concat_exp"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $tmp2387 = $MATCH->{"to"};
                (((("|" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $m2 = Perlito5::Grammar::Regex6::or_list_exp($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"or_list_exp"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{"capture"} = [Perlito5::Match::flat($MATCH->{"concat_exp"}), @{Perlito5::Match::flat($MATCH->{"or_list_exp"})}];
                    1
                }))) || ($MATCH->{"to"} = $tmp2387, (do {
                    $MATCH->{"capture"} = [Perlito5::Match::flat($MATCH->{"concat_exp"})];
                    1
                }))
            }))) || ($MATCH->{"to"} = $tmp2386, (do {
                $MATCH->{"capture"} = [];
                1
            }))
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Regex6::rule {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $tmp2396 = $MATCH->{"to"};
            (((do {
                my $m = $MATCH;
                if (!(do {
                    my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                })) {;
                    $MATCH = $m
                }
                1
            }) && (("|" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)))) || ($MATCH->{"to"} = $tmp2396, 1)
        }) && (do {
            my $m2 = Perlito5::Grammar::Regex6::or_list_exp($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"or_list_exp"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = Perlito5::Rul::Or::->new("or_list", Perlito5::Match::flat($MATCH->{"or_list_exp"}));
            1
        })));
        $tmp ? $MATCH : undef
    }
}
{
    package main;
    package Perlito5::Rul;
    sub Perlito5::Rul::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::Rul::constant {
        my $str = shift;
        my $len = length($str);
        if ($len) {
            my @cond;
            my $i = 0;
            for my $char (split(m//, $str)) {
                if ($char eq "\\") {;
                    $char = "\\\\"
                }
                if ($char eq "'") {;
                    $char = "\\'"
                }
                push(@cond, "('" . $char . "' eq \$str->[\$MATCH->{to} + " . $i . "])");
                $i++
            }
            return "(" . join(" && ", @cond, "(\$MATCH->{to} += " . $len . ")") . ")"
        }
        else {;
            return 1
        }
    }
    package Perlito5::Rul::Quantifier;
    sub Perlito5::Rul::Quantifier::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::Rul::Quantifier::term {;
        $_[0]->{"term"}
    }
    sub Perlito5::Rul::Quantifier::quant {;
        $_[0]->{"quant"}
    }
    sub Perlito5::Rul::Quantifier::emit_perl5 {
        my $self = $_[0];
        if ($self->{"quant"} eq '') {;
            return $self->{"term"}->emit_perl5()
        }
        if ($self->{"quant"} eq "+") {
            $self->{"term"}->set_captures_to_array();
            return "(do { " . "my \$last_match_null = 0; " . "my \$m = \$MATCH; " . "my \$to = \$MATCH->{to}; " . "my \$count = 0; " . "while (" . $self->{"term"}->emit_perl5() . " && (\$last_match_null < 2)) " . "{ " . "if (\$to == \$MATCH->{to}) { " . "\$last_match_null = \$last_match_null + 1; " . "} " . "else { " . "\$last_match_null = 0; " . "}; " . "\$m = \$MATCH; " . "\$to = \$MATCH->{to}; " . "\$count = \$count + 1; " . "}; " . "\$MATCH = \$m; " . "\$MATCH->{to} = \$to; " . "\$count > 0; " . "})"
        }
        if ($self->{"quant"} eq "*") {
            $self->{"term"}->set_captures_to_array();
            return "(do { " . "my \$last_match_null = 0; " . "my \$m = \$MATCH; " . "my \$to = \$MATCH->{to}; " . "while (" . $self->{"term"}->emit_perl5() . " && (\$last_match_null < 2)) " . "{ " . "if (\$to == \$MATCH->{to}) { " . "\$last_match_null = \$last_match_null + 1; " . "} " . "else { " . "\$last_match_null = 0; " . "}; " . "\$m = \$MATCH; " . "\$to = \$MATCH->{to}; " . "}; " . "\$MATCH = \$m; " . "\$MATCH->{to} = \$to; " . "1 " . "})"
        }
        if ($self->{"quant"} eq "?") {
            $self->{"term"}->set_captures_to_array();
            return "(do { " . "my \$m = \$MATCH; " . "if (!" . $self->{"term"}->emit_perl5() . ") " . "{ " . "\$MATCH = \$m; " . "}; " . "1 " . "})"
        }
        die("Perlito5::Rul::Quantifier:  not implemented")
    }
    sub Perlito5::Rul::Quantifier::set_captures_to_array {
        my $self = $_[0];
        $self->{"term"}->set_captures_to_array()
    }
    package Perlito5::Rul::Or;
    sub Perlito5::Rul::Or::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::Rul::Or::or_list {;
        $_[0]->{"or_list"}
    }
    sub Perlito5::Rul::Or::emit_perl5 {
        my $self = $_[0];
        if (scalar(@{$self->{"or_list"}}) == 1) {;
            return $self->{"or_list"}->[0]->emit_perl5()
        }
        my $pos = "\$" . Perlito5::get_label();
        "(do { " . "my " . $pos . " = \$MATCH->{to}; (" . join(") || (\$MATCH->{to} = " . $pos . ", ", map($_->emit_perl5(), @{$self->{"or_list"}})) . ") })"
    }
    sub Perlito5::Rul::Or::set_captures_to_array {
        my $self = $_[0];
        map($_->set_captures_to_array(), @{$self->{"or_list"}})
    }
    package Perlito5::Rul::Concat;
    sub Perlito5::Rul::Concat::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::Rul::Concat::concat {;
        $_[0]->{"concat"}
    }
    sub Perlito5::Rul::Concat::emit_perl5 {
        my $self = $_[0];
        if (scalar(@{$self->{"concat"}}) == 1) {;
            return $self->{"concat"}->[0]->emit_perl5()
        }
        "(" . join(" && ", map($_->emit_perl5(), @{$self->{"concat"}})) . ")"
    }
    sub Perlito5::Rul::Concat::set_captures_to_array {
        my $self = $_[0];
        map($_->set_captures_to_array(), @{$self->{"concat"}})
    }
    package Perlito5::Rul::Subrule;
    sub Perlito5::Rul::Subrule::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::Rul::Subrule::metasyntax {;
        $_[0]->{"metasyntax"}
    }
    sub Perlito5::Rul::Subrule::captures {;
        $_[0]->{"captures"}
    }
    sub Perlito5::Rul::Subrule::emit_perl5 {
        my $self = $_[0];
        my $meth = $self->{"metasyntax"};
        my $code;
        if ($self->{"captures"} == 1) {;
            $code = "if (\$m2) { \$MATCH->{to} = \$m2->{to}; \$MATCH->{'" . ($self->{"metasyntax"}) . "'} = \$m2; 1 } else { 0 }; "
        }
        elsif ($self->{"captures"} > 1) {;
            $code = "if (\$m2) { " . "\$MATCH->{to} = \$m2->{to}; " . "if (exists \$MATCH->{'" . ($self->{"metasyntax"}) . "'}) { " . "push \@{ \$MATCH->{'" . ($self->{"metasyntax"}) . "'} }, \$m2; " . "} " . "else { " . "\$MATCH->{'" . ($self->{"metasyntax"}) . "'} = [ \$m2 ]; " . "}; " . "1 " . "} else { 0 }; "
        }
        else {;
            $code = "if (\$m2) { \$MATCH->{to} = \$m2->{to}; 1 } else { 0 }; "
        }
        "(do { " . "my \$m2 = " . $meth . "(\$str, \$MATCH->{to}); " . $code . "})"
    }
    sub Perlito5::Rul::Subrule::set_captures_to_array {
        my $self = $_[0];
        if ($self->{"captures"} > 0) {;
            $self->{"captures"} = ($self->{"captures"}) + 1
        }
    }
    package Perlito5::Rul::Constant;
    sub Perlito5::Rul::Constant::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::Rul::Constant::constant {;
        $_[0]->{"constant"}
    }
    sub Perlito5::Rul::Constant::emit_perl5 {
        my $self = $_[0];
        my $str = $self->{"constant"};
        Perlito5::Rul::constant($str)
    }
    sub Perlito5::Rul::Constant::set_captures_to_array {;
        my $self = $_[0]
    }
    package Perlito5::Rul::Dot;
    sub Perlito5::Rul::Dot::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::Rul::Dot::emit_perl5 {
        my $self = $_[0];
        "('' ne \$str->[\$MATCH->{to}] " . "&& ++\$MATCH->{to}" . ")"
    }
    sub Perlito5::Rul::Dot::set_captures_to_array {;
        my $self = $_[0]
    }
    package Perlito5::Rul::SpecialChar;
    sub Perlito5::Rul::SpecialChar::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::Rul::SpecialChar::char {;
        $_[0]->{"char"}
    }
    sub Perlito5::Rul::SpecialChar::emit_perl5 {
        my $self = $_[0];
        my $char = $self->{"char"};
        if ($char eq "n") {;
            return Perlito5::Rul::Subrule::->new("metasyntax", "is_newline", "captures", 0)->emit_perl5()
        }
        if ($char eq "N") {;
            return Perlito5::Rul::Subrule::->new("metasyntax", "not_newline", "captures", 0)->emit_perl5()
        }
        if ($char eq "d") {;
            return Perlito5::Rul::Subrule::->new("metasyntax", "digit", "captures", 0)->emit_perl5()
        }
        if ($char eq "s") {;
            return Perlito5::Rul::Subrule::->new("metasyntax", "space", "captures", 0)->emit_perl5()
        }
        if ($char eq "t") {;
            return Perlito5::Rul::constant(chr(9))
        }
        return Perlito5::Rul::constant($char)
    }
    sub Perlito5::Rul::SpecialChar::set_captures_to_array {;
        my $self = $_[0]
    }
    package Perlito5::Rul::Block;
    sub Perlito5::Rul::Block::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::Rul::Block::closure {;
        $_[0]->{"closure"}
    }
    sub Perlito5::Rul::Block::emit_perl5 {
        my $self = $_[0];
        "(do { " . ($self->{"closure"}) . "; 1 })"
    }
    sub Perlito5::Rul::Block::set_captures_to_array {;
        my $self = $_[0]
    }
    package Perlito5::Rul::Before;
    sub Perlito5::Rul::Before::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::Rul::Before::rule_exp {;
        $_[0]->{"rule_exp"}
    }
    sub Perlito5::Rul::Before::emit_perl5 {
        my $self = $_[0];
        "(do { " . "my \$tmp = \$MATCH; " . "\$MATCH = { 'from' => \$tmp->{to}, 'to' => \$tmp->{to} }; " . "my \$res = " . $self->{"rule_exp"}->emit_perl5() . "; " . "\$MATCH = \$tmp; " . "\$res ? 1 : 0 " . "})"
    }
    sub Perlito5::Rul::Before::set_captures_to_array {;
        my $self = $_[0]
    }
    package Perlito5::Rul::NotBefore;
    sub Perlito5::Rul::NotBefore::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::Rul::NotBefore::rule_exp {;
        $_[0]->{"rule_exp"}
    }
    sub Perlito5::Rul::NotBefore::emit_perl5 {
        my $self = $_[0];
        "(do { " . "my \$tmp = \$MATCH; " . "\$MATCH = { 'from' => \$tmp->{to}, 'to' => \$tmp->{to} }; " . "my \$res = " . $self->{"rule_exp"}->emit_perl5() . "; " . "\$MATCH = \$tmp; " . "\$res ? 0 : 1 " . "})"
    }
    sub Perlito5::Rul::NotBefore::set_captures_to_array {;
        my $self = $_[0]
    }
    1
}
{
    package main;
    package Perlito5::JSON;
    sub Perlito5::JSON::ast_dumper {
        my $seen = {};
        my $level = '';
        my $pos = "[TODO - recursive structure is not supported]";
        return Perlito5::JSON::_dumper($_[0], $level, $seen, $pos)
    }
    sub Perlito5::JSON::_dumper {
        (my $obj, my $tab, my $seen, my $pos) = @_;
        !defined($obj) && return "null";
        my $ref = ref($obj);
        !$ref && return Perlito5::JSON::escape_string($obj);
        my $as_string = '' . $obj;
        $seen->{$as_string} && return $seen->{$as_string};
        $seen->{$as_string} = $pos;
        my $tab1 = $tab . "  ";
        if ($ref eq "ARRAY") {
            @{$obj} || return "[]";
            my @out;
            for my $i (0 .. $#{$obj}) {
                my $here = $pos . "[" . $i . "]";
                push(@out, $tab1 . Perlito5::JSON::_dumper($obj->[$i], $tab1, $seen, $here))
            }
            return "[
" . join(",
", @out) . "
" . $tab . "]"
        }
        elsif ($ref eq "SCALAR") {;
            return "{ \"_type\": \"SCALAR\", \"value\": " . Perlito5::JSON::_dumper(${$obj}, $tab1, $seen, $pos) . " }"
        }
        elsif ($ref eq "CODE") {;
            return "{ \"_type\": \"CODE\", \"value\": \"DUMMY\" }"
        }
        $ref =~ s/^Perlito5::AST:://;
        my @out;
        $ref ne "HASH" && push(@out, "\"_type\": \"" . $ref . "\"");
        for my $i (sort {;
            $a cmp $b
        } keys(%{$obj})) {
            my $here = $pos . "{" . $i . "}";
            push(@out, $tab1 . ("\"" . $i . "\": ") . Perlito5::JSON::_dumper($obj->{$i}, $tab1, $seen, $here))
        }
        return "{
" . join(",
", @out) . "
" . $tab . "}"
    }
    sub Perlito5::JSON::escape_string {
        my $s = shift;
        my @out;
        $s eq '' && return "\"\"";
        (0 + $s) eq $s && $s =~ m/[0-9]/ && return 0 + $s;
        for my $i (0 .. length($s) - 1) {
            my $c = substr($s, $i, 1);
            if ($c eq "\\" || $c eq "\"") {;
                push(@out, "\\" . $c)
            }
            elsif ($c eq "
") {;
                push(@out, "\\n")
            }
            elsif ($c eq "\x{d}") {;
                push(@out, "\\r")
            }
            elsif ($c eq "\x{9}") {;
                push(@out, "\\t")
            }
            elsif ($c eq "\x{8}") {;
                push(@out, "\\b")
            }
            elsif ($c eq "\x{c}") {;
                push(@out, "\\f")
            }
            elsif ($c le chr(31)) {;
                push(@out, sprintf("\\u%04x", ord($c)))
            }
            else {;
                push(@out, $c)
            }
        }
        return join('', "\"", @out, "\"")
    }
    1
}
{
    package main;
    package Perlito5::AST::Apply;
    {
        sub Perlito5::AST::Apply::_emit_assignment_javascript2 {
            (my $parameters, my $arguments, my $level, my $wantarray) = @_;
            if ($parameters->isa("Perlito5::AST::Apply") && ($parameters->{"code"} eq "circumfix:<( )>")) {
                my $tmp = Perlito5::JavaScript2::get_label();
                my $tmp2 = Perlito5::JavaScript2::get_label();
                return Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, "var " . $tmp . " = " . Perlito5::JavaScript2::to_list([$arguments], $level + 1) . ";", "var " . $tmp2 . " = " . $tmp . ".slice(0);", (map($_->emit_javascript2_set_list($level + 1, $tmp) . ";", @{$parameters->arguments()})), "return " . $tmp2)
            }
            return $parameters->emit_javascript2_set($arguments, $level + 1, $wantarray)
        }
        sub Perlito5::AST::Apply::emit_regex_javascript2 {
            my $op = shift;
            my $var = shift;
            my $regex = shift;
            my $level = shift;
            my $wantarray = shift;
            $regex = Perlito5::Macro::preprocess_regex($regex);
            my $str;
            my $code = $regex->{"code"};
            my $regex_args = $regex->{"arguments"};
            if ($code eq "p5:s") {
                my $replace = $regex_args->[1];
                my $modifier = $regex_args->[2]->{"buf"};
                my $fun;
                if (ref($replace) eq "Perlito5::AST::Block") {
                    $replace = Perlito5::AST::Sub::->new("block", $replace);
                    $fun = $replace->emit_javascript2($level + 2, $wantarray);
                    $modifier =~ s/e//g
                }
                else {;
                    $fun = Perlito5::JavaScript2::emit_function_javascript2($level + 2, $wantarray, $replace)
                }
                $str = Perlito5::JavaScript2::emit_wrap_javascript2($level + 1, $wantarray, "var tmp = p5s(" . $var->emit_javascript2() . ", " . $regex_args->[0]->emit_javascript2() . ", " . $fun . ", " . Perlito5::JavaScript2::escape_string($modifier) . ", " . ($wantarray eq "runtime" ? "p5want" : $wantarray eq "list" ? 1 : 0) . ");", $var->emit_javascript2() . " = tmp[0];", "return tmp[1];")
            }
            elsif ($code eq "p5:m") {;
                $str = "p5m(" . $var->emit_javascript2() . ", " . $regex_args->[0]->emit_javascript2() . ", " . Perlito5::JavaScript2::escape_string($regex_args->[1]->{"buf"}) . ", " . ($wantarray eq "runtime" ? "p5want" : $wantarray eq "list" ? 1 : 0) . ")"
            }
            elsif ($code eq "p5:tr") {;
                $str = Perlito5::JavaScript2::emit_wrap_javascript2($level + 1, $wantarray, "var tmp = p5tr(" . $var->emit_javascript2() . ", " . $regex_args->[0]->emit_javascript2() . ", " . $regex_args->[1]->emit_javascript2() . ", " . Perlito5::JavaScript2::escape_string($regex_args->[2]->{"buf"}) . ", " . ($wantarray eq "runtime" ? "p5want" : $wantarray eq "list" ? 1 : 0) . ");", $var->emit_javascript2() . " = tmp[0];", "return tmp[1];")
            }
            else {;
                die("Error: regex emitter - unknown operator " . $code)
            }
            if ($op eq "=~") {;
                return $str
            }
            if ($op eq "!~") {;
                return "!(" . $str . ")"
            }
            die("Error: regex emitter")
        }
        sub Perlito5::AST::Apply::emit_javascript2_set {
            (my $self, my $arguments, my $level, my $wantarray) = @_;
            my $code = $self->{"code"};
            if ($code eq "prefix:<\$>") {;
                return "p5scalar_deref_set(" . Perlito5::JavaScript2::emit_javascript2_autovivify($self->{"arguments"}->[0], $level + 1, "scalar") . ", " . Perlito5::JavaScript2::to_scalar([$arguments], $level + 1) . ", " . Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME) . ")"
            }
            if ($code eq "prefix:<*>") {;
                return "p5typeglob_deref_set(" . Perlito5::JavaScript2::to_scalar($self->{"arguments"}, $level + 1) . ", " . Perlito5::JavaScript2::to_scalar([$arguments], $level + 1) . ", " . Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME) . ")"
            }
            my $open = $wantarray eq "void" ? '' : "(";
            my $close = $wantarray eq "void" ? '' : ")";
            $open . $self->emit_javascript2($level + 1) . " = " . $arguments->emit_javascript2($level + 1) . $close
        }
        my %emit_js = ("infix:<=~>", sub {
            (my $self, my $level, my $wantarray) = @_;
            Perlito5::AST::Apply::emit_regex_javascript2("=~", $self->{"arguments"}->[0], $self->{"arguments"}->[1], $level, $wantarray)
        }, "infix:<!~>", sub {
            (my $self, my $level, my $wantarray) = @_;
            Perlito5::AST::Apply::emit_regex_javascript2("!~", $self->{"arguments"}->[0], $self->{"arguments"}->[1], $level, $wantarray)
        }, "p5:s", sub {
            (my $self, my $level, my $wantarray) = @_;
            Perlito5::AST::Apply::emit_regex_javascript2("=~", $self->{"arguments"}->[3], $self, $level, $wantarray)
        }, "p5:m", sub {
            (my $self, my $level, my $wantarray) = @_;
            Perlito5::AST::Apply::emit_regex_javascript2("=~", $self->{"arguments"}->[2], $self, $level, $wantarray)
        }, "p5:tr", sub {
            (my $self, my $level, my $wantarray) = @_;
            Perlito5::AST::Apply::emit_regex_javascript2("=~", $self->{"arguments"}->[3], $self, $level, $wantarray)
        }, "p5:qr", sub {
            (my $self, my $level, my $wantarray) = @_;
            "p5qr(" . Perlito5::JavaScript2::to_str($self->{"arguments"}->[0]) . ", " . Perlito5::JavaScript2::to_str($self->{"arguments"}->[1]) . ")"
        }, "__PACKAGE__", sub {
            my $self = $_[0];
            Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME)
        }, "__SUB__", sub {
            my $self = $_[0];
            $Perlito5::AST::Sub::SUB_REF // "__SUB__"
        }, "wantarray", sub {
            my $self = $_[0];
            "p5want"
        }, "package", sub {
            my $self = $_[0];
            "p5make_package(" . Perlito5::JavaScript2::escape_string($self->{"namespace"}) . ")"
        }, "bless", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $class;
            if ($self->{"arguments"}->[1]) {;
                $class = Perlito5::JavaScript2::to_str($self->{"arguments"}->[1])
            }
            else {;
                $class = Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME)
            }
            "CORE.bless(p5list_to_a([" . $self->{"arguments"}->[0]->emit_javascript2($level, "scalar") . ", " . $class . "]))"
        }, "infix:<~~>", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg0 = $self->{"arguments"}->[0];
            my $arg1 = $self->{"arguments"}->[1];
            "p5smrt_scalar(" . $arg0->emit_javascript2($level, "scalar") . ", " . $arg1->emit_javascript2($level, "scalar") . ")"
        }, "infix:<&&>", sub {
            (my $self, my $level, my $wantarray) = @_;
            "p5and(" . $self->{"arguments"}->[0]->emit_javascript2($level, "scalar") . ", " . Perlito5::JavaScript2::emit_function_javascript2($level, $wantarray, $self->{"arguments"}->[1]) . ")"
        }, "infix:<and>", sub {
            (my $self, my $level, my $wantarray) = @_;
            "p5and(" . $self->{"arguments"}->[0]->emit_javascript2($level, "scalar") . ", " . Perlito5::JavaScript2::emit_function_javascript2($level, $wantarray, $self->{"arguments"}->[1]) . ")"
        }, "infix:<||>", sub {
            (my $self, my $level, my $wantarray) = @_;
            "p5or(" . $self->{"arguments"}->[0]->emit_javascript2($level, "scalar") . ", " . Perlito5::JavaScript2::emit_function_javascript2($level, $wantarray, $self->{"arguments"}->[1]) . ")"
        }, "infix:<or>", sub {
            (my $self, my $level, my $wantarray) = @_;
            "p5or(" . $self->{"arguments"}->[0]->emit_javascript2($level, "scalar") . ", " . Perlito5::JavaScript2::emit_function_javascript2($level, $wantarray, $self->{"arguments"}->[1]) . ")"
        }, "infix:<xor>", sub {
            (my $self, my $level, my $wantarray) = @_;
            "p5xor(" . $self->{"arguments"}->[0]->emit_javascript2($level, "scalar") . ", " . Perlito5::JavaScript2::emit_function_javascript2($level, $wantarray, $self->{"arguments"}->[1]) . ")"
        }, "infix:<=>>", sub {
            (my $self, my $level, my $wantarray) = @_;
            return "p5list_to_a([" . Perlito5::AST::Lookup::->autoquote($self->{"arguments"}->[0])->emit_javascript2($level) . ", " . $self->{"arguments"}->[1]->emit_javascript2($level) . "])"
        }, "infix:<cmp>", sub {
            my $self = $_[0];
            "p5cmp(" . join(", ", map(Perlito5::JavaScript2::to_str($_), @{$self->{"arguments"}})) . ")"
        }, "infix:<<=>>", sub {
            my $self = $_[0];
            "p5cmp(" . join(", ", map(Perlito5::JavaScript2::to_num($_), @{$self->{"arguments"}})) . ")"
        }, "infix:<**>", sub {
            my $self = $_[0];
            "Math.pow(" . join(", ", map(Perlito5::JavaScript2::to_num($_), @{$self->{"arguments"}})) . ")"
        }, "infix:<<<>", sub {
            my $self = $_[0];
            "p5shift_left(" . join(", ", map(Perlito5::JavaScript2::to_num($_), @{$self->{"arguments"}})) . ")"
        }, "infix:<%>", sub {
            my $self = $_[0];
            "p5modulo(" . join(", ", map(Perlito5::JavaScript2::to_num($_), @{$self->{"arguments"}})) . ")"
        }, "prefix:<!>", sub {
            my $self = shift;
            my $level = shift;
            "!( " . Perlito5::JavaScript2::to_bool($self->{"arguments"}->[0], $level) . ")"
        }, "prefix:<not>", sub {
            my $self = shift;
            my $level = shift;
            my $arg = pop(@{$self->{"arguments"}});
            if (!$arg) {;
                return "true"
            }
            "!( " . Perlito5::JavaScript2::to_bool($arg, $level) . ")"
        }, "prefix:<~>", sub {
            my $self = $_[0];
            "p5complement( " . Perlito5::JavaScript2::to_num($self->{"arguments"}->[0]) . ")"
        }, "prefix:<->", sub {
            (my $self, my $level, my $wantarray) = @_;
            "p5negative( " . $self->{"arguments"}->[0]->emit_javascript2($level, "scalar") . ")"
        }, "prefix:<+>", sub {
            (my $self, my $level, my $wantarray) = @_;
            "(" . $self->{"arguments"}->[0]->emit_javascript2($level, $wantarray) . ")"
        }, "require", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ($arg->{"is_version_string"}) {;
                return "p5pkg[\"Perlito5\"][\"test_perl_version\"]([" . Perlito5::JavaScript2::to_str($self->{"arguments"}->[0]) . "], " . Perlito5::JavaScript2::to_context($wantarray) . ")"
            }
            "p5pkg[\"Perlito5::Grammar::Use\"][\"require\"]([" . Perlito5::JavaScript2::to_str($self->{"arguments"}->[0]) . ", " . ($self->{"arguments"}->[0]->{"bareword"} ? 1 : 0) . "], " . Perlito5::JavaScript2::to_context($wantarray) . ")"
        }, "select", sub {
            (my $self, my $level, my $wantarray) = @_;
            "p5pkg[\"CORE\"][\"select\"]([" . ($self->{"arguments"}->[0]->{"bareword"} ? Perlito5::JavaScript2::to_str($self->{"arguments"}->[0]) : $self->{"arguments"}->[0]->emit_javascript2($level, "scalar")) . "])"
        }, "prefix:<\$>", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0];
            return "p5scalar_deref(" . $arg->emit_javascript2($level) . ", " . Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME) . ", " . "\"\"" . ")"
        }, "prefix:<\@>", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0];
            my $s = "p5array_deref(" . Perlito5::JavaScript2::emit_javascript2_autovivify($arg, $level, "array") . ", " . Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME) . ")";
            return $wantarray eq "scalar" ? "p5num(" . $s . ")" : $s
        }, "prefix:<\$#>", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0];
            return "(p5array_deref(" . Perlito5::JavaScript2::emit_javascript2_autovivify($arg, $level, "array") . ", " . Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME) . ").length - 1)"
        }, "prefix:<%>", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0];
            return "p5hash_deref(" . Perlito5::JavaScript2::emit_javascript2_autovivify($arg, $level, "hash") . ", " . Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME) . ")"
        }, "prefix:<&>", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0];
            "p5cget_by_name(" . Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME) . ", " . $arg->emit_javascript2($level) . ")([])"
        }, "circumfix:<[ ]>", sub {
            (my $self, my $level, my $wantarray) = @_;
            "(new p5ArrayRef(" . Perlito5::JavaScript2::to_list($self->{"arguments"}) . "))"
        }, "circumfix:<{ }>", sub {
            (my $self, my $level, my $wantarray) = @_;
            "(new p5HashRef(" . Perlito5::JavaScript2::to_list($self->{"arguments"}, $level, "hash") . "))"
        }, "prefix:<\\>", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ($arg->isa("Perlito5::AST::Apply")) {
                if ($arg->{"code"} eq "prefix:<\@>") {;
                    return "(new p5ArrayRef(" . $arg->emit_javascript2($level) . "))"
                }
                if ($arg->{"code"} eq "prefix:<%>") {;
                    return "(new p5HashRef(" . $arg->emit_javascript2($level) . "))"
                }
                if ($arg->{"code"} eq "circumfix:<( )>") {;
                    return "p5_list_of_refs(" . Perlito5::JavaScript2::to_list($arg->{"arguments"}) . ")"
                }
                if ($arg->{"code"} eq "prefix:<&>") {;
                    return "p5code_lookup_by_name(" . Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME) . ", " . $arg->{"arguments"}->[0]->emit_javascript2($level) . ")"
                }
            }
            if ($arg->isa("Perlito5::AST::Var")) {
                if ($arg->{"sigil"} eq "\@") {;
                    return "(new p5ArrayRef(" . $arg->emit_javascript2($level) . "))"
                }
                if ($arg->{"sigil"} eq "%") {;
                    return "(new p5HashRef(" . $arg->emit_javascript2($level) . "))"
                }
                if ($arg->{"sigil"} eq "*") {;
                    return "(new p5GlobRef(" . $arg->emit_javascript2($level) . "))"
                }
                if ($arg->{"sigil"} eq "&") {
                    if ($arg->{"namespace"}) {;
                        return "p5pkg[" . Perlito5::JavaScript2::escape_string($arg->{"namespace"}) . "]." . ($arg->{"name"})
                    }
                    else {;
                        return Perlito5::JavaScript2::pkg() . "." . ($arg->{"name"})
                    }
                }
            }
            return "(new p5ScalarRef(" . $arg->emit_javascript2($level) . "))"
        }, "postfix:<++>", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ($arg->isa("Perlito5::AST::Index") || $arg->isa("Perlito5::AST::Lookup") || $arg->isa("Perlito5::AST::Call")) {;
                return $arg->emit_javascript2($level + 1, 0, "p5postincr")
            }
            if ($arg->isa("Perlito5::AST::Var") && $arg->{"sigil"} eq "\$") {
                my $tmp = Perlito5::JavaScript2::get_label();
                return Perlito5::JavaScript2::emit_wrap_javascript2($level, "scalar", "var " . $tmp . " = " . $arg->emit_javascript2($level) . ";", $arg->emit_javascript2($level) . " = p5incr_(" . $tmp . ");", "return " . $tmp)
            }
            "(" . join(" ", map($_->emit_javascript2(), @{$self->{"arguments"}})) . ")++"
        }, "postfix:<-->", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ($arg->isa("Perlito5::AST::Index") || $arg->isa("Perlito5::AST::Lookup") || $arg->isa("Perlito5::AST::Call")) {;
                return $arg->emit_javascript2($level + 1, 0, "p5postdecr")
            }
            if ($arg->isa("Perlito5::AST::Var") && $arg->{"sigil"} eq "\$") {
                my $tmp = Perlito5::JavaScript2::get_label();
                return Perlito5::JavaScript2::emit_wrap_javascript2($level, "scalar", "var " . $tmp . " = " . $arg->emit_javascript2($level) . ";", $arg->emit_javascript2($level) . " = p5decr_(" . $tmp . ");", "return " . $tmp)
            }
            "(" . join(" ", map($_->emit_javascript2(), @{$self->{"arguments"}})) . ")--"
        }, "prefix:<++>", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ($arg->isa("Perlito5::AST::Index") || $arg->isa("Perlito5::AST::Lookup") || $arg->isa("Perlito5::AST::Call")) {;
                return $arg->emit_javascript2($level + 1, 0, "p5incr")
            }
            if ($arg->isa("Perlito5::AST::Var") && $arg->{"sigil"} eq "\$") {
                my $tmp = Perlito5::JavaScript2::get_label();
                return Perlito5::JavaScript2::emit_wrap_javascript2($level, "scalar", "var " . $tmp . " = " . $arg->emit_javascript2($level) . ";", $arg->emit_javascript2($level) . " = p5incr_(" . $tmp . ");", "return " . $arg->emit_javascript2($level + 1))
            }
            "++(" . join(" ", map($_->emit_javascript2(), @{$self->{"arguments"}})) . ")"
        }, "prefix:<-->", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ($arg->isa("Perlito5::AST::Index") || $arg->isa("Perlito5::AST::Lookup") || $arg->isa("Perlito5::AST::Call")) {;
                return $arg->emit_javascript2($level + 1, 0, "p5decr")
            }
            if ($arg->isa("Perlito5::AST::Var") && $arg->{"sigil"} eq "\$") {
                my $tmp = Perlito5::JavaScript2::get_label();
                return Perlito5::JavaScript2::emit_wrap_javascript2($level, "scalar", "var " . $tmp . " = " . $arg->emit_javascript2($level) . ";", $arg->emit_javascript2($level) . " = p5decr_(" . $tmp . ");", "return " . $arg->emit_javascript2($level + 1))
            }
            "--(" . join(" ", map($_->emit_javascript2(), @{$self->{"arguments"}})) . ")"
        }, "infix:<x>", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0];
            if (ref($arg) eq "Perlito5::AST::Apply" && ($arg->{"code"} eq "circumfix:<( )>" || $arg->{"code"} eq "list:<,>")) {;
                return "p5list_replicate(" . $self->{"arguments"}->[0]->emit_javascript2($level, "list") . "," . Perlito5::JavaScript2::to_num($self->{"arguments"}->[1], $level) . ", " . ($wantarray eq "runtime" ? "p5want" : $wantarray eq "list" ? 1 : 0) . ")"
            }
            "p5str_replicate(" . Perlito5::JavaScript2::to_str($self->{"arguments"}->[0], $level) . "," . Perlito5::JavaScript2::to_num($self->{"arguments"}->[1], $level) . ")"
        }, "list:<.>", sub {
            (my $self, my $level, my $wantarray) = @_;
            "(" . join(" + ", map(Perlito5::JavaScript2::to_str($_), @{$self->{"arguments"}})) . ")"
        }, "list:<,>", sub {
            (my $self, my $level, my $wantarray) = @_;
            Perlito5::JavaScript2::to_list($self->{"arguments"})
        }, "infix:<..>", sub {
            (my $self, my $level, my $wantarray) = @_;
            return "p5range(" . $self->{"arguments"}->[0]->emit_javascript2($level) . ", " . $self->{"arguments"}->[1]->emit_javascript2($level) . ", " . ($wantarray eq "runtime" ? "p5want" : $wantarray eq "list" ? 1 : 0) . ", " . "\"" . Perlito5::JavaScript2::get_label() . "\"" . ", " . 0 . ")"
        }, "infix:<...>", sub {
            (my $self, my $level, my $wantarray) = @_;
            return "p5range(" . $self->{"arguments"}->[0]->emit_javascript2($level) . ", " . $self->{"arguments"}->[1]->emit_javascript2($level) . ", " . ($wantarray eq "runtime" ? "p5want" : $wantarray eq "list" ? 1 : 0) . ", " . "\"" . Perlito5::JavaScript2::get_label() . "\"" . ", " . 1 . ")"
        }, "delete", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ($arg->isa("Perlito5::AST::Lookup")) {
                my $v = $arg->obj();
                my $v_js = $v->emit_javascript2();
                my $key_js = $arg->autoquote($arg->{"index_exp"})->emit_javascript2($level);
                my $suffix = (($v->isa("Perlito5::AST::Var") && $v->{"sigil"} eq "\$") ? '' : "._hash_");
                return "((function (v,k) { var ret = v[k]; delete (v[k]); return ret;})(" . $v_js . $suffix . "," . $key_js . "))"
            }
            if ($arg->isa("Perlito5::AST::Index")) {
                my $v = $arg->obj();
                if ($v->isa("Perlito5::AST::Var") && $v->{"sigil"} eq "\$") {;
                    return "(delete " . $v->emit_javascript2() . "[" . $arg->{"index_exp"}->emit_javascript2($level) . "])"
                }
                return "(delete " . $v->emit_javascript2() . "._array_[" . $arg->{"index_exp"}->emit_javascript2($level) . "])"
            }
            if ($arg->isa("Perlito5::AST::Call")) {
                if ($arg->method() eq "postcircumfix:<{ }>") {;
                    return "(delete " . $arg->invocant()->emit_javascript2() . "._hash_[" . Perlito5::AST::Lookup::->autoquote($arg->{"arguments"})->emit_javascript2($level) . "])"
                }
                if ($arg->method() eq "postcircumfix:<[ ]>") {;
                    return "(delete " . $arg->invocant()->emit_javascript2() . "._array_[" . $arg->{"arguments"}->emit_javascript2($level) . "])"
                }
            }
            if ($arg->isa("Perlito5::AST::Var") && $arg->{"sigil"} eq "&") {;
                die("TODO delete &code")
            }
            if ($arg->isa("Perlito5::AST::Apply") && $arg->{"code"} eq "prefix:<&>") {;
                die("TODO delete &\$code")
            }
        }, "scalar", sub {
            (my $self, my $level, my $wantarray) = @_;
            Perlito5::JavaScript2::to_scalar($self->{"arguments"}, $level + 1)
        }, "ternary:<? :>", sub {
            (my $self, my $level, my $wantarray) = @_;
            "( " . Perlito5::JavaScript2::to_bool($self->{"arguments"}->[0]) . " ? " . ($self->{"arguments"}->[1])->emit_javascript2($level, $wantarray) . " : " . ($self->{"arguments"}->[2])->emit_javascript2($level, $wantarray) . ")"
        }, "circumfix:<( )>", sub {
            (my $self, my $level, my $wantarray) = @_;
            "p5context(" . "[" . join(", ", map($_->emit_javascript2($level, $wantarray), @{$self->{"arguments"}})) . "], " . ($wantarray eq "runtime" ? "p5want" : $wantarray eq "list" ? 1 : 0) . ")"
        }, "infix:<=>", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $parameters = $self->{"arguments"}->[0];
            my $arguments = $self->{"arguments"}->[1];
            return Perlito5::AST::Apply::_emit_assignment_javascript2($parameters, $arguments, $level, $wantarray)
        }, "break", sub {
            (my $self, my $level, my $wantarray) = @_;
            $Perlito5::THROW = 1;
            Perlito5::JavaScript2::emit_wrap_statement_javascript2($level, $wantarray, "throw(new p5_error(\"break\", \"\"))")
        }, "next", sub {
            (my $self, my $level, my $wantarray) = @_;
            $Perlito5::THROW = 1;
            my $label = '';
            @{$self->{"arguments"}} && ($label = $self->{"arguments"}->[0]->{"code"} || '');
            Perlito5::JavaScript2::emit_wrap_statement_javascript2($level, $wantarray, "throw(new p5_error(\"next\", " . Perlito5::JavaScript2::escape_string($label) . "))")
        }, "last", sub {
            (my $self, my $level, my $wantarray) = @_;
            $Perlito5::THROW = 1;
            my $label = '';
            @{$self->{"arguments"}} && ($label = $self->{"arguments"}->[0]->{"code"} || '');
            Perlito5::JavaScript2::emit_wrap_statement_javascript2($level, $wantarray, "throw(new p5_error(\"last\", " . Perlito5::JavaScript2::escape_string($label) . "))")
        }, "redo", sub {
            (my $self, my $level, my $wantarray) = @_;
            $Perlito5::THROW = 1;
            my $label = '';
            @{$self->{"arguments"}} && ($label = $self->{"arguments"}->[0]->{"code"} || '');
            Perlito5::JavaScript2::emit_wrap_statement_javascript2($level, $wantarray, "throw(new p5_error(\"redo\", " . Perlito5::JavaScript2::escape_string($label) . "))")
        }, "return", sub {
            (my $self, my $level, my $wantarray) = @_;
            $Perlito5::THROW = 1;
            Perlito5::JavaScript2::emit_wrap_statement_javascript2($level, $wantarray, "throw(" . Perlito5::JavaScript2::to_runtime_context($self->{"arguments"}, $level + 1) . ")")
        }, "goto", sub {
            (my $self, my $level, my $wantarray) = @_;
            $Perlito5::THROW = 1;
            Perlito5::JavaScript2::emit_wrap_statement_javascript2($level, $wantarray, "throw(" . $self->{"arguments"}->[0]->emit_javascript2($level) . ")")
        }, "do", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ($arg->isa("Perlito5::AST::Block")) {
                my $block = $arg->{"stmts"};
                return Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, (Perlito5::JavaScript2::LexicalBlock::->new("block", $block))->emit_javascript2($level + 1, $wantarray))
            }
            my $ast = Perlito5::AST::Apply::->new("code", "eval", "namespace", '', "arguments", [Perlito5::AST::Apply::->new("code", "slurp_file", "namespace", "Perlito5::Grammar::Use", "arguments", $self->{"arguments"})], "_scope", Perlito5::Grammar::Scope::->new_base_scope(), "_hash_hints", {}, "_scalar_hints", 0);
            my $js = $ast->emit_javascript2($level, $wantarray);
            return $js
        }, "eval", sub {
            (my $self, my $level, my $wantarray) = @_;
            $Perlito5::THROW = 1;
            my $arg = $self->{"arguments"}->[0];
            my $eval;
            if ($arg->isa("Perlito5::AST::Block")) {;
                $eval = Perlito5::AST::Apply::->new("code", "do", "arguments", [$arg])->emit_javascript2($level + 1, $wantarray)
            }
            else {
                my %vars;
                for my $var (@{$self->{"_scope"}->{"block"}}, @Perlito5::CAPTURES) {;
                    if ($var->{"_decl"} && $var->{"_decl"} ne "global") {;
                        $vars{$var->{"_id"}} = $var
                    }
                }
                my $scope = Perlito5::DumpToAST::dump_to_ast({"block" => [values(%vars)], }, {}, "s");
                my $scope_js = "(new p5ArrayRef(" . Perlito5::JavaScript2::to_list([$scope]) . "))";
                my $hash_hints = Perlito5::DumpToAST::dump_to_ast($self->{"_hash_hints"}, {}, "s");
                my $hash_hints_js = $hash_hints->emit_javascript2($level);
                $eval = "eval(p5pkg[\"Perlito5::JavaScript2::Runtime\"].perl5_to_js([" . Perlito5::JavaScript2::to_str($arg) . ", " . Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME) . ", " . Perlito5::JavaScript2::escape_string($wantarray) . ", " . (0 + ($self->{"_scalar_hints"})) . ", " . $hash_hints_js . ", " . $scope_js . "]))"
            }
            my $context = Perlito5::JavaScript2::to_context($wantarray);
            Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, ($context eq "p5want" ? () : "var p5want = " . $context . ";"), "var r;", "p5pkg[\"main\"][\"v_\@\"] = \"\";", "try {", ["r = " . $eval . ''], "}", "catch(err) {", ["if (err instanceof p5_error && (err.type == 'last' || err.type == 'redo' || err.type == 'next')) {", ["throw(err)"], "}", "else if ( err instanceof p5_error || err instanceof Error ) {", ["p5pkg[\"main\"][\"v_\@\"] = err;", "if (p5str(p5pkg[\"main\"][\"v_\@\"]).substr(-1, 1) != \"\\n\") {", ["try {" . '', ["p5pkg[\"main\"][\"v_\@\"] = p5pkg[\"main\"][\"v_\@\"] + \"\\n\" + err.stack + \"\\n\";"], "}", "catch(err) { }"], "}"], "}", "else {", ["return(err);"], "}"], "}", "return r;")
        }, "substr", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $length = $self->{"arguments"}->[2];
            if ($length && $length->isa("Perlito5::AST::Int") && $length->{"int"} > 0) {;
                return Perlito5::JavaScript2::to_str($self->{"arguments"}->[0]) . ".substr(" . Perlito5::JavaScript2::to_num($self->{"arguments"}->[1]) . ", " . Perlito5::JavaScript2::to_num($self->{"arguments"}->[2]) . ")"
            }
            my $arg_list = Perlito5::JavaScript2::to_list_preprocess($self->{"arguments"});
            my $arg_code = Perlito5::JavaScript2::to_list($arg_list);
            return "CORE.substr(" . $arg_code . ", " . Perlito5::JavaScript2::to_context($wantarray) . ")"
        }, "undef", sub {
            (my $self, my $level, my $wantarray) = @_;
            if ($self->{"arguments"} && @{$self->{"arguments"}}) {
                my $arg = $self->{"arguments"}->[0];
                if (ref($arg) eq "Perlito5::AST::Var" && $arg->{"sigil"} eq "&") {;
                    return "(delete p5pkg[" . Perlito5::JavaScript2::escape_string(($arg->{"namespace"} || $Perlito5::PKG_NAME)) . "][" . Perlito5::JavaScript2::escape_string($arg->{"name"}) . "])"
                }
                return "(" . Perlito5::AST::Apply::_emit_assignment_javascript2($arg, Perlito5::AST::Apply::->new("arguments", [], "bareword", 1, "code", "undef"), $level + 1, $wantarray) . ")"
            }
            return "null"
        }, "defined", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0];
            my $invocant;
            if (ref($arg) eq "Perlito5::AST::Apply" && $arg->{"code"} eq "prefix:<&>") {
                my $arg2 = $arg->{"arguments"}->[0];
                $invocant = "p5code_lookup_by_name(" . Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME) . ", " . $arg2->emit_javascript2($level) . ")"
            }
            elsif (ref($arg) eq "Perlito5::AST::Var" && $arg->{"sigil"} eq "&") {;
                $invocant = "p5pkg[" . Perlito5::JavaScript2::escape_string(($arg->{"namespace"} || $Perlito5::PKG_NAME)) . "][" . Perlito5::JavaScript2::escape_string($arg->{"name"}) . "]"
            }
            else {;
                $invocant = $arg->emit_javascript2($level, "scalar")
            }
            "(" . $invocant . " != null)"
        }, "shift", sub {
            (my $self, my $level, my $wantarray) = @_;
            if ($self->{"arguments"} && @{$self->{"arguments"}}) {;
                return $self->{"arguments"}->[0]->emit_javascript2($level) . ".shift()"
            }
            if ($Perlito5::JavaScript2::is_inside_subroutine) {;
                return "List__.shift()"
            }
            return "p5pkg.main.List_ARGV.shift()"
        }, "pop", sub {
            (my $self, my $level, my $wantarray) = @_;
            if ($self->{"arguments"} && @{$self->{"arguments"}}) {;
                return $self->{"arguments"}->[0]->emit_javascript2($level) . ".pop()"
            }
            if ($Perlito5::JavaScript2::is_inside_subroutine) {;
                return "List__.pop()"
            }
            return "p5pkg.main.List_ARGV.pop()"
        }, "unshift", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @arguments = @{$self->{"arguments"}};
            my $v = shift(@arguments);
            return $v->emit_javascript2($level) . ".p5unshift(" . Perlito5::JavaScript2::to_list(\@arguments) . ")"
        }, "push", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @arguments = @{$self->{"arguments"}};
            my $v = shift(@arguments);
            return $v->emit_javascript2($level) . ".p5push(" . Perlito5::JavaScript2::to_list(\@arguments) . ")"
        }, "tie", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @arguments = @{$self->{"arguments"}};
            my $v = shift(@arguments);
            my $meth;
            if ($v->isa("Perlito5::AST::Var") && $v->{"sigil"} eq "%") {;
                $meth = "hash"
            }
            elsif ($v->isa("Perlito5::AST::Var") && $v->{"sigil"} eq "\@") {;
                $meth = "array"
            }
            elsif ($v->isa("Perlito5::AST::Var") && $v->{"sigil"} eq "\$") {;
                $meth = "scalar"
            }
            else {;
                die("tie '", ref($v), "' not implemented")
            }
            return "p5tie_" . $meth . "(" . $v->emit_javascript2($level) . ", " . Perlito5::JavaScript2::to_list(\@arguments) . ")"
        }, "untie", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @arguments = @{$self->{"arguments"}};
            my $v = shift(@arguments);
            my $meth;
            if ($v->isa("Perlito5::AST::Var") && $v->{"sigil"} eq "%") {;
                $meth = "hash"
            }
            elsif ($v->isa("Perlito5::AST::Var") && $v->{"sigil"} eq "\@") {;
                $meth = "array"
            }
            elsif ($v->isa("Perlito5::AST::Var") && $v->{"sigil"} eq "\$") {;
                $meth = "scalar"
            }
            else {;
                die("tie '", ref($v), "' not implemented")
            }
            return "p5untie_" . $meth . "(" . $v->emit_javascript2($level) . ")"
        }, "print", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun;
            if ($self->{"special_arg"}) {;
                $fun = $self->{"special_arg"}->emit_javascript2($level)
            }
            else {;
                $fun = "\"STDOUT\""
            }
            my $list = Perlito5::JavaScript2::to_list(\@in, $level);
            "p5pkg[\"Perlito5::IO\"].print(" . $fun . ", " . $list . ")"
        }, "say", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun;
            if ($self->{"special_arg"}) {;
                $fun = $self->{"special_arg"}->emit_javascript2($level)
            }
            else {;
                $fun = "\"STDOUT\""
            }
            my $list = Perlito5::JavaScript2::to_list(\@in, $level);
            "p5pkg[\"Perlito5::IO\"].say(" . $fun . ", " . $list . ")"
        }, "printf", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun;
            if ($self->{"special_arg"}) {;
                $fun = $self->{"special_arg"}->emit_javascript2($level)
            }
            else {;
                $fun = "\"STDOUT\""
            }
            my $list = Perlito5::JavaScript2::to_list(\@in, $level);
            "p5pkg[\"Perlito5::IO\"].printf(" . $fun . ", " . $list . ")"
        }, "close", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun = shift(@in);
            "p5pkg[\"Perlito5::IO\"].close(" . $fun->emit_javascript2($level) . ", [])"
        }, "open", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun = shift(@in);
            if (ref($fun) ne "Perlito5::AST::Apply") {;
                return Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, $fun->emit_javascript2($level) . " = CORE.bless([ {file_handle : {id : null}}, \"GLOB\" ]);", "return CORE.open(" . Perlito5::JavaScript2::to_list($self->{"arguments"}, $level) . ")")
            }
            else {;
                return "CORE.open(" . Perlito5::JavaScript2::to_list($self->{"arguments"}, $level) . ")"
            }
        }, "chomp", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $v = $self->{"arguments"}->[0];
            return Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, "var r = p5chomp(" . $v->emit_javascript2($level) . ");", $v->emit_javascript2($level) . " = r[1];", "return r[0]")
        }, "chop", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $v = $self->{"arguments"}->[0];
            return Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, "var r = p5chop(" . $v->emit_javascript2($level) . ");", $v->emit_javascript2($level) . " = r[1];", "return r[0]")
        }, "read", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun = shift(@in);
            my $scalar = shift(@in);
            my $length = shift(@in);
            return Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, "var r = p5pkg[\"Perlito5::IO\"].read(" . $fun->emit_javascript2($level) . ", [" . $length->emit_javascript2($level) . "]);", $scalar->emit_javascript2($level) . " = r[1];", "return r[0]")
        }, "readline", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun = shift(@in) || bless({"arguments" => [], "bareword" => 1, "code" => "ARGV", "namespace" => '', }, "Perlito5::AST::Apply");
            return "CORE.readline([" . $fun->emit_javascript2($level) . "], " . Perlito5::JavaScript2::to_context($wantarray) . ")"
        }, "map", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun;
            if ($self->{"special_arg"}) {;
                $fun = $self->{"special_arg"}
            }
            else {;
                $fun = shift(@in)
            }
            my $list = Perlito5::JavaScript2::to_list(\@in, $level);
            if (ref($fun) eq "Perlito5::AST::Block") {;
                $fun = $fun->{"stmts"}
            }
            else {;
                $fun = [$fun]
            }
            "p5map(" . Perlito5::JavaScript2::pkg() . ", " . "function (p5want) {" . "
" . Perlito5::JavaScript2::tab($level + 1) . (Perlito5::JavaScript2::LexicalBlock::->new("block", $fun))->emit_javascript2($level + 1, $wantarray) . "
" . Perlito5::JavaScript2::tab($level) . "}, " . $list . ")"
        }, "grep", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun;
            if ($self->{"special_arg"}) {;
                $fun = $self->{"special_arg"}
            }
            else {;
                $fun = shift(@in)
            }
            my $list = Perlito5::JavaScript2::to_list(\@in, $level);
            if (ref($fun) eq "Perlito5::AST::Block") {;
                $fun = $fun->{"stmts"}
            }
            else {;
                $fun = [$fun]
            }
            "p5grep(" . Perlito5::JavaScript2::pkg() . ", " . "function (p5want) {" . "
" . Perlito5::JavaScript2::tab($level + 1) . (Perlito5::JavaScript2::LexicalBlock::->new("block", $fun))->emit_javascript2($level + 1, $wantarray) . "
" . Perlito5::JavaScript2::tab($level) . "}, " . $list . ")"
        }, "sort", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun;
            my $list;
            if ($self->{"special_arg"}) {;
                $fun = $self->{"special_arg"}
            }
            elsif (ref($in[0]) eq "Perlito5::AST::Block") {;
                $fun = shift(@in)
            }
            if (ref($fun) eq "Perlito5::AST::Block") {;
                $fun = "function (p5want) {" . "
" . Perlito5::JavaScript2::tab($level + 1) . (Perlito5::JavaScript2::LexicalBlock::->new("block", $fun->{"stmts"}))->emit_javascript2($level + 1, $wantarray) . "
" . Perlito5::JavaScript2::tab($level) . "}"
            }
            else {;
                $fun = "null"
            }
            $list = Perlito5::JavaScript2::to_list(\@in, $level);
            "p5sort(" . Perlito5::JavaScript2::pkg() . ", " . $fun . ", " . $list . ")"
        }, "infix:<//>", sub {
            (my $self, my $level, my $wantarray) = @_;
            "p5defined_or" . "(" . $self->{"arguments"}->[0]->emit_javascript2($level, "scalar") . ", " . Perlito5::JavaScript2::emit_function_javascript2($level, $wantarray, $self->{"arguments"}->[1]) . ")"
        }, "exists", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ($arg->isa("Perlito5::AST::Lookup")) {
                my $v = $arg->obj();
                if ($v->isa("Perlito5::AST::Var") && $v->{"sigil"} eq "\$") {
                    $v->{"sigil"} = "%";
                    return "(" . $v->emit_javascript2() . ").hasOwnProperty(" . $arg->autoquote($arg->{"index_exp"})->emit_javascript2($level) . ")"
                }
                return "(" . $v->emit_javascript2() . ")._hash_.hasOwnProperty(" . $arg->autoquote($arg->{"index_exp"})->emit_javascript2($level) . ")"
            }
            if ($arg->isa("Perlito5::AST::Index")) {
                my $v = $arg->obj();
                if ($v->isa("Perlito5::AST::Var") && $v->{"sigil"} eq "\$") {;
                    return "(" . $v->emit_javascript2() . ").hasOwnProperty(" . $arg->{"index_exp"}->emit_javascript2($level) . ")"
                }
                return "(" . $v->emit_javascript2() . ")._array_.hasOwnProperty(" . $arg->{"index_exp"}->emit_javascript2($level) . ")"
            }
            if ($arg->isa("Perlito5::AST::Call")) {
                if ($arg->method() eq "postcircumfix:<{ }>") {;
                    return Perlito5::JavaScript2::emit_javascript2_autovivify($arg->invocant(), $level, "hash") . "._hash_.hasOwnProperty(" . Perlito5::AST::Lookup::->autoquote($arg->{"arguments"})->emit_javascript2($level) . ")"
                }
                if ($arg->method() eq "postcircumfix:<[ ]>") {;
                    return Perlito5::JavaScript2::emit_javascript2_autovivify($arg->invocant(), $level, "array") . "._array_.hasOwnProperty(" . $arg->{"arguments"}->emit_javascript2($level) . ")"
                }
            }
            if ($arg->isa("Perlito5::AST::Var") && $arg->{"sigil"} eq "&") {
                my $name = $arg->{"name"};
                my $namespace = $arg->{"namespace"} || $Perlito5::PKG_NAME;
                return "p5pkg[" . Perlito5::JavaScript2::escape_string($namespace) . "].hasOwnProperty(" . Perlito5::JavaScript2::escape_string($name) . ")"
            }
            if ($arg->isa("Perlito5::AST::Apply") && $arg->{"code"} eq "prefix:<&>") {
                my $arg2 = $arg->{"arguments"}->[0];
                return "p5sub_exists(" . Perlito5::JavaScript2::to_str($arg2) . ", " . Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME) . ")"
            }
        }, "prototype", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0];
            return "p5sub_prototype(" . $arg->emit_javascript2() . ", " . Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME) . ")"
        }, "split", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @js;
            my $arg = $self->{"arguments"}->[0];
            if ($arg && $arg->isa("Perlito5::AST::Apply") && $arg->{"code"} eq "p5:m") {
                push(@js, "new RegExp(" . $arg->{"arguments"}->[0]->emit_javascript2() . ", " . Perlito5::JavaScript2::escape_string($arg->{"arguments"}->[1]->{"buf"}) . ")");
                shift(@{$self->{"arguments"}})
            }
            return "CORE.split(" . "[" . join(", ", @js, map($_->emit_javascript2(), @{$self->{"arguments"}})) . "], " . Perlito5::JavaScript2::to_context($wantarray) . ")"
        });
        sub Perlito5::AST::Apply::emit_javascript2 {
            (my $self, my $level, my $wantarray) = @_;
            my $apply = $self->op_assign();
            if ($apply) {;
                return $apply->emit_javascript2($level)
            }
            my $apply = $self->op_auto();
            if ($apply) {;
                return $apply->emit_javascript2($level)
            }
            my $code = $self->{"code"};
            if (ref($code) ne '') {
                my @args = ();
                push(@args, $_->emit_javascript2())
                    for @{$self->{"arguments"}};
                if (ref($code) eq "Perlito5::AST::Apply" && $code->{"code"} eq "prefix:<&>") {
                    my $arg = $self->{"code"}->{"arguments"}->[0];
                    $code = "p5code_lookup_by_name(" . Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME) . ", " . $arg->emit_javascript2($level) . ")";
                    return $code . "([" . join(",", @args) . "])"
                }
                return "(" . $self->{"code"}->emit_javascript2($level) . ")([" . join(",", @args) . "])"
            }
            exists($emit_js{$code}) && return $emit_js{$code}->($self, $level, $wantarray);
            if (exists($Perlito5::JavaScript2::op_infix_js_str{$code})) {;
                return "(" . join($Perlito5::JavaScript2::op_infix_js_str{$code}, map {;
                    Perlito5::JavaScript2::to_str($_, $level)
                } @{$self->{"arguments"}}) . ")"
            }
            if (exists($Perlito5::JavaScript2::op_infix_js_num{$code})) {;
                return "(" . join($Perlito5::JavaScript2::op_infix_js_num{$code}, map {;
                    Perlito5::JavaScript2::to_num($_, $level)
                } @{$self->{"arguments"}}) . ")"
            }
            if (exists($Perlito5::JavaScript2::op_prefix_js_str{$code})) {;
                return $Perlito5::JavaScript2::op_prefix_js_str{$code} . "(" . Perlito5::JavaScript2::to_str($self->{"arguments"}->[0]) . ")"
            }
            if ($self->{"namespace"}) {
                if ($self->{"namespace"} eq "JS") {;
                    if ($code eq "inline") {
                        if ($self->{"arguments"}->[0]->isa("Perlito5::AST::Buf")) {;
                            return $self->{"arguments"}->[0]->{"buf"}
                        }
                        else {;
                            die("JS::inline needs a string constant")
                        }
                    }
                }
                if ($self->{"namespace"} eq "Perlito5") {;
                    if ($code eq "eval_ast") {;
                        $self->{"namespace"} = "Perlito5::JavaScript2::Runtime"
                    }
                }
                if ($self->{"namespace"} eq "Scalar::Util") {;
                    if ($code eq "refaddr") {;
                        return "p5refaddr(" . $self->{"arguments"}->[0]->emit_javascript2($level + 1, "scalar") . ")"
                    }
                }
                $code = "p5pkg[" . Perlito5::JavaScript2::escape_string($self->{"namespace"}) . "]." . $code
            }
            else {;
                $code = Perlito5::JavaScript2::pkg() . "." . $code
            }
            my $sig;
            my $may_need_autoload;
            {
                my $name = $self->{"code"};
                my $namespace = $self->{"namespace"} || $Perlito5::PKG_NAME;
                my $effective_name = $namespace . "::" . ($self->{"code"});
                if (exists($Perlito5::PROTO->{$effective_name})) {;
                    $sig = $Perlito5::PROTO->{$effective_name}
                }
                elsif ((!$self->{"namespace"} || $namespace eq "CORE") && exists($Perlito5::CORE_PROTO->{"CORE::" . $name})) {
                    $effective_name = "CORE::" . $name;
                    $sig = $Perlito5::CORE_PROTO->{$effective_name}
                }
                elsif (exists($Perlito5::PACKAGES->{$name})) {;
                    return Perlito5::JavaScript2::escape_string($name)
                }
                else {
                    if ($self->{"bareword"}) {;
                        return Perlito5::JavaScript2::escape_string(($self->{"namespace"} ? ($self->{"namespace"}) . "::" : '') . $name)
                    }
                    $may_need_autoload = 1
                }
                (exists($self->{"proto"})) && ($sig = $self->{"proto"})
            }
            $self->{"ignore_proto"} && ($sig = '');
            if ($sig) {
                my @out = ();
                my @in = @{$self->{"arguments"} || []};
                my $close = "]";
                my $optional = 0;
                while (length($sig)) {
                    my $c = substr($sig, 0, 1);
                    if ($c eq ";") {;
                        $optional = 1
                    }
                    elsif ($c eq "\$" || $c eq "_") {;
                        (@in || !$optional) && push(@out, shift(@in)->emit_javascript2($level + 1, "scalar"))
                    }
                    elsif ($c eq "+") {;
                        if (@in || !$optional) {
                            my $in = shift(@in);
                            if (($in->isa("Perlito5::AST::Apply") && $in->{"code"} eq "prefix:<\@>") || ($in->isa("Perlito5::AST::Var") && $in->{"sigil"} eq "\@") || ($in->isa("Perlito5::AST::Apply") && $in->{"code"} eq "prefix:<%>") || ($in->isa("Perlito5::AST::Var") && $in->{"sigil"} eq "%")) {;
                                push(@out, $in->emit_javascript2($level + 1, "list"))
                            }
                            else {;
                                push(@out, $in->emit_javascript2($level + 1, "scalar"))
                            }
                        }
                    }
                    elsif ($c eq "\@") {
                        (@in || !$optional) && ($close = "].concat(" . Perlito5::JavaScript2::to_list(\@in, $level + 1) . ")");
                        @in = ()
                    }
                    elsif ($c eq "&") {;
                        push(@out, shift(@in)->emit_javascript2($level + 1, "scalar"))
                    }
                    elsif ($c eq "*") {;
                        if (@in || !$optional) {
                            my $arg = shift(@in);
                            if ($arg->{"bareword"}) {;
                                push(@out, Perlito5::JavaScript2::escape_string($arg->{"code"}))
                            }
                            else {;
                                push(@out, $arg->emit_javascript2($level + 1, "scalar"))
                            }
                        }
                    }
                    elsif ($c eq "\\") {
                        if (substr($sig, 0, 2) eq "\\\$") {
                            $sig = substr($sig, 1);
                            (@in || !$optional) && push(@out, shift(@in)->emit_javascript2($level + 1, "scalar"))
                        }
                        elsif (substr($sig, 0, 2) eq "\\\@" || substr($sig, 0, 2) eq "\\%") {
                            $sig = substr($sig, 1);
                            (@in || !$optional) && push(@out, shift(@in)->emit_javascript2($level + 1, "list"))
                        }
                        elsif (substr($sig, 0, 5) eq "\\[\@%]") {
                            $sig = substr($sig, 4);
                            (@in || !$optional) && push(@out, shift(@in)->emit_javascript2($level + 1, "list"))
                        }
                        elsif (substr($sig, 0, 6) eq "\\[\$\@%]") {
                            $sig = substr($sig, 5);
                            (@in || !$optional) && push(@out, shift(@in)->emit_javascript2($level + 1, "list"))
                        }
                    }
                    $sig = substr($sig, 1)
                }
                return $code . "([" . join(", ", @out) . $close . ", " . Perlito5::JavaScript2::to_context($wantarray) . ")"
            }
            my $arg_list = Perlito5::JavaScript2::to_list_preprocess($self->{"arguments"});
            my $arg_code = $self->{"code"} eq "scalar" ? "[" . join(", ", map($_->emit_javascript2($level), @{$arg_list})) . "]" : Perlito5::JavaScript2::to_list($arg_list, $level);
            if ($may_need_autoload) {
                my $name = $self->{"code"};
                my $namespace = $self->{"namespace"} || $Perlito5::PKG_NAME;
                return "p5cget(" . Perlito5::JavaScript2::escape_string($namespace) . ", " . Perlito5::JavaScript2::escape_string($name) . ")(" . $arg_code . ", " . Perlito5::JavaScript2::to_context($wantarray) . ")"
            }
            $code . "(" . $arg_code . ", " . Perlito5::JavaScript2::to_context($wantarray) . ")"
        }
        sub Perlito5::AST::Apply::emit_javascript2_set_list {
            (my $self, my $level, my $list) = @_;
            my $code = $self->{"code"};
            if ($self->{"code"} eq "undef") {;
                return $list . ".shift()"
            }
            if ($self->{"code"} eq "prefix:<\$>") {;
                return "p5scalar_deref_set(" . Perlito5::JavaScript2::emit_javascript2_autovivify($self->{"arguments"}->[0], $level + 1, "scalar") . ", " . $list . ".shift()" . ", " . Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME) . ")"
            }
            die("not implemented: assign to ", $self->{"code"})
        }
        sub Perlito5::AST::Apply::emit_javascript2_get_decl {
            my $self = shift;
            my $code = $self->{"code"};
            if ($code ne "do" && $code ne "eval") {;
                $self->{"arguments"} && return (map(+$_->emit_javascript2_get_decl(), @{$self->{"arguments"}}))
            }
            return ()
        }
        sub Perlito5::AST::Apply::emit_javascript2_has_regex {
            my $self = shift;
            my $code = $self->{"code"};
            if ($code eq "p5:m" || $code eq "p5:s" || $code eq "infix:<=~>" || $code eq "infix:<!~>") {;
                return 1
            }
            return ()
        }
    }
    1
}
{
    package main;
    package Perlito5::JavaScript2;
    {
        my %label;
        sub Perlito5::JavaScript2::pkg {;
            "p5pkg[" . Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME) . "]"
        }
        sub Perlito5::JavaScript2::get_label {;
            "tmp" . ($Perlito5::ID++)
        }
        sub Perlito5::JavaScript2::tab {
            my $level = shift;
            "\x{9}" x $level
        }
        our $is_inside_subroutine;
        our %op_prefix_js_str = ("prefix:<-A>", "p5atime", "prefix:<-C>", "p5ctime", "prefix:<-M>", "p5mtime", "prefix:<-d>", "p5is_directory", "prefix:<-e>", "p5file_exists", "prefix:<-f>", "p5is_file", "prefix:<-s>", "p5size", "prefix:<-p>", "p5is_pipe");
        our %op_infix_js_str = ("infix:<eq>", " == ", "infix:<ne>", " != ", "infix:<le>", " <= ", "infix:<ge>", " >= ", "infix:<lt>", " < ", "infix:<gt>", " > ");
        our %op_infix_js_num = ("infix:<==>", " == ", "infix:<!=>", " != ", "infix:<+>", " + ", "infix:<->", " - ", "infix:<*>", " * ", "infix:</>", " / ", "infix:<>>", " > ", "infix:<<>", " < ", "infix:<>=>", " >= ", "infix:<<=>", " <= ", "infix:<&>", " & ", "infix:<|>", " | ", "infix:<^>", " ^ ", "infix:<>>>", " >>> ");
        our %op_to_bool = map(+($_, 1), "prefix:<!>", "infix:<!=>", "infix:<==>", "infix:<<=>", "infix:<>=>", "infix:<>>", "infix:<<>", "infix:<eq>", "infix:<ne>", "infix:<ge>", "infix:<le>", "infix:<gt>", "infix:<lt>", "infix:<~~>", "prefix:<not>", "exists", "defined");
        our %op_to_str = map(+($_, 1), "substr", "join", "list:<.>", "chr", "lc", "uc", "lcfirst", "ucfirst", "ref");
        our %op_to_num = map(+($_, 1), "length", "index", "ord", "oct", "infix:<->", "infix:<+>", "infix:<*>", "infix:</>", "infix:<%>", "infix:<**>");
        my %safe_char = (" ", 1, "!", 1, "\"", 1, "#", 1, "\$", 1, "%", 1, "&", 1, "(", 1, ")", 1, "*", 1, "+", 1, ",", 1, "-", 1, ".", 1, "/", 1, ":", 1, ";", 1, "<", 1, "=", 1, ">", 1, "?", 1, "\@", 1, "[", 1, "]", 1, "^", 1, "_", 1, "`", 1, "{", 1, "|", 1, "}", 1, "~", 1);
        sub Perlito5::JavaScript2::escape_string {
            my $s = shift;
            my @out;
            my $tmp = '';
            $s eq '' && return "''";
            for my $i (0 .. length($s) - 1) {
                my $c = substr($s, $i, 1);
                if (($c ge "a" && $c le "z") || ($c ge "A" && $c le "Z") || ($c ge 0 && $c le 9) || exists($safe_char{$c})) {;
                    $tmp = $tmp . $c
                }
                elsif ($c eq "\\") {;
                    $tmp = $tmp . "\\\\"
                }
                else {
                    $tmp ne '' && push(@out, "'" . $tmp . "'");
                    push(@out, "String.fromCharCode(" . ord($c) . ")");
                    $tmp = ''
                }
            }
            $tmp ne '' && push(@out, "'" . $tmp . "'");
            return join(" + ", @out)
        }
        sub Perlito5::JavaScript2::to_str {
            my $cond = shift;
            my $level = shift;
            my $wantarray = "scalar";
            if ($cond->isa("Perlito5::AST::Apply") && $cond->{"code"} eq "circumfix:<( )>" && $cond->{"arguments"} && @{$cond->{"arguments"}}) {;
                return Perlito5::JavaScript2::to_str($cond->{"arguments"}->[0], $level)
            }
            if (($cond->isa("Perlito5::AST::Buf")) || ($cond->isa("Perlito5::AST::Apply") && exists($op_to_str{$cond->{"code"}}))) {;
                return $cond->emit_javascript2($level, $wantarray)
            }
            else {;
                return "p5str(" . $cond->emit_javascript2($level, $wantarray) . ")"
            }
        }
        sub Perlito5::JavaScript2::is_num {
            my $cond = shift;
            ($cond->isa("Perlito5::AST::Int") || $cond->isa("Perlito5::AST::Num") || ($cond->isa("Perlito5::AST::Apply") && exists($op_to_num{$cond->{"code"}}))) && return 1;
            return 0
        }
        sub Perlito5::JavaScript2::to_num {
            my $cond = shift;
            my $level = shift;
            my $wantarray = "scalar";
            if (Perlito5::JavaScript2::is_num($cond)) {;
                return $cond->emit_javascript2($level, $wantarray)
            }
            else {;
                return "p5num(" . $cond->emit_javascript2($level, $wantarray) . ")"
            }
        }
        sub Perlito5::JavaScript2::to_bool {
            my $cond = shift;
            my $level = shift;
            my $wantarray = "scalar";
            if ($cond->isa("Perlito5::AST::Apply") && $cond->{"code"} eq "circumfix:<( )>" && $cond->{"arguments"} && @{$cond->{"arguments"}}) {;
                return Perlito5::JavaScript2::to_bool($cond->{"arguments"}->[0], $level)
            }
            if ($cond->isa("Perlito5::AST::Apply") && ($cond->{"code"} eq "infix:<&&>" || $cond->{"code"} eq "infix:<and>")) {;
                return "(" . Perlito5::JavaScript2::to_bool($cond->{"arguments"}->[0], $level) . " && " . Perlito5::JavaScript2::to_bool($cond->{"arguments"}->[1], $level) . ")"
            }
            if ($cond->isa("Perlito5::AST::Apply") && ($cond->{"code"} eq "infix:<||>" || $cond->{"code"} eq "infix:<or>")) {;
                return "(" . Perlito5::JavaScript2::to_bool($cond->{"arguments"}->[0], $level) . " || " . Perlito5::JavaScript2::to_bool($cond->{"arguments"}->[1], $level) . ")"
            }
            if (($cond->isa("Perlito5::AST::Int")) || ($cond->isa("Perlito5::AST::Num")) || ($cond->isa("Perlito5::AST::Apply") && exists($op_to_bool{$cond->{"code"}}))) {;
                return $cond->emit_javascript2($level, $wantarray)
            }
            else {;
                return "p5bool(" . $cond->emit_javascript2($level, $wantarray) . ")"
            }
        }
        sub Perlito5::JavaScript2::is_scalar {;
            !$_[0]->isa("Perlito5::AST::Int") && !$_[0]->isa("Perlito5::AST::Num") && !$_[0]->isa("Perlito5::AST::Buf") && !$_[0]->isa("Perlito5::AST::Sub") && !($_[0]->isa("Perlito5::AST::Var") && $_[0]->{"sigil"} eq "\$") && !($_[0]->isa("Perlito5::AST::Apply") && (exists($op_to_str{$_[0]->{"code"}}) || exists($op_to_num{$_[0]->{"code"}}) || exists($op_to_bool{$_[0]->{"code"}})))
        }
        sub Perlito5::JavaScript2::to_list {
            my $items = Perlito5::JavaScript2::to_list_preprocess($_[0]);
            my $level = $_[1];
            my $literal_type = $_[2] || "array";
            my $wantarray = "list";
            my $interpolate = 0;
            for $_ (@{$items}) {;
                Perlito5::JavaScript2::is_scalar($_) && ($interpolate = 1)
            }
            if ($literal_type eq "hash") {
                if (!$interpolate) {
                    my @out;
                    my $printable = 1;
                    my @in = @{$items};
                    while (@in) {
                        my $k = shift(@in);
                        my $v = shift(@in);
                        $k = $k->emit_javascript2($level, 0);
                        $k =~ m/[ \[]/ && ($printable = 0);
                        $v = $v ? $v->emit_javascript2($level, 0) : "null";
                        push(@out, $k . " : " . $v)
                    }
                    $printable && return "{" . join(", ", @out) . "}"
                }
                return "p5a_to_h(" . Perlito5::JavaScript2::to_list($items, $level, "array") . ")"
            }
            $interpolate ? ("p5list_to_a([" . join(", ", map($_->emit_javascript2($level, $wantarray), @{$items})) . "])") : ("[" . join(", ", map($_->emit_javascript2($level, $wantarray), @{$items})) . "]")
        }
        sub Perlito5::JavaScript2::to_list_preprocess {
            my @items;
            for my $item (@{$_[0]}) {
                if ($item->isa("Perlito5::AST::Apply") && ($item->{"code"} eq "circumfix:<( )>" || $item->{"code"} eq "list:<,>" || $item->{"code"} eq "infix:<=>>")) {
                    if ($item->isa("Perlito5::AST::Apply") && $item->{"code"} eq "infix:<=>>") {;
                        $item->{"arguments"}->[0] = Perlito5::AST::Lookup::->autoquote($item->{"arguments"}->[0])
                    }
                    for my $arg (@{Perlito5::JavaScript2::to_list_preprocess($item->arguments())}) {;
                        push(@items, $arg)
                    }
                }
                else {;
                    push(@items, $item)
                }
            }
            return \@items
        }
        sub Perlito5::JavaScript2::to_scalar {
            my $items = Perlito5::JavaScript2::to_scalar_preprocess($_[0]);
            my $level = $_[1];
            my $wantarray = "scalar";
            @{$items} ? "(" . join(", ", map($_->emit_javascript2($level, $wantarray), @{$items})) . ")" : "null"
        }
        sub Perlito5::JavaScript2::to_scalar_preprocess {
            my @items;
            for my $item (@{$_[0]}) {
                if ($item->isa("Perlito5::AST::Apply") && ($item->{"code"} eq "list:<,>" || $item->{"code"} eq "infix:<=>>")) {
                    if ($item->isa("Perlito5::AST::Apply") && $item->{"code"} eq "infix:<=>>") {;
                        $item->{"arguments"}->[0] = Perlito5::AST::Lookup::->autoquote($item->{"arguments"}->[0])
                    }
                    for my $arg (@{Perlito5::JavaScript2::to_scalar_preprocess($item->arguments())}) {;
                        push(@items, $arg)
                    }
                }
                else {;
                    push(@items, $item)
                }
            }
            return \@items
        }
        sub Perlito5::JavaScript2::to_runtime_context {
            my $items = Perlito5::JavaScript2::to_scalar_preprocess($_[0]);
            my $level = $_[1];
            my $wantarray = "runtime";
            @{$items} == 1 && Perlito5::JavaScript2::is_scalar($items->[0]) && return $items->[0]->emit_javascript2($level, $wantarray);
            "p5context(" . "[" . join(", ", map($_->emit_javascript2($level, $wantarray), @{$items})) . "]" . ", p5want)"
        }
        sub Perlito5::JavaScript2::to_context {
            my $wantarray = shift;
            $wantarray eq "list" ? 1 : $wantarray eq "scalar" ? "\"\"" : $wantarray eq "void" ? "null" : "p5want"
        }
        sub Perlito5::JavaScript2::autoquote {
            my $index = shift;
            my $level = shift;
            $index = Perlito5::AST::Lookup::->autoquote($index);
            return Perlito5::JavaScript2::to_str($index, $level)
        }
        sub Perlito5::JavaScript2::emit_javascript2_autovivify {
            my $obj = shift;
            my $level = shift;
            my $type = shift;
            if ($obj->isa("Perlito5::AST::Index") || $obj->isa("Perlito5::AST::Lookup") || $obj->isa("Perlito5::AST::Call")) {;
                return $obj->emit_javascript2($level, 0, $type)
            }
            if ($obj->isa("Perlito5::AST::Apply") && $obj->{"code"} eq "prefix:<\$>") {
                my $arg = $obj->{"arguments"}->[0];
                return "p5scalar_deref(" . $arg->emit_javascript2($level) . ", " . Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME) . ", " . Perlito5::JavaScript2::escape_string($type) . ")"
            }
            if ($obj->isa("Perlito5::AST::Apply")) {;
                return $obj->emit_javascript2($level)
            }
            if ($obj->isa("Perlito5::AST::Buf")) {;
                return $obj->emit_javascript2($level)
            }
            "(" . $obj->emit_javascript2($level) . " || (" . $obj->emit_javascript2($level) . " = " . ($type eq "array" ? "new p5ArrayRef([])" : $type eq "hash" ? "new p5HashRef({})" : "new p5ScalarRef(null)") . ")" . ")"
        }
        sub Perlito5::JavaScript2::emit_javascript2_list_with_tabs {
            (my $level, my $argument) = @_;
            my $tab = Perlito5::JavaScript2::tab($level);
            return map {;
                ref($_) eq "ARRAY" ? Perlito5::JavaScript2::emit_javascript2_list_with_tabs($level + 1, $_) : $tab . $_
            } @{$argument}
        }
        sub Perlito5::JavaScript2::emit_func_javascript2 {
            (my $level, my $wantarray, my @argument) = @_;
            return join("
", "function () {", Perlito5::JavaScript2::emit_javascript2_list_with_tabs($level, [\@argument, "}"]))
        }
        sub Perlito5::JavaScript2::emit_wrap_javascript2 {
            (my $level, my $wantarray, my @argument) = @_;
            return join("
", "(function () {", Perlito5::JavaScript2::emit_javascript2_list_with_tabs($level, [\@argument, "})()"]))
        }
        sub Perlito5::JavaScript2::emit_function_javascript2 {
            (my $level, my $wantarray, my $argument) = @_;
            if ($argument->isa("Perlito5::AST::Apply") && ($argument->{"code"} eq "return" || $argument->{"code"} eq "last" || $argument->{"code"} eq "next" || $argument->{"code"} eq "redo")) {;
                Perlito5::JavaScript2::emit_func_javascript2($level, $wantarray, $argument->emit_javascript2($level, $wantarray))
            }
            else {;
                Perlito5::JavaScript2::emit_func_javascript2($level, $wantarray, "return " . $argument->emit_javascript2($level + 1, $wantarray))
            }
        }
        sub Perlito5::JavaScript2::emit_wrap_statement_javascript2 {
            (my $level, my $wantarray, my $argument) = @_;
            if ($wantarray eq "void") {;
                return $argument
            }
            Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, $argument)
        }
    }
    package Perlito5::JavaScript2::LexicalBlock;
    {
        sub Perlito5::JavaScript2::LexicalBlock::new {
            my $class = shift;
            bless({@_, }, $class)
        }
        sub Perlito5::JavaScript2::LexicalBlock::block {;
            $_[0]->{"block"}
        }
        sub Perlito5::JavaScript2::LexicalBlock::has_decl {
            my $self = $_[0];
            my $type = $_[1];
            for my $decl (@{$self->{"block"}}) {;
                (grep {;
                    $_->{"decl"} eq $type
                } $decl->emit_javascript2_get_decl()) && return 1
            }
            return 0
        }
        sub Perlito5::JavaScript2::LexicalBlock::emit_javascript2_subroutine_body {
            (my $self, my $level, my $wantarray) = @_;
            $self->{"top_level"} = 1;
            my $outer_throw = $Perlito5::THROW;
            $Perlito5::THROW = 0;
            my $s = $self->emit_javascript2($level, $wantarray);
            $Perlito5::THROW = $outer_throw;
            return $s
        }
        sub Perlito5::JavaScript2::LexicalBlock::emit_javascript2 {
            (my $self, my $level, my $wantarray) = @_;
            my $original_level = $level;
            my @block;
            for my $stmt (@{$self->{"block"}}) {;
                if (defined($stmt)) {;
                    push(@block, $stmt)
                }
            }
            if (!@block) {
                $wantarray eq "list" && return "return []";
                $wantarray eq "scalar" && return "return null";
                $wantarray eq "runtime" && return "return p5want ? [] : null";
                return "null;"
            }
            my @str;
            my $has_local = $self->has_decl("local");
            my $has_regex = 0;
            if (grep {;
                $_->emit_javascript2_has_regex()
            } @block) {
                $has_local = 1;
                $has_regex = 1
            }
            my $create_context = $self->{"create_context"} && $self->has_decl("my");
            my $outer_pkg = $Perlito5::PKG_NAME;
            if ($self->{"top_level"} || $create_context) {;
                $level++
            }
            my $last_statement;
            if ($wantarray ne "void") {;
                $last_statement = pop(@block)
            }
            for my $decl (@block) {
                if (ref($decl) eq "Perlito5::AST::Apply" && $decl->{"code"} eq "package") {;
                    $Perlito5::PKG_NAME = $decl->{"namespace"}
                }
                my @var_decl = $decl->emit_javascript2_get_decl();
                for my $arg (@var_decl) {;
                    push(@str, $arg->emit_javascript2_init($level, $wantarray))
                }
                if (!($decl->isa("Perlito5::AST::Decl") && $decl->decl() eq "my")) {;
                    push(@str, $decl->emit_javascript2($level, "void") . ";")
                }
            }
            if ($last_statement) {
                my @var_decl = $last_statement->emit_javascript2_get_decl();
                for my $arg (@var_decl) {;
                    push(@str, $arg->emit_javascript2_init($level, $wantarray))
                }
                if ($last_statement->isa("Perlito5::AST::Apply") && $last_statement->{"code"} eq "return" && $self->{"top_level"} && @{$last_statement->{"arguments"}}) {;
                    $last_statement = $last_statement->{"arguments"}->[0]
                }
                if ($last_statement->isa("Perlito5::AST::For") || $last_statement->isa("Perlito5::AST::While") || $last_statement->isa("Perlito5::AST::If") || $last_statement->isa("Perlito5::AST::Block") || $last_statement->isa("Perlito5::AST::Apply") && $last_statement->{"code"} eq "goto" || $last_statement->isa("Perlito5::AST::Apply") && $last_statement->{"code"} eq "return") {;
                    push(@str, $last_statement->emit_javascript2($level, $wantarray))
                }
                elsif ($has_local) {;
                    push(@str, "return p5cleanup_local(local_idx, (" . ($wantarray eq "runtime" ? Perlito5::JavaScript2::to_runtime_context([$last_statement], $level + 1) : $wantarray eq "scalar" ? Perlito5::JavaScript2::to_scalar([$last_statement], $level + 1) : $last_statement->emit_javascript2($level, $wantarray)) . "));")
                }
                else {;
                    push(@str, "return (" . ($wantarray eq "runtime" ? Perlito5::JavaScript2::to_runtime_context([$last_statement], $level + 1) : $wantarray eq "scalar" ? Perlito5::JavaScript2::to_scalar([$last_statement], $level + 1) : $last_statement->emit_javascript2($level, $wantarray)) . ");")
                }
            }
            if ($has_local) {
                unshift(@str, ("var local_idx = p5LOCAL.length;", ($has_regex ? ("var regex_tmp = p5_regex_capture;", "p5LOCAL.push(function(){ p5_regex_capture = regex_tmp });") : ())));
                push(@str, "p5cleanup_local(local_idx, null);")
            }
            my $out;
            if ($self->{"top_level"} && $Perlito5::THROW) {
                $level = $original_level;
                my $tab = "
" . Perlito5::JavaScript2::tab($level + 1);
                $out = "try {" . $tab . join($tab, @str) . "
" . Perlito5::JavaScript2::tab($level) . "}" . "
" . Perlito5::JavaScript2::tab($level) . "catch(err) {" . "
" . Perlito5::JavaScript2::tab($level + 1) . "if ( err instanceof Error ) {" . "
" . Perlito5::JavaScript2::tab($level + 2) . "throw(err);" . "
" . Perlito5::JavaScript2::tab($level + 1) . "}" . "
" . Perlito5::JavaScript2::tab($level + 1) . "else {" . "
" . Perlito5::JavaScript2::tab($level + 2) . ($has_local ? "return p5cleanup_local(local_idx, err)" : "return(err)") . ";
" . Perlito5::JavaScript2::tab($level + 1) . "}" . "
" . Perlito5::JavaScript2::tab($level) . "}"
            }
            elsif ($create_context) {
                $level = $original_level;
                my $tab = "
" . Perlito5::JavaScript2::tab($level + 1);
                $out = "(function () {" . $tab . join($tab, @str) . "
" . Perlito5::JavaScript2::tab($level) . "})();"
            }
            else {
                $level = $original_level;
                my $tab = "
" . Perlito5::JavaScript2::tab($level);
                $out = join($tab, @str)
            }
            $Perlito5::PKG_NAME = $outer_pkg;
            return $out
        }
        sub Perlito5::JavaScript2::LexicalBlock::emit_javascript2_has_regex {;
            ()
        }
    }
    package Perlito5::AST::CompUnit;
    {
        sub Perlito5::AST::CompUnit::emit_javascript2 {
            (my $self, my $level, my $wantarray) = @_;
            return Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, Perlito5::JavaScript2::LexicalBlock::->new("block", $self->{"body"})->emit_javascript2($level + 1, $wantarray)) . ";"
        }
        sub Perlito5::AST::CompUnit::emit_javascript2_program {
            (my $comp_units, my %options) = @_;
            $Perlito5::PKG_NAME = "main";
            my $level = 0;
            my $wantarray = "void";
            my $str;
            $str .= Perlito5::Compiler::do_not_edit("//");
            if ($options{"expand_use"}) {
                $str .= Perlito5::JavaScript2::Runtime::->emit_javascript2();
                $str .= Perlito5::JavaScript2::Array::->emit_javascript2();
                $str .= Perlito5::JavaScript2::CORE::->emit_javascript2();
                $str .= Perlito5::JavaScript2::IO::->emit_javascript2();
                $str .= Perlito5::JavaScript2::Sprintf::->emit_javascript2()
            }
            $str .= "var p5want;
" . "var List__ = [];
";
            for my $comp_unit (@{$comp_units}) {;
                $str = $str . $comp_unit->emit_javascript2($level, $wantarray) . ";
"
            }
            return $str
        }
        sub Perlito5::AST::CompUnit::emit_javascript2_get_decl {;
            ()
        }
        sub Perlito5::AST::CompUnit::emit_javascript2_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Int;
    {
        sub Perlito5::AST::Int::emit_javascript2 {
            (my $self, my $level, my $wantarray) = @_;
            $self->{"int"}
        }
        sub Perlito5::AST::Int::emit_javascript2_get_decl {;
            ()
        }
        sub Perlito5::AST::Int::emit_javascript2_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Num;
    {
        sub Perlito5::AST::Num::emit_javascript2 {
            (my $self, my $level, my $wantarray) = @_;
            $self->{"num"}
        }
        sub Perlito5::AST::Num::emit_javascript2_get_decl {;
            ()
        }
        sub Perlito5::AST::Num::emit_javascript2_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Buf;
    {
        sub Perlito5::AST::Buf::emit_javascript2 {
            (my $self, my $level, my $wantarray) = @_;
            Perlito5::JavaScript2::escape_string($self->{"buf"})
        }
        sub Perlito5::AST::Buf::emit_javascript2_get_decl {;
            ()
        }
        sub Perlito5::AST::Buf::emit_javascript2_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Block;
    {
        sub Perlito5::AST::Block::emit_javascript2 {
            (my $self, my $level, my $wantarray) = @_;
            my $body;
            if ($wantarray ne "void") {;
                $body = Perlito5::JavaScript2::LexicalBlock::->new("block", $self->{"stmts"})
            }
            else {;
                $body = Perlito5::JavaScript2::LexicalBlock::->new("block", $self->{"stmts"})
            }
            my $init = '';
            if ($self->{"name"} eq "INIT") {
                my $tmp = "p5pkg.main." . Perlito5::JavaScript2::get_label();
                $init = Perlito5::JavaScript2::tab($level + 2) . ("if (" . $tmp . ") { return }; " . $tmp . " = 1;
")
            }
            return ($wantarray ne "void" ? "return " : '') . "p5block(" . "function (v) {}, " . "function () {
" . $init . Perlito5::JavaScript2::tab($level + 2) . $body->emit_javascript2($level + 2, $wantarray) . "
" . Perlito5::JavaScript2::tab($level + 1) . "}, " . "[0], " . $self->emit_javascript2_continue($level, $wantarray) . ", " . Perlito5::JavaScript2::escape_string($self->{"label"} || '') . "
" . Perlito5::JavaScript2::tab($level) . ")"
        }
        sub Perlito5::AST::Block::emit_javascript2_continue {
            my $self = shift;
            my $level = shift;
            my $wantarray = shift;
            if (!$self->{"continue"} || !@{$self->{"continue"}->{"stmts"}}) {;
                return "false"
            }
            return "function () {
" . (Perlito5::JavaScript2::LexicalBlock::->new("block", $self->{"continue"}->stmts()))->emit_javascript2($level + 2, $wantarray) . "
" . Perlito5::JavaScript2::tab($level + 1) . "}"
        }
        sub Perlito5::AST::Block::emit_javascript2_get_decl {;
            ()
        }
        sub Perlito5::AST::Block::emit_javascript2_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Index;
    {
        sub Perlito5::AST::Index::emit_javascript2 {
            (my $self, my $level, my $wantarray, my $autovivification_type) = @_;
            my $method = $autovivification_type || "p5aget";
            $autovivification_type eq "array" && ($method = "p5aget_array");
            $autovivification_type eq "hash" && ($method = "p5aget_hash");
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\@>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->{"sigil"} eq "\@") || ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "circumfix:<( )>")) {;
                return "p5list_slice(" . $self->{"obj"}->emit_javascript2($level, "list") . ", " . Perlito5::JavaScript2::to_list([$self->{"index_exp"}], $level) . ", " . Perlito5::JavaScript2::to_context($wantarray) . ")"
            }
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<%>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->{"sigil"} eq "%")) {
                my $obj = $self->{"obj"}->clone();
                $obj->{"sigil"} eq "%" && ($obj->{"sigil"} = "\@");
                $obj->{"code"} eq "prefix:<%>" && ($obj->{"code"} = "prefix:<\@>");
                return "p5hash_slice(" . $obj->emit_javascript2($level, "list") . ", " . Perlito5::JavaScript2::to_list([$self->{"index_exp"}], $level) . ", " . Perlito5::JavaScript2::to_context($wantarray) . ")"
            }
            return $self->emit_javascript2_container($level) . "." . $method . "(" . Perlito5::JavaScript2::to_num($self->{"index_exp"}, $level) . ")"
        }
        sub Perlito5::AST::Index::emit_javascript2_set {
            (my $self, my $arguments, my $level, my $wantarray) = @_;
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\@>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->{"sigil"} eq "\@")) {;
                return Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, "var a = [];", "var v = " . Perlito5::JavaScript2::to_list([$self->{"index_exp"}], $level) . ";", "var src=" . Perlito5::JavaScript2::to_list([$arguments], $level) . ";", "var out=" . Perlito5::JavaScript2::emit_javascript2_autovivify($self->{"obj"}, $level, "array") . ";", "var tmp" . ";", "for (var i=0, l=v.length; i<l; ++i) {", ["tmp = src.p5aget(i);", "out.p5aset(v[i], tmp);", "a.push(tmp)"], "}", "return a")
            }
            return $self->emit_javascript2_container($level) . ".p5aset(" . Perlito5::JavaScript2::to_num($self->{"index_exp"}, $level + 1) . ", " . Perlito5::JavaScript2::to_scalar([$arguments], $level + 1) . ")"
        }
        sub Perlito5::AST::Index::emit_javascript2_set_list {
            (my $self, my $level, my $list) = @_;
            my $wantarray = "list";
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\@>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->{"sigil"} eq "\@")) {;
                return Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, "var a = [];", "var v = " . Perlito5::JavaScript2::to_list([$self->{"index_exp"}], $level) . ";", "var out=" . Perlito5::JavaScript2::emit_javascript2_autovivify($self->{"obj"}, $level, "array") . ";", "var tmp" . ";", "for (var i=0, l=v.length; i<l; ++i) {", ["tmp = " . $list . ".shift();", "out.p5aset(v[i], tmp);", "a.push(tmp)"], "}", "return a")
            }
            return $self->emit_javascript2_container($level) . ".p5aset(" . Perlito5::JavaScript2::to_num($self->{"index_exp"}, $level + 1) . ", " . $list . ".shift()" . ")"
        }
        sub Perlito5::AST::Index::emit_javascript2_container {
            my $self = shift;
            my $level = shift;
            if ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\$>") {
                my $v = Perlito5::AST::Apply::->new(%{$self->{"obj"}}, "code", "prefix:<\@>");
                return $v->emit_javascript2($level)
            }
            if ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "circumfix:<( )>") {;
                return Perlito5::JavaScript2::to_list([$self->{"obj"}], $level)
            }
            if ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->{"sigil"} eq "\$") {
                my $obj = $self->{"obj"}->clone();
                $obj->{"sigil"} = "\@";
                return $obj->emit_javascript2($level)
            }
            else {;
                return Perlito5::JavaScript2::emit_javascript2_autovivify($self->{"obj"}, $level, "array") . "._array_"
            }
        }
        sub Perlito5::AST::Index::emit_javascript2_get_decl {;
            ()
        }
        sub Perlito5::AST::Index::emit_javascript2_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Lookup;
    {
        sub Perlito5::AST::Lookup::emit_javascript2 {
            (my $self, my $level, my $wantarray, my $autovivification_type) = @_;
            my $method = $autovivification_type || "p5hget";
            $autovivification_type eq "array" && ($method = "p5hget_array");
            $autovivification_type eq "hash" && ($method = "p5hget_hash");
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\@>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->{"sigil"} eq "\@")) {
                my $v;
                if ($self->{"obj"}->isa("Perlito5::AST::Var")) {;
                    $v = $self->{"obj"}
                }
                $self->{"obj"}->isa("Perlito5::AST::Apply") && ($v = Perlito5::AST::Apply::->new("code", "prefix:<%>", "namespace", $self->{"obj"}->namespace(), "arguments", $self->{"obj"}->arguments()));
                return "p5list_lookup_slice(" . $v->emit_javascript2($level, "list") . ", " . Perlito5::JavaScript2::to_list([$self->{"index_exp"}], $level) . ", " . Perlito5::JavaScript2::to_context($wantarray) . ")"
            }
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<%>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->{"sigil"} eq "%")) {
                my $v;
                if ($self->{"obj"}->isa("Perlito5::AST::Var")) {;
                    $v = $self->{"obj"}
                }
                $self->{"obj"}->isa("Perlito5::AST::Apply") && ($v = Perlito5::AST::Apply::->new("code", "prefix:<%>", "namespace", $self->{"obj"}->namespace(), "arguments", $self->{"obj"}->arguments()));
                return "p5hash_lookup_slice(" . $v->emit_javascript2($level, "list") . ", " . Perlito5::JavaScript2::to_list([$self->{"index_exp"}], $level) . ", " . Perlito5::JavaScript2::to_context($wantarray) . ")"
            }
            return $self->emit_javascript2_container($level) . "." . $method . "(" . Perlito5::JavaScript2::autoquote($self->{"index_exp"}, $level) . ")"
        }
        sub Perlito5::AST::Lookup::emit_javascript2_set {
            (my $self, my $arguments, my $level, my $wantarray) = @_;
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\@>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->{"sigil"} eq "\@")) {
                my $v;
                $self->{"obj"}->isa("Perlito5::AST::Var") && ($v = $self->{"obj"});
                $self->{"obj"}->isa("Perlito5::AST::Apply") && ($v = Perlito5::AST::Apply::->new("code", "prefix:<%>", "namespace", $self->{"obj"}->namespace(), "arguments", $self->{"obj"}->arguments()));
                return Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, "var a = [];", "var v = " . Perlito5::JavaScript2::to_list([$self->{"index_exp"}], $level) . ";", "var src=" . Perlito5::JavaScript2::to_list([$arguments], $level) . ";", "var out=" . $v->emit_javascript2($level) . ";", "var tmp" . ";", "for (var i=0, l=v.length; i<l; ++i)" . "{", ["tmp = src.p5hget(i);", "out.p5hset(v[i], tmp);", "a.push(tmp)"], "}", "return a")
            }
            return $self->emit_javascript2_container($level) . ".p5hset(" . Perlito5::JavaScript2::autoquote($self->{"index_exp"}, $level) . ", " . Perlito5::JavaScript2::to_scalar([$arguments], $level + 1) . ")"
        }
        sub Perlito5::AST::Lookup::emit_javascript2_set_list {
            (my $self, my $level, my $list) = @_;
            my $wantarray = "list";
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\@>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->{"sigil"} eq "\@")) {
                my $v;
                $self->{"obj"}->isa("Perlito5::AST::Var") && ($v = $self->{"obj"});
                $self->{"obj"}->isa("Perlito5::AST::Apply") && ($v = Perlito5::AST::Apply::->new("code", "prefix:<%>", "namespace", $self->{"obj"}->namespace(), "arguments", $self->{"obj"}->arguments()));
                return Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, "var a = [];", "var v = " . Perlito5::JavaScript2::to_list([$self->{"index_exp"}], $level) . ";", "var out=" . $v->emit_javascript2($level) . ";", "var tmp" . ";", "for (var i=0, l=v.length; i<l; ++i)" . "{", ["tmp = " . $list . ".shift();", "out.p5hset(v[i], tmp);", "a.push(tmp)"], "}", "return a")
            }
            return $self->emit_javascript2_container($level) . ".p5hset(" . Perlito5::JavaScript2::autoquote($self->{"index_exp"}, $level) . ", " . $list . ".shift()" . ")"
        }
        sub Perlito5::AST::Lookup::emit_javascript2_container {
            my $self = shift;
            my $level = shift;
            if ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\$>") {
                my $v = Perlito5::AST::Apply::->new(%{$self->{"obj"}}, "code", "prefix:<%>");
                return $v->emit_javascript2($level)
            }
            if ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->{"sigil"} eq "\$") {
                my $v = Perlito5::AST::Var::->new(%{$self->{"obj"}}, "sigil", "%");
                return $v->emit_javascript2($level)
            }
            else {;
                return Perlito5::JavaScript2::emit_javascript2_autovivify($self->{"obj"}, $level, "hash") . "._hash_"
            }
        }
        sub Perlito5::AST::Lookup::emit_javascript2_get_decl {;
            ()
        }
        sub Perlito5::AST::Lookup::emit_javascript2_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Var;
    {
        my $table = {"\$" => "v_", "\@" => "List_", "%" => "Hash_", "&" => '', };
        sub Perlito5::AST::Var::emit_javascript2_global {
            (my $self, my $level, my $wantarray) = @_;
            my $str_name = $self->{"name"};
            my $sigil = $self->{"_real_sigil"} || $self->{"sigil"};
            my $namespace = $self->{"namespace"} || $self->{"_namespace"};
            if ($sigil eq "\@" && $self->{"name"} eq "_" && $namespace eq "main") {
                my $s = "List__";
                if ($self->{"sigil"} eq "\$#") {;
                    return "(" . $s . ".length - 1)"
                }
                if ($wantarray eq "scalar") {;
                    return $s . ".length"
                }
                if ($wantarray eq "runtime") {;
                    return "(p5want" . " ? " . $s . " : " . $s . ".length" . ")"
                }
                return $s
            }
            if ($sigil eq "\$" && $self->{"name"} > 0) {;
                return "p5_regex_capture[" . (($self->{"name"}) - 1) . "]"
            }
            if ($sigil eq "::") {
                $self->{"namespace"} eq "__PACKAGE__" && return Perlito5::JavaScript2::pkg();
                $self->{"namespace"} eq "__SUB__" && return $Perlito5::AST::Sub::SUB_REF // "__SUB__";
                return Perlito5::JavaScript2::escape_string($namespace)
            }
            my $s = "p5make_package(" . Perlito5::JavaScript2::escape_string($namespace) . ")[" . Perlito5::JavaScript2::escape_string(($table->{$sigil}) . $str_name) . "]";
            if ($sigil eq "*") {;
                return $s
            }
            if ($sigil eq "&") {;
                return $s . "(List__, " . Perlito5::JavaScript2::to_context($wantarray) . ")"
            }
            if ($sigil eq "\@" || $sigil eq "\$#") {
                $s = $s . " || (" . $s . " = [])";
                $s = "p5pkg[" . $s . ", " . Perlito5::JavaScript2::escape_string($namespace) . "][" . Perlito5::JavaScript2::escape_string(($table->{$sigil}) . $str_name) . "]";
                if ($self->{"sigil"} eq "\$#") {;
                    return "(" . $s . ".length - 1)"
                }
                if ($wantarray eq "scalar") {;
                    return $s . ".length"
                }
            }
            elsif ($sigil eq "%") {
                $s = $s . " || (" . $s . " = {})";
                $s = "p5pkg[" . $s . ", " . Perlito5::JavaScript2::escape_string($namespace) . "][" . Perlito5::JavaScript2::escape_string(($table->{$sigil}) . $str_name) . "]"
            }
            return $s
        }
        sub Perlito5::AST::Var::emit_javascript2 {
            (my $self, my $level, my $wantarray) = @_;
            $self = $self->to_begin_scratchpad();
            my $sigil = $self->{"_real_sigil"} || $self->{"sigil"};
            my $decl_type = $self->{"_decl"} || "global";
            if ($decl_type ne "my" && $decl_type ne "state") {;
                return $self->emit_javascript2_global($level, $wantarray)
            }
            my $str_name = ($self->{"name"}) . "_" . ($self->{"_id"});
            if ($self->{"sigil"} eq "\$#") {;
                return "(" . ($table->{"\@"}) . $str_name . ".length - 1)"
            }
            if ($sigil eq "\@") {
                if ($wantarray eq "scalar") {;
                    return $self->emit_javascript2($level, "list") . ".length"
                }
                if ($wantarray eq "runtime") {;
                    return "(p5want" . " ? " . $self->emit_javascript2($level, "list") . " : " . $self->emit_javascript2($level, "list") . ".length" . ")"
                }
            }
            ($table->{$sigil}) . $str_name
        }
        sub Perlito5::AST::Var::emit_javascript2_set {
            (my $self, my $arguments, my $level, my $wantarray) = @_;
            $self = $self->to_begin_scratchpad();
            my $open = $wantarray eq "void" ? '' : "(";
            my $close = $wantarray eq "void" ? '' : ")";
            my $sigil = $self->{"_real_sigil"} || $self->{"sigil"};
            if ($sigil eq "\$") {;
                return $open . $self->emit_javascript2() . " = " . Perlito5::JavaScript2::to_scalar([$arguments], $level + 1) . $close
            }
            if ($sigil eq "\@") {
                if ($self->{"sigil"} eq "\$#") {
                    $self = $self->clone();
                    $self->{"sigil"} = "\@";
                    return $open . $self->emit_javascript2() . ".length = 1 + " . Perlito5::JavaScript2::to_scalar([$arguments], $level + 1) . $close
                }
                return $open . $self->emit_javascript2() . " = " . Perlito5::JavaScript2::to_list([$arguments], $level + 1) . $close
            }
            if ($sigil eq "%") {;
                return $open . $self->emit_javascript2() . " = " . Perlito5::JavaScript2::to_list([$arguments], $level + 1, "hash") . $close
            }
            if ($sigil eq "*") {
                my $namespace = $self->{"namespace"} || $self->{"_namespace"};
                return "p5typeglob_set(" . Perlito5::JavaScript2::escape_string($namespace) . ", " . Perlito5::JavaScript2::escape_string($self->{"name"}) . ", " . Perlito5::JavaScript2::to_scalar([$arguments], $level + 1) . ")"
            }
            die("don't know how to assign to variable ", $sigil, $self->name())
        }
        sub Perlito5::AST::Var::emit_javascript2_set_list {
            (my $self, my $level, my $list) = @_;
            my $sigil = $self->{"_real_sigil"} || $self->{"sigil"};
            if ($sigil eq "\$") {;
                return $self->emit_javascript2() . " = " . $list . ".shift()"
            }
            if ($sigil eq "\@") {;
                return join(";
" . Perlito5::JavaScript2::tab($level), $self->emit_javascript2() . " = " . $list, $list . " = []")
            }
            if ($sigil eq "%") {;
                return join(";
" . Perlito5::JavaScript2::tab($level), $self->emit_javascript2() . " = p5a_to_h(" . $list . ")", $list . " = []")
            }
            die("don't know how to assign to variable ", $sigil, $self->name())
        }
        sub Perlito5::AST::Var::emit_javascript2_get_decl {;
            ()
        }
        sub Perlito5::AST::Var::emit_javascript2_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Decl;
    {
        sub Perlito5::AST::Decl::emit_javascript2 {
            (my $self, my $level, my $wantarray) = @_;
            $self->{"var"}->emit_javascript2($level)
        }
        sub Perlito5::AST::Decl::emit_javascript2_init {
            (my $self, my $level, my $wantarray) = @_;
            my $var = $self->{"var"};
            ref($var) eq "Perlito5::AST::Var" && $var->is_begin_scratchpad() && return '';
            if ($self->{"decl"} eq "local") {
                my $var_set;
                my $tmp_name = Perlito5::JavaScript2::get_label();
                my $id = $Perlito5::ID++;
                my $tmp = Perlito5::AST::Var::->new("sigil", "\$", "name", $tmp_name, "_decl", "my", "_id", $id);
                if (ref($var) eq "Perlito5::AST::Var") {;
                    $var_set = $var->emit_javascript2() . " = " . $tmp->emit_javascript2()
                }
                else {;
                    $var_set = $var->emit_javascript2_set($tmp)
                }
                return Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, "var " . $tmp->emit_javascript2() . " = " . $var->emit_javascript2() . ";", "p5LOCAL.push(function(){ " . $var_set . " });", "return " . $var->emit_javascript2_set(Perlito5::AST::Apply::->new("code", "undef", "arguments", [], "namespace", ''), $level + 1) . ";") . ";"
            }
            if ($self->{"decl"} eq "my" || $self->{"decl"} eq "state") {
                my $str = "var " . $self->{"var"}->emit_javascript2();
                if ($self->{"var"}->{"sigil"} eq "%") {;
                    $str = $str . " = {};"
                }
                elsif ($self->{"var"}->{"sigil"} eq "\@") {;
                    $str = $str . " = [];"
                }
                else {;
                    $str = $str . ";"
                }
                return $str
            }
            elsif ($self->{"decl"} eq "our") {
                my $str = $self->{"var"}->emit_javascript2();
                if ($self->{"var"}->{"sigil"} eq "%") {;
                    $str = $str . " = {};"
                }
                elsif ($self->{"var"}->{"sigil"} eq "\@") {;
                    $str = $str . " = [];"
                }
                else {;
                    return "// our " . $str
                }
                return "if (typeof " . $self->{"var"}->emit_javascript2() . " == \"undefined\" ) { " . $str . "}"
            }
            else {;
                die("not implemented: Perlito5::AST::Decl '" . ($self->{"decl"}) . "'")
            }
        }
        sub Perlito5::AST::Decl::emit_javascript2_set {
            (my $self, my $arguments, my $level, my $wantarray) = @_;
            $self->var()->emit_javascript2_set($arguments, $level, $wantarray)
        }
        sub Perlito5::AST::Decl::emit_javascript2_set_list {
            (my $self, my $level, my $list) = @_;
            $self->var()->emit_javascript2_set_list($level, $list)
        }
        sub Perlito5::AST::Decl::emit_javascript2_get_decl {
            my $self = shift;
            return ($self)
        }
        sub Perlito5::AST::Decl::emit_javascript2_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Call;
    {
        sub Perlito5::AST::Call::emit_javascript2 {
            (my $self, my $level, my $wantarray, my $autovivification_type) = @_;
            my $meth = $self->{"method"};
            if ($meth eq "postcircumfix:<[ ]>") {
                my $method = $autovivification_type || "p5aget";
                $autovivification_type eq "array" && ($method = "p5aget_array");
                $autovivification_type eq "hash" && ($method = "p5aget_hash");
                return Perlito5::JavaScript2::emit_javascript2_autovivify($self->{"invocant"}, $level, "array") . "._array_." . $method . "(" . Perlito5::JavaScript2::to_num($self->{"arguments"}, $level + 1) . ")"
            }
            if ($meth eq "postcircumfix:<{ }>") {
                my $method = $autovivification_type || "p5hget";
                $autovivification_type eq "array" && ($method = "p5hget_array");
                $autovivification_type eq "hash" && ($method = "p5hget_hash");
                return Perlito5::JavaScript2::emit_javascript2_autovivify($self->{"invocant"}, $level, "hash") . "._hash_." . $method . "(" . Perlito5::JavaScript2::autoquote($self->{"arguments"}, $level + 1, "list") . ")"
            }
            if ($meth eq "postcircumfix:<( )>") {
                my $invocant = $self->{"invocant"}->emit_javascript2($level, "scalar");
                return "(" . $invocant . ")(" . Perlito5::JavaScript2::to_list($self->{"arguments"}) . ", " . Perlito5::JavaScript2::to_context($wantarray) . ")"
            }
            my $invocant = $self->{"invocant"}->emit_javascript2($level, "scalar");
            if (ref($meth)) {;
                $meth = $meth->emit_javascript2($level, "scalar")
            }
            else {;
                $meth = Perlito5::JavaScript2::escape_string($meth)
            }
            return "p5call(" . $invocant . ", " . $meth . ", " . Perlito5::JavaScript2::to_list($self->{"arguments"}) . ", " . Perlito5::JavaScript2::to_context($wantarray) . ")"
        }
        sub Perlito5::AST::Call::emit_javascript2_set {
            (my $self, my $arguments, my $level, my $wantarray) = @_;
            if ($self->{"method"} eq "postcircumfix:<[ ]>") {;
                return Perlito5::JavaScript2::emit_javascript2_autovivify($self->{"invocant"}, $level, "array") . "._array_.p5aset(" . Perlito5::JavaScript2::to_num($self->{"arguments"}, $level + 1) . ", " . Perlito5::JavaScript2::to_scalar([$arguments], $level + 1) . ")"
            }
            if ($self->{"method"} eq "postcircumfix:<{ }>") {;
                return Perlito5::JavaScript2::emit_javascript2_autovivify($self->{"invocant"}, $level, "hash") . "._hash_.p5hset(" . Perlito5::JavaScript2::autoquote($self->{"arguments"}, $level + 1, "list") . ", " . Perlito5::JavaScript2::to_scalar([$arguments], $level + 1) . ")"
            }
            die("don't know how to assign to method ", $self->{"method"})
        }
        sub Perlito5::AST::Call::emit_javascript2_set_list {
            (my $self, my $level, my $list) = @_;
            if ($self->{"method"} eq "postcircumfix:<[ ]>") {;
                return Perlito5::JavaScript2::emit_javascript2_autovivify($self->{"invocant"}, $level, "array") . "._array_.p5aset(" . Perlito5::JavaScript2::to_num($self->{"arguments"}, $level + 1) . ", " . $list . ".shift()" . ")"
            }
            if ($self->{"method"} eq "postcircumfix:<{ }>") {;
                return Perlito5::JavaScript2::emit_javascript2_autovivify($self->{"invocant"}, $level, "hash") . "._hash_.p5hset(" . Perlito5::JavaScript2::autoquote($self->{"arguments"}, $level + 1, "list") . ", " . $list . ".shift()" . ")"
            }
            die("don't know how to assign to method ", $self->{"method"})
        }
        sub Perlito5::AST::Call::emit_javascript2_get_decl {;
            ()
        }
        sub Perlito5::AST::Call::emit_javascript2_has_regex {;
            ()
        }
    }
    package Perlito5::AST::If;
    {
        sub Perlito5::AST::If::emit_javascript2 {
            (my $self, my $level, my $wantarray) = @_;
            my $cond = $self->{"cond"};
            my @str;
            my $old_level = $level;
            if ($cond) {
                my @var_decl = $cond->emit_javascript2_get_decl();
                for my $arg (@var_decl) {
                    $level = $old_level + 1;
                    push(@str, $arg->emit_javascript2_init($level, $wantarray))
                }
            }
            my $body = ref($self->{"body"}) ne "Perlito5::AST::Block" ? $self->{"body"} : (!@{$self->{"body"}->stmts()}) ? undef : $wantarray ne "void" ? Perlito5::JavaScript2::LexicalBlock::->new("block", $self->{"body"}->stmts()) : Perlito5::JavaScript2::LexicalBlock::->new("block", $self->{"body"}->stmts(), "create_context", 1);
            my $otherwise = ref($self->{"otherwise"}) ne "Perlito5::AST::Block" ? $self->{"otherwise"} : (!@{$self->{"otherwise"}->stmts()}) ? undef : $wantarray ne "void" ? Perlito5::JavaScript2::LexicalBlock::->new("block", $self->{"otherwise"}->stmts()) : Perlito5::JavaScript2::LexicalBlock::->new("block", $self->{"otherwise"}->stmts(), "create_context", 1);
            my $s = "if ( " . Perlito5::JavaScript2::to_bool($cond, $level + 1) . " ) {";
            if ($body) {;
                $s = $s . "
" . Perlito5::JavaScript2::tab($level + 1) . $body->emit_javascript2($level + 1, $wantarray) . "
" . Perlito5::JavaScript2::tab($level) . "}"
            }
            else {;
                $s = $s . "}"
            }
            if ($otherwise) {
                if (@{$otherwise->{"block"}} == 1 && ref($otherwise->{"block"}->[0]) eq "Perlito5::AST::If") {;
                    $s = $s . "
" . Perlito5::JavaScript2::tab($level) . "else " . $otherwise->{"block"}->[0]->emit_javascript2($level, $wantarray)
                }
                else {;
                    $s = $s . "
" . Perlito5::JavaScript2::tab($level) . "else {" . "
" . Perlito5::JavaScript2::tab($level + 1) . $otherwise->emit_javascript2($level + 1, $wantarray) . "
" . Perlito5::JavaScript2::tab($level) . "}"
                }
            }
            push(@str, $s);
            if (@str) {
                $level = $old_level;
                return ($wantarray ne "void" ? "return " : '') . Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, @str)
            }
            else {;
                return join("
" . Perlito5::JavaScript2::tab($level), @str)
            }
        }
        sub Perlito5::AST::If::emit_javascript2_get_decl {;
            ()
        }
        sub Perlito5::AST::If::emit_javascript2_has_regex {;
            ()
        }
    }
    package Perlito5::AST::When;
    {
        sub Perlito5::AST::When::emit_javascript2 {
            (my $self, my $level, my $wantarray) = @_;
            my $cond = $self->{"cond"};
            my @str;
            my $old_level = $level;
            if ($cond) {
                my @var_decl = $cond->emit_javascript2_get_decl();
                for my $arg (@var_decl) {
                    $level = $old_level + 1;
                    push(@str, $arg->emit_javascript2_init($level, $wantarray))
                }
            }
            $cond = Perlito5::AST::Apply::->new("arguments", [Perlito5::AST::Var::SCALAR_ARG(), $cond], "code", "infix:<~~>", "namespace", '');
            my $next = Perlito5::AST::Apply::->new("arguments", [], "bareword", 1, "code", "next", "namespace", '');
            my $body = ref($self->{"body"}) ne "Perlito5::AST::Block" ? Perlito5::JavaScript2::LexicalBlock::->new("block", [$self->{"body"}]) : (!@{$self->{"body"}->stmts()}) ? undef : $wantarray ne "void" ? Perlito5::JavaScript2::LexicalBlock::->new("block", $self->{"body"}->stmts()) : Perlito5::JavaScript2::LexicalBlock::->new("block", $self->{"body"}->stmts(), "create_context", 1);
            push(@{$body->{"block"}}, $next);
            my $s = "if ( " . Perlito5::JavaScript2::to_bool($cond, $level + 1) . " ) {";
            if ($body) {;
                $s = $s . "
" . Perlito5::JavaScript2::tab($level + 1) . $body->emit_javascript2($level + 1, $wantarray) . "
" . Perlito5::JavaScript2::tab($level) . "}"
            }
            else {;
                $s = $s . "}"
            }
            push(@str, $s);
            if (@str) {
                $level = $old_level;
                return ($wantarray ne "void" ? "return " : '') . Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, @str)
            }
            else {;
                return join("
" . Perlito5::JavaScript2::tab($level), @str)
            }
        }
        sub Perlito5::AST::When::emit_javascript2_get_decl {;
            ()
        }
        sub Perlito5::AST::When::emit_javascript2_has_regex {;
            ()
        }
    }
    package Perlito5::AST::While;
    {
        sub Perlito5::AST::While::emit_javascript2 {
            (my $self, my $level, my $wantarray) = @_;
            my $cond = $self->{"cond"};
            my @str;
            my $old_level = $level;
            if ($cond) {
                my @var_decl = $cond->emit_javascript2_get_decl();
                for my $arg (@var_decl) {
                    $level = $old_level + 1;
                    push(@str, $arg->emit_javascript2_init($level, $wantarray))
                }
            }
            if (ref($self->{"body"}) eq "Perlito5::AST::Apply" && $self->{"body"}->{"code"} eq "do") {;
                push(@str, "do {" . $self->{"body"}->emit_javascript2($level + 2, $wantarray) . "
" . Perlito5::JavaScript2::tab($level + 1) . "} while (" . Perlito5::JavaScript2::to_bool($cond, $level + 2) . ")")
            }
            else {
                my $body = ref($self->{"body"}) ne "Perlito5::AST::Block" ? [$self->{"body"}] : $self->{"body"}->{"stmts"};
                push(@str, "p5while(" . "function () {
" . Perlito5::JavaScript2::tab($level + 2) . (Perlito5::JavaScript2::LexicalBlock::->new("block", $body))->emit_javascript2($level + 2, $wantarray) . "
" . Perlito5::JavaScript2::tab($level + 1) . "}, " . Perlito5::JavaScript2::emit_function_javascript2($level + 1, "scalar", $cond) . ", " . Perlito5::AST::Block::emit_javascript2_continue($self, $level, $wantarray) . ", " . Perlito5::JavaScript2::escape_string($self->{"label"} || '') . ", " . 0 . ")")
            }
            if (@str) {
                $level = $old_level;
                return Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, @str)
            }
            else {;
                return join("
" . Perlito5::JavaScript2::tab($level), @str)
            }
        }
        sub Perlito5::AST::While::emit_javascript2_get_decl {;
            ()
        }
        sub Perlito5::AST::While::emit_javascript2_has_regex {;
            ()
        }
    }
    package Perlito5::AST::For;
    {
        sub Perlito5::AST::For::emit_javascript2 {
            (my $self, my $level, my $wantarray) = @_;
            my $body = ref($self->{"body"}) ne "Perlito5::AST::Block" ? [$self->{"body"}] : $self->{"body"}->{"stmts"};
            my @str;
            my $old_level = $level;
            my $cond = ref($self->{"cond"}) eq "ARRAY" ? $self->{"cond"} : [$self->{"cond"}];
            for my $expr (@{$cond}, $self->{"topic"}) {;
                if ($expr) {
                    my @var_decl = $expr->emit_javascript2_get_decl();
                    for my $arg (@var_decl) {
                        $level = $old_level + 1;
                        push(@str, $arg->emit_javascript2_init($level, $wantarray))
                    }
                }
            }
            if (ref($self->{"cond"}) eq "ARRAY") {;
                push(@str, Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, "var label = " . Perlito5::JavaScript2::escape_string(($self->{"label"} || '')) . ";", "for ( " . ($self->{"cond"}->[0] ? $self->{"cond"}->[0]->emit_javascript2($level + 1) . "; " : "; ") . ($self->{"cond"}->[1] ? Perlito5::JavaScript2::to_bool($self->{"cond"}->[1], $level + 1) . "; " : "; ") . ($self->{"cond"}->[2] ? $self->{"cond"}->[2]->emit_javascript2($level + 1) . " " : '') . ") {", ["var _redo;", "do {", ["_redo = false;", "try {", [Perlito5::JavaScript2::LexicalBlock::->new("block", $body)->emit_javascript2($level + 4, "void")], "}", "catch(err) {", ["if (err instanceof p5_error && (err.v == label || err.v == '')) {", ["if (err.type == 'last') { return }", "else if (err.type == 'redo') { _redo = true }", "else if (err.type != 'next') { throw(err) }"], "}", "else {", ["throw(err)"], "}"], "}"], "} while (_redo);"], "}"))
            }
            else {
                my $cond = Perlito5::JavaScript2::to_list([$self->{"cond"}], $level + 1);
                my $topic = $self->{"topic"};
                my $decl = '';
                my $v = $topic;
                if ($v->{"decl"}) {
                    $decl = $v->{"decl"};
                    $v = $v->{"var"}
                }
                else {;
                    $decl = $v->{"_decl"} || "global"
                }
                my $namespace = $v->{"namespace"} || $v->{"_namespace"} || $Perlito5::PKG_NAME;
                my $s;
                if ($decl eq "my" || $decl eq "state") {
                    my $sig = $v->emit_javascript2($level + 1);
                    push(@str, "(function(){ " . ("var " . $sig . "; ") . "p5for_lex(" . ("function (v) { " . $sig . " = v }, ") . "function () {
" . Perlito5::JavaScript2::tab($level + 2) . (Perlito5::JavaScript2::LexicalBlock::->new("block", $body))->emit_javascript2($level + 2, $wantarray) . "
" . Perlito5::JavaScript2::tab($level + 1) . "}, " . $cond . ", " . Perlito5::AST::Block::emit_javascript2_continue($self, $level, $wantarray) . ", " . Perlito5::JavaScript2::escape_string($self->{"label"} || '') . ") " . "})()")
                }
                else {;
                    push(@str, "p5for(" . "p5make_package(" . Perlito5::JavaScript2::escape_string($namespace) . "), " . "\"v_" . ($v->{"name"}) . "\", " . "function () {" . "
" . Perlito5::JavaScript2::tab($level + 2) . (Perlito5::JavaScript2::LexicalBlock::->new("block", $body))->emit_javascript2($level + 2, $wantarray) . "
" . Perlito5::JavaScript2::tab($level + 1) . "}, " . $cond . ", " . Perlito5::AST::Block::emit_javascript2_continue($self, $level, $wantarray) . ", " . Perlito5::JavaScript2::escape_string($self->{"label"} || '') . ")")
                }
            }
            if (@str > 1) {
                $level = $old_level;
                return Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, @str)
            }
            else {;
                return join("
" . Perlito5::JavaScript2::tab($level), @str)
            }
        }
        sub Perlito5::AST::For::emit_javascript2_get_decl {;
            ()
        }
        sub Perlito5::AST::For::emit_javascript2_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Sub;
    {
        sub Perlito5::AST::Sub::emit_javascript2 {
            (my $self, my $level, my $wantarray) = @_;
            if (my $node = $self->maybe_rewrite_statevars()) {;
                return $node->emit_javascript2(@_[1 .. $#_])
            }
            my $prototype = defined($self->{"sig"}) ? Perlito5::JavaScript2::escape_string($self->{"sig"}) : "null";
            my $sub_ref = Perlito5::JavaScript2::get_label();
            local $Perlito5::AST::Sub::SUB_REF = $sub_ref;
            local $Perlito5::JavaScript2::is_inside_subroutine = 1;
            my @captured;
            for my $stmt (@{$self->{"block"}->{"stmts"}}) {;
                push(@captured, $stmt->get_captures())
            }
            my %dont_capture = map {;
                $_->{"dont"} ? ($_->{"dont"}, 1) : ()
            } @captured;
            my %capture = map {;
                $_->{"dont"} ? () : $dont_capture{$_->{"_id"}} ? () : ($_->{"_decl"} eq "local" || $_->{"_decl"} eq "global" || $_->{"_decl"} eq '') ? () : ($_->{"_id"}, $_)
            } @captured;
            my @captures_ast = map {;
                $capture{$_}
            } sort {;
                $a cmp $b
            } keys(%capture);
            local @Perlito5::CAPTURES = @captures_ast;
            my $js_block = Perlito5::JavaScript2::LexicalBlock::->new("block", $self->{"block"}->{"stmts"})->emit_javascript2_subroutine_body($level + 2, "runtime");
            my @s = ("var " . $sub_ref . ";", $sub_ref . " = function (List__, p5want) {", [$js_block], "};", $sub_ref . "._prototype_ = " . $prototype . ";", "return " . $sub_ref);
            if ($self->{"name"}) {
                my $s = Perlito5::JavaScript2::emit_wrap_javascript2($level, "scalar", @s);
                return "p5typeglob_set(" . Perlito5::JavaScript2::escape_string($self->{"namespace"}) . ", " . Perlito5::JavaScript2::escape_string($self->{"name"}) . ", " . $s . ")"
            }
            else {
                my $s = Perlito5::JavaScript2::emit_wrap_javascript2($level, "scalar", @s);
                return $s
            }
        }
        sub Perlito5::AST::Sub::emit_javascript2_get_decl {;
            ()
        }
        sub Perlito5::AST::Sub::emit_javascript2_has_regex {;
            ()
        }
    }
    1
}
{
    package main;
    package Perlito5::JavaScript2::Runtime;
    sub Perlito5::JavaScript2::Runtime::perl5_to_js {
        (my $source, my $namespace, my $want, my $scalar_hints, my $hash_hints, my $scope_js) = @_;
        local $_;
        local ${^GLOBAL_PHASE};
        local ${^H} = $scalar_hints;
        local %{^H} = %{$hash_hints};
        local @Perlito5::BASE_SCOPE = ($scope_js->[0]);
        local @Perlito5::SCOPE_STMT;
        local $Perlito5::CLOSURE_SCOPE = 0;
        local $Perlito5::PKG_NAME = $namespace;
        local @Perlito5::UNITCHECK_BLOCK;
        my $match = Perlito5::Grammar::exp_stmts($source, 0);
        if (!$match || $match->{"to"} != length($source)) {;
            die("Syntax error in eval near pos ", $match->{"to"})
        }
        my $ast = Perlito5::AST::Apply::->new("code", "do", "arguments", [Perlito5::AST::Block::->new("stmts", $match->{"capture"})]);
        $ast = $ast->emit_begin_scratchpad();
        my $js_code = $ast->emit_javascript2(0, $want);
        Perlito5::set_global_phase("UNITCHECK");
        $_->()
            while $_ = shift(@Perlito5::UNITCHECK_BLOCK);
        if ($Perlito5::JavaScript::DEBUG) {;
            print($js_code, "

")
        }
        return $js_code
    }
    sub Perlito5::JavaScript2::Runtime::eval_ast {
        (my $ast) = @_;
        my $want = 0;
        $ast = $ast->emit_begin_scratchpad();
        my $js_code = $ast->emit_javascript2(0, $want);
        Perlito5::set_global_phase("UNITCHECK");
        $_->()
            while $_ = shift(@Perlito5::UNITCHECK_BLOCK);
        if ($Perlito5::JavaScript::DEBUG) {;
            print($js_code, "

")
        }
        $_ = $js_code;
        return JS::inline("eval(\"(function(){\" + p5pkg.main.v__ + \"})()\")")
    }
    sub Perlito5::JavaScript2::Runtime::emit_javascript2 {;
        return ("//
// lib/Perlito5/JavaScript2/Runtime.js
//
// Runtime for \"Perlito\" Perl5-in-JavaScript2
//
// AUTHORS
//
// Flavio Soibelmann Glock  fglock\@gmail.com
//
// COPYRIGHT
//
// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.
//
// This program is free software; you can redistribute it and/or modify it
// under the same terms as Perl itself.
//
// See http://www.perl.com/perl/misc/Artistic.html

\"use strict\";
var isNode = typeof require != \"undefined\";

if (typeof p5pkg !== \"object\") {
    var p5pkg = {};
    var p5LOCAL = [];

    var universal = function () {};
    p5pkg.UNIVERSAL = new universal();
    p5pkg.UNIVERSAL._ref_ = \"UNIVERSAL\";
    p5pkg.UNIVERSAL.isa = function (List__) {
        var o = List__[0];
        var s = List__[1];
        var clas;
        if (typeof o === \"string\") {
            clas = p5pkg[o];
        }
        else {
            clas = o._class_;
        }
        if (!clas) {
            return false;
        }
        if (clas._ref_ == s) {
            return true;
        }
        var isa = clas.List_ISA;
        if (isa) {
            for (var i = 0; i < isa.length; i++) {
                if (isa[i] == s) {
                    return true;
                }
                if (p5pkg.UNIVERSAL.isa( isa[i], s )) {
                    return true;
                }
            }
        }
        return false;
    };
    p5pkg.UNIVERSAL.can = function (List__) {
        var o = List__[0];
        var s = List__[1];
        if (typeof o === \"string\") {
            return p5method_lookup(s, o, {})
        }
        if ( s.indexOf(\"::\") == -1 ) {
            return p5method_lookup(s, o._class_._ref_, {})
        }
        var c = s.split(\"::\");
        s = c.pop(); 
        return p5method_lookup(s, c.join(\"::\"), {});
    };
    p5pkg.UNIVERSAL.DOES = p5pkg.UNIVERSAL.can;

    var core = function () {};
    p5pkg[\"CORE\"] = new core();
    p5pkg[\"CORE\"]._ref_ = \"CORE\";

    var core_global = function () {};
    core_global.prototype = p5pkg.CORE;
    p5pkg[\"CORE::GLOBAL\"] = new core_global();
    p5pkg[\"CORE::GLOBAL\"]._ref_ = \"CORE::GLOBAL\";

    var p5_error = function (type, v) {
        this.type = type;
        this.v = this.message = v;
        this.toString = function(){
            if (this.type == 'break') {
                return 'Can\\'t \"break\" outside a given block'
            }
            if (this.type == 'next' || this.type == 'last' || this.type == 'redo') {
                if (this.v == \"\") { return 'Can\\'t \"' + this.type + '\" outside a loop block' }
                return 'Label not found for \"' + this.type + ' ' + this.v + '\"';
            }
            return this.v;
        };
    };
    p5_error.prototype = Error.prototype;
}

function p5make_package(pkg_name) {
    if (!p5pkg.hasOwnProperty(pkg_name)) {
        var tmp = function () {};
        tmp.prototype = p5pkg.CORE;
        p5pkg[pkg_name] = new tmp();
        p5pkg[pkg_name]._ref_ = pkg_name;
        p5pkg[pkg_name]._class_ = p5pkg[pkg_name];  // XXX memory leak
        p5pkg[pkg_name]._is_package_ = 1;

        // TODO - add the other package global variables
        p5pkg[pkg_name][\"List_ISA\"] = [];
        p5pkg[pkg_name][\"v_a\"] = null;
        p5pkg[pkg_name][\"v_b\"] = null;
        p5pkg[pkg_name][\"v__\"] = null;
        p5pkg[pkg_name][\"v_AUTOLOAD\"] = null;
    }
    return p5pkg[pkg_name];
}

function p5get_class_for_method(method, class_name, seen) {
    // default mro
    // TODO - cache the methods that were already looked up
    if ( p5pkg[class_name].hasOwnProperty(method) ) {
        return class_name
    }
    var isa = p5pkg[class_name].List_ISA;
    if (isa) {
        for (var i = 0; i < isa.length; i++) {
            if (!seen[isa[i]]) {
                var m = p5get_class_for_method(method, isa[i], seen);
                if (m) {
                    return m 
                }
                seen[isa[i]]++;
            }
        }
    }
}

function p5method_lookup(method, class_name, seen) {
    var c = p5get_class_for_method(method, class_name, seen);
    if (c) {
        return p5pkg[c][method]
    }
    if ( p5pkg.UNIVERSAL.hasOwnProperty(method) ) {
        return p5pkg.UNIVERSAL[method]
    }
}

function p5method_not_found(method, class_name) {
    return \"Can't locate object method \\\"\"
        + method + \"\\\" via package \\\"\" + class_name + \"\\\" (perhaps you forgot to load \\\"\"
        + class_name + \"\\\"?)\";
}

function p5call(invocant, method, list, p5want) {
    var invocant_original = invocant;
    if (typeof invocant === \"string\") {
        list.unshift(invocant);
        invocant = p5make_package(invocant);
    }
    else if ( invocant.hasOwnProperty(\"_is_package_\") ) {
        list.unshift(invocant._ref_);   // invocant is a \"package\" object
    }
    else {
        list.unshift(invocant);
    }

    if ( invocant.hasOwnProperty(\"_class_\") ) {

        if ( invocant._class_.hasOwnProperty(method) ) {
            return invocant._class_[method](list, p5want)
        }
        var m = p5method_lookup(method, invocant._class_._ref_, {});
        if (m) {
            return m(list, p5want)
        }

        // method can have an optional namespace
        var pkg_name = method.split(/::/);
        if (pkg_name.length > 1) {
            var name = pkg_name.pop();
            pkg_name = pkg_name.join(\"::\");
            m = p5method_lookup(name, pkg_name, {});
            if (m) {
                return m(list, p5want)
            }
            p5pkg.CORE.die([p5method_not_found(name, pkg_name)]);
        }

        if (method == \"print\" || method == \"printf\" || method == \"say\" || method == \"close\") {
            list.shift();
            return p5pkg['Perlito5::IO'][method]( invocant_original, list, p5want);
        }

        if (method.substr(0, 1) != \"(\"
         && method != \"import\"
         && method != \"unimport\"
         && method != \"isa\"
         && method != \"can\"
        ) {
            pkg_name = p5get_class_for_method('AUTOLOAD', invocant._class_._ref_, {}) || p5get_class_for_method('AUTOLOAD', \"UNIVERSAL\", {});
            if (pkg_name) {
                p5pkg[pkg_name][\"v_AUTOLOAD\"] = invocant._class_._ref_ + \"::\" + method;
                return p5pkg[pkg_name][\"AUTOLOAD\"](list, p5want);
            }
        }
        p5pkg.CORE.die([p5method_not_found(method, invocant._class_._ref_)]);
    }
    p5pkg.CORE.die([\"Can't call method \", method, \" on unblessed reference\"]);
}

function p5cget(namespace, name) {
    if(p5pkg[namespace].hasOwnProperty(name)) {
        return p5pkg[namespace][name]
    }
    if(p5pkg[namespace].hasOwnProperty(\"AUTOLOAD\")) {
        p5pkg[namespace][\"v_AUTOLOAD\"] = namespace + \"::\" + name;
        return p5pkg[namespace][\"AUTOLOAD\"]
    }
    p5pkg.CORE.die([\"Undefined subroutine &\" + namespace + \"::\" + name]);
}

function p5cget_by_name(namespace, name) {
    // name can be a function already
    if (typeof name === \"function\") {
        return name;
    }
    // name can have an optional namespace
    var parts = name.split(/::/);
    if (parts.length > 1) {
        name = parts.pop();
        namespace = parts.join(\"::\");
    }
    if(p5pkg[namespace].hasOwnProperty(name)) {
        return p5pkg[namespace][name]
    }
    if(p5pkg[namespace].hasOwnProperty(\"AUTOLOAD\")) {
        p5pkg[namespace][\"v_AUTOLOAD\"] = namespace + \"::\" + name;
        return p5pkg[namespace][\"AUTOLOAD\"]
    }
    p5pkg.CORE.die([\"Undefined subroutine &\" + namespace + \"::\" + name]);
}

function p5code_lookup_by_name(package_name, sub_name) {
    // sub_name can be a function already
    if (typeof sub_name === \"function\") {
        return sub_name;
    }
    // sub_name can have an optional namespace
    var parts = sub_name.split(/::/);
    if (parts.length > 1) {
        sub_name = parts.pop();
        package_name = parts.join(\"::\");
    }
    if (p5pkg.hasOwnProperty(package_name)) {
        var c = p5pkg[package_name];
        if ( c.hasOwnProperty(sub_name) ) {
            return c[sub_name]
        }
    }
    return null;
}

function p5sub_exists(name, current_pkg_name) {
    var v = name;
    var pkg_name = v.split(/::/);
    if (pkg_name.length > 1) {
        v = pkg_name.pop();
        pkg_name = pkg_name.join(\"::\");
    }
    else {
        pkg_name = current_pkg_name;
    }
    var c = v.charCodeAt(0);
    if (c < 27) {
        pkg_name = 'main';
    }
    return p5pkg.hasOwnProperty(pkg_name) && p5pkg[pkg_name].hasOwnProperty(v) 
}

function p5sub_prototype(name, current_pkg_name) {
    if (!name) {
        return null;
    }
    if (typeof name === \"function\") {
        return name._prototype_;
    }
    var v = name;
    var pkg_name = v.split(/::/);
    if (pkg_name.length > 1) {
        v = pkg_name.pop();
        pkg_name = pkg_name.join(\"::\");
    }
    else {
        pkg_name = current_pkg_name;
    }
    var c = v.charCodeAt(0);
    if (c < 27) {
        pkg_name = 'main';
    }
    if (p5pkg.hasOwnProperty(pkg_name) && p5pkg[pkg_name].hasOwnProperty(v)) {
        return p5pkg[pkg_name][v]._prototype_
    }
    return p5pkg[\"Perlito5\"].v_PROTO._hash_[name] || p5pkg[\"Perlito5\"].v_CORE_PROTO._hash_[name]
}

function p5scalar_deref(v, current_pkg_name, autoviv_type) {
    if (typeof v === \"string\") {
        var pkg_name = v.split(/::/);
        if (pkg_name.length > 1) {
            v = pkg_name.pop();
            pkg_name = pkg_name.join(\"::\");
        }
        else {
            pkg_name = current_pkg_name;
        }
        var c = v.charCodeAt(0);
        if (c < 27) {
            pkg_name = 'main';
        }
        var name = \"v_\"+v;
        if (!p5make_package(pkg_name)[name]) {
            if (autoviv_type == 'array') {
                p5pkg[pkg_name][name] = new p5ArrayRef([]);
            }
            else if (autoviv_type == 'hash') {
                p5pkg[pkg_name][name] = new p5HashRef([]);
            }
            else if (autoviv_type == 'scalar') {
                p5pkg[pkg_name][name] = new p5ScalarRef([]);
            }
        }
        return p5pkg[pkg_name][name];
    }
    if (!v._scalar_) {
        CORE.die([\"not a SCALAR reference\"]);
        // if (autoviv_type == 'array') {
        //     v._scalar_ = new p5ArrayRef([]);
        // }
        // else if (autoviv_type == 'hash') {
        //     v._scalar_ = new p5HashRef([]);
        // }
        // else if (autoviv_type == 'scalar') {
        //     v._scalar_ = new p5ScalarRef([]);
        // }
    }
    return v._scalar_;
}

function p5scalar_deref_set(v, n, current_pkg_name) {
    if (typeof v === \"string\") {
        var pkg_name = v.split(/::/);
        if (pkg_name.length > 1) {
            v = pkg_name.pop();
            pkg_name = pkg_name.join(\"::\");
        }
        else {
            pkg_name = current_pkg_name;
        }
        var c = v.charCodeAt(0);
        if (c < 27) {
            pkg_name = 'main';
        }
        var name = \"v_\"+v;
        p5make_package(pkg_name)[name] = n;
        return p5pkg[pkg_name][name];
    }
    v._scalar_ = n;
    return v._scalar_;
}

function p5array_deref(v, current_pkg_name) {
    if (typeof v === \"string\") {
        var pkg_name = v.split(/::/);
        if (pkg_name.length > 1) {
            v = pkg_name.pop();
            pkg_name = pkg_name.join(\"::\");
        }
        else {
            pkg_name = current_pkg_name;
        }
        var c = v.charCodeAt(0);
        if (c < 27) {
            pkg_name = 'main';
        }
        var name = \"List_\"+v;
        if (!p5make_package(pkg_name)[name]) {
                p5pkg[pkg_name][name] = [];
        }
        return p5pkg[pkg_name][name];
    }
    return v._array_;
}

function p5hash_deref(v, current_pkg_name) {
    if (typeof v === \"string\") {
        var pkg_name = v.split(/::/);
        if (pkg_name.length > 1) {
            v = pkg_name.pop();
            pkg_name = pkg_name.join(\"::\");
        }
        else {
            pkg_name = current_pkg_name;
        }
        var c = v.charCodeAt(0);
        if (c < 27) {
            pkg_name = 'main';
        }
        var name = \"Hash_\"+v;
        if (!p5make_package(pkg_name)[name]) {
                p5pkg[pkg_name][name] = [];
        }
        return p5pkg[pkg_name][name];
    }
    return v._hash_;
}

// regex globals
p5make_package(\"Regex\");
var p5_last_regex = new RegExp(\"\", \"\");
var p5_regex_capture = [];

p5make_package(\"main\");
p5make_package(\"Perlito5\");
p5pkg[\"Perlito5\"].v_PKG_NAME = \"main\";
p5make_package(\"main::STDIN\").file_handle = { id : 0, readline_buffer : '' };
p5make_package(\"main::STDOUT\").file_handle = { id : 1 };
p5make_package(\"main::STDERR\").file_handle = { id : 2 };
p5make_package(\"main::STDIN\")['List_ISA'] = ['Perlito5::IO'];
// p5make_package(\"main::STDOUT\")['List_ISA'] = ['Perlito5::IO'];
// p5make_package(\"main::STDERR\")['List_ISA'] = ['Perlito5::IO'];
p5make_package(\"ARGV\").file_handle = { id : null };
p5make_package(\"main\")[\"STDOUT\"] = p5pkg[\"main::STDOUT\"];
p5make_package(\"main\")[\"STDERR\"] = p5pkg[\"main::STDERR\"];
p5make_package(\"main\")[\"STDIN\"] = p5pkg[\"main::STDIN\"];
p5pkg[\"STDOUT\"] = p5pkg[\"main::STDOUT\"];
p5pkg[\"STDERR\"] = p5pkg[\"main::STDERR\"];
p5pkg[\"STDIN\"] = p5pkg[\"main::STDIN\"];
p5pkg[\"Perlito5\"].v_SELECT = \"main::STDOUT\";
p5pkg[\"main\"][\"v_\@\"] = [];      // \$\@
p5pkg[\"main\"][\"v_|\"] = 0;       // \$|
p5pkg[\"main\"][\"v_/\"] = \"\\n\";    // \$/
p5pkg[\"main\"]['v_\"'] = \" \";     // \$\"
p5pkg[\"main\"][\"List_#\"] = [];   // \@#
p5scalar_deref_set(String.fromCharCode(15), isNode ? \"node.js\" : \"javascript2\");  // \$^O
p5pkg[\"main\"][\"List_INC\"] = [];
p5pkg[\"main\"][\"Hash_INC\"] = { \"strict.pm\" : \"strict.pm\", \"feature.pm\" : \"feature.pm\", \"warnings.pm\" : \"warnings.pm\" };
p5pkg[\"main\"][\"List_ARGV\"] = [];
p5pkg[\"main\"][\"Hash_ENV\"] = {};
p5pkg[\"main\"][\"Hash_SIG\"] = {};
if (isNode) {
    p5pkg[\"main\"][\"List_ARGV\"] = process.argv.splice(2);

    p5pkg[\"main\"][\"Hash_ENV\"] = {};
    for (var e in process.env) p5pkg[\"main\"][\"Hash_ENV\"][e] = process.env[e];

    p5pkg[\"main\"][\"v_\$\"] = process.pid;   // \$\$
    p5scalar_deref_set(String.fromCharCode(24), process.argv[0]);  // \$^X
} else if (typeof arguments === \"object\") {
    p5pkg[\"main\"][\"List_ARGV\"] = arguments;
}

p5make_package(\"Perlito5::IO\");
p5make_package(\"Perlito5::Runtime\");
p5make_package(\"Perlito5::Grammar\");

var sigils = { '\@' : 'List_', '%' : 'Hash_', '\$' : 'v_', '&' : '' };

function p5typeglob_set(namespace, name, obj) {
    p5make_package(namespace);
    if ( obj.hasOwnProperty(\"_ref_\") ) {
        if ( obj._ref_ == \"HASH\" ) {
            p5pkg[namespace][sigils['%'] + name] = obj._hash_;
        }
        else if ( obj._ref_ == \"ARRAY\" ) {
            p5pkg[namespace][sigils['\@'] + name] = obj._array_;
        }
        else if ( obj._ref_ == \"SCALAR\" ) {
            p5pkg[namespace][sigils['\$'] + name] = obj._scalar_;
        }
        else if ( obj._ref_ == \"CODE\" ) {
            p5pkg[namespace][sigils['&'] + name] = obj._code_;
        }
        else if ( obj._ref_ == \"GLOB\" ) {
            // TODO
            p5pkg[namespace][name] = obj;
        }
    }
    else {
        p5pkg[namespace][name] = obj;   // native CODE
        // TODO - non-reference
    }
    return p5pkg[namespace][name];  // TODO - return GLOB
}

function p5typeglob_deref_set(v, obj, current_pkg_name) {
    if (typeof v === \"string\") {
        var pkg_name = v.split(/::/);
        if (pkg_name.length > 1) {
            v = pkg_name.pop();
            pkg_name = pkg_name.join(\"::\");
        }
        else {
            pkg_name = current_pkg_name;
        }
        return p5typeglob_set(pkg_name, v, obj);
    }
    CORE.die([\"TODO: can't p5typeglob_deref_set()\"]);
}

function p5cleanup_local(idx, value) {
    while (p5LOCAL.length > idx) {
        var l = p5LOCAL.pop();
        l();
    }
    return value;
}

//-------- Reference

var p5id = Math.floor(Math.random() * 1000000000) + 1000000000;

function p5HashRef(o) {
    this._hash_ = o;
    this._ref_ = \"HASH\";
    this.bool = function() { return 1 };
}

function p5ArrayRef(o) {
    this._array_ = o;
    this._ref_ = \"ARRAY\";
    this.bool = function() { return 1 };
}

function p5ScalarRef(o) {
    this._scalar_ = o;
    this._ref_ = \"SCALAR\";
    this.bool = function() { return 1 };
}

function p5GlobRef(o) {
    this._scalar_ = o;
    this._ref_ = \"GLOB\";
    this.bool = function() { return 1 };
}

function p5CodeRef(o) {
    this._code_ = o;
    this._ref_ = \"CODE\";
    this.bool = function() { return 1 };
}

//-------- Hash 

Object.defineProperty( Object.prototype, \"p5hget\", {
    enumerable : false,
    value : function (i) { return this[i] }
});
Object.defineProperty( Object.prototype, \"p5hset\", {
    enumerable : false,
    value : function (i, v) { this[i] = v; return this[i] }
});

Object.defineProperty( Object.prototype, \"p5incr\", {
    enumerable : false,
    value : function (i) {
        this[i] = p5incr_(this[i]);
        return this[i];
    }
});
Object.defineProperty( Object.prototype, \"p5postincr\", {
    enumerable : false,
    value : function (i) {
        var v = this[i];
        this[i] = p5incr_(this[i]);
        return v;
    }
});
Object.defineProperty( Object.prototype, \"p5decr\", {
    enumerable : false,
    value : function (i) {
        this[i] = p5decr_(this[i]);
        return this[i];
    }
});
Object.defineProperty( Object.prototype, \"p5postdecr\", {
    enumerable : false,
    value : function (i) {
        var v = this[i];
        this[i] = p5decr_(this[i]);
        return v;
    }
});

Object.defineProperty( Object.prototype, \"p5hget_array\", {
    enumerable : false,
    value : function (i) {
        if (this[i] == null) { this[i] = new p5ArrayRef([]) }
        return this[i]
    }
});
Object.defineProperty( Object.prototype, \"p5hget_hash\", {
    enumerable : false,
    value : function (i) {
        if (this[i] == null) { this[i] = new p5HashRef({}) }
        return this[i]
    }
});

//-------


var p5context = function(List__, p5want) {
    if (p5want) {
        return p5list_to_a(List__);
    }
    // scalar: return the last value
    var o = List__;
    if (o instanceof Array) {
        o =   o.length
            ? o[o.length-1]
            : null;
    }
    if (o instanceof Array) {
        o =   o.length
    }
    return o;
}

var p5list_to_a = function(args) {
    var res = [];
    for (var i = 0; i < args.length; i++) {
        var o = args[i];
        if  (  o == null
            || o._class_    // perl5 blessed reference
            || o._ref_      // perl5 un-blessed reference
            )
        {
            res.push(o);
        }
        else if (o instanceof Array) {
            // perl5 array
            for (var j = 0; j < o.length; j++) {
                res.push(o[j]);
            }
        }
        else if (typeof o === \"object\") {
            // perl5 hash
            for(var j in o) {
                if (o.hasOwnProperty(j)) {
                    res.push(j);
                    res.push(o[j]);
                }
            }
        }
        else {
            // non-ref
            res.push(o);
        }
    }
    return res;
};

var p5_list_of_refs = function(a) {
    // implements \\( \@a )
    var res = [];
    for (var i = 0; i < a.length; i++) {
        res.push(new p5ScalarRef(a[i]));
    }
    return res;
};

var p5a_to_h = function(a) {
    var res = {};
    for (var i = 0; i < a.length; i+=2) {
        res[p5str(a[i])] = a[i+1];
    }
    return res;
};

var p5idx = function(a, i) {
    return i >= 0 ? i : a.length + i
};

var p5smrt_scalar = function(a1, a2) {
    if (a2 == null) {
        return a1 == null;
    }
    if (typeof a2 == \"string\") {
        return p5str(a1) == a2;
    }
    if (typeof a2 == \"number\") {
        return p5num(a1) == a2;
    }
    CORE.die(\"Not implemented: smartmatch operator with argument type '\", (typeof a2), \"'\");
};

var p5refaddr = function(o) {
    if (o == null) {
        return null;
    }
    if (typeof o === \"object\") {
        if (o instanceof Array) {
            return null;
        }
        if ( o.hasOwnProperty(\"_ref_\") ) {
            if (!o._id_) { o._id_ = p5id++ }
            return o._id_;
        }
    }
    if (typeof o === \"function\") {
        if (!o._id_) { o._id_ = p5id++ }
        return o._id_;
    }
    return null;
};

var p5str = function(o) {
    if (o == null) {
        return \"\";
    }
    if (typeof o === \"object\") {
        if (o instanceof Array) {
            return CORE.join([\"\"].concat(o));
        }
        if ( o.hasOwnProperty(\"_ref_\") ) {
            var class_name = '';
            if (o._class_ && typeof o._class_._ref_ === \"string\") {
                // blessed reference
                // test for overload
                var meth = p5method_lookup('(\"\"', o._class_._ref_, {});
                if (meth) {
                    return p5str(meth([o], 0));
                }
                // TODO - test the \"fallback\" flag
                meth = p5method_lookup('(0+', o._class_._ref_, {});
                if (meth) {
                    return p5str(meth([o], 0));
                }
                // no overload, strigify the reference instead
                class_name = o._class_._ref_ + '=';
            }
            if (!o._id_) { o._id_ = p5id++ }
            return [class_name, o._ref_, '(0x', o._id_.toString( 16 ), ')'].join('');
        }
    }
    if (typeof o === \"function\") {
        var class_name = '';
        if (o._class_ && typeof o._class_._ref_ === \"string\") {
            // blessed reference
            class_name = o._class_._ref_ + '=';
        }
        if (!o._id_) { o._id_ = p5id++ }
        return [class_name, 'CODE(0x', o._id_.toString( 16 ), ')'].join('');
    }
    if (typeof o == \"number\" && Math.abs(o) < 0.0001 && o != 0) {
        return o.toExponential().replace(/e-(\\d)\$/,\"e-0\$1\");
    }
    if (typeof o === \"boolean\") {
        return o ? \"1\" : \"\";
    }
    if (typeof o !== \"string\") {
        return \"\" + o;
    }
    return o;
};

var p5num = function(o) {
    if (o == null) {
        return 0;
    }
    if (typeof o === \"object\") {
        if (o instanceof Array) {
            return o.length;
        }
        if ( o.hasOwnProperty(\"_ref_\") ) {
            if (o._class_ && typeof o._class_._ref_ === \"string\") {
                // blessed reference
                // test for overload
                var meth = p5method_lookup('(0+', o._class_._ref_, {});
                if (meth) {
                    return p5num(meth([o], 0));
                }
                // TODO - test the \"fallback\" flag
                meth = p5method_lookup('(\"\"', o._class_._ref_, {});
                if (meth) {
                    return p5num(meth([o], 0));
                }
            }
        }
    }
    if (typeof o !== \"number\") {
        var s = p5str(o).trim();
        var s1 = s.substr(0, 3).toUpperCase();
        if ( s1 == \"NAN\" ) { return NaN };
        if ( s1 == \"INF\" ) { return Infinity };
        s1 = s.substr(0, 4).toUpperCase();
        if ( s1 == \"-NAN\" ) { return NaN };
        if ( s1 == \"-INF\" ) { return -Infinity };
        s1 = parseFloat(s);
        if ( isNaN(s1) ) { return 0 };
        return s1;
    }
    return o;
};

var p5bool = function(o) {
    if (o) {
        if (typeof o === \"boolean\") {
            return o;
        }
        if (typeof o === \"number\") {
            return o;
        }
        if (typeof o === \"string\") {
            return o != \"\" && o != \"0\";
        }
        if (typeof o.length === \"number\") {
            return o.length;
        }
        if (o instanceof Error) {
            return true;
        }
        for (var i in o) {
            return true;
        }
    }
    return false;
};

var p5incr_ = function(o) {
    if (typeof o === \"number\") {
        return o + 1;
    }
    return p5str_inc(p5str(o));
};

var p5decr_ = function(o) {
    if (typeof o === \"number\") {
        return o - 1;
    }
    return p5num(o) - 1;
};

var p5modulo = function(o, k) {
    var m = o % k;
    if ( k < 0 && m > 0 ) {
        m = m + k;
    }
    else if ( k > 0 && m < 0 ) {
        m = m + k;
    }
    return m;
};

var p5shift_left = function(o, k) {
    return k < 31 ? o << k : o * Math.pow(2, k);
};

var p5and = function(a, fb) {
    if (p5bool(a)) {
        return fb();
    }
    return a;
};

var p5or = function(a, fb) {
    if (p5bool(a)) {
        return a;
    }
    return fb();
};

var p5defined_or = function(a, fb) {
    if (a == null) {
        return fb();
    }
    return a;
};

var p5xor = function(a, fb) {
    return p5bool(a) ? !p5bool(fb()) : fb()
};

var p5cmp = function(a, b) {
    return a > b ? 1 : a < b ? -1 : 0 
};

var p5complement = function(a) {
    return a < 0 ? ~a : 4294967295 - a
    // return a < 0 ? ~a : 18446744073709551615 - a
};

var p5str_replicate = function(o, n) {
    n = Math.floor(n);
    return n > 0 ? Array(n + 1).join(o) : \"\";
};

var p5list_replicate = function(o, n, want) {
    o = p5list_to_a([o]);
    n = p5num(n);

    if (!want) {
        return p5str_replicate(o.pop(), n);   // scalar context
    }

    var out = [];
    for(var i = 0; i < n; i++) {
        for(var j = 0; j < o.length; j++) {
            out.push(o[j]);
        }
    }
    return (want ? out : out.length)
};

var p5list_slice = function(o, ix, want) {
    var out = [];
    for (var i=0, l=ix.length; i<l; ++i) {
        if (ix[i] < o.length) {
            out[i] = o[ix[i]];
        }
    }
    if (want) { return out }
    return out.length ? out[out.length-1] : null;
}

var p5hash_slice = function(o, ix, want) {
    var out = [];
    for (var i=0, l=ix.length; i<l; ++i) {
        out.push(ix[i]);
        out.push(o[ix[i]]);
    }
    if (want) { return out }
    return out.length ? out[out.length-1] : null;
}

var p5list_lookup_slice = function(o, ix, want) {
    var out = [];
    for (var i=0, l=ix.length; i<l; ++i) {
        out[i] = o[ix[i]];
    }
    if (want) { return out }
    return out.length ? out[out.length-1] : null;
}

var p5hash_lookup_slice = function(o, ix, want) {
    var out = [];
    for (var i=0, l=ix.length; i<l; ++i) {
        out.push(ix[i]);
        out.push(o[ix[i]]);
    }
    if (want) { return out }
    return out.length ? out[out.length-1] : null;
}

var p5str_inc = function(s) {
    if (s.length < 2) {
        if ((s >= \"0\" && s <= \"8\") || (s >= \"A\" && s <= \"Y\") || (s >= \"a\" && s <= \"y\")) {
            return String.fromCharCode(s.charCodeAt(0) + 1);
        }
        if (s == \"9\") {
            return \"10\";
        }
        if (s == \"Z\") {
            return \"AA\";
        }
        if (s == \"z\") {
            return \"aa\";
        }
        return \"1\";
    }
    var c0 = s.substr(0, 1);
    if (c0 >= \"0\" && c0 <= \"9\") {
        return p5str(p5num(s)+1);
    }
    var c = p5str_inc(s.substr(s.length-1, 1));
    if (c.length == 1) {
        return s.substr(0, s.length-1) + c;
    }
    return p5str_inc(s.substr(0, s.length-1)) + c.substr(c.length-1, 1);
};

var p5looks_like_number = function(a) {
    if (typeof a === \"number\") {
        return 1;
    }
    a = a.trim();
    var s1 = a.toUpperCase();
    if ( s1 == \"NAN\" || s1 == \"INF\" || s1 == \"-NAN\" || s1 == \"-INF\" ) {
        return 1
    };
    if (s1.match(/^[\\+\\-]?[0-9]+\\.?(?:E[-+]?[0-9]+)?\$/)) {          // 999 999.
        return 1;
    }
    if (s1.match(/^[\\+\\-]?[0-9]*\\.[0-9]+(?:E[-+]?[0-9]+)?\$/)) {    // 999.999 .999
        return 1;
    }
    return 0;
}

var p5range_state = {};
var p5range = function(a, b, p5want, id, three_dots) {
    if (p5want) {
        // list context
        var tmp = [];
        if (typeof a === \"number\" || typeof b === \"number\") {
            a = p5num(a);
            b = p5num(b);
            if (isNaN(a) || isNaN(b) || a == Infinity || b == Infinity) {
                p5pkg.CORE.die([\"Range iterator outside integer range\"]);
            }
            a = CORE.int([a]);
            while (a <= b) {
                tmp.push(a);
                a++;
            }
        }
        else {
            a = p5str(a);
            b = p5str(b);
            if (a == '') {
                return [a];
            }

            if (a.substr(0, 1) != '0' && p5looks_like_number(a) && p5looks_like_number(b)) {
                // both sides look like number
                return p5range(p5num(a), p5num(b), p5want, id, three_dots)
            }

            // If the initial value specified isn't part of a magical increment sequence
            // (that is, a non-empty string matching /^[a-zA-Z]*[0-9]*\\z/ ),
            // only the initial value will be returned.
            if (!a.match(/^[a-zA-Z]*[0-9]*\$/)) {
                if (a.length > b.length) {
                    return []
                }
                return [a]
            }

            while (  (a.length < b.length)
                  || (a.length == b.length && a <= b) ) {
                tmp.push(a);
                a = p5incr_(a);
            }
        }
        return tmp;
    }
    // flip-flop operator
    var v;
    if (p5range_state[id]) {
        v = ++p5range_state[id];
        if (p5bool(b)) {
            p5range_state[id] = 0;
            v = v + \"E0\";
        }
        return v;
    }
    else {
        p5range_state[id] = 0;
        if (p5bool(a)) {
            p5range_state[id]++;
            v = p5range_state[id];
        }
        if (v && !three_dots && p5bool(b)) {
            p5range_state[id] = 0;
            v = v + \"E0\";
        }
        return v;
    }
};

var p5negative = function(o) {
    if (o == null) {
        return '-0';
    }
    if (typeof o === \"object\" && (o instanceof Array)) {
        return -(o.length);
    }
    if (typeof o !== \"number\") {
        var s = p5str(o);
        var c = s.substr(0, 1);
        if ( c == '+' ) { s = s.substr(1); return '-' + s }
        if ( c == '-' ) { s = s.substr(1); return '+' + s }
        var s1 = parseFloat(s.trim());
        if ( isNaN(s1) ) {
            if ( c.length && !c.match(/[ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz]/) ) {
                if ( s.trim().substr(0,1) == \"-\" ) { return 0 };
                return '-0';
            };
            return '-' + s
        };
        return -s1;
    }
    return -o;
};

function p5regex_s_modifier (s) {
    var cc = s.split(/(\\\\.)|/);
    var out = [];
    var is_char_class = false;
    for(var i = 0; i < cc.length; i++) {
        var c = cc[i];
        if (typeof c != \"undefined\") {
            if (c == \"[\")                    { is_char_class = true }
            if (c == \"]\" && is_char_class )  { is_char_class = false }
            if (c == \".\" && !is_char_class ) { c = \"[\\\\S\\\\s]\" }
            out.push(c);
        }
    }
    return out.join(\"\");
}

function p5regex_x_modifier (s) {
    var cc = s.split(/(\\\\.)|/);
    var out = [];
    var is_char_class = false;
    var is_comment = false;
    for(var i = 0; i < cc.length; i++) {
        var c = cc[i];
        if (typeof c != \"undefined\") {
            if (c == \"[\")                    { is_char_class = true }
            if (c == \"]\" && is_char_class )  { is_char_class = false }
            if (c == \" \" && !is_char_class ) { c = \"\" }
            if (c == \"#\" && !is_char_class ) { c = \"\"; is_comment = true }
            if (c == \"\\n\" && is_comment )    { c = \"\"; is_comment = false }
            if (is_comment)                  { c = \"\" }
            out.push(c);
        }
    }
    return out.join(\"\");
}

function p5regex_compile (s, flags) {
    if (flags.indexOf(\"s\") != -1) {
        flags = flags.replace(\"s\", \"\");
        s = p5regex_s_modifier(s);
    }
    if (flags.indexOf(\"x\") != -1) {
        flags = flags.replace(\"x\", \"\");
        s = p5regex_x_modifier(s);
    }
    return new RegExp(s, flags);
}

var p5qr = function(search, modifier) {
    // TODO - \"Regex\" stringification
    var re = p5regex_compile(search, modifier);
    return CORE.bless([(new p5ScalarRef(re)), 'Regex']);
};

var p5m = function(s, search, modifier, want) {
    // TODO - captures
    var re;
    if (search.hasOwnProperty('_scalar_')) {
        // search is a Regex object
        re = search._scalar_;
    }
    else {
        re = p5regex_compile(search, modifier);
    }

    p5_regex_capture = [];
    var res = [];
    var myArray;
    while ((myArray = re.exec(s)) !== null) {
        var m = myArray.shift();
        if (myArray.length) {
            res = res.concat(myArray);
            p5_regex_capture = p5_regex_capture.concat(myArray);
        }
        else {
            res.push(m);
        }
        if (re.lastIndex == 0) {
            return (want ? res : res.length)
        }
    }
    return (want ? res : res.length)
};

var p5s = function(s, search, fun_replace, modifier, want) {
    // TODO - captures
    var count = null;
    var re;
    if (search.hasOwnProperty('_scalar_')) {
        // search is a Regex object
        re = search._scalar_;
    }
    else {
        re = p5regex_compile(search, modifier);
    }

    p5_regex_capture = [];
    var res = [];
    var myArray;
    var last_index = 0;
    while ((myArray = re.exec(s)) !== null) {
        var m = myArray.shift();
        p5_regex_capture = [].concat(myArray);
        if (myArray.index > last_index) {
            res.push(s.substr(last_index, myArray.index - last_index));
        }
        res.push(fun_replace());
        last_index = re.lastIndex;
        if (last_index == 0) {
            count = 1;
            last_index = myArray.index + m.length;
            if (s.length > last_index) {
                res.push(s.substr(last_index, s.length - last_index));
            }
            return [res.join(''), count]
        }
        count++;
    }
    if (s.length > last_index) {
        res.push(s.substr(last_index, s.length - last_index));
    }
    return [res.join(''), count]
};

var p5tr = function(s, search, replace, modifier, want) {
    var count = 0;
    // TODO - expand character lists in spec
    // TODO - modifiers
    search = search.split(\"\");
    replace = replace.split(\"\");
    while (search.length > replace.length) {
        replace.push(replace[replace.length-1]);
    }
    var tr = {};
    for(var i = 0; i < search.length; i++) {
        tr[search[i]] = replace[i];
    }
    var res = s.split(\"\");
    for(var i = 0; i < res.length; i++) {
        if (tr.hasOwnProperty(res[i])) {
            res[i] = tr[res[i]];
            count++;
        }
    }
    return [res.join(''), count]
};

var p5chop = function(s) {
    // TODO - hash

    if (s instanceof Array) {
        // perl5 array
        var count = 0;
        var res;
        for (var j = 0; j < s.length; j++) {
            res = p5chop(p5str(s[j]));
            count = res[0];
            s[j] = res[1];
        }
        return [count, s];
    }

    s = p5str(s);
    return [s.substr(-1,1), s.substr(0,s.length-1)]
};

var p5chomp = function(s) {
    // TODO - hash
    // TODO - special cases of \$/ - empty string, reference

    if (s instanceof Array) {
        // perl5 array
        var count = 0;
        var res;
        for (var j = 0; j < s.length; j++) {
            res = p5chomp(p5str(s[j]));
            count = count + res[0];
            s[j] = res[1];
        }
        return [count, s];
    }

    s = p5str(s);
    var sep = p5pkg[\"main\"][\"v_/\"];  // \$/
    var c = s.substr(-sep.length);
    if (c == sep) {
        return [c.length, s.substr(0,s.length-sep.length)]
    }
    else {
        return [0, s]
    }
};

var p5for = function(namespace, var_name, func, args, cont, label) {
    var local_idx = p5LOCAL.length;
    var v_old = namespace[var_name];
    var _redo;
    p5LOCAL.push(function(){ namespace[var_name] = v_old });
    for(var i = 0; i < args.length; i++) {
        namespace[var_name] = args[i];
        do {
            _redo = false;
            try {
                func()
            }
            catch(err) {
                if (err instanceof p5_error && (err.v == label || err.v == '')) {
                    if (err.type == 'last') {
                        p5cleanup_local(local_idx, null);
                        return
                    }
                    else if (err.type == 'redo') { _redo = true }
                    else if (err.type != 'next') { throw(err) }
                }
                else {
                    throw(err)
                }
            }
            if (cont) {
                try {
                    if (!_redo) { cont() }
                }
                catch(err) {
                    if (err instanceof p5_error && (err.v == label || err.v == '')) {
                        if (err.type == 'last') {
                            p5cleanup_local(local_idx, null);
                            return
                        }
                        else if (err.type == 'redo') { _redo = true }
                        else if (err.type != 'next') { throw(err) }
                    }            
                    else {
                        throw(err)
                    }
                }
            }
        } while (_redo);
    }
    p5cleanup_local(local_idx, null);
};

var p5for_lex = function(set_var, func, args, cont, label) {
    var local_idx = p5LOCAL.length;
    var _redo;
    for(var i = 0; i < args.length; i++) {
        set_var(args[i]);
        do {
            _redo = false;
            try {
                func()
            }
            catch(err) {
                if (err instanceof p5_error && (err.v == label || err.v == '')) {
                    if (err.type == 'last') {
                        p5cleanup_local(local_idx, null);
                        return
                    }
                    else if (err.type == 'redo') { _redo = true }
                    else if (err.type != 'next') { throw(err) }
                }            
                else {
                    throw(err)
                }
            }
            if (cont) {
                try {
                    if (!_redo) { cont() }
                }
                catch(err) {
                    if (err instanceof p5_error && (err.v == label || err.v == '')) {
                        if (err.type == 'last') {
                            p5cleanup_local(local_idx, null);
                            return
                        }
                        else if (err.type == 'redo') { _redo = true }
                        else if (err.type != 'next') { throw(err) }
                    }            
                    else {
                        throw(err)
                    }
                }
            }
        } while (_redo);
    }
    p5cleanup_local(local_idx, null);
};

var p5block = function(set_var, func, args, cont, label) {
    var local_idx = p5LOCAL.length;
    var _redo;
    for(var i = 0; i < args.length; i++) {
        set_var(args[i]);
        do {
            _redo = false;
            try {
                return func()
            }
            catch(err) {
                if (err instanceof p5_error && (err.v == label || err.v == '')) {
                    if (err.type == 'last') {
                        p5cleanup_local(local_idx, null);
                        return
                    }
                    else if (err.type == 'redo') { _redo = true }
                    else if (err.type != 'next') { throw(err) }
                }            
                else {
                    throw(err)
                }
            }
            if (cont) {
                try {
                    if (!_redo) { cont() }
                }
                catch(err) {
                    if (err instanceof p5_error && (err.v == label || err.v == '')) {
                        if (err.type == 'last') {
                            p5cleanup_local(local_idx, null);
                            return
                        }
                        else if (err.type == 'redo') { _redo = true }
                        else if (err.type != 'next') { throw(err) }
                    }            
                    else {
                        throw(err)
                    }
                }
            }
        } while (_redo);
    }
    p5cleanup_local(local_idx, null);
};


var p5while = function(func, cond, cont, label, redo) {
    var local_idx = p5LOCAL.length;
    while (redo || p5bool(cond())) {
        redo = false;
        try {
            func()
        }
        catch(err) {
            if (err instanceof p5_error && (err.v == label || err.v == '')) {
                if (err.type == 'last') {
                    p5cleanup_local(local_idx, null);
                    return
                }
                else if (err.type == 'redo') { redo = true }
                else if (err.type != 'next') { throw(err) }
            }            
            else {
                throw(err)
            }
        }
        if (cont) {
            try {
                if (!redo) { cont() }
            }
            catch(err) {
                if (err instanceof p5_error && (err.v == label || err.v == '')) {
                    if (err.type == 'last') {
                        p5cleanup_local(local_idx, null);
                        return
                    }
                    else if (err.type == 'redo') { redo = true }
                    else if (err.type != 'next') { throw(err) }
                }            
                else {
                    throw(err)
                }
            }
        }
    }
    p5cleanup_local(local_idx, null);
};

var p5map = function(namespace, func, args) {
    var v_old = p5pkg[\"main\"][\"v__\"];
    var out = [];
    for(var i = 0; i < args.length; i++) {
        p5pkg[\"main\"][\"v__\"] = args[i];
        var o = p5list_to_a([func(1)]);
        for(var j = 0; j < o.length; j++) {
            out.push(o[j]);
        }
    }
    p5pkg[\"main\"][\"v__\"] = v_old;
    return out;
};

var p5grep = function(namespace, func, args) {
    var v_old = p5pkg[\"main\"][\"v__\"];
    var out = [];
    for(var i = 0; i < args.length; i++) {
        p5pkg[\"main\"][\"v__\"] = args[i];
        if (p5bool(func(0))) {
            out.push(args[i])
        }
    }
    p5pkg[\"main\"][\"v__\"] = v_old;
    return out;
};

var p5sort = function(namespace, func, args) {
    var a_old = namespace[\"v_a\"];
    var b_old = namespace[\"v_b\"];
    var out = 
        func == null
        ? args.sort()
        : args.sort(
            function(a, b) {
                namespace[\"v_a\"] = a;
                namespace[\"v_b\"] = b;
                return func(0);
            }
        );
    namespace[\"v_a\"] = a_old;
    namespace[\"v_b\"] = b_old;
    return out;
};

")
    }
    1
}
{
    package main;
    package Perlito5::JavaScript2::Lib;
    sub Perlito5::JavaScript2::Lib::init {;
        @Perlito5::Grammar::Use::Perlito_internal_lib_directory = ("Perlito5X/JavaScript", "Perlito5X", '')
    }
    1
}
{
    package main;
    package Perlito5::JavaScript2::Array;
    sub Perlito5::JavaScript2::Array::emit_javascript2 {;
        return ("//
// lib/Perlito5/JavaScript2/Runtime.js
//
// Runtime for \"Perlito\" Perl5-in-JavaScript2
//
// AUTHORS
//
// Flavio Soibelmann Glock  fglock\@gmail.com
//
// COPYRIGHT
//
// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.
//
// This program is free software; you can redistribute it and/or modify it
// under the same terms as Perl itself.
//
// See http://www.perl.com/perl/misc/Artistic.html

//-------- Array 

Object.defineProperty( Array.prototype, \"p5aget\", {
    enumerable : false,
    value : function (i) {
        if (i < 0) { i =  this.length + i };
        return this[i] 
    }
});
Object.defineProperty( Array.prototype, \"p5aset\", {
    enumerable : false,
    value : function (i, v) {
        if (i < 0) { i =  this.length + i };
        this[i] = v;
        return this[i]
    }
});

Object.defineProperty( Array.prototype, \"p5incr\", {
    enumerable : false,
    value : function (i) {
        if (i < 0) { i =  this.length + i };
        this[i] = p5incr_(this[i]);
        return this[i];
    }
});
Object.defineProperty( Array.prototype, \"p5postincr\", {
    enumerable : false,
    value : function (i) {
        if (i < 0) { i =  this.length + i };
        var v = this[i];
        this[i] = p5incr_(this[i]);
        return v;
    }
});
Object.defineProperty( Array.prototype, \"p5decr\", {
    enumerable : false,
    value : function (i) {
        if (i < 0) { i =  this.length + i };
        this[i] = p5decr_(this[i]);
        return this[i];
    }
});
Object.defineProperty( Array.prototype, \"p5postdecr\", {
    enumerable : false,
    value : function (i) {
        if (i < 0) { i =  this.length + i };
        var v = this[i];
        this[i] = p5decr_(this[i]);
        return v;
    }
});

Object.defineProperty( Array.prototype, \"p5aget_array\", {
    enumerable : false,
    value : function (i) {
        if (i < 0) { i =  this.length + i };
        if (this[i] == null) { this[i] = new p5ArrayRef([]) }
        return this[i]
    }
});
Object.defineProperty( Array.prototype, \"p5aget_hash\", {
    enumerable : false,
    value : function (i) {
        if (i < 0) { i =  this.length + i };
        if (this[i] == null) { this[i] = new p5HashRef({}) }
        return this[i]
    }
});
Object.defineProperty( Array.prototype, \"p5unshift\", {
    enumerable : false,
    configurable : true,
    value : function (args) { 
        for(var i = args.length-1; i >= 0; i--) {
            this.unshift(args[i]);
        }
        return this.length; 
    }
});
Object.defineProperty( Array.prototype, \"p5push\", {
    enumerable : false,
    configurable : true,
    value : function (args) { 
        for(var i = 0; i < args.length; i++) {
            this.push(args[i]);
        }
        return this.length; 
    }
});

var p5tie_array = function(v, List__) {
    var pkg_name = p5str(List__.shift());

    var res = p5call(pkg_name, 'TIEARRAY', List__, null);
    
    // TODO
    
    //  A class implementing an ordinary array should have the following methods:
    //      TIEARRAY pkg_name, LIST
    //      FETCH this, key
    //      STORE this, key, value
    //      FETCHSIZE this
    //      STORESIZE this, count
    //      CLEAR this
    //      PUSH this, LIST
    //      POP this
    //      SHIFT this
    //      UNSHIFT this, LIST
    //      SPLICE this, offset, length, LIST
    //      EXTEND this, count
    //      DESTROY this
    //      UNTIE this
    
    Object.defineProperty( v, \"p5aget\", {
        enumerable : false,
        configurable : true,
        value : function (i) {
            return p5call(res, 'FETCH', [i]);
        }
    });
    Object.defineProperty( v, \"p5aset\", {
        enumerable : false,
        configurable : true,
        value : function (i, value) {
            p5call(res, 'STORE', [i, value]);
            return value;
        }
    });
    Object.defineProperty( v, \"p5incr\", {
        enumerable : false,
        configurable : true,
        value : function (i) {
            var value = p5incr_(p5call(res, 'FETCH', [i]));
            p5call(res, 'STORE', [i, value]);
            return value;
        }
    });
    Object.defineProperty( v, \"p5postincr\", {
        enumerable : false,
        configurable : true,
        value : function (i) {
            var value = p5call(res, 'FETCH', [i]);
            p5call(res, 'STORE', [i, p5incr_(value)]);
            return value;
        }
    });
    Object.defineProperty( v, \"p5decr\", {
        enumerable : false,
        configurable : true,
        value : function (i) {
            var value = p5decr_(p5call(res, 'FETCH', [i]));
            p5call(res, 'STORE', [i, value]);
            return value;
        }
    });
    Object.defineProperty( v, \"p5postdecr\", {
        enumerable : false,
        configurable : true,
        value : function (i) {
            var value = p5call(res, 'FETCH', [i]);
            p5call(res, 'STORE', [i, p5decr_(value)]);
            return value;
        }
    });
    
    Object.defineProperty( v, \"p5aget_array\", {
        enumerable : false,
        configurable : true,
        value : function (i) {
            var value = p5call(res, 'FETCH', [i]);
            if (value == null) {
                value = new p5ArrayRef([]);
                p5call(res, 'STORE', [i, value]);
            }
            return value;
        }
    });
    Object.defineProperty( v, \"p5aget_hash\", {
        enumerable : false,
        configurable : true,
        value : function (i) {
            var value = p5call(res, 'FETCH', [i]);
            if (value == null) {
                value = new p5HashRef({});
                p5call(res, 'STORE', [i, value]);
            }
            return value;
        }
    });
    Object.defineProperty( v, \"p5untie\", {
        enumerable : false,
        configurable : true,
        value : function (i) { return p5call(res, 'UNTIE', []) }
    });
    Object.defineProperty( v, \"shift\", {
        enumerable : false,
        configurable : true,
        value : function () { return p5call(res, 'SHIFT', []) }
    });
    Object.defineProperty( v, \"pop\", {
        enumerable : false,
        configurable : true,
        value : function () { return p5call(res, 'POP', []) }
    });
    Object.defineProperty( v, \"p5unshift\", {
        enumerable : false,
        configurable : true,
        value : function (args) { 
            for(var i = args.length-1; i >= 0; i--) {
                p5call(res, 'UNSHIFT', [args[i]]);
            }
            return p5call(res, 'FETCHSIZE', []); 
        }
    });
    Object.defineProperty( v, \"p5push\", {
        enumerable : false,
        configurable : true,
        value : function (args) { 
            for(var i = 0; i < args.length; i++) {
                p5call(res, 'PUSH', [args[i]]);
            }
            return p5call(res, 'FETCHSIZE', []); 
        }
    });

    return res;
};

var p5untie_array = function(v) {
    if (v.hasOwnProperty('p5untie')) {
        var res = v.p5untie();  // call UNTIE
        delete v.p5aget;
        delete v.p5aset;
        delete v.p5incr;
        delete v.p5postincr;
        delete v.p5decr;
        delete v.p5postdecr;
        delete v.p5aget_array;
        delete v.p5aget_hash;
        delete v.p5untie;
        delete v.shift;
        delete v.pop;
        delete v.p5unshift;
        delete v.p5push;
        return res;
    }
    else {
        return null;
    }
};


function p5ArrayOfAlias(o) {

    // this is the structure that represents \@_
    // _array = [ ref, index,
    //            ref, index,
    //            ...
    //          ]

    // TODO - autovivify array cells

    this._array_ = o;

    this.p5aget = function (i) {
        if (i < 0) { i =  this.length + i };
        return this._array_[i+i][this._array_[i+i+1]]; 
    }
    this.p5aset = function (i, v) {
        if (i < 0) { i =  this.length + i };
        this._array_[i+i][this._array_[i+i+1]] = v;
        return this._array_[i+i][this._array_[i+i+1]]
    }
    this.p5incr = function (i) {
        if (i < 0) { i =  this.length + i };
        this._array_[i+i][this._array_[i+i+1]] = p5incr_(this._array_[i+i][this._array_[i+i+1]]);
        return this._array_[i+i][this._array_[i+i+1]];
    }
    this.p5postincr = function (i) {
        if (i < 0) { i =  this.length + i };
        var v = this._array_[i+i][this._array_[i+i+1]];
        this._array_[i+i][this._array_[i+i+1]] = p5incr_(this._array_[i+i][this._array_[i+i+1]]);
        return v;
    }
    this.p5decr = function (i) {
        if (i < 0) { i =  this.length + i };
        this._array_[i+i][this._array_[i+i+1]] = p5decr_(this._array_[i+i][this._array_[i+i+1]]);
        return this._array_[i+i][this._array_[i+i+1]];
    }
    this.p5postdecr = function (i) {
        if (i < 0) { i =  this.length + i };
        var v = this._array_[i+i][this._array_[i+i+1]];
        this._array_[i+i][this._array_[i+i+1]] = p5decr_(this._array_[i+i][this._array_[i+i+1]]);
        return v;
    }
    this.p5aget_array = function (i) {
        if (i < 0) { i =  this.length + i };
        if (this._array_[i+i][this._array_[i+i+1]] == null) {
            this._array_[i+i][this._array_[i+i+1]] = new p5ArrayRef([])
        }
        return this._array_[i+i][this._array_[i+i+1]]
    }
    this.p5aget_hash = function (i) {
        if (i < 0) { i =  this.length + i };
        if (this._array_[i+i][this._array_[i+i+1]] == null) {
            this._array_[i+i][this._array_[i+i+1]] = new p5HashRef({})
        }
        return this._array_[i+i][this._array_[i+i+1]]
    }
    this.p5unshift = function (args) { 
        for(var i = args.length-1; i >= 0; i--) {
            this.unshift(0);
            this.unshift([args[i]]);
        }
        return this._array_.length / 2; 
    }
    this.p5push = function (args) { 
        for(var i = 0; i < args.length; i++) {
            this.push([args[i]]);
            this.push(0);
        }
        return this._array_.length / 2; 
    }
    this.shift = function () { 
        var v0 = this._array_.shift();
        return v0[this._array_.shift()];
    }
    this.pop = function () { 
        var v1 = this._array_.pop();
        var v0 = this._array_.pop();
        return v0[v1];
    }
}


")
    }
    1
}
{
    package main;
    package Perlito5::JavaScript2::CORE;
    sub Perlito5::JavaScript2::CORE::emit_javascript2 {;
        return ("//
//
// lib/Perlito5/JavaScript2/CORE.js
//
// CORE functions for \"Perlito\" Perl5-in-JavaScript2
//
// AUTHORS
//
// Flavio Soibelmann Glock  fglock\@gmail.com
//
// COPYRIGHT
//
// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.
//
// This program is free software; you can redistribute it and/or modify it
// under the same terms as Perl itself.
//
// See http://www.perl.com/perl/misc/Artistic.html

var CORE = p5pkg.CORE;

var isNode = typeof require != \"undefined\";

") . (("if (isNode) {
    try {
        var sleep = require(\"sleep\");
        CORE.sleep = function(List__) {
            var n = p5num(List__[0]) || 1;
            sleep.usleep(n * 1000000);  // sleep for n seconds (1 second is 1000000 microseconds)
            return n;
        }
    }
    catch (err) {
        CORE.sleep = function(List__) {
            CORE.die(\"sleep() function failed. Maybe you need 'npm install sleep'?\\n\" + err);
        }
    }
}
if (!CORE.sleep) {
    CORE.sleep = function(List__) {
        CORE.die(\"sleep() not supported for this platform\");
    }
}

")) . (("if (isNode) {
    try {
        var crypt = require(\"crypt3\");
        CORE.crypt = function(List__) {
            var text = p5str(List__[0]);
            var salt = p5str(List__[1]);
            while(salt.length < 2) {
                salt += \"A\";
            }
            return crypt(text, salt);
        }
    }
    catch (err) {
        CORE.crypt = function(List__) {
            CORE.die(\"crypt() function failed. Maybe you need 'npm install crypt3'?\\n\" + err);
        }
    }
}
if (!CORE.crypt) {
    CORE.crypt = function(List__) {
        CORE.die(\"crypt() not supported for this platform\");
    }
}

")) . (("CORE.time = function(List__) {
    return CORE.int([Date.now() / 1000]);
}
")) . (("var _fmt_date = function(date) {
    return ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][date.getDay()] + ' ' +
        ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][date.getMonth()] + ' ' +
        date.getDate() + ' ' + 
        CORE.sprintf([ \"%02d:%02d:%02d \", date.getHours(), date.getMinutes(), date.getSeconds() ]) +
        date.getFullYear();
}
var _list_date = function(date) {
    var year_start = new Date(date);
    year_start.setMonth(0, 1);
    var year_day = Math.round((date-year_start)/8.64e7);

    var isdst = 0;  // not implemented

    return [date.getSeconds(),date.getMinutes(),date.getHours(),date.getDate(),
        date.getMonth(),date.getFullYear()-1900,date.getDay(),
        year_day,
        isdst
    ];
}
CORE.localtime = function(List__, want) {
    var n = List__.length ? p5num(List__[0]) : CORE.time() ;
    var date = new Date(n*1000);
    if (!want) {
        return _fmt_date(date);
    }
    return _list_date(date);
}
CORE.gmtime = function(List__, want) {
    var n = List__.length ? p5num(List__[0]) : CORE.time() ;
    var ofs = new Date().getTimezoneOffset() * 60;
    var date = new Date((n + ofs)*1000);
    if (!want) {
        return _fmt_date(date);
    }
    return _list_date(date);
}

CORE.bless = function(List__) {
    var o        = List__[0];
    var pkg_name = List__[1];
    if (typeof pkg_name === \"object\") {
        // bless {}, Class
        o._class_ = pkg_name;
        return o;
    }
    if (!p5pkg.hasOwnProperty(pkg_name)) {
        p5make_package(pkg_name);
    }
    o._class_ = p5pkg[pkg_name];
    return o;
};

CORE.caller = function(List__, want) {
    var caller = p5pkg[\"Perlito5\"].List_CALLER;
    if ( caller && caller[0] ) {
        // TODO
        return caller[0]._array_
    }
    return p5context([null, null, null], want);
};

CORE.chr = function(List__) {
    var v = p5num(List__[0]);
    return String.fromCharCode(v >= 0 ? v : 65533);
};

CORE.ord = function(List__) {
    return p5str(List__[0]).charCodeAt(0);
};

CORE.hex = function(List__) {
    var v = List__[0];

    for(var i = 0; i < v.length; i++) {
        if (v.charCodeAt(i) > 255) {
            CORE.die([\"Wide character in hex\"]);
        }
    }

    var b1 = v.substr(0,1);
    var b2 = v.substr(0,2);
    if (b1 == \"x\" || b1 == \"X\" || b2 == \"0x\" || b2 == \"0X\") {
        return CORE.oct(List__);
    }
    v = \"0x\" + v;
    return CORE.oct([v]);
};

CORE.oct = function(List__) {
    var v = List__[0];
    v = v.trim();

    for(var i = 0; i < v.length; i++) {
        if (v.charCodeAt(i) > 255) {
            CORE.die([\"Wide character in oct\"]);
        }
    }

    var b = v.substr(0,1);
    if (b == \"b\" || b == \"B\" || b == \"x\" || b == \"X\") {
        v = \"0\" + v;
    }
    b = v.substr(0,2);

    for(var i = 2; i < v.length; i++) {
        if (v.substr(i,2) == \"__\") {
            v = v.substr(0, i);
        }
    }

    var re = new RegExp('_', 'g');
    v = v.replace(re, \"\");
    var result;

    if (b == \"0b\" || b == \"0B\") {
        for(var i = 2; i < v.length; i++) {
            var c = v.substr(i,1);
            if (c >= \"0\" && c <= \"1\") {}
            else {
                v = v.substr(0, i);
            }
        }
        if (v.length == 2) { return 0 }
        result = parseInt(v.substr(2), 2);
    }
    else if (b == \"0x\" || b == \"0X\") {
        for(var i = 2; i < v.length; i++) {
            var c = v.substr(i,1);
            if (c >= \"0\" && c <= \"9\" || c >= \"A\" && c <= \"F\" || c >= \"a\" && c <= \"f\") {}
            else {
                v = v.substr(0, i);
            }
        }
        if (v.length == 2) { return 0 }
        result = parseInt(v.substr(2), 16);
    }
    else {
        result = parseInt(v, 8);
    }
    return isNaN(result) ? 0 : result;
};

CORE.abs   = function(List__) { return Math.abs(List__[0]) };
CORE.exp   = function(List__) { return Math.exp(List__[0]) };
CORE.log   = function(List__) { return Math.log(List__[0]) };
CORE.cos   = function(List__) { return Math.cos(List__[0]) };
CORE.sin   = function(List__) { return Math.sin(List__[0]) };
CORE.sqrt  = function(List__) { return Math.sqrt(List__[0]) };
CORE.atan2 = function(List__) { return Math.atan2(List__[0], List__[1]) };
CORE.int   = function(List__) { return List__[0] > 0 ? Math.floor(List__[0]) : Math.ceil(List__[0]) };

var p5rand = function(v) { return Math.random() * v };
CORE.srand = function(List__) {
    if (List__.length > 0) {
        var v = p5num(List__[0]) || 1;
        p5rand = function() {
            v = Math.sin(v) * 10000;
            return v - Math.floor(v);
        };
        return List__[0];
    }
    return CORE.int(CORE.rand(100000));
};
CORE.rand = function(List__) {
    var v = p5num(List__[0]) || 1;
    return p5rand(v);
};

CORE.lc      = function(List__) { return p5str(List__[0]).toLowerCase() };
CORE.uc      = function(List__) { return p5str(List__[0]).toUpperCase() };
CORE.fc      = function(List__) { return p5str(List__[0]).toUpperCase() };

CORE.lcfirst = function(List__) {
    var s = p5str(List__[0]);
    var c = s.length > 0 ? s.slice(0,1).toLowerCase() : \"\";
    s = s.length > 1 ? s.substr(1) : \"\";
    return c + s
};

CORE.ucfirst = function(List__) {
    var s = p5str(List__[0]);
    var c = s.length > 0 ? s.slice(0,1).toUpperCase() : \"\";
    s = s.length > 1 ? s.substr(1) : \"\";
    return c + s
};

CORE.quotemeta = function(List__) {
    var s = p5str(List__[0]);
    var out = [];
    for(var i = 0; i < s.length; i++) {
        if (s.substr(i, 1).match(/[^0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz]/)) {
            out.push(String.fromCharCode(92));
        }
        out.push(s.substr(i, 1));
    }
    return out.join(\"\");       
};

CORE.substr = function(List__) {
    var expr        = List__[0];
    var offset      = List__[1];
    var length      = List__[2];
    var replacement = List__[3];
    if (length < 0) {
        var s = p5str(expr);
        length = s.length - offset + length;
    } 
    return p5str(expr).substr(offset, length);
};

CORE.values = function(List__, p5want) {
    var o = List__[0];
    delete o[\"_each_\"];
    if (p5want) {
        if (o == null) {
            return [];
        };
        if (typeof o.values === \"function\") {
            return o.values();
        }
        var out = [];
        for (var i in o) {
            out.push(o[i]);
        }
        return out;
    }
    return CORE.keys(List__, p5want);
};

CORE.keys = function(List__, p5want) {
    var o = List__[0];
    delete o[\"_each_\"];
    if (p5want) {
        if (o == null) {
            return [];
        }
        if (typeof o.keys === \"function\") {
            return o.keys();
        }
        var out = [];
        for (var i in o) {
            out.push(i);
        }
        return out;
    }
    else {
        if (o == null) {
            return 0;
        }
        if (typeof o.keys === \"function\") {
            return p5num(o.keys());
        }
        var out = 0;
        for (var i in o) {
            out++;
        }
        return out;
    }
};

CORE.each = function(List__, p5want) {
    var o = List__[0];
    if (o.hasOwnProperty(\"_each_\")) {
        return o._each_(p5want)
    }
    var keys = CORE.keys([o], 1);
    var i = 0;
    o._each_ = function () {
        if (i < keys.length) {
            i++;
            return p5want ? [keys[i-1], o[keys[i-1]]] : keys[i-1];
        }
        i = 0;
        return p5want ? [] : null;
    };
    return o._each_(p5want);
};

CORE.reverse = function(List__, p5want) {
    var o = List__;
    if (p5want) {
        if (o == null) {
            return [];
        }
        return List__.reverse();
    }
    o = p5str(o);
    return o.split(\"\").reverse().join(\"\")
};

CORE.splice = function(List__, p5want) {
    var array  = List__.shift();
    // CORE.say([ array ]);
    var offset = p5num(List__.shift());
    var limit  = List__.length ? p5num(List__.shift()) : (array.length + 1);

    if (limit < 0) {
        limit = array.length + limit - 1;
    }

    var list = [offset, limit];
    for(var i = 0; i < List__.length; i++) {
        list = p5list_to_a([ list, List__[i] ]);
    }

    var out = array.splice.apply(array, list);
    // CORE.say([ CORE.join([\":\",array]), \" ofs=\", offset, \" lim=\", limit, \" list=\", list, \" out=\", CORE.join([\":\",out])  ]);
    return p5want ? out : out.pop();
};

CORE.join = function(List__) {
    var s = List__.shift();
    var o = [];
    for (var i = 0; i < List__.length; i++) {
        o.push(p5str(List__[i]));
    }
    return o.join(s);
};

CORE.index = function(List__) {
    var o = List__[0];
    var s = List__[1];
    try {
        return o.indexOf(s, p5num(List__[2]));
    }
    catch(err) {
        return -1;
    }
};
CORE.rindex = function(List__) {
    var o = List__[0];
    var s = List__[1];
    try {
        if (List__.length > 2) {
            var i = p5num(List__[2]);
            if (i < 0) {
                if (s.length == 0) {
                    return 0;
                }
                return -1;
            }
            return o.lastIndexOf(s, i);
        }
        return o.lastIndexOf(s);
    }
    catch(err) {
        return -1;
    }
};

CORE.length = function(List__) {
    return p5str(List__[0]).length;
};

CORE.pack    = function(List__) { CORE.warn([ \"CORE::pack not implemented\" ]) };
CORE.unpack  = function(List__) { CORE.warn([ \"CORE::unpack not implemented\" ]) };

CORE.ref = function(List__) {
    var o = List__[0];
    if (o == null) {
        return \"\";
    }
    if (o._class_ && typeof o._class_._ref_ === \"string\") {
        // blessed reference
        return o._class_._ref_;
    }
    if (typeof o._ref_ === \"string\") {
        // un-blessed reference
        return o._ref_;
    }
    if (typeof o === \"function\") {
        return \"CODE\";
    }
    return \"\";
};

CORE.split = function(List__, want) {
    var pattern = List__[0];
    var s       = p5str(List__[1]);
    var limit   = p5num(List__[2]);
    if (!want) {
        // scalar context
        return p5num(CORE.split(List__, 1));
    }
    if (limit == 0) {
        // strip trailing empty strings and undef
        var res = CORE.split([pattern, s, -1], 1);
        while (res.length && (res[res.length - 1] == '' || typeof res[res.length - 1] == \"undefined\") ) {
            res.pop()
        }
        return res;
    }
    if (s == '') {
        return []
    }
    // make sure pattern is a RegExp
    if (typeof pattern === \"object\" && (pattern instanceof RegExp)) {
        pattern = pattern.source;
    }
    else {
        pattern = p5str(pattern);
        if (pattern == \" \") {
            // single space string is special
            pattern = \"(?: |\\t|\\n)+\";
            s = s.replace(/^(?: |\\t|\\n)+/, \"\");
        }
    }
    // add \"g\", \"m\" modifiers
    var flags = \"g\";
    if (pattern.substr(0, 1) == \"^\" || pattern.substr(-1,1) == \"\$\") {
        flags = flags + \"m\";
    }
    pattern = new RegExp(pattern, flags);
    var res = [];
    var pos = 0;
    var count = 0;
    while (1) {
        if (limit > 0 && limit <= (count + 1)) {
            res.push(s.substr(pos));
            return res;
        }
        var m = pattern.exec(s);
        if (m === null) {
            // no match
            res.push(s.substr(pos));
            return res;
        }
        if (m[0].length == 0 && m.index == pos) {
            // pointer didn't move
            pattern.lastIndex = pattern.lastIndex + 1;
        }
        else {
            var part = s.substr(pos, m.index - pos);
            res.push(part);
            count++;
            pos = m.index + m[0].length;
            pattern.lastIndex = pos;
        }
        for (var i = 1; i < m.length ; i++) {
            res.push(m[i]);     // captured substrings; don't increment count
        }
    }
};


"))
    }
    1
}
{
    package main;
    package Perlito5::JavaScript2::IO;
    sub Perlito5::JavaScript2::IO::emit_javascript2 {;
        return ("//
//
// lib/Perlito5/JavaScript2/IO.js
//
// I/O functions for \"Perlito\" Perl5-in-JavaScript2
//
// AUTHORS
//
// Flavio Soibelmann Glock  fglock\@gmail.com
//
// COPYRIGHT
//
// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.
//
// This program is free software; you can redistribute it and/or modify it
// under the same terms as Perl itself.
//
// See http://www.perl.com/perl/misc/Artistic.html

var isNode = typeof require != \"undefined\";
if (isNode) {

    var fs = require(\"fs\");

    p5typeglob_set(\"Perlito5::IO\", \"print\", function (filehandle, List__, p5want) {
        try {
            var v = filehandle;
            var pkg;
            if (CORE.ref([v])) {
                // looks like a filehandle
                pkg = v;
            }
            else {
                // looks like a package name
                pkg = p5make_package(v);
            }
            if (!pkg.file_handle) {
                pkg.file_handle = {};
            }
            var handle_id = pkg.file_handle.id;
            if (handle_id == 1) {
                for (var i = 0; i < List__.length; i++) {
                    process.stdout.write(p5str(List__[i]));
                }
            }
            else if (handle_id == 2) {
                for (var i = 0; i < List__.length; i++) {
                    process.stderr.write(p5str(List__[i]));
                }
            }
            else {
                for (var i = 0; i < List__.length; i++) {
                    fs.writeSync(handle_id, p5str(List__[i]));
                }
            }
            return 1;
        }
        catch(err) {
            p5pkg[\"main\"][\"v_!\"] = err;
            return '';
        }
    } );

    var p5_extra_buffer_size = 100;
    p5typeglob_set(\"Perlito5::IO\", \"read\", function (filehandle, List__, p5want) {
        try {
            var v = filehandle;
            var length = List__.shift();
            var pkg;
            if (CORE.ref([v])) {
                // looks like a filehandle
                pkg = v;
            }
            else {
                // looks like a package name
                pkg = p5make_package(v);
            }
            if (!pkg.file_handle) {
                pkg.file_handle = {};
            }
            var handle_id = pkg.file_handle.id;

            if (!pkg.file_handle.buffer) {
                // we don't have any data yet
                var length_wanted = length + 2 * p5_extra_buffer_size;
                var buffer = new Buffer(length_wanted);
                var bytes_read = fs.readSync(handle_id, buffer, 0, length_wanted, null);
                if (bytes_read < length_wanted) {
                    pkg.file_handle.buffer_eof = 1;
                }
                pkg.file_handle.buffer = buffer;
                pkg.file_handle.buffer_start = 0;
                pkg.file_handle.buffer_end = bytes_read;
                pkg.file_handle.buffer_length = pkg.file_handle.buffer_end;
            }
            else if (pkg.file_handle.buffer_length > (length + p5_extra_buffer_size)) {
                // we have enough data
            }
            else if (!pkg.file_handle.buffer_eof) {
                // we have some data; append more data to the internal buffer
                var length_wanted = length + 2 * p5_extra_buffer_size;
                var buffer = new Buffer(pkg.file_handle.buffer_length + length_wanted);
                pkg.file_handle.buffer.copy(buffer, 0, pkg.file_handle.buffer_start, pkg.file_handle.buffer_end);
                var bytes_read = fs.readSync(handle_id, buffer, pkg.file_handle.buffer_length, length_wanted, null);
                if (bytes_read < length_wanted) {
                    pkg.file_handle.buffer_eof = 1;
                }
                pkg.file_handle.buffer = buffer;
                pkg.file_handle.buffer_start = 0;
                pkg.file_handle.buffer_end = pkg.file_handle.buffer_length + bytes_read;
                pkg.file_handle.buffer_length = pkg.file_handle.buffer_end;
            }

            var s = pkg.file_handle.buffer.toString('utf-8', pkg.file_handle.buffer_start, pkg.file_handle.buffer_end).substr(0, length);

            // how many bytes we actually used
            var buffer_used = Buffer.byteLength(s, 'utf-8');

            pkg.file_handle.buffer_start = pkg.file_handle.buffer_start + buffer_used;
            pkg.file_handle.buffer_length = pkg.file_handle.buffer_length - buffer_used;

            if ( handle_id == 0) {
                // STDIN
                pkg.file_handle.buffer_eof = (s.length ? 0 : 1);
                pkg.file_handle.eof = (s.length ? 0 : 1);
            }
            else if ( pkg.file_handle.buffer_eof && pkg.file_handle.buffer_length <= 0 ) {
                pkg.file_handle.eof = 1;
            }

            return [s.length, s];
        }
        catch(err) {
            p5pkg[\"main\"][\"v_!\"] = err;
            return [];
        }
    } );

    var p5ARGV = 0;
    (function (f) {
        p5typeglob_set(\"Perlito5::IO\", \"readline\", f);
        p5typeglob_set(\"Perlito5::IO\", \"getline\", f);
    })(function (List__, p5want) {
        var filehandle = List__.shift();

        if (p5want) {
            var out = [];
            while (1) {
                var s = p5pkg[\"Perlito5::IO\"].readline([filehandle], 0);
                if (s == null) {
                    return out;
                }
                out.push(s);
            }
        }

        var v = filehandle;
        var pkg;
        if (CORE.ref([v])) {
            // looks like a filehandle
            pkg = v;
        }
        else {
            // looks like a package name
            pkg = p5make_package(v);
            if (v == \"ARGV\") {
                // ARGV is magical
                if (pkg.file_handle.id == null) {
                    if (!p5ARGV) {
                        if (p5pkg[\"main\"][\"List_ARGV\"].length == 0) {
                            p5pkg[\"main\"][\"List_ARGV\"].push('-');
                        }
                    }
                    p5ARGV = 1;
                    // TODO - open \$ARGV[1], ...
                    var filename = p5pkg[\"main\"][\"List_ARGV\"].shift();
                    CORE.open([ \"ARGV\", \"<\", filename ]) || CORE.die([ p5pkg[\"main\"][\"v_!\"] ]);
                }
            }
        }
        if (!pkg.file_handle) {
            pkg.file_handle = {};
        }

        if (CORE.eof([v])) {
            return null;
        }

        var separator = p5pkg[\"main\"][\"v_/\"];  // input record separator
        var buf = pkg.file_handle.readline_buffer;
        var pos;

        if (separator) {
            pos = buf.indexOf(separator);
            while ( pos < 0 && !pkg.file_handle.eof ) {
                var r = p5pkg[\"Perlito5::IO\"].read(filehandle, [100]);
                buf = buf + r[1];
                pos = buf.indexOf(separator);
            }
        }
        else {
            // no separator
            pos = -1;
            while ( !pkg.file_handle.eof ) {
                var r = p5pkg[\"Perlito5::IO\"].read(filehandle, [100]);
                buf = buf + r[1];
            }
        }

        if (pos < 0) {
            pkg.file_handle.readline_buffer = '';
            if (!buf.length) {
                pkg.file_handle.readline_buffer = '';
                pkg.file_handle.eof = 1;
                return null
            }
            return buf;
        }
        var s = buf.substr(0, pos + separator.length);
        pkg.file_handle.readline_buffer = buf.substr(pos + separator.length);
        if (!s.length) {
            pkg.file_handle.readline_buffer = '';
            pkg.file_handle.eof = 1;
            return null
        }
        return s;
    });

    p5typeglob_set(\"Perlito5::IO\", \"close\", function (filehandle, List__, p5want) {
        try {
            var v = filehandle;
            var pkg;
            if (CORE.ref([v])) {
                // looks like a filehandle
                pkg = v;
            }
            else {
                // looks like a package name
                pkg = p5make_package(v);
            }
            if (!pkg.file_handle) {
                pkg.file_handle = {};
            }
            var handle_id = pkg.file_handle.id;
            if (handle_id == 1) {
                process.stdout.close();
            }
            else if (handle_id == 2) {
                process.stderr.close();
            }
            else {
                fs.closeSync(handle_id);
            }
            pkg.file_handle.id = null;
            return 1;
        }
        catch(err) {
            p5pkg[\"main\"][\"v_!\"] = err;
            return '';
        }
    } );

    CORE.eof = function(List__) {
        try {
            var filehandle = List__.shift();
            var v = filehandle;
            var pkg;
            if (CORE.ref([v])) {
                // looks like a filehandle
                pkg = v;
            }
            else {
                // looks like a package name
                pkg = p5make_package(v);
            }
            if (!pkg.file_handle) {
                pkg.file_handle = {};
            }
            var handle_id = pkg.file_handle.id;
            if (handle_id == null) {
                return 1;  // file is not open
            }
            return pkg.file_handle.eof && pkg.file_handle.readline_buffer.length == 0;
        }
        catch(err) {
            p5pkg[\"main\"][\"v_!\"] = err;
            return '';
        }
    };

    CORE.open = function(List__) {
        try {
            var filehandle = List__.shift();
            var flags = List__.shift();
            var path;
            if (List__.length) {
                path = List__.shift();
            }
            else {
                // 2-argument open
                var re = new RegExp(\"^([<>+|]*)(.*)\$\", \"\");
                var capture = re.exec(flags);
                flags = capture[1];
                path = capture[2];
            }
            var v = filehandle;
            var pkg;
            if (CORE.ref([v])) {
                // looks like a filehandle
                pkg = v;
            }
            else {
                // looks like a package name
                pkg = p5make_package(v);
                if (path == \"-\") {
                    if (flags == '>' || flags == '>>' || flags == '+>' || flags == '+>>') {
                        pkg.file_handle = p5pkg[\"STDOUT\"].file_handle;
                    }
                    else {
                        pkg.file_handle = p5pkg[\"STDIN\"].file_handle;
                    }
                }
            }
            if (!pkg.file_handle) {
                pkg.file_handle = {};
            }
            var handle_id = pkg.file_handle.id;
            if (handle_id != null) {
                if (handle_id < 2) {
                    return 1;   // STDIN, STDOUT, STDERR
                }
                p5pkg[\"Perlito5::IO\"].close(filehandle, []);
            }
            if (flags == '>') {
                flags = 'w'
            }
            else if (flags == '>>') {
                flags = 'a'
            }
            else if (flags == '<' || flags == '' || flags == '<:encoding(UTF-8)') {
                flags = 'r'
            }
            else if (flags == '+>') {
                flags = 'w+'
            }
            else if (flags == '+>>') {
                flags = 'a+'
            }
            else if (flags == '+<') {
                flags = 'r+'
            }
            else {
                CORE.die([ \"don't know what to do with MODE '\", flags, \"'\" ]);
            }
            var id = fs.openSync(path, flags);
            pkg.file_handle = { id : id, readline_buffer : '' };
            return 1;
        }
        catch(err) {
            p5pkg[\"main\"][\"v_!\"] = err;
            return '';
        }
    };

    var p5atime = function(s) {
        try {
            var stat = fs.statSync(s); return stat[\"atime\"];
        }
        catch(err) {
            return '';
        }
    };
    var p5mtime = function(s) {
        try {
            var stat = fs.statSync(s); return stat[\"mtime\"];
        }
        catch(err) {
            return '';
        }
    };
    var p5ctime = function(s) {
        try {
            var stat = fs.statSync(s); return stat[\"ctime\"];
        }
        catch(err) {
            return '';
        }
    };
    var p5size = function(s) {
        try {
            var stat = fs.statSync(s); return stat[\"size\"];
        }
        catch(err) {
            return '';
        }
    };
    var p5is_file = function(s) {
        try {
            var stat = fs.statSync(s); return stat.isFile() ? 1 : 0;
        }
        catch(err) {
            return '';
        }
    };
    var p5is_directory = function(s) {
        try {
            var stat = fs.statSync(s); return stat.isDirectory() ? 1 : 0;
        }
        catch(err) {
            return '';
        }
    };
    var p5file_exists = function(s) {
        return p5is_file(s) || p5is_directory(s);
    };
    var p5is_pipe = function(s) {
        try {
            var stat = fs.statSync(s);
            return stat.isFIFO() ? 1 : \"\";
        }
        catch(err) {
            try {
                var filehandle = s;
                var v = filehandle;
                var pkg;
                if (CORE.ref([v])) {
                    // looks like a filehandle
                    pkg = v;
                }
                else {
                    // looks like a package name
                    pkg = p5make_package(v);
                }
                if (!pkg.file_handle) {
                    pkg.file_handle = {};
                }
                var handle_id = pkg.file_handle.id;
                if (handle_id == 0) {
                    return process.stdin.isTTY ? \"\" : 1;
                }
                else if (handle_id == 1) {
                    return process.stdout.isTTY ? \"\" : 1;
                }
                else if (handle_id == 2) {
                    return process.stderr.isTTY ? \"\" : 1;
                }
            }
            catch(err) {
            }
        }
        return '';
    };

    CORE.binmode = function(List__) {
        try {
            // TODO
            return 1;
        }
        catch(err) {
            p5pkg[\"main\"][\"v_!\"] = err;
            return '';
        }
    };

    CORE.rmdir = function(List__) {
        try {
            fs.rmdir(p5str(List__[0]));
            return 1;
        }
        catch(err) {
            p5pkg[\"main\"][\"v_!\"] = err;
            return '';
        }
    };

    CORE.chdir = function(List__) {
        try {
            process.chdir(p5str(List__[0]));
            return 1;
        }
        catch(err) {
            p5pkg[\"main\"][\"v_!\"] = err;
            return '';
        }
    };

    CORE.exit = function(List__) {
        process.exit(List__[0]);
    };

    CORE.rename = function(List__) {
        try {
            fs.renameSync(p5str(List__[0]), p5str(List__[1]));
            return 1;
        }
        catch(err) {
            p5pkg[\"main\"][\"v_!\"] = err;
            return '';
        }
    };

    CORE.unlink = function(List__) {
        var count = 0;
        try {
            for(var i = 0; i < List__.length; i++) {
                fs.unlinkSync(p5str(List__[i]));
                count++;
            }
            return count;
        }
        catch(err) {
            p5pkg[\"main\"][\"v_!\"] = err;
            return count;
        }
    };

} else {
    // not running in node.js
    p5typeglob_set(\"Perlito5::IO\", \"print\", function (filehandle, List__, p5want) {
        var s = \"\";
        for (var i = 0; i < List__.length; i++) {
            s = s + p5str(List__[i]);
        }
        if (console && typeof console.log === 'function') {
            console.log(s);
        }
        else if (typeof write === 'function') {
            // d8 shell uses \"write\"
            write(s);
        }
        else if (typeof print === 'function') {
            // Rhino uses \"print\"
            print(s);
        }
        else {
            alert(s);
        }
        return 1;
    });
}

p5typeglob_set(\"Perlito5::IO\", \"say\", function (filehandle, List__, p5want) {
    p5pkg['Perlito5::IO'].print( filehandle, List__);
    p5pkg['Perlito5::IO'].print( filehandle, [\"\\n\"]);
    return 1;
} );
p5typeglob_set(\"Perlito5::IO\", \"printf\", function (filehandle, List__, p5want) {
    p5pkg[\"Perlito5::IO\"].print( filehandle, CORE.sprintf(List__));
    return 1;
} );

CORE.select = function(List__) {
    if (List__.length == 1) {
        var v = List__[0];
        p5pkg[\"Perlito5\"].v_SELECT = v;
    }
    return p5pkg[\"Perlito5\"].v_SELECT;
};

CORE.die = function(List__) {
    var i;
    var s = \"\";
    for (var i = 0; i < List__.length; i++) {
        s = s + p5str(List__[i]);
    }
    if (s.substr(-1, 1) != \"\\n\") {
        try {
            if (s == \"\") {
                s = \"Died\";
            }
            s = s + \" at \" + p5pkg[\"Perlito5\"].v_FILE_NAME + \" line \" + p5pkg[\"Perlito5\"].v_LINE_NUMBER;
            s = s + \"\\n\" + new Error().stack + \"\\n\";
        }
        catch(err) { }
    }
    p5pkg[\"main\"][\"v_\@\"] = s;
    throw(new p5_error(\"die\", s));
};

CORE.say = function(List__) {
    return p5pkg['Perlito5::IO'].say( 'STDOUT', List__);
};
CORE.print = function(List__) {
    return p5pkg['Perlito5::IO'].print( 'STDOUT', List__);
};
CORE.printf = function(List__) {
    return p5pkg['Perlito5::IO'].printf( 'STDOUT', List__);
};
CORE.readline = function(List__, p5want) {
    return p5pkg['Perlito5::IO'].readline(List__, p5want);
};

CORE.warn = function(List__) {
    var i;
    var s = \"\";
    for (var i = 0; i < List__.length; i++) {
        s = s + p5str(List__[i]);
    }
    if (s.substr(-1, 1) != \"\\n\") {
        try {
            if (s == \"\") {
                s = \"Warning: something's wrong\";
            }
            s = s + \" at \" + p5pkg[\"Perlito5\"].v_FILE_NAME + \" line \" + p5pkg[\"Perlito5\"].v_LINE_NUMBER;
            s = s + \"\\n\" + new Error().stack + \"\\n\";
        }
        catch(err) { }
    }
    p5pkg['Perlito5::IO'].print( 'STDERR', [s]);
};


")
    }
    1
}
{
    package main;
    package Perlito5::JavaScript2::Sprintf;
    sub Perlito5::JavaScript2::Sprintf::emit_javascript2 {;
        return ("/**
 * Copyright (c) 2010 Jakob Westhoff
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the \"Software\"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

CORE.sprintf = function(List__) {
    var format = List__.shift();
    var list = List__;

    // Check for format definition
    if ( typeof format != 'string' ) {
        CORE.die([\"sprintf: The first arguments need to be a valid format string.\"]);
    }
    
    /**
     * Define the regex to match a formating string
     * The regex consists of the following parts:
     * percent sign to indicate the start
     * (optional) sign specifier
     * (optional) padding specifier
     * (optional) alignment specifier
     * (optional) width specifier
     * (optional) precision specifier
     * type specifier:
     *  % - literal percent sign
     *  b - binary number
     *  c - ASCII character represented by the given value
     *  d - signed decimal number
     *  f - floating point value
     *  o - octal number
     *  s - string
     *  x - hexadecimal number (lowercase characters)
     *  X - hexadecimal number (uppercase characters)
     */
    var r = new RegExp( /%(\\+)?([0 ]|'(.))?(-)?([0-9]+)?(\\.([0-9]+))?([%bcdfosxX])/g );

    /**
     * Each format string is splitted into the following parts:
     * 0: Full format string
     * 1: sign specifier (+)
     * 2: padding specifier (0/<space>/'<any char>)
     * 3: if the padding character starts with a ' this will be the real 
     *    padding character
     * 4: alignment specifier
     * 5: width specifier
     * 6: precision specifier including the dot
     * 7: precision specifier without the dot
     * 8: type specifier
     */
    var parts      = [];
    var paramIndex = 0;
    var part;
    while ( part = r.exec( format ) ) {
        // Check if an input value has been provided, for the current
        // format string
        if ( paramIndex >= list.length ) {
            CORE.die([\"sprintf: At least one argument was missing.\"]);
        }

        parts[parts.length] = {
            /* beginning of the part in the string */
            begin: part.index,
            /* end of the part in the string */
            end: part.index + part[0].length,
            /* force sign */
            sign: ( part[1] == '+' ),
            /* is the given data negative */
            negative: ( parseInt( list[paramIndex] ) < 0 ) ? true : false,
            /* padding character (default: <space>) */
            padding: ( part[2] == undefined )
                     ? ( ' ' ) /* default */
                     : ( ( part[2].substring( 0, 1 ) == \"'\" ) 
                         ? ( part[3] ) /* use special char */
                         : ( part[2] ) /* use normal <space> or zero */
                       ),
            /* should the output be aligned left?*/
            alignLeft: ( part[4] == '-' ),
            /* width specifier (number or false) */
            width: ( part[5] != undefined ) ? part[5] : false,
            /* precision specifier (number or false) */
            precision: ( part[7] != undefined ) ? part[7] : false,
            /* type specifier */
            type: part[8],
            /* the given data associated with this part converted to a string */
            data: ( part[8] != '%' ) ? String ( list[paramIndex++] ) : false
        };
    }

    var newString = \"\";
    var start = 0;
    // Generate our new formated string
    for( var i=0; i<parts.length; ++i ) {
        // Add first unformated string part
        newString += format.substring( start, parts[i].begin );
        
        // Mark the new string start
        start = parts[i].end;

        // Create the appropriate preformat substitution
        // This substitution is only the correct type conversion. All the
        // different options and flags haven't been applied to it at this
        // point
        var preSubstitution = \"\";
        switch ( parts[i].type ) {
            case '%':
                preSubstitution = \"%\";
            break;
            case 'b':
                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 2 );
            break;
            case 'c':
                preSubstitution = String.fromCharCode( Math.abs( parseInt( parts[i].data ) ) );
            break;
            case 'd':
                preSubstitution = String( Math.abs( parseInt( parts[i].data ) ) );
            break;
            case 'f':
                preSubstitution = ( parts[i].precision == false )
                                  ? ( String( ( Math.abs( parseFloat( parts[i].data ) ) ) ) )
                                  : ( Math.abs( parseFloat( parts[i].data ) ).toFixed( parts[i].precision ) );
            break;
            case 'o':
                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 8 );
            break;
            case 's':
                preSubstitution = parts[i].data.substring( 0, parts[i].precision ? parts[i].precision : parts[i].data.length ); /* Cut if precision is defined */
            break;
            case 'x':
                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 16 ).toLowerCase();
            break;
            case 'X':
                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 16 ).toUpperCase();
            break;
            default:
                throw 'sprintf: Unknown type \"' + parts[i].type + '\" detected. This should never happen. Maybe the regex is wrong.';
        }

        // The % character is a special type and does not need further processing
        if ( parts[i].type ==  \"%\" ) {
            newString += preSubstitution;
            continue;
        }

        // Modify the preSubstitution by taking sign, padding and width
        // into account

        // Pad the string based on the given width
        if ( parts[i].width != false ) {
            // Padding needed?
            if ( parts[i].width > preSubstitution.length ) 
            {
                var origLength = preSubstitution.length;
                for( var j = 0; j < parts[i].width - origLength; ++j ) 
                {
                    preSubstitution = ( parts[i].alignLeft == true ) 
                                      ? ( preSubstitution + parts[i].padding )
                                      : ( parts[i].padding + preSubstitution );
                }
            }
        }

        // Add a sign symbol if neccessary or enforced, but only if we are
        // not handling a string
        if ( parts[i].type == 'b' 
          || parts[i].type == 'd' 
          || parts[i].type == 'o' 
          || parts[i].type == 'f' 
          || parts[i].type == 'x' 
          || parts[i].type == 'X' ) {
            if ( parts[i].negative == true ) {
                preSubstitution = \"-\" + preSubstitution;
            }
            else if ( parts[i].sign == true ) {
                preSubstitution = \"+\" + preSubstitution;
            }
        }

        // Add the substitution to the new string
        newString += preSubstitution;
    }

    // Add the last part of the given format string, which may still be there
    newString += format.substring( start, format.length );

    return newString;
};

")
    }
    1
}
{
    package main;
    package Perlito5::Perl5;
    {
        sub Perlito5::Perl5::escape_string {;
            return Perlito5::Dumper::escape_string($_[0])
        }
        sub Perlito5::Perl5::emit_perl5_block {
            my $block = $_[0];
            return ["block", map {;
                defined($_) && $_->emit_perl5()
            } @{$block}]
        }
    }
    package Perlito5::AST::CompUnit;
    {
        sub Perlito5::AST::CompUnit::emit_perl5 {
            my $self = $_[0];
            return ["block", (["stmt", ["keyword", "package"], ["bareword", $self->{"name"}]], map {;
                defined($_) && $_->emit_perl5()
            } @{$self->{"body"}})]
        }
        sub Perlito5::AST::CompUnit::emit_perl5_program {
            my $comp_units = $_[0];
            return ["comment", Perlito5::Compiler::do_not_edit("#")], map {;
                $_->emit_perl5()
            } map {;
                ref($_) eq "ARRAY" ? @{$_} : $_
            } @{$comp_units}
        }
    }
    package Perlito5::AST::Int;
    {;
        sub Perlito5::AST::Int::emit_perl5 {
            my $self = $_[0];
            ["number", $self->{"int"}]
        }
    }
    package Perlito5::AST::Num;
    {;
        sub Perlito5::AST::Num::emit_perl5 {
            my $self = $_[0];
            ["number", $self->{"num"}]
        }
    }
    package Perlito5::AST::Buf;
    {;
        sub Perlito5::AST::Buf::emit_perl5 {
            my $self = $_[0];
            if ($self->{"is_vstring"}) {;
                return join(".", map {;
                    ord($_)
                } split(m//, $self->{"buf"}))
            }
            Perlito5::Perl5::escape_string($self->{"buf"})
        }
    }
    package Perlito5::AST::Block;
    {;
        sub Perlito5::AST::Block::emit_perl5 {
            my $self = $_[0];
            my @out;
            $self->{"label"} && push(@out, ["label", $self->{"label"}]);
            if ($self->{"name"}) {;
                push(@out, ["stmt", ["keyword", $self->{"name"}], Perlito5::Perl5::emit_perl5_block($self->{"stmts"})])
            }
            else {;
                push(@out, Perlito5::Perl5::emit_perl5_block($self->{"stmts"}))
            }
            if ($self->{"continue"} && @{$self->{"continue"}->{"stmts"}}) {;
                push(@out, ["stmt", ["keyword", "continue"], Perlito5::Perl5::emit_perl5_block($self->{"continue"}->{"stmts"})])
            }
            return @out
        }
    }
    package Perlito5::AST::Index;
    {;
        sub Perlito5::AST::Index::emit_perl5 {
            my $self = $_[0];
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\@>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && ($self->{"obj"}->sigil() eq "\$" || $self->{"obj"}->sigil() eq "\@"))) {;
                return ["apply", "[", $self->{"obj"}->emit_perl5(), $self->{"index_exp"}->emit_perl5()]
            }
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<%>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && ($self->{"obj"}->sigil() eq "%"))) {;
                return ["apply", "[", $self->{"obj"}->emit_perl5(), $self->{"index_exp"}->emit_perl5()]
            }
            if ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\$>") {;
                return ["op", "infix:<->>", $self->{"obj"}->{"arguments"}->[0]->emit_perl5(), ["op", "circumfix:<[ ]>", $self->{"index_exp"}->emit_perl5()]]
            }
            return ["op", "infix:<->>", $self->{"obj"}->emit_perl5(), ["op", "circumfix:<[ ]>", $self->{"index_exp"}->emit_perl5()]]
        }
    }
    package Perlito5::AST::Lookup;
    {;
        sub Perlito5::AST::Lookup::emit_perl5 {
            my $self = $_[0];
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\@>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && ($self->{"obj"}->sigil() eq "\$" || $self->{"obj"}->sigil() eq "\@"))) {;
                return ["apply", "{", $self->{"obj"}->emit_perl5(), $self->autoquote($self->{"index_exp"})->emit_perl5()]
            }
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<%>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && ($self->{"obj"}->sigil() eq "%"))) {;
                return ["apply", "{", $self->{"obj"}->emit_perl5(), $self->autoquote($self->{"index_exp"})->emit_perl5()]
            }
            if ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\$>") {;
                return ["op", "infix:<->>", $self->{"obj"}->{"arguments"}->[0]->emit_perl5(), ["op", "circumfix:<{ }>", $self->autoquote($self->{"index_exp"})->emit_perl5()]]
            }
            return ["op", "infix:<->>", $self->{"obj"}->emit_perl5(), ["op", "circumfix:<{ }>", $self->autoquote($self->{"index_exp"})->emit_perl5()]]
        }
    }
    package Perlito5::AST::Var;
    {;
        sub Perlito5::AST::Var::emit_perl5 {
            my $self = $_[0];
            $self = $self->to_begin_scratchpad();
            my $str_name = $self->{"name"};
            my $c = substr($str_name, 0, 1);
            if ($c ne '' && $c lt " " && $self->{"sigil"} ne "::") {;
                return ($self->{"sigil"}) . "{^" . chr((ord($c) + ord("A")) - 1) . substr($str_name, 1) . "}"
            }
            my $ns = '';
            if ($self->{"namespace"}) {
                $self->{"sigil"} eq "::" && return ($self->{"namespace"}) . "::";
                if ($self->{"namespace"} eq "main" && substr($str_name, 0, 1) eq "^") {;
                    return ($self->{"sigil"}) . "{" . $str_name . "}"
                }
                else {;
                    $ns = ($self->{"namespace"}) . "::"
                }
            }
            if (($c ge "a" && $c le "z") || ($c ge "A" && $c le "Z") || ($c eq "_") || ($str_name eq "/" || $str_name eq "&") || ((0 + $str_name) eq $str_name)) {;
                return ($self->{"sigil"}) . $ns . $str_name
            }
            return ($self->{"sigil"}) . "{" . Perlito5::Perl5::escape_string($ns . $str_name) . "}"
        }
    }
    package Perlito5::AST::Call;
    {;
        sub Perlito5::AST::Call::emit_perl5 {
            my $self = $_[0];
            my $invocant = $self->{"invocant"}->emit_perl5();
            if ($self->{"method"} eq "postcircumfix:<[ ]>") {;
                return ["op", "infix:<->>", $invocant, ["op", "circumfix:<[ ]>", $self->{"arguments"}->emit_perl5()]]
            }
            if ($self->{"method"} eq "postcircumfix:<{ }>") {;
                return ["op", "infix:<->>", $invocant, ["op", "circumfix:<{ }>", Perlito5::AST::Lookup::->autoquote($self->{"arguments"})->emit_perl5()]]
            }
            my $meth = $self->{"method"};
            if ($meth eq "postcircumfix:<( )>") {;
                $meth = ''
            }
            if (ref($meth)) {;
                $meth = $meth->emit_perl5()
            }
            if ($meth) {;
                return ["call", $invocant, $meth, map {;
                    $_->emit_perl5()
                } @{$self->{"arguments"}}]
            }
            return ["op", "infix:<->>", $invocant, ["op", "list:<,>", map {;
                $_->emit_perl5()
            } @{$self->{"arguments"}}]]
        }
    }
    package Perlito5::AST::Apply;
    {
        sub Perlito5::AST::Apply::emit_perl5_args {
            my $self = $_[0];
            !$self->{"arguments"} && return ();
            return map {;
                $_->emit_perl5()
            } @{$self->{"arguments"}}
        }
        sub Perlito5::AST::Apply::emit_perl5_choose_regex_quote {
            if (!(grep {;
                $_ =~ m!/!
            } @_)) {;
                return "/"
            }
            if (!(grep {;
                $_ =~ m/!/
            } @_)) {;
                return "!"
            }
            if (!(grep {;
                $_ =~ m/%/
            } @_)) {;
                return "%"
            }
            if (!(grep {;
                $_ =~ m/:/
            } @_)) {;
                return ":"
            }
            if (!(grep {;
                $_ =~ m/;/
            } @_)) {;
                return ";"
            }
            return "^"
        }
        sub Perlito5::AST::Apply::emit_perl5_regex_expression {
            my $ast = $_[0];
            if ($ast->isa("Perlito5::AST::Buf")) {
                my $replace = $ast->{"buf"};
                return $replace
            }
            if ($ast->isa("Perlito5::AST::Apply") && $ast->{"code"} eq "list:<.>") {
                my $s = '';
                for my $a (@{$ast->{"arguments"}}) {;
                    $s .= Perlito5::AST::Apply::emit_perl5_regex_expression($a)
                }
                return $s
            }
            my $out = [];
            Perlito5::Perl5::PrettyPrinter::pretty_print([$ast->emit_perl5()], 0, $out);
            my $code = join('', @{$out});
            chomp($code);
            return $code
        }
        sub Perlito5::AST::Apply::emit_perl5 {
            my $self = $_[0];
            if (ref($self->{"code"})) {
                my $code = $self->{"code"};
                if (ref($code) eq "Perlito5::AST::Apply" && $code->code() eq "prefix:<&>") {;
                    return ["apply", "(", $code->emit_perl5(), $self->emit_perl5_args()]
                }
                return ["op", "infix:<->>", $self->{"code"}->emit_perl5(), $self->emit_perl5_args()]
            }
            if ($self->{"code"} eq "infix:<=>>") {;
                return ["op", $self->{"code"}, Perlito5::AST::Lookup::->autoquote($self->{"arguments"}->[0])->emit_perl5(), $self->{"arguments"}->[1]->emit_perl5()]
            }
            if ($self->{"namespace"} eq "Perlito5") {;
                if ($self->{"code"} eq "eval_ast") {;
                    $self->{"namespace"} = "Perlito5::Perl5::Runtime"
                }
            }
            my $ns = '';
            if ($self->{"namespace"}) {;
                $ns = ($self->{"namespace"}) . "::"
            }
            my $code = $ns . ($self->{"code"});
            if ($code eq "circumfix:<{ }>" && @{$self->{"arguments"}} == 1) {;
                return ["op", $code, $self->{"arguments"}->[0]->emit_perl5(), '']
            }
            if ($code eq "prefix:<\$>" || $code eq "prefix:<\@>" || $code eq "prefix:<%>" || $code eq "prefix:<&>" || $code eq "prefix:<*>" || $code eq "prefix:<\$#>") {
                my $arg = $self->{"arguments"}->[0];
                if (ref($arg) eq "Perlito5::AST::Apply" && $arg->{"code"} eq "do") {
                    my $arg = $arg->{"arguments"}->[0];
                    if (ref($arg) eq "Perlito5::AST::Block") {;
                        return ["op", $code, $arg->emit_perl5()]
                    }
                }
                $code =~ m/<([^>]+)>/;
                my $cap = $1;
                return ["apply", "{", $cap, $arg->emit_perl5()]
            }
            if (($code eq "eval" || $code eq "do") && ref($self->{"arguments"}->[0]) eq "Perlito5::AST::Block") {;
                return ["op", "prefix:<" . $code . ">", $self->{"arguments"}->[0]->emit_perl5()]
            }
            if ($Perlito5::Perl5::PrettyPrinter::op{$self->{"code"}}) {;
                return ["op", $self->{"code"}, $self->emit_perl5_args()]
            }
            if ($self->{"code"} eq "p5:s") {
                my $replace0 = Perlito5::AST::Apply::emit_perl5_regex_expression($self->{"arguments"}->[0]);
                my $replace1 = Perlito5::AST::Apply::emit_perl5_regex_expression($self->{"arguments"}->[1]);
                my $q = Perlito5::AST::Apply::emit_perl5_choose_regex_quote($replace0, $replace1, $self->{"arguments"}->[2]->{"buf"});
                return "s" . $q . $replace0 . $q . $replace1 . $q . ($self->{"arguments"}->[2]->{"buf"})
            }
            if ($self->{"code"} eq "p5:m") {
                my $replace0 = Perlito5::AST::Apply::emit_perl5_regex_expression($self->{"arguments"}->[0]);
                my $q = Perlito5::AST::Apply::emit_perl5_choose_regex_quote($replace0, $self->{"arguments"}->[1]->{"buf"});
                return "m" . $q . $replace0 . $q . ($self->{"arguments"}->[1]->{"buf"})
            }
            if ($self->{"code"} eq "p5:tr") {
                my $replace0 = Perlito5::AST::Apply::emit_perl5_regex_expression($self->{"arguments"}->[0]);
                my $replace1 = Perlito5::AST::Apply::emit_perl5_regex_expression($self->{"arguments"}->[1]);
                my $q = Perlito5::AST::Apply::emit_perl5_choose_regex_quote($replace0, $replace1, $self->{"arguments"}->[2]->{"buf"});
                return "tr" . $q . $replace0 . $q . $replace1 . $q . ($self->{"arguments"}->[2]->{"buf"})
            }
            if ($self->{"code"} eq "p5:qr") {
                my $replace0 = Perlito5::AST::Apply::emit_perl5_regex_expression($self->{"arguments"}->[0]);
                my $q = Perlito5::AST::Apply::emit_perl5_choose_regex_quote($replace0, $self->{"arguments"}->[1]->{"buf"});
                return "qr" . $q . $replace0 . $q . ($self->{"arguments"}->[1]->{"buf"})
            }
            if ($self->{"code"} eq "package") {;
                return ["stmt", "package", ["bareword", $self->{"namespace"}]]
            }
            if ($code eq "map" || $code eq "grep" || $code eq "sort" || $code eq "print" || $code eq "use") {
                if ($self->{"special_arg"}) {;
                    return ["op", "prefix:<" . $code . ">", $self->{"special_arg"}->emit_perl5(), ["op", "list:<,>", $self->emit_perl5_args()]]
                }
                return ["apply", "(", $code, $self->emit_perl5_args()]
            }
            if ($code eq "readline") {;
                return ["paren", "<", $self->emit_perl5_args()]
            }
            $self->{"ignore_proto"} && ($code = "&" . $code);
            if ($self->{"bareword"} && !@{$self->{"arguments"}}) {
                my $effective_name = ($self->{"namespace"} || $Perlito5::PKG_NAME) . "::" . ($self->{"code"});
                if (exists($Perlito5::PROTO->{$effective_name})) {;
                    $code = $effective_name
                }
                else {;
                    return ["bareword", $code]
                }
            }
            return ["apply", "(", $code, $self->emit_perl5_args()]
        }
    }
    package Perlito5::AST::If;
    {;
        sub Perlito5::AST::If::emit_perl5 {
            my $self = $_[0];
            if ($self->{"body"} && ref($self->{"body"}) ne "Perlito5::AST::Block") {;
                return ["stmt_modifier", $self->{"body"}->emit_perl5(), ["stmt", "if", $self->{"cond"}->emit_perl5()]]
            }
            if ($self->{"otherwise"} && ref($self->{"otherwise"}) ne "Perlito5::AST::Block") {;
                return ["stmt_modifier", $self->{"otherwise"}->emit_perl5(), ["stmt", "unless", $self->{"cond"}->emit_perl5()]]
            }
            my @out = (["stmt", ["keyword", "if"], ["paren", "(", $self->{"cond"}->emit_perl5()], Perlito5::Perl5::emit_perl5_block($self->{"body"}->stmts())]);
            my $otherwise = $self->{"otherwise"};
            while ($otherwise && @{$otherwise->{"stmts"}} == 1 && ref($otherwise->{"stmts"}->[0]) eq "Perlito5::AST::If" && ($otherwise->{"stmts"}->[0]->{"body"} && ref($otherwise->{"stmts"}->[0]->{"body"}) eq "Perlito5::AST::Block")) {
                push(@out, ["stmt", ["keyword", "elsif"], ["paren", "(", $otherwise->{"stmts"}->[0]->{"cond"}->emit_perl5()], Perlito5::Perl5::emit_perl5_block($otherwise->{"stmts"}->[0]->{"body"}->{"stmts"})]);
                $otherwise = $otherwise->{"stmts"}->[0]->{"otherwise"}
            }
            !($otherwise && scalar(@{$otherwise->stmts()})) && return @out;
            push(@out, ["stmt", ["keyword", "else"], Perlito5::Perl5::emit_perl5_block($otherwise->stmts())]);
            return @out
        }
    }
    package Perlito5::AST::When;
    {;
        sub Perlito5::AST::When::emit_perl5 {
            my $self = $_[0];
            return ["stmt", ["keyword", "when"], ["paren", "(", $self->{"cond"}->emit_perl5()], Perlito5::Perl5::emit_perl5_block($self->{"body"}->stmts())]
        }
    }
    package Perlito5::AST::While;
    {;
        sub Perlito5::AST::While::emit_perl5 {
            my $self = $_[0];
            my @out;
            $self->{"label"} && push(@out, ["label", $self->{"label"}]);
            if ($self->{"body"} && ref($self->{"body"}) ne "Perlito5::AST::Block") {;
                return @out, ["stmt_modifier", $self->{"body"}->emit_perl5(), ["stmt", ["keyword", "while"], $self->{"cond"}->emit_perl5()]]
            }
            push(@out, ["stmt", ["keyword", "while"], ["paren", "(", $self->{"cond"}->emit_perl5()], Perlito5::Perl5::emit_perl5_block($self->{"body"}->stmts())]);
            if ($self->{"continue"} && @{$self->{"continue"}->{"stmts"}}) {;
                push(@out, ["stmt", ["keyword", "continue"], Perlito5::Perl5::emit_perl5_block($self->{"continue"}->{"stmts"})])
            }
            return @out
        }
    }
    package Perlito5::AST::For;
    {;
        sub Perlito5::AST::For::emit_perl5 {
            my $self = $_[0];
            my @out;
            $self->{"label"} && push(@out, ["label", $self->{"label"}]);
            if ($self->{"body"} && ref($self->{"body"}) ne "Perlito5::AST::Block") {;
                return @out, ["stmt_modifier", $self->{"body"}->emit_perl5(), ["stmt", "for", $self->{"cond"}->emit_perl5()]]
            }
            my $cond;
            if (ref($self->{"cond"}) eq "ARRAY") {;
                $cond = ["paren_semicolon", "(", ($self->{"cond"}->[0] ? $self->{"cond"}->[0]->emit_perl5() : []), ($self->{"cond"}->[1] ? $self->{"cond"}->[1]->emit_perl5() : []), ($self->{"cond"}->[2] ? $self->{"cond"}->[2]->emit_perl5() : [])]
            }
            else {;
                $cond = ["paren", "(", $self->{"cond"}->emit_perl5()]
            }
            my @sig;
            my $sig_ast = $self->{"topic"};
            if (!$sig_ast) {}
            else {;
                @sig = $sig_ast->emit_perl5()
            }
            push(@out, ["stmt", ["keyword", "for"], @sig, $cond, Perlito5::Perl5::emit_perl5_block($self->{"body"}->stmts())]);
            if ($self->{"continue"} && @{$self->{"continue"}->{"stmts"}}) {;
                push(@out, ["stmt", ["keyword", "continue"], Perlito5::Perl5::emit_perl5_block($self->{"continue"}->{"stmts"})])
            }
            return @out
        }
    }
    package Perlito5::AST::Decl;
    {;
        sub Perlito5::AST::Decl::emit_perl5 {
            my $self = $_[0];
            my $var = $self->{"var"};
            ref($var) eq "Perlito5::AST::Var" && $var->is_begin_scratchpad() && return $var->emit_perl5();
            return ["op", "prefix:<" . ($self->{"decl"}) . ">", ($self->{"type"} ? $self->{"type"} : ()), $var->emit_perl5()]
        }
    }
    package Perlito5::AST::Sub;
    {;
        sub Perlito5::AST::Sub::emit_perl5 {
            my $self = $_[0];
            my @sig;
            my @parts;
            defined($self->{"sig"}) && push(@sig, ["paren", "(", ["bareword", $self->{"sig"}]]);
            if (defined($self->{"block"})) {;
                push(@parts, Perlito5::Perl5::emit_perl5_block($self->{"block"}->{"stmts"}))
            }
            !$self->{"name"} && return ["op", "prefix:<sub>", @sig, @parts];
            return ["stmt", ["keyword", "sub"], ["bareword", ($self->{"namespace"}) . "::" . ($self->{"name"})], @sig, @parts]
        }
    }
    1
}
{
    package main;
    package Perlito5::Perl5::PrettyPrinter;
    my %dispatch = ("stmt", sub {;
        Perlito5::Perl5::PrettyPrinter::statement(@_)
    }, "stmt_modifier", sub {;
        Perlito5::Perl5::PrettyPrinter::statement_modifier(@_)
    }, "block", sub {;
        Perlito5::Perl5::PrettyPrinter::block(@_)
    }, "keyword", sub {;
        Perlito5::Perl5::PrettyPrinter::keyword(@_)
    }, "bareword", sub {;
        Perlito5::Perl5::PrettyPrinter::bareword(@_)
    }, "number", sub {;
        Perlito5::Perl5::PrettyPrinter::number(@_)
    }, "op", sub {;
        Perlito5::Perl5::PrettyPrinter::op(@_)
    }, "paren", sub {;
        Perlito5::Perl5::PrettyPrinter::paren(@_)
    }, "paren_semicolon", sub {;
        Perlito5::Perl5::PrettyPrinter::paren_semicolon(@_)
    }, "apply", sub {;
        Perlito5::Perl5::PrettyPrinter::apply(@_)
    }, "call", sub {;
        Perlito5::Perl5::PrettyPrinter::call(@_)
    }, "comment", sub {;
        Perlito5::Perl5::PrettyPrinter::comment(@_)
    }, "label", sub {;
        Perlito5::Perl5::PrettyPrinter::label(@_)
    });
    my %pair = ("(", ")", "[", "]", "{", "}", "<", ">");
    our %op = ("prefix:<\$>", {"fix" => "deref", "prec" => 0, "str" => "\$", }, "prefix:<\@>", {"fix" => "deref", "prec" => 0, "str" => "\@", }, "prefix:<%>", {"fix" => "deref", "prec" => 0, "str" => "%", }, "prefix:<&>", {"fix" => "deref", "prec" => 0, "str" => "&", }, "prefix:<*>", {"fix" => "deref", "prec" => 0, "str" => "*", }, "prefix:<\$#>", {"fix" => "deref", "prec" => 0, "str" => "\$#", }, "circumfix:<[ ]>", {"fix" => "circumfix", "prec" => 0, "str" => "[", }, "circumfix:<{ }>", {"fix" => "circumfix", "prec" => 0, "str" => "{", }, "circumfix:<( )>", {"fix" => "circumfix", "prec" => 0, "str" => "(", }, "infix:<->>", {"fix" => "infix", "prec" => -1, "str" => "->", }, "prefix:<-->", {"fix" => "prefix", "prec" => 1, "str" => "--", }, "prefix:<++>", {"fix" => "prefix", "prec" => 1, "str" => "++", }, "postfix:<-->", {"fix" => "postfix", "prec" => 1, "str" => "--", }, "postfix:<++>", {"fix" => "postfix", "prec" => 1, "str" => "++", }, "infix:<**>", {"fix" => "infix", "prec" => 2, "str" => "**", }, "prefix:<\\>", {"fix" => "prefix", "prec" => 3, "str" => "\\", }, "prefix:<+>", {"fix" => "prefix", "prec" => 3, "str" => "+", }, "prefix:<->", {"fix" => "prefix", "prec" => 3, "str" => "-", }, "prefix:<~>", {"fix" => "prefix", "prec" => 3, "str" => "~", }, "prefix:<!>", {"fix" => "prefix", "prec" => 3, "str" => "!", }, "infix:<=~>", {"fix" => "infix", "prec" => 4, "str" => " =~ ", }, "infix:<!~>", {"fix" => "infix", "prec" => 4, "str" => " !~ ", }, "infix:<*>", {"fix" => "infix", "prec" => 5, "str" => " * ", }, "infix:</>", {"fix" => "infix", "prec" => 5, "str" => " / ", }, "infix:<%>", {"fix" => "infix", "prec" => 5, "str" => " % ", }, "infix:<x>", {"fix" => "infix", "prec" => 5, "str" => " x ", }, "infix:<+>", {"fix" => "infix", "prec" => 6, "str" => " + ", }, "infix:<->", {"fix" => "infix", "prec" => 6, "str" => " - ", }, "list:<.>", {"fix" => "list", "prec" => 6, "str" => " . ", }, "infix:<<<>", {"fix" => "infix", "prec" => 7, "str" => " << ", }, "infix:<>>>", {"fix" => "infix", "prec" => 7, "str" => " >> ", }, "infix:<lt>", {"fix" => "infix", "prec" => 9, "str" => " lt ", }, "infix:<le>", {"fix" => "infix", "prec" => 9, "str" => " le ", }, "infix:<gt>", {"fix" => "infix", "prec" => 9, "str" => " gt ", }, "infix:<ge>", {"fix" => "infix", "prec" => 9, "str" => " ge ", }, "infix:<<=>", {"fix" => "infix", "prec" => 9, "str" => " <= ", }, "infix:<>=>", {"fix" => "infix", "prec" => 9, "str" => " >= ", }, "infix:<<>", {"fix" => "infix", "prec" => 9, "str" => " < ", }, "infix:<>>", {"fix" => "infix", "prec" => 9, "str" => " > ", }, "infix:<<=>>", {"fix" => "infix", "prec" => 10, "str" => " <=> ", }, "infix:<cmp>", {"fix" => "infix", "prec" => 10, "str" => " cmp ", }, "infix:<==>", {"fix" => "infix", "prec" => 10, "str" => " == ", }, "infix:<!=>", {"fix" => "infix", "prec" => 10, "str" => " != ", }, "infix:<ne>", {"fix" => "infix", "prec" => 10, "str" => " ne ", }, "infix:<eq>", {"fix" => "infix", "prec" => 10, "str" => " eq ", }, "infix:<&>", {"fix" => "infix", "prec" => 11, "str" => " & ", }, "infix:<|>", {"fix" => "infix", "prec" => 12, "str" => " | ", }, "infix:<^>", {"fix" => "infix", "prec" => 12, "str" => " ^ ", }, "infix:<..>", {"fix" => "infix", "prec" => 13, "str" => " .. ", }, "infix:<...>", {"fix" => "infix", "prec" => 13, "str" => " ... ", }, "infix:<~~>", {"fix" => "infix", "prec" => 13, "str" => " ~~ ", }, "infix:<&&>", {"fix" => "infix", "prec" => 14, "str" => " && ", }, "infix:<||>", {"fix" => "infix", "prec" => 15, "str" => " || ", }, "infix:<//>", {"fix" => "infix", "prec" => 15, "str" => " // ", }, "ternary:<? :>", {"fix" => "ternary", "prec" => 16, }, "infix:<=>", {"fix" => "infix", "prec" => 17, "str" => " = ", }, "infix:<**=>", {"fix" => "infix", "prec" => 17, "str" => " **= ", }, "infix:<+=>", {"fix" => "infix", "prec" => 17, "str" => " += ", }, "infix:<-=>", {"fix" => "infix", "prec" => 17, "str" => " -= ", }, "infix:<*=>", {"fix" => "infix", "prec" => 17, "str" => " *= ", }, "infix:</=>", {"fix" => "infix", "prec" => 17, "str" => " /= ", }, "infix:<x=>", {"fix" => "infix", "prec" => 17, "str" => " x= ", }, "infix:<|=>", {"fix" => "infix", "prec" => 17, "str" => " |= ", }, "infix:<&=>", {"fix" => "infix", "prec" => 17, "str" => " &= ", }, "infix:<.=>", {"fix" => "infix", "prec" => 17, "str" => " .= ", }, "infix:<<<=>", {"fix" => "infix", "prec" => 17, "str" => " <<= ", }, "infix:<>>=>", {"fix" => "infix", "prec" => 17, "str" => " >>= ", }, "infix:<%=>", {"fix" => "infix", "prec" => 17, "str" => " %= ", }, "infix:<||=>", {"fix" => "infix", "prec" => 17, "str" => " ||= ", }, "infix:<&&=>", {"fix" => "infix", "prec" => 17, "str" => " &&= ", }, "infix:<^=>", {"fix" => "infix", "prec" => 17, "str" => " ^= ", }, "infix:<//=>", {"fix" => "infix", "prec" => 17, "str" => " //= ", }, "infix:<=>>", {"fix" => "infix", "prec" => 18, "str" => " => ", }, "list:<,>", {"fix" => "list", "prec" => 19, "str" => ", ", }, "prefix:<not>", {"fix" => "prefix", "prec" => 20, "str" => "not ", }, "infix:<and>", {"fix" => "infix", "prec" => 21, "str" => " and ", }, "infix:<or>", {"fix" => "infix", "prec" => 22, "str" => " or ", }, "infix:<xor>", {"fix" => "infix", "prec" => 22, "str" => " xor ", });
    $op{"prefix:<" . $_ . ">"} = {"fix" => "prefix", "prec" => 8, "str" => $_ . " ", }
        for "-r", "-w", "-x", "-o", "-R", "-W", "-X", "-O", "-e", "-z", "-s", "-f", "-d", "-l", "-p", "-S", "-b", "-c", "-t", "-u", "-g", "-k", "-T", "-B", "-M", "-A", "-C";
    $op{"prefix:<" . $_ . ">"} = {"fix" => "parsed", "prec" => 15, "str" => '' . $_, }
        for "do", "sub", "my", "our", "state", "local", "eval", "map", "grep", "sort", "print", "use";
    my %tab;
    sub Perlito5::Perl5::PrettyPrinter::tab {
        my $level = $_[0];
        $tab{$level} //= "    " x $level
    }
    sub Perlito5::Perl5::PrettyPrinter::render {
        (my $data, my $level, my $out) = @_;
        if (ref($data)) {;
            $dispatch{$data->[0]}->($data, $level, $out)
        }
        else {;
            push(@{$out}, $data)
        }
    }
    sub Perlito5::Perl5::PrettyPrinter::op_precedence {
        (my $data) = @_;
        !ref($data) && return 0;
        $data->[0] ne "op" && return 0;
        return $op{$data->[1]}->{"prec"} || 0
    }
    sub Perlito5::Perl5::PrettyPrinter::statement_need_semicolon {
        (my $data) = @_;
        !ref($data) && return 1;
        ($data->[0] eq "block" || $data->[0] eq "comment" || $data->[0] eq "label") && return 0;
        if ($data->[0] eq "stmt") {;
            if (ref($data->[1])) {
                my $dd = $data->[1];
                if ($dd->[0] eq "keyword") {;
                    ref($data->[-1]) && $data->[-1]->[0] eq "block" && return 0
                }
            }
        }
        return 1
    }
    sub Perlito5::Perl5::PrettyPrinter::op_render {
        (my $data, my $level, my $out, my $current_op) = @_;
        if (ref($data)) {
            my $this_prec = Perlito5::Perl5::PrettyPrinter::op_precedence($data);
            my $use_paren = $this_prec && $current_op->{"prec"} && ($current_op->{"prec"} < $this_prec || $current_op->{"prec"} == 6);
            $use_paren && push(@{$out}, "(");
            Perlito5::Perl5::PrettyPrinter::render($data, $level, $out);
            $use_paren && push(@{$out}, ")")
        }
        else {;
            push(@{$out}, $data)
        }
    }
    sub Perlito5::Perl5::PrettyPrinter::op {
        (my $data, my $level, my $out) = @_;
        my $op = $data->[1];
        my $spec = $op{$op} || die("unknown op: " . $op);
        if ($spec->{"fix"} eq "infix") {
            Perlito5::Perl5::PrettyPrinter::op_render($data->[2], $level, $out, $spec);
            push(@{$out}, $spec->{"str"});
            Perlito5::Perl5::PrettyPrinter::op_render($data->[3], $level, $out, $spec)
        }
        elsif ($spec->{"fix"} eq "prefix") {
            push(@{$out}, $spec->{"str"});
            if ($op eq "prefix:<not>" && !$data->[2]) {;
                push(@{$out}, "()")
            }
            else {;
                Perlito5::Perl5::PrettyPrinter::op_render($data->[2], $level, $out, $spec)
            }
        }
        elsif ($spec->{"fix"} eq "postfix") {
            Perlito5::Perl5::PrettyPrinter::op_render($data->[2], $level, $out, $spec);
            push(@{$out}, $spec->{"str"})
        }
        elsif ($spec->{"fix"} eq "ternary") {
            Perlito5::Perl5::PrettyPrinter::op_render($data->[2], $level, $out, $spec);
            push(@{$out}, " ? ");
            Perlito5::Perl5::PrettyPrinter::op_render($data->[3], $level, $out, $spec);
            push(@{$out}, " : ");
            Perlito5::Perl5::PrettyPrinter::op_render($data->[4], $level, $out, $spec)
        }
        elsif ($spec->{"fix"} eq "deref") {
            push(@{$out}, $spec->{"str"});
            Perlito5::Perl5::PrettyPrinter::op_render($data->[2], $level, $out, $spec)
        }
        elsif ($spec->{"fix"} eq "circumfix") {
            push(@{$out}, $spec->{"str"});
            for my $line (2 .. $#{$data}) {
                Perlito5::Perl5::PrettyPrinter::op_render($data->[$line], $level, $out, $spec);
                $line != $#{$data} && push(@{$out}, ", ")
            }
            push(@{$out}, $pair{$spec->{"str"}})
        }
        elsif ($spec->{"fix"} eq "list") {;
            for my $line (2 .. $#{$data}) {
                Perlito5::Perl5::PrettyPrinter::op_render($data->[$line], $level, $out, $spec);
                $line != $#{$data} && push(@{$out}, $spec->{"str"})
            }
        }
        elsif ($spec->{"fix"} eq "parsed") {
            push(@{$out}, $spec->{"str"});
            for my $line (2 .. $#{$data}) {
                my $d = $data->[$line];
                push(@{$out}, " ");
                Perlito5::Perl5::PrettyPrinter::render($d, $level, $out)
            }
        }
        else {;
            die("unknown fixity: " . ($spec->{"fix"}))
        }
        return
    }
    sub Perlito5::Perl5::PrettyPrinter::call {
        (my $data, my $level, my $out) = @_;
        my @dd = @{$data};
        shift(@dd);
        my $open = "(";
        Perlito5::Perl5::PrettyPrinter::render(shift(@dd), $level, $out);
        push(@{$out}, "->");
        my $d = $dd[0];
        Perlito5::Perl5::PrettyPrinter::render($d, $level, $out);
        $dd[0] = "list:<,>";
        push(@{$out}, $open);
        Perlito5::Perl5::PrettyPrinter::op(["op", @dd], $level, $out);
        push(@{$out}, $pair{$open})
    }
    sub Perlito5::Perl5::PrettyPrinter::apply {
        (my $data, my $level, my $out) = @_;
        my @dd = @{$data};
        shift(@dd);
        my $open = shift(@dd);
        my $d = $dd[0];
        if ($d eq "return") {;
            $open = " "
        }
        Perlito5::Perl5::PrettyPrinter::render($d, $level, $out);
        $dd[0] = "list:<,>";
        push(@{$out}, $open);
        Perlito5::Perl5::PrettyPrinter::op(["op", @dd], $level, $out);
        push(@{$out}, $pair{$open})
    }
    sub Perlito5::Perl5::PrettyPrinter::paren {
        (my $data, my $level, my $out) = @_;
        my @dd = @{$data};
        shift(@dd);
        my $open = $dd[0];
        $dd[0] = "list:<,>";
        push(@{$out}, $open);
        Perlito5::Perl5::PrettyPrinter::op(["op", @dd], $level, $out);
        push(@{$out}, $pair{$open})
    }
    sub Perlito5::Perl5::PrettyPrinter::paren_semicolon {
        (my $data, my $level, my $out) = @_;
        push(@{$out}, $data->[1]);
        for my $line (2 .. $#{$data}) {
            @{$data->[$line]} && Perlito5::Perl5::PrettyPrinter::render($data->[$line], $level, $out);
            if ($line != $#{$data}) {
                if (@{$data->[$line + 1]}) {;
                    push(@{$out}, "; ")
                }
                else {;
                    push(@{$out}, ";")
                }
            }
        }
        push(@{$out}, $pair{$data->[1]})
    }
    sub Perlito5::Perl5::PrettyPrinter::label {
        (my $data, my $level, my $out) = @_;
        push(@{$out}, $data->[1], ":");
        return
    }
    sub Perlito5::Perl5::PrettyPrinter::keyword {
        (my $data, my $level, my $out) = @_;
        push(@{$out}, $data->[1]);
        return
    }
    sub Perlito5::Perl5::PrettyPrinter::bareword {
        (my $data, my $level, my $out) = @_;
        push(@{$out}, $data->[1]);
        return
    }
    sub Perlito5::Perl5::PrettyPrinter::number {
        (my $data, my $level, my $out) = @_;
        push(@{$out}, $data->[1]);
        return
    }
    sub Perlito5::Perl5::PrettyPrinter::comment {
        (my $data, my $level, my $out) = @_;
        push(@{$out}, $data->[1]);
        return
    }
    sub Perlito5::Perl5::PrettyPrinter::statement {
        (my $data, my $level, my $out) = @_;
        for my $line (1 .. $#{$data}) {
            my $d = $data->[$line];
            Perlito5::Perl5::PrettyPrinter::render($d, $level, $out);
            $line != $#{$data} && push(@{$out}, " ")
        }
    }
    sub Perlito5::Perl5::PrettyPrinter::statement_modifier {
        (my $data, my $level, my $out) = @_;
        Perlito5::Perl5::PrettyPrinter::render($data->[1], $level, $out);
        push(@{$out}, "
", Perlito5::Perl5::PrettyPrinter::tab($level + 1));
        Perlito5::Perl5::PrettyPrinter::render($data->[2], $level, $out)
    }
    sub Perlito5::Perl5::PrettyPrinter::block {
        (my $data, my $level, my $out) = @_;
        if (@{$data} == 1) {
            push(@{$out}, "{}");
            return
        }
        if (@{$data} == 2) {;
            push(@{$out}, "{;", "
")
        }
        else {;
            push(@{$out}, "{", "
")
        }
        $level++;
        for my $line (1 .. $#{$data}) {
            my $d = $data->[$line];
            push(@{$out}, Perlito5::Perl5::PrettyPrinter::tab($level));
            Perlito5::Perl5::PrettyPrinter::render($d, $level, $out);
            $line != $#{$data} && Perlito5::Perl5::PrettyPrinter::statement_need_semicolon($d) && push(@{$out}, ";");
            push(@{$out}, "
")
        }
        $level--;
        push(@{$out}, Perlito5::Perl5::PrettyPrinter::tab($level), "}")
    }
    sub Perlito5::Perl5::PrettyPrinter::pretty_print {
        (my $data, my $level, my $out) = @_;
        for my $line (0 .. $#{$data}) {
            my $d = $data->[$line];
            push(@{$out}, Perlito5::Perl5::PrettyPrinter::tab($level));
            Perlito5::Perl5::PrettyPrinter::render($d, $level, $out);
            $line != $#{$data} && Perlito5::Perl5::PrettyPrinter::statement_need_semicolon($d) && push(@{$out}, ";");
            push(@{$out}, "
")
        }
    }
    1
}
{
    package main;
    package Perlito5::Perl5::Runtime;
    sub Perlito5::Perl5::Runtime::eval_ast {
        (my $ast) = @_;
        my $want = 0;
        my @data = $ast->emit_perl5(0, $want);
        my $out = [];
        Perlito5::Perl5::PrettyPrinter::pretty_print(\@data, 0, $out);
        my $code = "package " . $Perlito5::PKG_NAME . "; " . join('', @{$out}) . "
";
        Perlito5::set_global_phase("UNITCHECK");
        $_->()
            while $_ = shift(@Perlito5::UNITCHECK_BLOCK);
        $code = "#line " . $Perlito5::LINE_NUMBER . " \"" . $Perlito5::FILE_NAME . "\"
" . $code;
        return eval($code)
    }
    sub Perlito5::Perl5::Runtime::emit_perl5 {;
        return ("
use v5.10;
use feature 'say';

")
    }
    1
}
{
    package main;
    package Perlito5::Perl6::TreeGrammar;
    sub Perlito5::Perl6::TreeGrammar::refactor_range_operator {
        (my $class, my $in) = @_;
        Perlito5::TreeGrammar::render(["And", ["Lookup", "code", ["Value", "infix:<..>"]], ["Lookup", "arguments", ["And", ["Index", 0, ["And", ["Ref", "Perlito5::AST::Int"], ["Lookup", "int", ["Value", 0]]]], ["Index", 1, ["Or", ["And", ["Ref", "Perlito5::AST::Int"], ["Action", sub {
            $in->{"code"} = "p6_prefix:<^>";
            $_[0]->{"int"}++;
            shift(@{$in->{"arguments"}})
        }]], ["And", ["Ref", "Perlito5::AST::Apply"], ["Lookup", "code", ["Value", "prefix:<\$#>"]], ["Action", sub {
            bless($in, "Perlito5::AST::Call");
            delete($in->{"code"});
            $in->{"method"} = "keys";
            shift(@{$in->{"arguments"}});
            my $invocant = shift(@{$in->{"arguments"}});
            $in->{"invocant"} = $invocant->{"arguments"}->[0]
        }]], ["And", ["Ref", "Perlito5::AST::Var"], ["Lookup", "sigil", ["Value", "\$#"]], ["Action", sub {
            bless($in, "Perlito5::AST::Call");
            delete($in->{"code"});
            $in->{"method"} = "keys";
            $in->{"arguments"} = [];
            my $invocant = $_[0];
            $invocant->{"sigil"} = "\@";
            $in->{"invocant"} = $invocant
        }]]]]]]], $in)
    }
    sub Perlito5::Perl6::TreeGrammar::refactor_while_glob {
        (my $class, my $in) = @_;
        Perlito5::TreeGrammar::render(["Ref", "Perlito5::AST::While", ["Lookup", "cond", ["And", ["Ref", "Perlito5::AST::Apply"], ["Lookup", "code", ["Value", "readline"]], ["Action", sub {;
            bless($in, "Perlito5::AST::For")
        }]]]], $in)
    }
    sub Perlito5::Perl6::TreeGrammar::refactor_sub_arguments {
        (my $class, my $in) = @_;
        (my $rule, my $result);
        $rule = Perlito5::Perl6::TreeGrammar::is_sub(["Action", sub {
            my $sub = $_[0];
            my $stmts;
            my $var;
            Perlito5::TreeGrammar::render(["Lookup", "block", ["Progn", ["Action", sub {;
                $stmts = $_[0]
            }], ["Star", ["Index", 0, Perlito5::Perl6::TreeGrammar::operator_eq("infix:<=>", ["Lookup", "arguments", ["And", ["Index", 0, Perlito5::Perl6::TreeGrammar::my_var(["Action", sub {;
                $var = $_[0]->{"var"}
            }])], ["Index", 1, Perlito5::Perl6::TreeGrammar::shift_arg()], ["Action", sub {
                push(@{$sub->{"args"}}, $var);
                shift(@{$stmts})
            }]]])]]]], $sub)
        }]);
        $result = Perlito5::TreeGrammar::scan($rule, $in)
    }
    sub Perlito5::Perl6::TreeGrammar::is_sub {;
        ["Ref", "Perlito5::AST::Sub", (@_ ? ["Progn", @_] : ())]
    }
    sub Perlito5::Perl6::TreeGrammar::named_sub {;
        ["Ref", "Perlito5::AST::Sub", ["And", ["Lookup", "name", ["Not", ["Value", '']]], (@_ ? ["Progn", @_] : ())]]
    }
    sub Perlito5::Perl6::TreeGrammar::operator_eq {
        my $name = shift;
        ["Ref", "Perlito5::AST::Apply", ["And", ["Lookup", "code", ["Value", $name]], (@_ ? ["Progn", @_] : ())]]
    }
    sub Perlito5::Perl6::TreeGrammar::my_var {;
        ["Ref", "Perlito5::AST::Decl", ["And", ["Lookup", "decl", ["Value", "my"]], (@_ ? ["Progn", @_] : ())]]
    }
    sub Perlito5::Perl6::TreeGrammar::var_is_at {;
        ["Ref", "Perlito5::AST::Var", ["And", ["Lookup", "sigil", ["Value", "\@"]], ["Lookup", "name", ["Value", "_"]], (@_ ? ["Progn", @_] : ())]]
    }
    sub Perlito5::Perl6::TreeGrammar::shift_arg {;
        ["Ref", "Perlito5::AST::Apply", ["And", ["Lookup", "code", ["Value", "shift"]], ["Or", ["Lookup", "arguments", ["Not", ["Index", 0]]], ["Lookup", "arguments", ["Index", 0, Perlito5::Perl6::TreeGrammar::var_is_at()]]], (@_ ? ["Progn", @_] : ())]]
    }
    1
}
{
    package main;
    {
        package Perlito5::Perl6;
        sub Perlito5::Perl6::emit_perl6_block {
            my $block = $_[0];
            return ["block", map {;
                defined($_) && $_->emit_perl6()
            } @{$block}]
        }
        my %safe_char = (" ", 1, "!", 1, "\"", 1, "#", 1, "\$", 1, "%", 1, "&", 1, "(", 1, ")", 1, "*", 1, "+", 1, ",", 1, "-", 1, ".", 1, "/", 1, ":", 1, ";", 1, "<", 1, "=", 1, ">", 1, "?", 1, "\@", 1, "[", 1, "]", 1, "^", 1, "_", 1, "`", 1, "{", 1, "|", 1, "}", 1, "~", 1);
        sub Perlito5::Perl6::escape_string {
            my $s = shift;
            my @out;
            my $tmp = '';
            $s eq '' && return "''";
            for my $i (0 .. length($s) - 1) {
                my $c = substr($s, $i, 1);
                if (($c ge "a" && $c le "z") || ($c ge "A" && $c le "Z") || ($c ge 0 && $c le 9) || exists($safe_char{$c})) {;
                    $tmp = $tmp . $c
                }
                else {
                    $tmp ne '' && push(@out, "'" . $tmp . "'");
                    push(@out, "chr(" . ord($c) . ")");
                    $tmp = ''
                }
            }
            $tmp ne '' && push(@out, "'" . $tmp . "'");
            @out < 2 && return @out;
            return ["op", "list:<~>", @out]
        }
    }
    package Perlito5::AST::CompUnit;
    {
        sub Perlito5::AST::CompUnit::emit_perl6 {
            my $self = $_[0];
            my @body = grep {;
                defined($_)
            } @{$self->{"body"}};
            my @out;
            my $pkg = {"name" => "main", "body" => [], };
            for my $stmt (@body) {
                if (ref($stmt) eq "Perlito5::AST::Apply" && $stmt->{"code"} eq "package") {
                    $Perlito5::PKG_NAME = $stmt->{"namespace"};
                    @{$pkg->{"body"}} && push(@out, ["stmt", ["keyword", "class"], ["bareword", $pkg->{"name"}], ["block", map {;
                        $_->emit_perl6()
                    } @{$pkg->{"body"}}]]);
                    $pkg = {"name" => $stmt->{"namespace"}, "body" => [], }
                }
                else {;
                    push(@{$pkg->{"body"}}, $stmt)
                }
            }
            @{$pkg->{"body"}} && push(@out, ["stmt", ["keyword", "class"], ["bareword", $pkg->{"name"}], ["block", map {;
                $_->emit_perl6()
            } @{$pkg->{"body"}}]]);
            return @out
        }
        sub Perlito5::AST::CompUnit::emit_perl6_program {
            my $comp_units = $_[0];
            my @body = @{$comp_units};
            my @out;
            push(@out, ["comment", Perlito5::Compiler::do_not_edit("#")]);
            my $pkg = {"name" => "main", "body" => [], };
            for my $stmt (@body) {
                if (ref($stmt) eq "Perlito5::AST::Apply" && $stmt->{"code"} eq "package") {
                    $Perlito5::PKG_NAME = $stmt->{"namespace"};
                    if (@{$pkg->{"body"}}) {
                        if ($pkg->{"name"} eq "main") {;
                            push(@out, map {;
                                $_->emit_perl6()
                            } @{$pkg->{"body"}})
                        }
                        else {;
                            push(@out, ["stmt", ["keyword", "class"], ["bareword", $pkg->{"name"}], ["block", map {;
                                $_->emit_perl6()
                            } @{$pkg->{"body"}}]])
                        }
                    }
                    $pkg = {"name" => $stmt->{"namespace"}, "body" => [], }
                }
                else {;
                    push(@{$pkg->{"body"}}, $stmt)
                }
            }
            if (@{$pkg->{"body"}}) {
                if ($pkg->{"name"} eq "main") {;
                    push(@out, map {;
                        $_->emit_perl6()
                    } @{$pkg->{"body"}})
                }
                else {;
                    push(@out, ["stmt", ["keyword", "class"], ["bareword", $pkg->{"name"}], ["block", map {;
                        $_->emit_perl6()
                    } @{$pkg->{"body"}}]])
                }
            }
            return @out
        }
    }
    package Perlito5::AST::Int;
    {;
        sub Perlito5::AST::Int::emit_perl6 {
            my $self = $_[0];
            ["number", $self->{"int"}]
        }
    }
    package Perlito5::AST::Num;
    {;
        sub Perlito5::AST::Num::emit_perl6 {
            my $self = $_[0];
            ["number", $self->{"num"}]
        }
    }
    package Perlito5::AST::Buf;
    {;
        sub Perlito5::AST::Buf::emit_perl6 {
            my $self = $_[0];
            Perlito5::Perl6::escape_string($self->{"buf"})
        }
    }
    package Perlito5::AST::Block;
    {;
        sub Perlito5::AST::Block::emit_perl6 {
            my $self = $_[0];
            my @out;
            $self->{"label"} && push(@out, ["label", $self->{"label"}]);
            if ($self->{"name"}) {;
                push(@out, ["stmt", ["keyword", $self->{"name"}], Perlito5::Perl6::emit_perl6_block($self->{"stmts"})])
            }
            else {;
                push(@out, Perlito5::Perl6::emit_perl6_block($self->{"stmts"}))
            }
            if ($self->{"continue"} && @{$self->{"continue"}->{"stmts"}}) {;
                push(@out, ["stmt", ["keyword", "continue"], Perlito5::Perl6::emit_perl6_block($self->{"continue"}->{"stmts"})])
            }
            return @out
        }
    }
    package Perlito5::AST::Index;
    {
        sub Perlito5::AST::Index::emit_perl6_index {
            my $self = $_[0];
            my $index = $self->{"index_exp"};
            if ($index->isa("Perlito5::AST::Apply") && $index->{"code"} eq "prefix:<->") {
                my $arg = $index->{"arguments"}->[0];
                if ($arg->isa("Perlito5::AST::Int")) {;
                    return ["op", "infix:<->", ["bareword", "*"], $arg->emit_perl6()]
                }
            }
            return $self->{"index_exp"}->emit_perl6()
        }
        sub Perlito5::AST::Index::emit_perl6 {
            my $self = $_[0];
            if ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\@>") {;
                return ["apply", "[", $self->{"obj"}->emit_perl6(), $self->emit_perl6_index()]
            }
            if ($self->{"obj"}->isa("Perlito5::AST::Var") && ($self->{"obj"}->sigil() eq "\$" || $self->{"obj"}->sigil() eq "\@")) {
                $self->{"obj"}->{"sigil"} = "\@";
                return ["apply", "[", $self->{"obj"}->emit_perl6(), $self->emit_perl6_index()]
            }
            if ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\$>") {;
                return ["apply", "[", $self->{"obj"}->{"arguments"}->[0]->emit_perl6(), $self->emit_perl6_index()]
            }
            return ["op", "infix:<.>", $self->{"obj"}->emit_perl6(), ["op", "circumfix:<[ ]>", $self->emit_perl6_index()]]
        }
    }
    package Perlito5::AST::Lookup;
    {;
        sub Perlito5::AST::Lookup::emit_perl6 {
            my $self = $_[0];
            if ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\@>") {
                $self->{"obj"}->{"sigil"} = "%";
                return ["apply", "{", $self->{"obj"}->emit_perl6(), $self->autoquote($self->{"index_exp"})->emit_perl6()]
            }
            if ($self->{"obj"}->isa("Perlito5::AST::Var") && ($self->{"obj"}->sigil() eq "\$" || $self->{"obj"}->sigil() eq "\@")) {
                $self->{"obj"}->{"sigil"} = "%";
                return ["apply", "{", $self->{"obj"}->emit_perl6(), $self->autoquote($self->{"index_exp"})->emit_perl6()]
            }
            if ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\$>") {;
                return ["apply", "{", $self->{"obj"}->{"arguments"}->[0]->emit_perl6(), $self->autoquote($self->{"index_exp"})->emit_perl6()]
            }
            return ["op", "infix:<.>", $self->{"obj"}->emit_perl6(), ["op", "circumfix:<{ }>", $self->autoquote($self->{"index_exp"})->emit_perl6()]]
        }
    }
    package Perlito5::AST::Var;
    {;
        sub Perlito5::AST::Var::emit_perl6 {
            my $self = $_[0];
            if ($self->{"sigil"} eq "\$#") {
                my $v = Perlito5::AST::Var::->new(%{$self}, "sigil", "\@");
                return ["op", "infix:<.>", $v->emit_perl6(), ["keyword", "end"]]
            }
            my $str_name = $self->{"name"};
            $str_name eq "\\" && ($str_name = "\\\\");
            $str_name eq "\"" && ($str_name = "\\\"");
            if ($self->{"sigil"} eq "::") {
                if ($self->{"namespace"} eq "__PACKAGE__") {;
                    return ["bareword", "\$?PACKAGE"]
                }
                return $self->{"namespace"}
            }
            my $ns = '';
            if ($self->{"namespace"}) {
                if ($self->{"namespace"} eq "main" && substr($self->{"name"}, 0, 1) eq "^") {;
                    return ($self->{"sigil"}) . "{" . ($self->{"name"}) . "}"
                }
                else {;
                    $ns = ($self->{"namespace"}) . "::"
                }
            }
            my $bareword = $ns . $str_name;
            my $c = substr($self->{"name"}, 0, 1);
            if (($c ge "a" && $c le "z") || ($c ge "A" && $c le "Z") || ($c eq "_")) {
                $self->{"sigil"} eq "\@" && $bareword eq "ARGV" && return "\@*ARGS";
                return ($self->{"sigil"}) . $bareword
            }
            if ($self->{"sigil"} eq "\$") {
                $bareword eq "/" && return "\"\\n\"";
                $bareword eq "\$" && return "\$*PID";
                $bareword eq 0 && return "\$*PROGRAM_NAME";
                $bareword eq "\@" && return "\$!";
                $bareword >= 1 && return "\$" . ($bareword - 1)
            }
            my $str = ($self->{"sigil"}) . "{'" . $bareword . "'}";
            return $str
        }
    }
    package Perlito5::AST::Call;
    {;
        sub Perlito5::AST::Call::emit_perl6 {
            my $self = $_[0];
            my $invocant = $self->{"invocant"}->emit_perl6();
            if ($self->{"method"} eq "postcircumfix:<[ ]>") {;
                return ["op", "infix:<.>", $invocant, ["op", "circumfix:<[ ]>", $self->{"arguments"}->emit_perl6()]]
            }
            if ($self->{"method"} eq "postcircumfix:<{ }>") {;
                return ["op", "infix:<.>", $invocant, ["op", "circumfix:<{ }>", Perlito5::AST::Lookup::->autoquote($self->{"arguments"})->emit_perl6()]]
            }
            my $meth = $self->{"method"};
            if ($meth eq "postcircumfix:<( )>") {
                if ((ref($self->{"invocant"}) eq "Perlito5::AST::Var" && $self->{"invocant"}->{"sigil"} eq "&") || (ref($self->{"invocant"}) eq "Perlito5::AST::Apply" && $self->{"invocant"}->{"code"} eq "prefix:<&>")) {;
                    return ["apply", "(", $invocant, map {;
                        $_->emit_perl6()
                    } @{$self->{"arguments"}}]
                }
                $meth = ''
            }
            if (ref($meth) eq "Perlito5::AST::Var") {;
                $meth = $meth->emit_perl6()
            }
            if ($meth) {;
                return ["call", $invocant, $meth, map {;
                    $_->emit_perl6()
                } @{$self->{"arguments"}}]
            }
            return ["op", "infix:<.>", $invocant, ["op", "list:<,>", map {;
                $_->emit_perl6()
            } @{$self->{"arguments"}}]]
        }
    }
    package Perlito5::AST::Apply;
    {
        my %special_var = (chr(15), "\$*VM");
        my %op_translate = ("list:<.>", "list:<~>", "infix:<.=>", "infix:<~=>", "infix:<=~>", "infix:<~~>", "infix:<!~>", "infix:<!~~>", "infix:<cmp>", "infix:<leq>", "ternary:<? :>", "ternary:<?? !!>", "reverse", "flip");
        sub Perlito5::AST::Apply::emit_perl6_args {
            my $self = $_[0];
            !$self->{"arguments"} && return ();
            return map {;
                $_->emit_perl6()
            } @{$self->{"arguments"}}
        }
        sub Perlito5::AST::Apply::emit_perl6 {
            my $self = $_[0];
            my $code = $self->{"code"};
            if (ref($code)) {;
                return ["op", "infix:<.>", $code->emit_perl6(), $self->emit_perl6_args()]
            }
            if ($code eq "infix:<=>>") {;
                return ["op", $code, Perlito5::AST::Lookup::->autoquote($self->{"arguments"}->[0])->emit_perl6(), $self->{"arguments"}->[1]->emit_perl6()]
            }
            if ($code eq "nan" && !$self->{"namespace"}) {;
                return ["keyword", "NaN"]
            }
            if ($code eq "inf" && !$self->{"namespace"}) {;
                return ["keyword", "Inf"]
            }
            if ($code eq "__PACKAGE__" && !$self->{"namespace"}) {;
                return ["bareword", "\$?PACKAGE"]
            }
            if ($code eq "prefix:<\$#>") {;
                return ["op", "infix:<.>", $self->{"arguments"}->[0]->emit_perl6(), ["keyword", "end"]]
            }
            if ($code eq "scalar") {
                my $arg = $self->{"arguments"}->[0];
                if ($arg->isa("Perlito5::AST::Var") && $arg->{"sigil"} eq "\@") {;
                    return ["op", "infix:<.>", $arg->emit_perl6(), ["keyword", "elems"]]
                }
            }
            if (($code eq "shift" || $code eq "pop") && !@{$self->{"arguments"}}) {;
                return ["apply", "(", $code, "\@_"]
            }
            if ($code eq "readline" && ref($self->{"arguments"}->[0]) eq "Perlito5::AST::Buf" && $self->{"arguments"}->[0]->{"buf"} eq '') {;
                return ["apply", "(", ["keyword", "lines"]]
            }
            if ($code eq "infix:<x>") {
                my $arg = $self->{"arguments"}->[0];
                if (ref($arg) eq "Perlito5::AST::Apply" && $arg->{"code"} eq "circumfix:<( )>") {;
                    $code = "infix:<xx>"
                }
            }
            if (($code eq "print" || $code eq "say") && !@{$self->{"arguments"}}) {;
                return ["keyword", "." . $code]
            }
            if ($code eq "infix:<..>") {
                Perlito5::Perl6::TreeGrammar::->refactor_range_operator($self);
                if (ref($self) ne "Perlito5::AST::Apply") {;
                    return $self->emit_perl6()
                }
                $code = $self->{"code"}
            }
            $op_translate{$code} && ($code = $op_translate{$code});
            if ($code eq "prefix:<\$>") {
                my $arg = $self->{"arguments"}->[0];
                $arg->isa("Perlito5::AST::Buf") && exists($special_var{$arg->{"buf"}}) && return $special_var{$arg->{"buf"}}
            }
            if ($Perlito5::Perl6::PrettyPrinter::op{$code}) {;
                return ["op", $code, $self->emit_perl6_args()]
            }
            if ($code eq "undef") {
                if (@{$self->{"arguments"}}) {;
                    die("TODO - undef(expr)")
                }
                else {;
                    return "Any"
                }
            }
            my $ns = '';
            if ($self->{"namespace"}) {;
                $ns = ($self->{"namespace"}) . "::"
            }
            $code = $ns . $code;
            if ($self->{"code"} eq "p5:s") {
                my $modifier = $self->{"arguments"}->[2]->{"buf"};
                $modifier && ($modifier = ":" . $modifier);
                return "s:P5" . $modifier . "!" . ($self->{"arguments"}->[0]->{"buf"}) . "!" . ($self->{"arguments"}->[1]->{"buf"}) . "!"
            }
            if ($self->{"code"} eq "p5:m") {
                my $s;
                if ($self->{"arguments"}->[0]->isa("Perlito5::AST::Buf")) {;
                    $s = $self->{"arguments"}->[0]->{"buf"}
                }
                else {;
                    for my $ast (@{$self->{"arguments"}->[0]->{"arguments"}}) {
                        if ($ast->isa("Perlito5::AST::Buf")) {;
                            $s .= $ast->{"buf"}
                        }
                        else {;
                            $s .= $ast->emit_perl6()
                        }
                    }
                }
                my $modifier = $self->{"arguments"}->[1]->{"buf"};
                $modifier && ($modifier = ":" . $modifier);
                return "m:P5" . $modifier . "!" . $s . "!"
            }
            if ($self->{"code"} eq "p5:tr") {;
                return "tr!" . ($self->{"arguments"}->[0]->{"buf"}) . "!" . ($self->{"arguments"}->[1]->{"buf"}) . "!"
            }
            if ($self->{"code"} eq "package") {
                $Perlito5::PKG_NAME = $self->{"namespace"};
                return ["stmt", "class", ["bareword", $self->{"namespace"}]]
            }
            if ($code eq "map" || $code eq "grep" || $code eq "sort") {
                if ($self->{"special_arg"}) {;
                    return ["op", "prefix:<" . $code . ">", ["block", map {;
                        $_->emit_perl6()
                    } @{$self->{"special_arg"}->{"stmts"}}], ["op", "list:<,>", $self->emit_perl6_args()]]
                }
                return ["apply", "(", $code, $self->emit_perl6_args()]
            }
            if ($self->{"bareword"} && !@{$self->{"arguments"}}) {;
                return ["bareword", $code]
            }
            if ($code eq "eval") {;
                $code = "EVAL"
            }
            return ["apply", "(", $code, $self->emit_perl6_args()]
        }
    }
    package Perlito5::AST::If;
    {;
        sub Perlito5::AST::If::emit_perl6 {
            my $self = $_[0];
            if ($self->{"body"} && ref($self->{"body"}) ne "Perlito5::AST::Block") {;
                return ["stmt_modifier", $self->{"body"}->emit_perl6(), ["stmt", "if", $self->{"cond"}->emit_perl6()]]
            }
            if ($self->{"otherwise"} && ref($self->{"otherwise"}) ne "Perlito5::AST::Block") {;
                return ["stmt_modifier", $self->{"otherwise"}->emit_perl6(), ["stmt", "unless", $self->{"cond"}->emit_perl6()]]
            }
            my @out = (["stmt", ["keyword", "if"], $self->{"cond"}->emit_perl6(), Perlito5::Perl6::emit_perl6_block($self->{"body"}->stmts())]);
            my $otherwise = $self->{"otherwise"};
            while ($otherwise && @{$otherwise->{"stmts"}} == 1 && ref($otherwise->{"stmts"}->[0]) eq "Perlito5::AST::If" && ($otherwise->{"stmts"}->[0]->{"body"} && ref($otherwise->{"stmts"}->[0]->{"body"}) eq "Perlito5::AST::Block")) {
                push(@out, ["stmt", ["keyword", "elsif"], $otherwise->{"stmts"}->[0]->{"cond"}->emit_perl6(), Perlito5::Perl6::emit_perl6_block($otherwise->{"stmts"}->[0]->{"body"}->{"stmts"})]);
                $otherwise = $otherwise->{"stmts"}->[0]->{"otherwise"}
            }
            !($otherwise && scalar(@{$otherwise->stmts()})) && return @out;
            push(@out, ["stmt", ["keyword", "else"], Perlito5::Perl6::emit_perl6_block($otherwise->stmts())]);
            return @out
        }
    }
    package Perlito5::AST::When;
    {;
        sub Perlito5::AST::When::emit_perl6 {
            my $self = $_[0];
            return ["stmt", ["keyword", "when"], $self->{"cond"}->emit_perl6(), Perlito5::Perl6::emit_perl6_block($self->{"body"}->stmts())]
        }
    }
    package Perlito5::AST::While;
    {;
        sub Perlito5::AST::While::emit_perl6 {
            my $self = $_[0];
            Perlito5::Perl6::TreeGrammar::->refactor_while_glob($self);
            if (ref($self) ne "Perlito5::AST::While") {;
                return $self->emit_perl6()
            }
            my @out;
            $self->{"label"} && push(@out, ["label", $self->{"label"}]);
            if ($self->{"body"} && ref($self->{"body"}) ne "Perlito5::AST::Block") {;
                return @out, ["stmt_modifier", $self->{"body"}->emit_perl6(), ["stmt", ["keyword", "while"], $self->{"cond"}->emit_perl6()]]
            }
            push(@out, ["stmt", ["keyword", "while"], $self->{"cond"}->emit_perl6(), Perlito5::Perl6::emit_perl6_block($self->{"body"}->stmts())]);
            if ($self->{"continue"} && @{$self->{"continue"}->{"stmts"}}) {;
                push(@out, ["stmt", ["keyword", "continue"], Perlito5::Perl6::emit_perl6_block($self->{"continue"}->{"stmts"})])
            }
            return @out
        }
    }
    package Perlito5::AST::For;
    {;
        sub Perlito5::AST::For::emit_perl6 {
            my $self = $_[0];
            my @out;
            $self->{"label"} && push(@out, ["label", $self->{"label"}]);
            if ($self->{"body"} && ref($self->{"body"}) ne "Perlito5::AST::Block") {;
                return @out, ["stmt_modifier", $self->{"body"}->emit_perl6(), ["stmt", "for", $self->{"cond"}->emit_perl6()]]
            }
            my $cond;
            my $keyword;
            if (ref($self->{"cond"}) eq "ARRAY") {
                $keyword = "loop";
                $cond = ["paren_semicolon", "(", ($self->{"cond"}->[0] ? $self->{"cond"}->[0]->emit_perl6() : []), ($self->{"cond"}->[1] ? $self->{"cond"}->[1]->emit_perl6() : []), ($self->{"cond"}->[2] ? $self->{"cond"}->[2]->emit_perl6() : [])]
            }
            else {
                $keyword = "for";
                $cond = $self->{"cond"}->emit_perl6()
            }
            my @sig;
            my $sig_ast = $self->{"topic"};
            if (!$sig_ast) {}
            else {
                ref($sig_ast) eq "Perlito5::AST::Decl" && ($sig_ast = $sig_ast->{"var"});
                @sig = ("->", $sig_ast->emit_perl6())
            }
            push(@out, ["stmt", ["keyword", $keyword], $cond, @sig, Perlito5::Perl6::emit_perl6_block($self->{"body"}->stmts())]);
            if ($self->{"continue"} && @{$self->{"continue"}->{"stmts"}}) {;
                push(@out, ["stmt", ["keyword", "continue"], Perlito5::Perl6::emit_perl6_block($self->{"continue"}->{"stmts"})])
            }
            return @out
        }
    }
    package Perlito5::AST::Decl;
    {;
        sub Perlito5::AST::Decl::emit_perl6 {
            my $self = $_[0];
            return ["op", "prefix:<" . ($self->{"decl"}) . ">", ($self->{"type"} ? $self->{"type"} : ()), $self->{"var"}->emit_perl6()]
        }
    }
    package Perlito5::AST::Sub;
    {;
        sub Perlito5::AST::Sub::emit_perl6 {
            my $self = $_[0];
            Perlito5::Perl6::TreeGrammar::->refactor_sub_arguments($self);
            my @parts;
            if ($self->{"args"}) {;
                push(@parts, ["paren", "(", (map {;
                    ["var", $_->emit_perl6(), "?"]
                } @{$self->{"args"}}), ["var", "*\@_"]])
            }
            else {;
                push(@parts, ["paren", "(", ["var", "*\@_"]])
            }
            defined($self->{"block"}) && push(@parts, Perlito5::Perl6::emit_perl6_block($self->{"block"}->{"stmts"}));
            !$self->{"name"} && return ["op", "prefix:<sub>", @parts];
            my $is_our = 1;
            $self->{"decl"} eq "my" && ($is_our = 0);
            my $name = $self->{"name"};
            if ($Perlito5::PKG_NAME ne $self->{"namespace"}) {
                $name = ($self->{"namespace"}) . "::" . $name;
                $is_our = 0
            }
            if ($is_our) {;
                return ["stmt", ["keyword", "our"], ["keyword", "sub"], ["bareword", $name], @parts]
            }
            else {;
                return ["stmt", ["keyword", "sub"], ["bareword", $name], @parts]
            }
        }
    }
    1
}
{
    package main;
    package Perlito5::Perl6::PrettyPrinter;
    my %dispatch = ("stmt", sub {;
        Perlito5::Perl6::PrettyPrinter::statement(@_)
    }, "stmt_modifier", sub {;
        Perlito5::Perl6::PrettyPrinter::statement_modifier(@_)
    }, "block", sub {;
        Perlito5::Perl6::PrettyPrinter::block(@_)
    }, "keyword", sub {;
        Perlito5::Perl6::PrettyPrinter::keyword(@_)
    }, "bareword", sub {;
        Perlito5::Perl6::PrettyPrinter::bareword(@_)
    }, "number", sub {;
        Perlito5::Perl6::PrettyPrinter::number(@_)
    }, "op", sub {;
        Perlito5::Perl6::PrettyPrinter::op(@_)
    }, "paren", sub {;
        Perlito5::Perl6::PrettyPrinter::paren(@_)
    }, "paren_semicolon", sub {;
        Perlito5::Perl6::PrettyPrinter::paren_semicolon(@_)
    }, "apply", sub {;
        Perlito5::Perl6::PrettyPrinter::apply(@_)
    }, "call", sub {;
        Perlito5::Perl6::PrettyPrinter::call(@_)
    }, "comment", sub {;
        Perlito5::Perl6::PrettyPrinter::comment(@_)
    }, "label", sub {;
        Perlito5::Perl6::PrettyPrinter::label(@_)
    }, "var", sub {;
        Perlito5::Perl6::PrettyPrinter::var(@_)
    });
    my %pair = ("(", ")", "[", "]", "{", "}");
    our %op = ("prefix:<\$>", {"fix" => "deref", "prec" => 0, "str" => "\$", }, "prefix:<\@>", {"fix" => "deref", "prec" => 0, "str" => "\@", }, "prefix:<%>", {"fix" => "deref", "prec" => 0, "str" => "%", }, "prefix:<&>", {"fix" => "deref", "prec" => 0, "str" => "&", }, "prefix:<*>", {"fix" => "deref", "prec" => 0, "str" => "*", }, "prefix:<\$#>", {"fix" => "deref", "prec" => 0, "str" => "\$#", }, "circumfix:<[ ]>", {"fix" => "circumfix", "prec" => 0, "str" => "[", }, "circumfix:<{ }>", {"fix" => "circumfix", "prec" => 0, "str" => "{", }, "circumfix:<( )>", {"fix" => "circumfix", "prec" => 0, "str" => "(", }, "infix:<.>", {"fix" => "infix", "prec" => -1, "str" => ".", }, "prefix:<-->", {"fix" => "prefix", "prec" => 1, "str" => "--", }, "prefix:<++>", {"fix" => "prefix", "prec" => 1, "str" => "++", }, "postfix:<-->", {"fix" => "postfix", "prec" => 1, "str" => "--", }, "postfix:<++>", {"fix" => "postfix", "prec" => 1, "str" => "++", }, "infix:<**>", {"fix" => "infix", "prec" => 2, "str" => "**", }, "p6_prefix:<^>", {"fix" => "prefix", "prec" => 3, "str" => "^", }, "prefix:<\\>", {"fix" => "prefix", "prec" => 3, "str" => "\\", }, "prefix:<+>", {"fix" => "prefix", "prec" => 3, "str" => "+", }, "prefix:<->", {"fix" => "prefix", "prec" => 3, "str" => "-", }, "prefix:<~>", {"fix" => "prefix", "prec" => 3, "str" => "~", }, "prefix:<!>", {"fix" => "prefix", "prec" => 3, "str" => "!", }, "infix:<=~>", {"fix" => "infix", "prec" => 4, "str" => " =~ ", }, "infix:<!~>", {"fix" => "infix", "prec" => 4, "str" => " !~ ", }, "infix:<*>", {"fix" => "infix", "prec" => 5, "str" => " * ", }, "infix:</>", {"fix" => "infix", "prec" => 5, "str" => " / ", }, "infix:<%>", {"fix" => "infix", "prec" => 5, "str" => " % ", }, "infix:<+>", {"fix" => "infix", "prec" => 6, "str" => " + ", }, "infix:<->", {"fix" => "infix", "prec" => 6, "str" => " - ", }, "infix:<x>", {"fix" => "infix", "prec" => 8, "str" => " x ", }, "infix:<xx>", {"fix" => "infix", "prec" => 8, "str" => " xx ", }, "list:<~>", {"fix" => "list", "prec" => 10, "str" => " ~ ", }, "infix:<~>", {"fix" => "infix", "prec" => 10, "str" => " ~ ", }, "infix:<<<>", {"fix" => "infix", "prec" => 12, "str" => " << ", }, "infix:<>>>", {"fix" => "infix", "prec" => 12, "str" => " >> ", }, "infix:<lt>", {"fix" => "infix", "prec" => 90, "str" => " lt ", }, "infix:<le>", {"fix" => "infix", "prec" => 90, "str" => " le ", }, "infix:<gt>", {"fix" => "infix", "prec" => 90, "str" => " gt ", }, "infix:<ge>", {"fix" => "infix", "prec" => 90, "str" => " ge ", }, "infix:<<=>", {"fix" => "infix", "prec" => 90, "str" => " <= ", }, "infix:<>=>", {"fix" => "infix", "prec" => 90, "str" => " >= ", }, "infix:<<>", {"fix" => "infix", "prec" => 90, "str" => " < ", }, "infix:<>>", {"fix" => "infix", "prec" => 90, "str" => " > ", }, "infix:<<=>>", {"fix" => "infix", "prec" => 100, "str" => " <=> ", }, "infix:<cmp>", {"fix" => "infix", "prec" => 100, "str" => " cmp ", }, "infix:<leq>", {"fix" => "infix", "prec" => 100, "str" => " leq ", }, "infix:<==>", {"fix" => "infix", "prec" => 100, "str" => " == ", }, "infix:<!=>", {"fix" => "infix", "prec" => 100, "str" => " != ", }, "infix:<ne>", {"fix" => "infix", "prec" => 100, "str" => " ne ", }, "infix:<eq>", {"fix" => "infix", "prec" => 100, "str" => " eq ", }, "infix:<&>", {"fix" => "infix", "prec" => 110, "str" => " & ", }, "infix:<|>", {"fix" => "infix", "prec" => 120, "str" => " | ", }, "infix:<^>", {"fix" => "infix", "prec" => 120, "str" => " ^ ", }, "infix:<..>", {"fix" => "infix", "prec" => 130, "str" => " .. ", }, "infix:<...>", {"fix" => "infix", "prec" => 130, "str" => " ... ", }, "infix:<~~>", {"fix" => "infix", "prec" => 130, "str" => " ~~ ", }, "infix:<&&>", {"fix" => "infix", "prec" => 140, "str" => " && ", }, "infix:<||>", {"fix" => "infix", "prec" => 150, "str" => " || ", }, "infix:<//>", {"fix" => "infix", "prec" => 150, "str" => " // ", }, "ternary:<?? !!>", {"fix" => "ternary", "prec" => 160, }, "infix:<=>", {"fix" => "infix", "prec" => 170, "str" => " = ", }, "infix:<**=>", {"fix" => "infix", "prec" => 170, "str" => " **= ", }, "infix:<+=>", {"fix" => "infix", "prec" => 170, "str" => " += ", }, "infix:<-=>", {"fix" => "infix", "prec" => 170, "str" => " -= ", }, "infix:<*=>", {"fix" => "infix", "prec" => 170, "str" => " *= ", }, "infix:</=>", {"fix" => "infix", "prec" => 170, "str" => " /= ", }, "infix:<x=>", {"fix" => "infix", "prec" => 170, "str" => " x= ", }, "infix:<|=>", {"fix" => "infix", "prec" => 170, "str" => " |= ", }, "infix:<&=>", {"fix" => "infix", "prec" => 170, "str" => " &= ", }, "infix:<.=>", {"fix" => "infix", "prec" => 170, "str" => " .= ", }, "infix:<<<=>", {"fix" => "infix", "prec" => 170, "str" => " <<= ", }, "infix:<>>=>", {"fix" => "infix", "prec" => 170, "str" => " >>= ", }, "infix:<%=>", {"fix" => "infix", "prec" => 170, "str" => " %= ", }, "infix:<||=>", {"fix" => "infix", "prec" => 170, "str" => " ||= ", }, "infix:<&&=>", {"fix" => "infix", "prec" => 170, "str" => " &&= ", }, "infix:<^=>", {"fix" => "infix", "prec" => 170, "str" => " ^= ", }, "infix:<//=>", {"fix" => "infix", "prec" => 170, "str" => " //= ", }, "infix:<~=>", {"fix" => "infix", "prec" => 170, "str" => " ~= ", }, "infix:<=>>", {"fix" => "infix", "prec" => 180, "str" => " => ", }, "list:<,>", {"fix" => "list", "prec" => 190, "str" => ", ", }, "infix:<:>", {"fix" => "infix", "prec" => 190, "str" => ":", }, "prefix:<not>", {"fix" => "prefix", "prec" => 200, "str" => " not ", }, "infix:<and>", {"fix" => "infix", "prec" => 210, "str" => " and ", }, "infix:<or>", {"fix" => "infix", "prec" => 220, "str" => " or ", }, "infix:<xor>", {"fix" => "infix", "prec" => 220, "str" => " xor ", });
    $op{"prefix:<" . $_ . ">"} = {"fix" => "prefix", "prec" => 8, "str" => $_ . " ", }
        for "-r", "-w", "-x", "-o", "-R", "-W", "-X", "-O", "-e", "-z", "-s", "-f", "-d", "-l", "-p", "-S", "-b", "-c", "-t", "-u", "-g", "-k", "-T", "-B", "-M", "-A", "-C";
    $op{"prefix:<" . $_ . ">"} = {"fix" => "parsed", "prec" => 8, "str" => '' . $_, }
        for "do", "sub", "my", "our", "state", "local", "map", "grep", "sort";
    my %tab;
    sub Perlito5::Perl6::PrettyPrinter::tab {
        my $level = $_[0];
        $tab{$level} //= "    " x $level
    }
    sub Perlito5::Perl6::PrettyPrinter::render {
        (my $data, my $level, my $out) = @_;
        if (ref($data)) {;
            $dispatch{$data->[0]}->($data, $level, $out)
        }
        else {;
            push(@{$out}, $data)
        }
    }
    sub Perlito5::Perl6::PrettyPrinter::op_precedence {
        (my $data) = @_;
        !ref($data) && return 0;
        $data->[0] ne "op" && return 0;
        return $op{$data->[1]}->{"prec"} || 0
    }
    sub Perlito5::Perl6::PrettyPrinter::statement_need_semicolon {
        (my $data) = @_;
        !ref($data) && return 1;
        ($data->[0] eq "block" || $data->[0] eq "comment" || $data->[0] eq "label") && return 0;
        if ($data->[0] eq "stmt") {;
            if (ref($data->[1])) {
                my $dd = $data->[1];
                if ($dd->[0] eq "keyword") {;
                    ref($data->[-1]) && $data->[-1]->[0] eq "block" && return 0
                }
            }
        }
        return 1
    }
    sub Perlito5::Perl6::PrettyPrinter::op_render {
        (my $data, my $level, my $out, my $current_op) = @_;
        if (ref($data)) {
            my $this_prec = Perlito5::Perl6::PrettyPrinter::op_precedence($data);
            $this_prec && $current_op->{"prec"} && $current_op->{"prec"} < $this_prec && push(@{$out}, "(");
            Perlito5::Perl6::PrettyPrinter::render($data, $level, $out);
            $this_prec && $current_op->{"prec"} && $current_op->{"prec"} < $this_prec && push(@{$out}, ")")
        }
        else {;
            push(@{$out}, $data)
        }
    }
    sub Perlito5::Perl6::PrettyPrinter::op {
        (my $data, my $level, my $out) = @_;
        my $op = $data->[1];
        my $spec = $op{$op} || die("unknown op: " . $op);
        if ($spec->{"fix"} eq "infix") {
            Perlito5::Perl6::PrettyPrinter::op_render($data->[2], $level, $out, $spec);
            push(@{$out}, $spec->{"str"});
            Perlito5::Perl6::PrettyPrinter::op_render($data->[3], $level, $out, $spec)
        }
        elsif ($spec->{"fix"} eq "prefix") {
            push(@{$out}, $spec->{"str"});
            Perlito5::Perl6::PrettyPrinter::op_render($data->[2], $level, $out, $spec)
        }
        elsif ($spec->{"fix"} eq "postfix") {
            Perlito5::Perl6::PrettyPrinter::op_render($data->[2], $level, $out, $spec);
            push(@{$out}, $spec->{"str"})
        }
        elsif ($spec->{"fix"} eq "ternary") {
            Perlito5::Perl6::PrettyPrinter::op_render($data->[2], $level, $out, $spec);
            push(@{$out}, " ?? ");
            Perlito5::Perl6::PrettyPrinter::op_render($data->[3], $level, $out, $spec);
            push(@{$out}, " !! ");
            Perlito5::Perl6::PrettyPrinter::op_render($data->[4], $level, $out, $spec)
        }
        elsif ($spec->{"fix"} eq "deref") {
            push(@{$out}, $spec->{"str"}, "(");
            Perlito5::Perl6::PrettyPrinter::op_render($data->[2], $level, $out, $spec);
            push(@{$out}, ")")
        }
        elsif ($spec->{"fix"} eq "circumfix") {
            push(@{$out}, $spec->{"str"});
            for my $line (2 .. $#{$data}) {
                Perlito5::Perl6::PrettyPrinter::op_render($data->[$line], $level, $out, $spec);
                $line != $#{$data} && push(@{$out}, ", ")
            }
            push(@{$out}, $pair{$spec->{"str"}})
        }
        elsif ($spec->{"fix"} eq "list") {;
            for my $line (2 .. $#{$data}) {
                Perlito5::Perl6::PrettyPrinter::op_render($data->[$line], $level, $out, $spec);
                $line != $#{$data} && push(@{$out}, $spec->{"str"})
            }
        }
        elsif ($spec->{"fix"} eq "parsed") {
            push(@{$out}, $spec->{"str"});
            for my $line (2 .. $#{$data}) {
                my $d = $data->[$line];
                push(@{$out}, " ");
                Perlito5::Perl6::PrettyPrinter::render($d, $level, $out)
            }
        }
        else {;
            die("unknown fixity: " . ($spec->{"fix"}))
        }
        return
    }
    sub Perlito5::Perl6::PrettyPrinter::call {
        (my $data, my $level, my $out) = @_;
        my @dd = @{$data};
        shift(@dd);
        my $open = "(";
        Perlito5::Perl6::PrettyPrinter::render(shift(@dd), $level, $out);
        push(@{$out}, ".");
        my $d = $dd[0];
        Perlito5::Perl6::PrettyPrinter::render($d, $level, $out);
        if ($open eq "(" && @dd == 1) {;
            return
        }
        $dd[0] = "list:<,>";
        push(@{$out}, $open);
        Perlito5::Perl6::PrettyPrinter::op(["op", @dd], $level, $out);
        push(@{$out}, $pair{$open})
    }
    sub Perlito5::Perl6::PrettyPrinter::apply {
        (my $data, my $level, my $out) = @_;
        my @dd = @{$data};
        shift(@dd);
        my $open = shift(@dd);
        my $d = $dd[0];
        Perlito5::Perl6::PrettyPrinter::render($d, $level, $out);
        if ($open eq "(" && @dd == 1) {;
            return
        }
        $dd[0] = "list:<,>";
        push(@{$out}, $open);
        Perlito5::Perl6::PrettyPrinter::op(["op", @dd], $level, $out);
        push(@{$out}, $pair{$open})
    }
    sub Perlito5::Perl6::PrettyPrinter::paren {
        (my $data, my $level, my $out) = @_;
        my @dd = @{$data};
        shift(@dd);
        my $open = $dd[0];
        $dd[0] = "list:<,>";
        push(@{$out}, $open);
        Perlito5::Perl6::PrettyPrinter::op(["op", @dd], $level, $out);
        push(@{$out}, $pair{$open})
    }
    sub Perlito5::Perl6::PrettyPrinter::paren_semicolon {
        (my $data, my $level, my $out) = @_;
        push(@{$out}, $data->[1]);
        for my $line (2 .. $#{$data}) {
            @{$data->[$line]} && Perlito5::Perl6::PrettyPrinter::render($data->[$line], $level, $out);
            if ($line != $#{$data}) {
                if (@{$data->[$line + 1]}) {;
                    push(@{$out}, "; ")
                }
                else {;
                    push(@{$out}, ";")
                }
            }
        }
        push(@{$out}, $pair{$data->[1]})
    }
    sub Perlito5::Perl6::PrettyPrinter::var {
        (my $data, my $level, my $out) = @_;
        push(@{$out}, @{$data}[1 .. $#{$data}]);
        return
    }
    sub Perlito5::Perl6::PrettyPrinter::label {
        (my $data, my $level, my $out) = @_;
        push(@{$out}, $data->[1], ":");
        return
    }
    sub Perlito5::Perl6::PrettyPrinter::keyword {
        (my $data, my $level, my $out) = @_;
        push(@{$out}, $data->[1]);
        return
    }
    sub Perlito5::Perl6::PrettyPrinter::bareword {
        (my $data, my $level, my $out) = @_;
        push(@{$out}, $data->[1]);
        return
    }
    sub Perlito5::Perl6::PrettyPrinter::number {
        (my $data, my $level, my $out) = @_;
        push(@{$out}, $data->[1]);
        return
    }
    sub Perlito5::Perl6::PrettyPrinter::comment {
        (my $data, my $level, my $out) = @_;
        push(@{$out}, $data->[1]);
        return
    }
    sub Perlito5::Perl6::PrettyPrinter::statement {
        (my $data, my $level, my $out) = @_;
        for my $line (1 .. $#{$data}) {
            my $d = $data->[$line];
            Perlito5::Perl6::PrettyPrinter::render($d, $level, $out);
            $line != $#{$data} && push(@{$out}, " ")
        }
    }
    sub Perlito5::Perl6::PrettyPrinter::statement_modifier {
        (my $data, my $level, my $out) = @_;
        Perlito5::Perl6::PrettyPrinter::render($data->[1], $level, $out);
        push(@{$out}, "
", Perlito5::Perl6::PrettyPrinter::tab($level + 1));
        Perlito5::Perl6::PrettyPrinter::render($data->[2], $level, $out)
    }
    sub Perlito5::Perl6::PrettyPrinter::block {
        (my $data, my $level, my $out) = @_;
        if (@{$data} == 1) {
            push(@{$out}, "{}");
            return
        }
        push(@{$out}, "{", "
");
        $level++;
        for my $line (1 .. $#{$data}) {
            my $d = $data->[$line];
            push(@{$out}, Perlito5::Perl6::PrettyPrinter::tab($level));
            Perlito5::Perl6::PrettyPrinter::render($d, $level, $out);
            $line != $#{$data} && Perlito5::Perl6::PrettyPrinter::statement_need_semicolon($d) && push(@{$out}, ";");
            push(@{$out}, "
")
        }
        $level--;
        push(@{$out}, Perlito5::Perl6::PrettyPrinter::tab($level), "}")
    }
    sub Perlito5::Perl6::PrettyPrinter::pretty_print {
        (my $data, my $level, my $out) = @_;
        for my $line (0 .. $#{$data}) {
            my $d = $data->[$line];
            push(@{$out}, Perlito5::Perl6::PrettyPrinter::tab($level));
            Perlito5::Perl6::PrettyPrinter::render($d, $level, $out);
            $line != $#{$data} && Perlito5::Perl6::PrettyPrinter::statement_need_semicolon($d) && push(@{$out}, ";");
            push(@{$out}, "
")
        }
    }
    1
}
{
    package main;
    package Perlito5::Java::LexicalBlock;
    {
        sub Perlito5::Java::LexicalBlock::new {
            my $class = shift;
            bless({@_, }, $class)
        }
        sub Perlito5::Java::LexicalBlock::block {;
            $_[0]->{"block"}
        }
        sub Perlito5::Java::LexicalBlock::has_decl {
            my $self = $_[0];
            my $type = $_[1];
            for my $decl (@{$self->{"block"}}) {;
                (grep {;
                    $_->{"decl"} eq $type
                } $decl->emit_java_get_decl()) && return 1
            }
            return 0
        }
        sub Perlito5::Java::LexicalBlock::emit_return {
            (my $has_local, my $local_label, my $value) = @_;
            $has_local ? "return PerlOp.cleanup_local(" . $local_label . ", " . $value . ")" : "return " . $value
        }
        sub Perlito5::Java::LexicalBlock::looks_like_dead_code {
            (my $decl) = @_;
            if ((ref($decl) eq "Perlito5::AST::Apply") && $decl->{"code"} eq "circumfix:<( )>") {
                !@{$decl->{"arguments"}} && return 1;
                !(grep {;
                    !Perlito5::Java::LexicalBlock::looks_like_dead_code($_)
                } @{$decl->{"arguments"}}) && return 1
            }
            if ((ref($decl) eq "Perlito5::AST::Apply") && ($decl->{"code"} eq "my" || $decl->{"code"} eq "our")) {;
                return 1
            }
            if ((ref($decl) eq "Perlito5::AST::Decl") && ($decl->{"decl"} eq "my" || $decl->{"decl"} eq "our")) {;
                return 1
            }
            if (((ref($decl) eq "Perlito5::AST::Int")) || ((ref($decl) eq "Perlito5::AST::Num")) || ((ref($decl) eq "Perlito5::AST::Buf")) || ((ref($decl) eq "Perlito5::AST::Var") && $decl->{"sigil"} ne "&") || ((ref($decl) eq "Perlito5::AST::Apply") && $decl->{"code"} eq "undef" && !@{$decl->{"arguments"}})) {;
                return 1
            }
            return 0
        }
        sub Perlito5::Java::LexicalBlock::emit_body_statement {
            (my $decl, my $level, my $wantarray) = @_;
            my @str;
            if (ref($decl) eq "Perlito5::AST::Apply" && $decl->{"code"} eq "package") {;
                $Perlito5::PKG_NAME = $decl->{"namespace"}
            }
            my @var_decl = $decl->emit_java_get_decl();
            for my $arg (@var_decl) {;
                push(@str, $arg->emit_java_init($level, $wantarray))
            }
            if (Perlito5::Java::LexicalBlock::looks_like_dead_code($decl)) {}
            elsif ((ref($decl) eq "Perlito5::AST::Apply") && ($decl->{"code"} eq "list:<,>" || $decl->{"code"} eq "infix:<=>>" || $decl->{"code"} eq "circumfix:<( )>")) {
                if ($decl->{"code"} eq "infix:<=>>") {;
                    $decl->{"arguments"}->[0] = Perlito5::AST::Lookup::->autoquote($decl->{"arguments"}->[0])
                }
                push(@str, Perlito5::Java::LexicalBlock::emit_body_statement($_))
                    for @{$decl->{"arguments"}}
            }
            elsif ((ref($decl) eq "Perlito5::AST::CompUnit") || (ref($decl) eq "Perlito5::AST::For") || (ref($decl) eq "Perlito5::AST::While") || (ref($decl) eq "Perlito5::AST::If") || (ref($decl) eq "Perlito5::AST::Block")) {;
                push(@str, $decl->emit_java($level, "statement"))
            }
            else {;
                push(@str, $decl->emit_java($level, "statement") . ";")
            }
            return @str
        }
        sub Perlito5::Java::LexicalBlock::emit_last_statement {
            (my $self, my $last_statement, my $level, my $wantarray, my $has_local, my $local_label) = @_;
            my @str;
            my @var_decl = $last_statement->emit_java_get_decl();
            for my $arg (@var_decl) {;
                push(@str, $arg->emit_java_init($level, $wantarray))
            }
            my @stmt = Perlito5::Macro::insert_return($last_statement);
            $last_statement = pop(@stmt);
            for $_ (@stmt) {;
                push(@str, $_->emit_java($level, "statement") . ";")
            }
            if ((ref($last_statement) eq "Perlito5::AST::Apply") && $last_statement->{"code"} eq "return") {
                if ($self->{"top_level"} || $last_statement->{"_return_from_block"} || $Perlito5::JAVA_CAN_RETURN) {
                    if (!@{$last_statement->{"arguments"}}) {;
                        push(@str, Perlito5::Java::LexicalBlock::emit_return($has_local, $local_label, "PerlOp.context(want)") . ";")
                    }
                    else {;
                        push(@str, Perlito5::Java::LexicalBlock::emit_return($has_local, $local_label, Perlito5::Java::to_runtime_context([$last_statement->{"arguments"}->[0]], $level + 1, "runtime")) . ";")
                    }
                }
                elsif (!@{$last_statement->{"arguments"}}) {
                    $Perlito5::THROW_RETURN = 1;
                    push(@str, "return PerlOp.ret(PerlOp.context(return_context));")
                }
                else {
                    $Perlito5::THROW_RETURN = 1;
                    push(@str, "return PerlOp.ret(" . Perlito5::Java::to_runtime_context([$last_statement->{"arguments"}->[0]], $level + 1, "return") . ");")
                }
            }
            else {
                my $s = $last_statement->emit_java($level, "runtime");
                (ref($last_statement) eq "Perlito5::AST::If") || (ref($last_statement) eq "Perlito5::AST::While") || (ref($last_statement) eq "Perlito5::AST::Block") || ($s .= ";");
                push(@str, $s)
            }
            return @str
        }
        sub Perlito5::Java::LexicalBlock::emit_java {
            (my $self, my $level, my $wantarray) = @_;
            local $Perlito5::PKG_NAME = $Perlito5::PKG_NAME;
            my $block_label = Perlito5::Java::get_java_loop_label($self->{"block_label"});
            $block_label && ($Perlito5::THROW = 1);
            my @block;
            my $block_last = $#{$self->{"block"}};
            STMT:
            for my $i (0 .. $block_last) {
                my $stmt = $self->{"block"}->[$i];
                if (defined($stmt)) {
                    push(@block, $stmt);
                    if ((ref($stmt) eq "Perlito5::AST::Apply") && $stmt->{"code"} eq "return") {;
                        last(STMT)
                    }
                }
            }
            if ($self->{"top_level"} && !@block) {;
                push(@block, Perlito5::AST::Apply::->new("code", "return", "arguments", []))
            }
            my @str;
            my @pre;
            my $has_local = $self->has_decl("local");
            my $has_regex = 0;
            if (grep {;
                $_->emit_java_has_regex()
            } @block) {
                $has_local = 1;
                $has_regex = 1
            }
            my $local_label = Perlito5::Java::get_label();
            local $Perlito5::JAVA_HAS_LOCAL = $has_local;
            local $Perlito5::JAVA_LOCAL_LABEL = $local_label;
            $has_local && ($Perlito5::JAVA_CAN_RETURN = 0);
            if ($has_local) {
                push(@pre, "int " . $local_label . " = PerlOp.local_length();");
                if ($has_regex) {;
                    push(@pre, "PerlOp.push_local_regex_result();")
                }
            }
            my $last_statement;
            if ($wantarray ne "void" && $wantarray ne "statement") {;
                $last_statement = pop(@block)
            }
            for my $decl (@block) {;
                push(@str, Perlito5::Java::LexicalBlock::emit_body_statement($decl, $level, "statement"))
            }
            if ($last_statement) {;
                push(@str, Perlito5::Java::LexicalBlock::emit_last_statement($self, $last_statement, $level, $wantarray, $has_local, $local_label))
            }
            if ($self->{"eval_block"}) {;
                return (@pre, "try {", \@str, "}", "catch(PlReturnException e) {", [Perlito5::Java::LexicalBlock::emit_return($has_local, $local_label, "e.ret") . ";"], "}", "catch(PlNextException e) {", ["throw e;"], "}", "catch(PlLastException e) {", ["throw e;"], "}", "catch(PlRedoException e) {", ["throw e;"], "}", "catch(PlDieException e) {", ["PlV.Scalar_EVAL_ERROR.set(e.ret);", "return PlCx.UNDEF;"], "}", "catch(Exception e) {", ["PlV.Scalar_EVAL_ERROR.set(new PlStringLazyError(e));", "return PlCx.UNDEF;"], "}")
            }
            if ($self->{"top_level"}) {
                if ($Perlito5::THROW_RETURN) {;
                    return (@pre, "try {", [@str], "}", "catch(PlReturnException e) {", [Perlito5::Java::LexicalBlock::emit_return($has_local, $local_label, "e.ret") . ";"], "}")
                }
                else {;
                    return (@pre, @str)
                }
            }
            if ($self->{"not_a_loop"}) {
                if ($has_local && !$last_statement) {
                    if (@block && $block[-1]->isa("Perlito5::AST::Apply") && $block[-1]->{"code"} eq "return") {}
                    else {;
                        push(@str, "PerlOp.cleanup_local(" . $local_label . ", PlCx.UNDEF);")
                    }
                }
                return (@pre, @str)
            }
            if ($Perlito5::THROW || ($self->{"continue"} && @{$self->{"continue"}->{"stmts"}} > 0)) {
                my $redo_label = Perlito5::Java::get_label();
                my $test_label = "e.label_id != 0";
                $block_label && ($test_label = "e.label_id != " . $block_label . " && e.label_id != 0");
                my @continue;
                if ($self->{"continue"}) {
                    local $Perlito5::JAVA_CAN_RETURN = 0;
                    push(@continue, "if (!" . $redo_label . ") {", ["try {", [Perlito5::Java::LexicalBlock::->new("block", $self->{"continue"}->{"stmts"}, "not_a_loop", 1)->emit_java($level + 2, $wantarray)], "}", "catch(PlNextException e) {", ["if (" . $test_label . ") {", ["throw e;"], "}"], "}", "catch(PlRedoException e) {", ["if (" . $test_label . ") {", ["throw e;"], "}", $redo_label . " = true;"], "}"], "}")
                }
                push(@pre, "boolean " . $redo_label . ";", "do {", [$redo_label . " = false;", "try {", [@str], "}", "catch(PlNextException e) {", ["if (" . $test_label . ") {", ["throw e;"], "}"], "}", "catch(PlRedoException e) {", ["if (" . $test_label . ") {", ["throw e;"], "}", $redo_label . " = true;"], "}", @continue], "} while (" . $redo_label . ");");
                @str = ()
            }
            elsif ($has_local && !$last_statement) {;
                push(@str, "PerlOp.cleanup_local(" . $local_label . ", PlCx.UNDEF);")
            }
            return (@pre, @str)
        }
        sub Perlito5::Java::LexicalBlock::emit_java_has_regex {;
            ()
        }
    }
    package Perlito5::AST::CompUnit;
    {
        sub Perlito5::AST::CompUnit::emit_java {
            (my $self, my $level, my $wantarray) = @_;
            local $Perlito5::JAVA_CAN_RETURN = 0;
            return Perlito5::Java::LexicalBlock::->new("block", $self->{"body"}, "not_a_loop", 1)->emit_java($level + 1, $wantarray)
        }
        sub Perlito5::AST::CompUnit::process_java_import_statement {
            (my $namespace, my $annotation_ast) = @_;
            my $str = '';
            my $Java_class = Perlito5::Java::get_java_class_info();
            my $class = $namespace;
            my $args_ast = $annotation_ast;
            my $ast = Perlito5::AST::Block::->new("stmts", [$args_ast]);
            my @data = Perlito5::Perl5::Runtime::eval_ast($ast);
            $Java_class->{$class} = Perlito5::Perl5::Runtime::eval_ast($ast) or die("error in arguments to generate Java class: " . ${"\@"});
            if ($Java_class->{$class}->{"java_path"}) {;
                $str .= "package " . ($Java_class->{$class}->{"java_path"}) . ";
"
            }
            elsif ($Java_class->{$class}->{"import"}) {;
                Perlito5::Java::set_java_class_defaults($class, $Java_class->{$class}->{"import"})
            }
            elsif ($Java_class->{$class}->{"extends"}) {
                my $extended = $Java_class->{$Java_class->{$class}->{"extends"}};
                if ($extended) {;
                    $Java_class->{$class}->{"extends_java_type"} = $extended->{"java_type"}
                }
                else {;
                    die("cannot extend class '" . ($Java_class->{$class}->{"extends"}) . "' because it was not declared")
                }
                my $perl_to_java = $class;
                $perl_to_java =~ s/:://g;
                Perlito5::Java::set_java_class_defaults($class, $perl_to_java)
            }
            elsif ($Java_class->{$class}->{"implements"}) {
                my $implemented = $Java_class->{$Java_class->{$class}->{"implements"}};
                if ($implemented) {;
                    $Java_class->{$class}->{"implements_java_type"} = $implemented->{"java_type"}
                }
                else {;
                    die("cannot implement class '" . ($Java_class->{$class}->{"implements"}) . "' because it was not declared")
                }
                my $perl_to_java = $class;
                $perl_to_java =~ s/:://g;
                Perlito5::Java::set_java_class_defaults($class, $perl_to_java)
            }
            else {;
                die("missing 'import' argument to generate Java class")
            }
            return $str
        }
        sub Perlito5::AST::CompUnit::emit_java_program {
            (my $comp_units, my %options) = @_;
            $Perlito5::PKG_NAME = "main";
            $Perlito5::THROW = 0;
            $Perlito5::THROW_RETURN = 0;
            my $level = 0;
            my $wantarray = "statement";
            my $str;
            $str .= Perlito5::Compiler::do_not_edit("//");
            for my $ann (@Perlito::ANNOTATION) {;
                $str .= Perlito5::AST::CompUnit::process_java_import_statement(@{$ann})
            }
            my @main;
            if ($options{"expand_use"}) {;
                for my $k (keys(%INC)) {;
                    push(@main, Perlito5::AST::Apply::->new("code", "infix:<=>", "arguments", [Perlito5::AST::Lookup::->new("obj", Perlito5::AST::Var::->new("_decl", "global", "_namespace", "main", "_real_sigil", "%", "name", "INC", "namespace", '', "sigil", "\$"), "index_exp", Perlito5::AST::Buf::->new("buf", $k)), Perlito5::AST::Buf::->new("buf", $INC{$k})])->emit_java($level + 1, "void") . ";")
                }
            }
            for my $comp_unit (@{$comp_units}) {
                my @str = $comp_unit->emit_java($level + 1, $wantarray);
                @str && !ref($str[-1]) && ($str[-1] .= ";
");
                push(@main, @str)
            }
            if ($options{"expand_use"}) {
                my $Java_class = Perlito5::Java::get_java_class_info();
                $str .= join('', Perlito5::Java::Runtime::->emit_java("java_classes", $Java_class, "java_constants", []))
            }
            my $main_class = "Main";
            $Perlito5::BOOTSTRAP_JAVA_EVAL && ($main_class = "LibPerl");
            $str .= Perlito5::Java::emit_wrap_java(-1, "class " . $main_class . " {", [@Perlito5::Java::Java_constants, "public static void main(String[] args) {", [($Perlito5::JAVA_EVAL ? "org.perlito.Perlito5.LibPerl.main( new String[]{} );" : ()), "PlV.init(args);", "int want = PlCx.VOID;", "int return_context = PlCx.VOID;", "PlArray List__ = new PlArray();", "Exception ee = null;", "try {", [@Perlito5::Java::Java_init, @main], "}", "catch(PlReturnException e) {", "}", "catch(PlNextException e) {", ["ee = new PlDieException(new PlString(\"Can't \\\"next\\\" outside a loop block\"));"], "}", "catch(PlLastException e) {", ["ee = new PlDieException(new PlString(\"Can't \\\"last\\\" outside a loop block\"));"], "}", "catch(PlRedoException e) {", ["ee = new PlDieException(new PlString(\"Can't \\\"redo\\\" outside a loop block\"));"], "}", "catch(Exception e) {", ["ee = e;"], "}", "if (ee != null) {", ["ee.printStackTrace(System.err);"], "}", "PlV.teardown();", "if (ee != null) {", ["System.exit(1);"], "}"], "}"], ["public static void init() {", ["main(new String[]{});"], "}"], ["public static PlObject[] apply(String functionName, String... args) {", ["PlArray list = new PlArray(args);", "PlObject result = new PlString(functionName).apply(PlCx.LIST, list);", "PlArray res = result instanceof PlArray ? (PlArray) result : new PlArray(result);", "PlObject[] out = new PlObject[res.to_int()];", "int i = 0;", "for (PlObject s : res) {", ["out[i++] = s;"], "}", "return out;"], "}"], ["public static PlObject[] apply(String functionName, PlObject... args) {", ["PlArray list = new PlArray(args);", "PlObject result = new PlString(functionName).apply(PlCx.LIST, list);", "PlArray res = result instanceof PlArray ? (PlArray) result : new PlArray(result);", "PlObject[] out = new PlObject[res.to_int()];", "int i = 0;", "for (PlObject s : res) {", ["out[i++] = s;"], "}", "return out;"], "}"], ["public static PlObject[] apply(String functionName) {", ["PlArray list = new PlArray();", "PlObject result = new PlString(functionName).apply(PlCx.LIST, list);", "PlArray res = result instanceof PlArray ? (PlArray) result : new PlArray(result);", "PlObject[] out = new PlObject[res.to_int()];", "int i = 0;", "for (PlObject s : res) {", ["out[i++] = s;"], "}", "return out;"], "}"], "}") . "
";
            return $str
        }
        sub Perlito5::AST::CompUnit::emit_java_get_decl {;
            ()
        }
        sub Perlito5::AST::CompUnit::emit_java_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Int;
    {
        sub Perlito5::AST::Int::emit_java {
            (my $self, my $level, my $wantarray) = @_;
            my $v = $self->{"int"};
            if (length($v) > 19 || $v > 2**62) {
                if (length($v) > 19 || $v >= 9223372036854775806.0) {;
                    return "new PlDouble(" . $v . ".0d)"
                }
                return "new PlInt(" . $v . "L)"
            }
            if ($v >= -2 && $v < 0) {;
                return "PlCx.MIN" . abs($v)
            }
            if ($v >= 0 && $v <= 9) {;
                return "PlCx.INT" . abs($v)
            }
            my $s = "new PlInt(" . $v . "L)";
            return Perlito5::Java::get_constant("PlInt", $s)
        }
        sub Perlito5::AST::Int::emit_java_set {;
            die("Can't modify constant item in scalar assignment")
        }
        sub Perlito5::AST::Int::emit_java_get_decl {;
            ()
        }
        sub Perlito5::AST::Int::emit_java_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Num;
    {
        my $inf = 1000**1000**1000;
        sub Perlito5::AST::Num::emit_java {
            (my $self, my $level, my $wantarray) = @_;
            my $s;
            if ($self->{"num"} == $inf) {;
                $s = "new PlDouble(Double.POSITIVE_INFINITY)"
            }
            else {;
                $s = "new PlDouble(" . ($self->{"num"}) . "d)"
            }
            return Perlito5::Java::get_constant("PlDouble", $s)
        }
        sub Perlito5::AST::Num::emit_java_set {;
            die("Can't modify constant item in scalar assignment")
        }
        sub Perlito5::AST::Num::emit_java_get_decl {;
            ()
        }
        sub Perlito5::AST::Num::emit_java_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Buf;
    {
        sub Perlito5::AST::Buf::emit_java {
            (my $self, my $level, my $wantarray) = @_;
            my $s = "PlStringConstant.getConstant(" . Perlito5::Java::escape_string($self->{"buf"}) . ")";
            return Perlito5::Java::get_constant("PlStringConstant", $s)
        }
        sub Perlito5::AST::Buf::emit_java_set {;
            die("Can't modify constant item in scalar assignment")
        }
        sub Perlito5::AST::Buf::emit_java_get_decl {;
            ()
        }
        sub Perlito5::AST::Buf::emit_java_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Block;
    {
        sub Perlito5::AST::Block::emit_java {
            (my $self, my $level, my $wantarray) = @_;
            local $Perlito5::THROW = 0;
            local $Perlito5::JAVA_CAN_RETURN = 0;
            my $body = Perlito5::Java::LexicalBlock::->new("block", $self->{"stmts"}, "block_label", $self->{"label"}, "continue", $self->{"continue"});
            my @str = $body->emit_java($level + 1, $wantarray);
            if ($Perlito5::THROW) {;
                @str = Perlito5::Java::emit_wrap_last_exception_java($self, \@str, $wantarray)
            }
            return Perlito5::Java::emit_wrap_java($level, @str)
        }
        sub Perlito5::AST::Block::emit_java_get_decl {;
            ()
        }
        sub Perlito5::AST::Block::emit_java_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Index;
    {
        sub Perlito5::AST::Index::emit_java {
            (my $self, my $level, my $wantarray, my $autovivification_type) = @_;
            my $method = $autovivification_type || "aget";
            $autovivification_type eq "scalar" && ($method = "aget_scalarref");
            $autovivification_type eq "array" && ($method = "aget_arrayref");
            $autovivification_type eq "hash" && ($method = "aget_hashref");
            $autovivification_type eq "lvalue" && ($method = "aget_lvalue");
            $autovivification_type eq "local" && ($method = "aget_lvalue_local");
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\@>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->{"sigil"} eq "\@") || ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "circumfix:<( )>")) {;
                return $self->{"obj"}->emit_java($level, "list", "lvalue") . ".aget_list_of_aliases(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_list([$self->{"index_exp"}], $level) . ")"
            }
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<%>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->{"sigil"} eq "%")) {
                my $obj = $self->{"obj"}->clone();
                $obj->{"sigil"} eq "%" && ($obj->{"sigil"} = "\@");
                $obj->{"code"} eq "prefix:<%>" && ($obj->{"code"} = "prefix:<\@>");
                return $obj->emit_java($level) . ".aget_hash_list_of_aliases(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_list([$self->{"index_exp"}], $level) . ")"
            }
            if ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\$>") {;
                return Perlito5::AST::Call::->new("method", "postcircumfix:<[ ]>", "invocant", $self->{"obj"}->{"arguments"}->[0], "arguments", $self->{"index_exp"})->emit_java($level, $wantarray, $autovivification_type)
            }
            my $s = Perlito5::Java::to_native_int($self->{"index_exp"}, $level + 1);
            return $self->emit_java_container($level) . "." . $method . "(" . $s . ")"
        }
        sub Perlito5::AST::Index::emit_java_set {
            (my $self, my $arguments, my $level, my $wantarray, my $localize) = @_;
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\@>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->{"sigil"} eq "\@")) {;
                return "((PlArray)" . $self->emit_java($level, "list") . ").list_set(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_list([$arguments], $level) . ")"
            }
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<%>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->{"sigil"} eq "%")) {;
                die("Can't modify index/value array slice in list assignment")
            }
            if ($localize) {;
                return $self->emit_java_container($level) . ".aget_lvalue_local(" . Perlito5::Java::autoquote($self->{"index_exp"}, $level) . ").set(" . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")"
            }
            my $s = Perlito5::Java::to_native_int($self->{"index_exp"}, $level + 1);
            if ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\$>") {
                my $obj = Perlito5::Java::emit_java_autovivify($self->{"obj"}->{"arguments"}->[0], $level + 1, "array");
                return $obj . ".aset(" . $s . ", " . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")"
            }
            return $self->emit_java_container($level) . ".aset(" . $s . ", " . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")"
        }
        sub Perlito5::AST::Index::emit_java_container {
            my $self = shift;
            my $level = shift;
            if ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\$>") {
                my $v = Perlito5::AST::Apply::->new(%{$self->{"obj"}}, "code", "prefix:<\@>");
                return $v->emit_java($level)
            }
            if ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "circumfix:<( )>") {;
                return Perlito5::Java::to_list([$self->{"obj"}], $level)
            }
            if ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->{"sigil"} eq "\$") {
                my $obj = $self->{"obj"}->clone();
                $obj->{"sigil"} = "\@";
                return $obj->emit_java($level)
            }
            else {;
                return Perlito5::Java::emit_java_autovivify($self->{"obj"}, $level, "array")
            }
        }
        sub Perlito5::AST::Index::emit_java_get_decl {;
            ()
        }
        sub Perlito5::AST::Index::emit_java_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Lookup;
    {
        sub Perlito5::AST::Lookup::emit_java {
            (my $self, my $level, my $wantarray, my $autovivification_type) = @_;
            my $method = $autovivification_type || "hget";
            $autovivification_type eq "scalar" && ($method = "hget_scalarref");
            $autovivification_type eq "array" && ($method = "hget_arrayref");
            $autovivification_type eq "hash" && ($method = "hget_hashref");
            $autovivification_type eq "lvalue" && ($method = "hget_lvalue");
            $autovivification_type eq "local" && ($method = "hget_lvalue_local");
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\$>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->{"sigil"} eq "\$")) {;
                if ($self->{"index_exp"}->isa("Perlito5::AST::Apply") && $self->{"index_exp"}->{"code"} eq "list:<,>") {
                    $self->{"index_exp"}->{"code"} = "join";
                    unshift(@{$self->{"index_exp"}->{"arguments"}}, Perlito5::AST::Var::->new("_decl", "global", "_namespace", "main", "name", ";", "namespace", '', "sigil", "\$"))
                }
            }
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\@>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->{"sigil"} eq "\@")) {
                my $v;
                if ($self->{"obj"}->isa("Perlito5::AST::Var")) {;
                    $v = $self->{"obj"}
                }
                $self->{"obj"}->isa("Perlito5::AST::Apply") && ($v = Perlito5::AST::Apply::->new("code", "prefix:<%>", "namespace", $self->{"obj"}->namespace(), "arguments", $self->{"obj"}->arguments()));
                return "((PlHash)" . $v->emit_java($level, "scalar") . ").hget_list_of_aliases(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_list([$self->{"index_exp"}], $level) . ")"
            }
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<%>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->{"sigil"} eq "%")) {
                my $v;
                if ($self->{"obj"}->isa("Perlito5::AST::Var")) {;
                    $v = $self->{"obj"}
                }
                $self->{"obj"}->isa("Perlito5::AST::Apply") && ($v = Perlito5::AST::Apply::->new("code", "prefix:<%>", "namespace", $self->{"obj"}->namespace(), "arguments", $self->{"obj"}->arguments()));
                return $v->emit_java($level) . ".hget_hash_list_of_aliases(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_list([$self->{"index_exp"}], $level) . ")"
            }
            if ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\$>") {;
                return Perlito5::AST::Call::->new("method", "postcircumfix:<{ }>", "invocant", $self->{"obj"}->{"arguments"}->[0], "arguments", $self->{"index_exp"})->emit_java($level, $wantarray, $autovivification_type)
            }
            my $index = Perlito5::AST::Lookup::->autoquote($self->{"index_exp"});
            if ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->{"name"} eq "+" && $self->{"obj"}->{"_namespace"} eq "main" && $self->{"obj"}->{"sigil"} eq "\$") {;
                return "PerlOp.regex_named_capture(" . Perlito5::Java::to_native_str($index, $level) . ")"
            }
            return $self->emit_java_container($level) . "." . $method . "(" . Perlito5::Java::to_native_str($index, $level) . ")"
        }
        sub Perlito5::AST::Lookup::emit_java_set {
            (my $self, my $arguments, my $level, my $wantarray, my $localize) = @_;
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\$>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->{"sigil"} eq "\$")) {;
                if ($self->{"index_exp"}->isa("Perlito5::AST::Apply") && $self->{"index_exp"}->{"code"} eq "list:<,>") {
                    $self->{"index_exp"}->{"code"} = "join";
                    unshift(@{$self->{"index_exp"}->{"arguments"}}, Perlito5::AST::Var::->new("_decl", "global", "_namespace", "main", "name", ";", "namespace", '', "sigil", "\$"))
                }
            }
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\@>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->{"sigil"} eq "\@")) {;
                return "((PlArray)" . $self->emit_java($level, "list") . ").list_set(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_list([$arguments], $level) . ")"
            }
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<%>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->{"sigil"} eq "%")) {;
                die("Can't modify index/value array slice in list assignment")
            }
            if ($localize) {;
                return $self->emit_java_container($level) . ".hget_lvalue_local(" . Perlito5::Java::autoquote($self->{"index_exp"}, $level) . ").set(" . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")"
            }
            if ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\$>") {
                my $obj = Perlito5::Java::emit_java_autovivify($self->{"obj"}->{"arguments"}->[0], $level + 1, "hash");
                return $obj . ".hset(" . Perlito5::Java::autoquote($self->{"index_exp"}, $level) . ", " . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")"
            }
            my $index = Perlito5::AST::Lookup::->autoquote($self->{"index_exp"});
            return $self->emit_java_container($level) . ".hset(" . Perlito5::Java::to_native_str($index, $level) . ", " . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")"
        }
        sub Perlito5::AST::Lookup::emit_java_container {
            my $self = shift;
            my $level = shift;
            if ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\$>") {
                my $v = Perlito5::AST::Apply::->new(%{$self->{"obj"}}, "code", "prefix:<%>");
                return $v->emit_java($level)
            }
            if ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->{"sigil"} eq "\$") {
                my $v = Perlito5::AST::Var::->new(%{$self->{"obj"}}, "sigil", "%");
                return $v->emit_java($level)
            }
            else {;
                return Perlito5::Java::emit_java_autovivify($self->{"obj"}, $level, "hash")
            }
        }
        sub Perlito5::AST::Lookup::emit_java_get_decl {;
            ()
        }
        sub Perlito5::AST::Lookup::emit_java_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Var;
    {
        sub Perlito5::AST::Var::emit_java_global {
            (my $self, my $level, my $wantarray, my $localize) = @_;
            my $local = $localize ? "_local" : '';
            my $str_name = $self->{"name"};
            my $sigil = $self->{"_real_sigil"} || $self->{"sigil"};
            my $namespace = $self->{"namespace"} || $self->{"_namespace"};
            if ($sigil eq "\@" && $self->{"name"} eq "_" && $namespace eq "main") {
                my $s = "List__";
                if ($self->{"sigil"} eq "\$#") {;
                    return $s . ".end_of_array_index()"
                }
                if ($wantarray eq "scalar") {;
                    return $s . ".length_of_array()"
                }
                if ($wantarray eq "runtime" || $wantarray eq "return") {;
                    return "(" . Perlito5::Java::to_context($wantarray) . " == PlCx.LIST" . " ? " . $s . " : " . $s . ".length_of_array()" . ")"
                }
                return $s
            }
            if ($sigil eq "\$") {
                if ($self->{"name"} > 0 && $self->{"name"} ne "Inf") {;
                    return "PerlOp.regex_var(" . (0 + ($self->{"name"})) . ")"
                }
                if ($namespace eq "main") {
                    my $java_name = $Perlito5::Java::special_scalar{$self->{"name"}};
                    if ($java_name) {
                        !$local && return "PlV." . $java_name;
                        return "PlV.sget" . $local . "_" . $java_name . "()"
                    }
                }
                if ($self->{"name"} eq "&" || $self->{"name"} eq "`" || $self->{"name"} eq "'") {;
                    return "PerlOp.regex_var(" . Perlito5::Java::escape_string($self->{"name"}) . ")"
                }
                if ($self->{"name"} eq "\$") {;
                    return "PerlOp.getPID()"
                }
            }
            if ($sigil eq "::") {;
                return Perlito5::Java::escape_string($namespace)
            }
            my $full_name = $namespace . "::" . $str_name;
            my $index = Perlito5::Java::escape_string($full_name);
            if ($sigil eq "\$") {
                if (!$local) {
                    my $scalar = Perlito5::AST::Buf::->new("buf", $full_name)->emit_java($level, "scalar");
                    return $scalar . ".scalarRef"
                }
                return "PlV.sget" . $local . "(" . $index . ")"
            }
            if ($sigil eq "*") {;
                return "PlV.fget" . $local . "(" . $index . ")"
            }
            if ($sigil eq "&") {
                my $namespace = $self->{"namespace"} || $Perlito5::PKG_NAME;
                my $sub = Perlito5::AST::Buf::->new("buf", $namespace . "::" . $str_name)->emit_java($level, "scalar");
                return $sub . ".apply(" . Perlito5::Java::to_context($wantarray) . ", List__)"
            }
            if ($sigil eq "\@") {
                if ($self->{"sigil"} eq "\$#") {;
                    return "PlV.array_get" . $local . "(" . $index . ").end_of_array_index()"
                }
                my $s = "PlV.array_get" . $local . "(" . $index . ")";
                if (!$local) {
                    my $scalar = Perlito5::AST::Buf::->new("buf", $full_name)->emit_java($level, "scalar");
                    $s = $scalar . ".arrayRef.o.array_deref_strict()"
                }
                if ($wantarray eq "scalar") {;
                    return $s . ".length_of_array()"
                }
                return $s
            }
            if ($sigil eq "%") {
                if (!defined($str_name)) {;
                    return "PerlOp.getSymbolTable(" . $index . ")"
                }
                if (!$local) {
                    my $scalar = Perlito5::AST::Buf::->new("buf", $full_name)->emit_java($level, "scalar");
                    return $scalar . ".hashRef.o.hash_deref_strict()"
                }
                return "PlV.hash_get" . $local . "(" . $index . ")"
            }
            die("don't know how to access variable ", $sigil, $self->name())
        }
        sub Perlito5::AST::Var::emit_java_global_set {
            (my $self, my $arguments, my $level, my $wantarray, my $localize) = @_;
            my $local = $localize ? "_local" : '';
            my $str_name = $self->{"name"};
            my $sigil = $self->{"_real_sigil"} || $self->{"sigil"};
            my $namespace = $self->{"namespace"} || $self->{"_namespace"};
            if ($sigil eq "\@" && $self->{"name"} eq "_" && $namespace eq "main") {
                my $s = "List__";
                if ($self->{"sigil"} eq "\$#") {;
                    return $s . ".set_end_of_array_index(" . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")"
                }
                if ($wantarray eq "scalar") {;
                    return $s . ".to_long()"
                }
                return $s . ".set(" . Perlito5::Java::to_list([$arguments], $level + 1) . ")"
            }
            if ($sigil eq "\$" && $self->{"name"} > 0 && $self->{"name"} ne "Inf") {;
                return "p5_regex_capture[" . (($self->{"name"}) - 1) . "]"
            }
            if ($sigil eq "::") {;
                return Perlito5::Java::escape_string($namespace)
            }
            my $full_name = $namespace . "::" . $str_name;
            my $index = Perlito5::Java::escape_string($full_name);
            if ($sigil eq "\$") {
                if ($namespace eq "main") {
                    my $java_name = $Perlito5::Java::special_scalar{$self->{"name"}};
                    if ($java_name) {
                        !$local && return "PlV." . $java_name . ".set(" . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")";
                        return "PlV.sset" . $local . "_" . $java_name . "(" . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")"
                    }
                }
                if (!$local) {
                    my $scalar = Perlito5::AST::Buf::->new("buf", $full_name)->emit_java($level, "scalar");
                    return $scalar . ".scalarRef.set(" . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")"
                }
                return "PlV.sset" . $local . "(" . $index . ", " . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")"
            }
            if ($sigil eq "\@") {
                if ($self->{"sigil"} eq "\$#") {
                    $self = $self->clone();
                    $self->{"sigil"} = "\@";
                    return "PlV.array_get(" . $index . ").set_end_of_array_index(" . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")"
                }
                if (!$local) {
                    my $scalar = Perlito5::AST::Buf::->new("buf", $full_name)->emit_java($level, "scalar");
                    return $scalar . ".arrayRef.o.array_deref_set(" . Perlito5::Java::to_list([$arguments], $level + 1) . ")"
                }
                return "PlV.array_set" . $local . "(" . $index . ", " . Perlito5::Java::to_list([$arguments], $level + 1) . ")"
            }
            if ($sigil eq "%") {
                if (!$local) {
                    my $scalar = Perlito5::AST::Buf::->new("buf", $full_name)->emit_java($level, "scalar");
                    return $scalar . ".hashRef.o.hash_deref_set(" . Perlito5::Java::to_list([$arguments], $level + 1) . ")"
                }
                return "PlV.hash_set" . $local . "(" . $index . ", " . Perlito5::Java::to_list([$arguments], $level + 1) . ")"
            }
            if ($sigil eq "*") {;
                return "PlV.glob_set" . $local . "(" . $index . ", " . Perlito5::Java::to_scalar([$arguments], $level + 1) . ", " . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ")"
            }
            if ($sigil eq "&") {}
            die("don't know how to assign to variable ", $sigil, $self->name())
        }
        sub Perlito5::AST::Var::emit_java_global_set_alias {
            (my $self, my $arguments, my $level, my $wantarray, my $localize) = @_;
            $localize && die("can't localize emit_java_global_set_alias()");
            my $str_name = $self->{"name"};
            my $sigil = $self->{"_real_sigil"} || $self->{"sigil"};
            my $namespace = $self->{"namespace"} || $self->{"_namespace"};
            if ($sigil eq "\$" && $self->{"name"} > 0) {;
                die("not implemented emit_java_global_set_alias() for regex capture")
            }
            my $index = Perlito5::Java::escape_string($namespace . "::" . $str_name);
            ref($arguments) && ($arguments = Perlito5::Java::to_scalar([$arguments], $level + 1));
            if ($sigil eq "\$") {
                if ($namespace eq "main") {
                    my $java_name = $Perlito5::Java::special_scalar{$self->{"name"}};
                    if ($java_name) {;
                        return "PlV.sset_alias_" . $java_name . "(" . $arguments . ")"
                    }
                }
                return "PlV.sset_alias(" . $index . ", " . $arguments . ")"
            }
            $sigil eq "\@" && return "PlV.aset_alias(" . $index . ", " . $arguments . ")";
            $sigil eq "%" && return "PlV.hset_alias(" . $index . ", " . $arguments . ")";
            die("can't emit_java_global_set_alias() for sigil '" . $sigil . "'")
        }
        sub Perlito5::AST::Var::emit_java {
            (my $self, my $level, my $wantarray) = @_;
            $self = $self->to_begin_scratchpad();
            my $sigil = $self->{"_real_sigil"} || $self->{"sigil"};
            my $decl_type = $self->{"_decl"} || "global";
            if ($decl_type ne "my" && $decl_type ne "state") {;
                return $self->emit_java_global($level, $wantarray)
            }
            my $str_name = ($self->{"name"}) . "_" . ($self->{"_id"});
            exists($Perlito5::Java::Java_var_name{$self->{"_id"}}) && ($str_name = $Perlito5::Java::Java_var_name{$self->{"_id"}});
            if ($self->{"sigil"} eq "\$#") {;
                return $str_name . ".end_of_array_index()"
            }
            if ($sigil eq "\@") {
                if ($wantarray eq "scalar") {;
                    return $self->emit_java($level, "list") . ".length_of_array()"
                }
                if ($wantarray eq "runtime" || $wantarray eq "return") {;
                    return "(" . Perlito5::Java::to_context($wantarray) . " == PlCx.LIST" . " ? " . $self->emit_java($level, "list") . " : " . $self->emit_java($level, "list") . ".length_of_array()" . ")"
                }
            }
            return $str_name
        }
        sub Perlito5::AST::Var::emit_java_set {
            (my $self, my $arguments, my $level, my $wantarray) = @_;
            $self = $self->to_begin_scratchpad();
            my $decl_type = $self->{"_decl"} || "global";
            if ($decl_type ne "my" && $decl_type ne "state") {;
                return $self->emit_java_global_set($arguments, $level, $wantarray)
            }
            my $open = $wantarray eq "void" || $wantarray eq "statement" ? '' : "(";
            my $close = $wantarray eq "void" || $wantarray eq "statement" ? '' : ")";
            my $sigil = $self->{"_real_sigil"} || $self->{"sigil"};
            my $id = $self->{"_id"};
            if ($sigil eq "\$" && $id) {
                my $Java_var = Perlito5::Java::get_java_var_info();
                my $type = $Java_var->{$id}->{"type"} || "PlLvalue";
                if ($type ne "PlLvalue") {
                    my $class_info = Perlito5::Java::get_java_class_info();
                    if (exists($class_info->{$type})) {
                        if (ref($arguments) eq "Perlito5::AST::Var") {
                            my $arg_sigil = $arguments->{"_real_sigil"} || $arguments->{"sigil"};
                            my $arg_id = $arguments->{"_id"};
                            if ($arg_sigil eq "\$") {
                                my $arg_type = "PlLvalue";
                                $arg_id && $Java_var->{$arg_id}->{"type"} && ($arg_type = $Java_var->{$arg_id}->{"type"});
                                if ($arg_type eq "PlLvalue") {
                                    if (exists($class_info->{$type}->{"perl_to_java"})) {;
                                        return $self->emit_java($level) . " = " . Perlito5::Java::to_scalar([$arguments], $level + 1) . "." . ($class_info->{$type}->{"perl_to_java"}) . "()"
                                    }
                                    if (exists($class_info->{$type}->{"java_type"})) {
                                        my $t = $class_info->{$type}->{"java_type"};
                                        return $self->emit_java($level) . " = " . "(" . $t . ")(" . Perlito5::Java::to_scalar([$arguments], $level + 1) . ".toJava())"
                                    }
                                }
                            }
                        }
                        my $java_type = $class_info->{$type}->{"java_type"};
                        return $self->emit_java($level) . " = " . Perlito5::Java::to_native_args([$arguments], $level + 1, $java_type)
                    }
                    return $self->emit_java($level) . " = " . Perlito5::Java::to_native_args([$arguments], $level + 1)
                }
                return $self->emit_java($level) . ".set(" . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")"
            }
            if ($sigil eq "\@") {
                if ($self->{"sigil"} eq "\$#") {
                    $self = $self->clone();
                    $self->{"sigil"} = "\@";
                    return $open . $self->emit_java($level) . ".set_end_of_array_index(" . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")" . $close
                }
                return $self->emit_java($level) . ".set(" . Perlito5::Java::to_list([$arguments], $level + 1) . ")"
            }
            if ($sigil eq "%") {;
                return $self->emit_java($level) . ".set(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_list([$arguments], $level + 1, "hash") . ")"
            }
            if ($sigil eq "*") {
                my $namespace = $self->{"namespace"} || $self->{"_namespace"};
                return "p5typeglob_set(" . Perlito5::Java::escape_string($namespace) . ", " . Perlito5::Java::escape_string($self->{"name"}) . ", " . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")"
            }
            die("don't know how to assign to variable ", $sigil, $self->name())
        }
        sub Perlito5::AST::Var::emit_java_get_decl {;
            ()
        }
        sub Perlito5::AST::Var::emit_java_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Decl;
    {
        sub Perlito5::AST::Decl::emit_java {
            (my $self, my $level, my $wantarray) = @_;
            my $var = $self->{"var"};
            ref($var) eq "Perlito5::AST::Var" && ($var = $var->to_begin_scratchpad());
            my $localize = '';
            if ($self->{"decl"} eq "local") {
                $localize = "local";
                if (ref($var) eq "Perlito5::AST::Var") {;
                    return $var->emit_java_global($level, $wantarray, $localize)
                }
            }
            $var->emit_java($level, $wantarray, $localize)
        }
        sub Perlito5::AST::Decl::emit_java_init {
            (my $self, my $level, my $wantarray) = @_;
            my $var = $self->{"var"};
            ref($var) eq "Perlito5::AST::Var" && $var->is_begin_scratchpad() && return ();
            my $Java_var = Perlito5::Java::get_java_var_info();
            my $type = $self->{"type"} || "PlLvalue";
            my $id = $self->{"var"}->{"_id"};
            if ($id) {
                $Java_var->{$id} && return;
                $Java_var->{$id} = {"id" => $id, "type" => $type, }
            }
            if ($self->{"decl"} eq "our") {;
                return ''
            }
            if ($self->{"decl"} eq "local") {;
                return ''
            }
            if ($self->{"decl"} eq "my" || $self->{"decl"} eq "state") {
                if ($self->{"var"}->{"sigil"} eq "%") {;
                    return "PlHash " . $self->{"var"}->emit_java($level) . " = new PlHash();"
                }
                elsif ($self->{"var"}->{"sigil"} eq "\@") {;
                    return "PlArray " . $self->{"var"}->emit_java($level) . " = new PlArray();"
                }
                else {
                    my $Java_class = Perlito5::Java::get_java_class_info();
                    my $java_type = $Java_class->{$type}->{"java_type"} || "PlLvalue";
                    if ($java_type eq "PlLvalue") {;
                        return $java_type . " " . $self->{"var"}->emit_java($level) . (" = new " . $java_type . "();")
                    }
                    else {;
                        return $java_type . " " . $self->{"var"}->emit_java($level) . ";"
                    }
                }
            }
            else {;
                die("not implemented: Perlito5::AST::Decl '" . ($self->{"decl"}) . "'")
            }
        }
        sub Perlito5::AST::Decl::emit_java_set {
            (my $self, my $arguments, my $level, my $wantarray) = @_;
            my $var = $self->{"var"};
            ref($var) eq "Perlito5::AST::Var" && ($var = $var->to_begin_scratchpad());
            my $localize = '';
            if ($self->{"decl"} eq "local") {
                $localize = "local";
                if (ref($var) eq "Perlito5::AST::Var") {;
                    return $var->emit_java_global_set($arguments, $level, $wantarray, $localize)
                }
            }
            $var->emit_java_set($arguments, $level, $wantarray, $localize)
        }
        sub Perlito5::AST::Decl::emit_java_get_decl {
            my $self = shift;
            my $var = $self->{"var"};
            ref($var) eq "Perlito5::AST::Var" && $var->is_begin_scratchpad() && return ();
            return ($self)
        }
        sub Perlito5::AST::Decl::emit_java_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Call;
    {
        sub Perlito5::AST::Call::emit_java {
            (my $self, my $level, my $wantarray, my $autovivification_type) = @_;
            my $meth = $self->{"method"};
            if ($meth eq "postcircumfix:<[ ]>") {
                my $method = $autovivification_type || "aget";
                $autovivification_type eq "scalar" && ($method = "aget_scalarref");
                $autovivification_type eq "array" && ($method = "aget_arrayref");
                $autovivification_type eq "hash" && ($method = "aget_hashref");
                $autovivification_type eq "lvalue" && ($method = "aget_lvalue");
                return Perlito5::Java::emit_java_autovivify($self->{"invocant"}, $level, "array") . "." . $method . "(" . Perlito5::Java::to_native_int($self->{"arguments"}, $level + 1) . ")"
            }
            if ($meth eq "postcircumfix:<{ }>") {
                my $method = $autovivification_type || "hget";
                $autovivification_type eq "scalar" && ($method = "hget_scalarref");
                $autovivification_type eq "array" && ($method = "hget_arrayref");
                $autovivification_type eq "hash" && ($method = "hget_hashref");
                $autovivification_type eq "lvalue" && ($method = "hget_lvalue");
                my $args = $self->{"arguments"};
                if ((ref($args) eq "Perlito5::AST::Apply") && $args->{"code"} eq "list:<,>") {
                    $args->{"code"} = "join";
                    unshift(@{$args->{"arguments"}}, Perlito5::AST::Var::->new("_decl", "global", "_namespace", "main", "name", ";", "namespace", '', "sigil", "\$"))
                }
                return Perlito5::Java::emit_java_autovivify($self->{"invocant"}, $level, "hash") . "." . $method . "(" . Perlito5::Java::to_native_str(Perlito5::AST::Lookup::->autoquote($self->{"arguments"}), $level + 1, "list") . ")"
            }
            if ($meth eq "postcircumfix:<( )>") {
                my $invocant;
                if (ref($self->{"invocant"}) eq "Perlito5::AST::Var" && $self->{"invocant"}->{"sigil"} eq "::") {
                    if ($self->{"invocant"}->{"namespace"} eq "__SUB__" || $self->{"invocant"}->{"namespace"} eq "CORE::__SUB__") {;
                        $invocant = "this.getCurrentSub()"
                    }
                    else {
                        my $fullname = $self->{"invocant"}->{"namespace"};
                        if ($fullname !~ m/::/) {;
                            $fullname = $Perlito5::PKG_NAME . "::" . $fullname
                        }
                        $invocant = Perlito5::AST::Buf::->new("buf", $fullname)->emit_java($level, "scalar")
                    }
                }
                elsif (ref($self->{"invocant"}) eq "Perlito5::AST::Int") {;
                    $invocant = Perlito5::AST::Buf::->new("buf", $Perlito5::PKG_NAME . "::" . ($self->{"invocant"}->{"int"}))->emit_java($level, "scalar")
                }
                else {;
                    $invocant = $self->{"invocant"}->emit_java($level, "scalar")
                }
                return $invocant . ".apply(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_list($self->{"arguments"}) . ")"
            }
            if (substr($meth, 0, 7) eq "SUPER::") {
                my $method = substr($meth, 7);
                if ($method) {
                    $method = Perlito5::Java::escape_string($method);
                    return "PerlOp.callSuper(" . $method . ", " . Perlito5::Java::pkg() . ", " . Perlito5::Java::to_method_call_param_list($self->{"invocant"}, $self->{"arguments"}, $level + 1) . ", " . Perlito5::Java::to_context($wantarray) . ")"
                }
            }
            if (ref($self->{"invocant"}) eq "Perlito5::AST::Var" && $self->{"invocant"}->{"sigil"} eq "::") {
                my $Java_class = Perlito5::Java::get_java_class_info();
                if (exists($Java_class->{$self->{"invocant"}->{"namespace"}})) {
                    my $info = $Java_class->{$self->{"invocant"}->{"namespace"}};
                    if ($meth eq "new") {;
                        return "new " . ($info->{"java_type"}) . "(" . Perlito5::Java::to_native_args($self->{"arguments"}) . ")"
                    }
                    if ($self->{"_no_params"}) {;
                        return ($info->{"java_type"}) . "." . $meth
                    }
                    else {;
                        return ($info->{"java_type"}) . "." . $meth . "(" . Perlito5::Java::to_native_args($self->{"arguments"}) . ")"
                    }
                }
            }
            my $invocant = $self->{"invocant"}->emit_java($level, "scalar");
            if (ref($self->{"invocant"}) eq "Perlito5::AST::Var" && $self->{"invocant"}->{"_id"}) {
                my $id = $self->{"invocant"}->{"_id"};
                my $Java_var = Perlito5::Java::get_java_var_info();
                my $type = $Java_var->{$id}->{"type"} || "PlLvalue";
                if ($type ne "PlLvalue") {
                    if ($self->{"_no_params"}) {;
                        return $invocant . "." . $meth
                    }
                    else {;
                        return $invocant . "." . $meth . "(" . Perlito5::Java::to_native_args($self->{"arguments"}) . ")"
                    }
                }
            }
            if (Perlito5::Java::is_native($self->{"invocant"})) {
                if ($self->{"_no_params"}) {;
                    return $invocant . "." . $meth
                }
                else {;
                    return $invocant . "." . $meth . "(" . Perlito5::Java::to_native_args($self->{"arguments"}) . ")"
                }
            }
            if (ref($meth)) {;
                $meth = $meth->emit_java($level, "scalar")
            }
            else {;
                $meth = Perlito5::AST::Buf::->new("buf", $meth)->emit_java($level, "scalar")
            }
            return "PerlOp.call(" . $meth . ", " . Perlito5::Java::to_method_call_param_list($self->{"invocant"}, $self->{"arguments"}, $level + 1) . ", " . Perlito5::Java::to_context($wantarray) . ")"
        }
        sub Perlito5::AST::Call::emit_java_set {
            (my $self, my $arguments, my $level, my $wantarray) = @_;
            if ($self->{"method"} eq "postcircumfix:<[ ]>") {;
                return Perlito5::Java::emit_java_autovivify($self->{"invocant"}, $level, "array") . ".aset(" . Perlito5::Java::to_native_int($self->{"arguments"}, $level + 1) . ", " . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")"
            }
            if ($self->{"method"} eq "postcircumfix:<{ }>") {
                my $args = $self->{"arguments"};
                if ((ref($args) eq "Perlito5::AST::Apply") && $args->{"code"} eq "list:<,>") {
                    $args->{"code"} = "join";
                    unshift(@{$args->{"arguments"}}, Perlito5::AST::Var::->new("_decl", "global", "_namespace", "main", "name", ";", "namespace", '', "sigil", "\$"))
                }
                return Perlito5::Java::emit_java_autovivify($self->{"invocant"}, $level, "hash") . ".hset(" . Perlito5::Java::to_native_str(Perlito5::AST::Lookup::->autoquote($self->{"arguments"}), $level + 1, "list") . ", " . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")"
            }
            die("don't know how to assign to method ", $self->{"method"})
        }
        sub Perlito5::AST::Call::emit_java_get_decl {;
            ()
        }
        sub Perlito5::AST::Call::emit_java_has_regex {;
            ()
        }
    }
    package Perlito5::AST::If;
    {
        sub Perlito5::AST::If::emit_java {
            (my $self, my $level, my $wantarray) = @_;
            my $cond = $self->{"cond"};
            my @str;
            my $old_level = $level;
            if ($cond) {
                my @var_decl = $cond->emit_java_get_decl();
                for my $arg (@var_decl) {;
                    push(@str, $arg->emit_java_init($level + 1, $wantarray))
                }
            }
            my $body = ref($self->{"body"}) ne "Perlito5::AST::Block" ? $self->{"body"} : (!@{$self->{"body"}->stmts()}) ? undef : Perlito5::Java::LexicalBlock::->new("block", $self->{"body"}->stmts(), "not_a_loop", 1);
            my $otherwise = ref($self->{"otherwise"}) ne "Perlito5::AST::Block" ? $self->{"otherwise"} : (!@{$self->{"otherwise"}->stmts()}) ? undef : Perlito5::Java::LexicalBlock::->new("block", $self->{"otherwise"}->stmts(), "not_a_loop", 1);
            push(@str, "if (" . Perlito5::Java::to_native_bool($cond, $level + 1) . ") {");
            if ($body) {;
                push(@str, [$body->emit_java($level + 1, $wantarray)])
            }
            push(@str, "}");
            if ($otherwise) {;
                push(@str, "else {", [$otherwise->emit_java($level + 1, $wantarray)], "}")
            }
            return Perlito5::Java::emit_wrap_java($level, @str)
        }
        sub Perlito5::AST::If::emit_java_get_decl {;
            ()
        }
        sub Perlito5::AST::If::emit_java_has_regex {;
            ()
        }
    }
    package Perlito5::AST::When;
    {
        sub Perlito5::AST::When::emit_java {
            (my $self, my $level, my $wantarray) = @_;
            my $cond = $self->{"cond"};
            my @str;
            my $old_level = $level;
            if ($cond) {
                my @var_decl = $cond->emit_java_get_decl();
                for my $arg (@var_decl) {
                    $level = $old_level + 1;
                    push(@str, $arg->emit_java_init($level, $wantarray))
                }
            }
            $cond = Perlito5::AST::Apply::->new("arguments", [Perlito5::AST::Var::SCALAR_ARG(), $cond], "code", "infix:<~~>", "namespace", '');
            my $next = Perlito5::AST::Apply::->new("arguments", [], "bareword", 1, "code", "next", "namespace", '');
            my $body = ref($self->{"body"}) ne "Perlito5::AST::Block" ? Perlito5::Java::LexicalBlock::->new("block", [$self->{"body"}], "not_a_loop", 1) : (!@{$self->{"body"}->stmts()}) ? undef : Perlito5::Java::LexicalBlock::->new("block", $self->{"body"}->stmts(), "not_a_loop", 1);
            push(@{$body->{"block"}}, $next);
            push(@str, "if (" . Perlito5::Java::to_native_bool($cond, $level + 1) . ") {");
            if ($body) {;
                push(@str, [$body->emit_java($level + 1, $wantarray)])
            }
            push(@str, "}");
            return Perlito5::Java::emit_wrap_java($level, @str)
        }
        sub Perlito5::AST::When::emit_java_get_decl {;
            ()
        }
        sub Perlito5::AST::When::emit_java_has_regex {;
            ()
        }
    }
    package Perlito5::AST::While;
    {
        sub Perlito5::AST::While::emit_java {
            (my $self, my $level, my $wantarray) = @_;
            my $cond = $self->{"cond"};
            my @str;
            my $old_level = $level;
            if ($cond) {
                my @var_decl = $cond->emit_java_get_decl();
                for my $arg (@var_decl) {
                    $level = $old_level + 1;
                    push(@str, $arg->emit_java_init($level, $wantarray))
                }
            }
            my $expression = Perlito5::Java::to_native_bool($cond, $level + 1);
            if ($expression eq "false") {;
                return "PerlOp.statement();"
            }
            if (ref($self->{"body"}) eq "Perlito5::AST::Apply" && $self->{"body"}->{"code"} eq "do") {;
                push(@str, "do {", [Perlito5::Java::LexicalBlock::->new("block", $self->{"body"}->{"arguments"}->[0]->{"stmts"}, "not_a_loop", 1)->emit_java($level + 2, $wantarray)], "}", "while (" . $expression . ");")
            }
            else {
                local $Perlito5::THROW = 0;
                my $body = ref($self->{"body"}) ne "Perlito5::AST::Block" ? [$self->{"body"}] : $self->{"body"}->{"stmts"};
                push(@str, "while (" . $expression . ") {", [Perlito5::Java::LexicalBlock::->new("block", $body, "block_label", $self->{"label"}, "continue", $self->{"continue"})->emit_java($level + 2, $wantarray)], "}");
                if ($Perlito5::THROW) {;
                    @str = Perlito5::Java::emit_wrap_last_exception_java($self, \@str, $wantarray)
                }
            }
            return Perlito5::Java::emit_wrap_java($level, @str)
        }
        sub Perlito5::AST::While::emit_java_get_decl {;
            ()
        }
        sub Perlito5::AST::While::emit_java_has_regex {;
            ()
        }
    }
    package Perlito5::AST::For;
    {
        sub Perlito5::AST::For::emit_java {
            (my $self, my $level, my $wantarray) = @_;
            local $Perlito5::THROW = 0;
            my $body = ref($self->{"body"}) ne "Perlito5::AST::Block" ? [$self->{"body"}] : $self->{"body"}->{"stmts"};
            my @str;
            my $cond = ref($self->{"cond"}) eq "ARRAY" ? $self->{"cond"} : [$self->{"cond"}];
            for my $expr (@{$cond}) {;
                if ($expr) {
                    my @var_decl = $expr->emit_java_get_decl();
                    for my $arg (@var_decl) {;
                        push(@str, $arg->emit_java_init($level, $wantarray))
                    }
                }
            }
            if (ref($self->{"cond"}) eq "ARRAY") {;
                push(@str, "for ( " . ($self->{"cond"}->[0] ? $self->{"cond"}->[0]->emit_java($level + 1) . "; " : "; ") . ($self->{"cond"}->[1] ? Perlito5::Java::to_native_bool($self->{"cond"}->[1], $level + 1) . "; " : "; ") . ($self->{"cond"}->[2] ? $self->{"cond"}->[2]->emit_java($level + 1) . " " : '') . ") {", [(Perlito5::Java::LexicalBlock::->new("block", $body, "block_label", $self->{"label"}))->emit_java($level + 2, $wantarray)], "}")
            }
            else {
                my $local_label = Perlito5::Java::get_label();
                my $cond = $self->{"cond"};
                my $loop_expression;
                my $loop_expression_is_integer = 0;
                if ((ref($cond) eq "Perlito5::AST::Apply") && $cond->{"code"} eq "infix:<..>") {
                    (my $arg1, my $arg2) = @{$cond->{"arguments"}};
                    if ((ref($arg1) eq "Perlito5::AST::Int") && (ref($arg2) eq "Perlito5::AST::Int")) {
                        $loop_expression_is_integer = 1;
                        $loop_expression = "long " . $local_label . " = " . ($arg1->{"int"}) . "; " . $local_label . " <= " . ($arg2->{"int"}) . "; " . $local_label . "++"
                    }
                    else {;
                        $loop_expression = "PlObject " . $local_label . " : new PerlRange(" . $arg1->emit_java($level + 1) . ", " . $arg2->emit_java($level + 1) . ")"
                    }
                }
                elsif ((ref($cond) eq "Perlito5::AST::Apply") && $cond->{"code"} eq "list:<,>") {
                    my $expr_label = Perlito5::Java::get_label();
                    push(@str, "PlObject " . $expr_label . " = " . Perlito5::Java::to_param_list($cond->{"arguments"}, $level + 1) . ";");
                    $loop_expression = "PlObject " . $local_label . " : " . $expr_label
                }
                else {
                    my $expr_label = Perlito5::Java::get_label();
                    push(@str, "PlObject " . $expr_label . " = " . $cond->emit_java($level + 1, "list") . ";");
                    $loop_expression = "PlObject " . $local_label . " : " . $expr_label
                }
                my $decl = '';
                my $v = $self->{"topic"};
                if ($v->{"decl"}) {
                    $decl = $v->{"decl"};
                    $v = $v->{"var"}
                }
                else {;
                    $decl = $v->{"_decl"} || "global"
                }
                my $namespace = $v->{"namespace"} || $v->{"_namespace"} || $Perlito5::PKG_NAME;
                my $s;
                if ($decl eq "my" || $decl eq "state") {
                    my $loop_init;
                    if ($loop_expression_is_integer) {;
                        $loop_init = "PlLvalue " . $v->emit_java($level + 1) . " = new PlLvalue(" . $local_label . ")"
                    }
                    else {;
                        $loop_init = "PlLvalue " . $v->emit_java($level + 1) . (" = (PlLvalue)" . $local_label)
                    }
                    push(@str, "for (" . $loop_expression . ") {", [$loop_init . ";", Perlito5::Java::LexicalBlock::->new("block", $body, "block_label", $self->{"label"}, "continue", $self->{"continue"})->emit_java($level + 2, $wantarray)], "}")
                }
                else {
                    my $local_label2 = Perlito5::Java::get_label();
                    my $loop_init;
                    if ($loop_expression_is_integer) {;
                        $loop_init = $v->emit_java($level, "scalar", "lvalue") . ".set(" . $local_label . ")"
                    }
                    else {;
                        $loop_init = $v->emit_java_global_set_alias("(PlLvalue)" . $local_label, $level + 1)
                    }
                    push(@str, "int " . $local_label2 . " = PerlOp.local_length();");
                    push(@str, $v->emit_java_global($level + 1, "scalar", 1) . ";");
                    push(@str, "for (" . $loop_expression . ") {", [$loop_init . ";", Perlito5::Java::LexicalBlock::->new("block", $body, "block_label", $self->{"label"}, "continue", $self->{"continue"})->emit_java($level + 2, $wantarray)], "}");
                    push(@str, "PerlOp.cleanup_local(" . $local_label2 . ", PlCx.UNDEF);")
                }
            }
            if ($Perlito5::THROW) {;
                @str = Perlito5::Java::emit_wrap_last_exception_java($self, \@str, $wantarray)
            }
            return Perlito5::Java::emit_wrap_java($level, @str)
        }
        sub Perlito5::AST::For::emit_java_get_decl {;
            ()
        }
        sub Perlito5::AST::For::emit_java_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Sub;
    {
        sub Perlito5::AST::Sub::emit_java {
            (my $self, my $level, my $wantarray) = @_;
            if (my $node = $self->maybe_rewrite_statevars()) {;
                return $node->emit_java($level, $wantarray)
            }
            local $Perlito5::THROW;
            !$self->{"_do_block"} && (local $Perlito5::THROW_RETURN);
            my $prototype = defined($self->{"sig"}) ? "new PlString(" . Perlito5::Java::escape_string($self->{"sig"}) . ")" : "PlCx.UNDEF";
            my $attributes = $self->{"attributes"} || [];
            my $is_lvalue;
            for $_ (@{$attributes}) {;
                $_->[0] eq "lvalue" && ($is_lvalue = 1)
            }
            my $is_defined = "true";
            if (!defined($self->{"block"})) {;
                $is_defined = "false"
            }
            my $outer_sub;
            $Perlito5::Java::is_inside_subroutine && ($outer_sub = "this.getCurrentSub()");
            my $sub_ref = Perlito5::Java::get_label();
            local $Perlito5::Java::is_inside_subroutine = 1;
            my $block = Perlito5::Java::LexicalBlock::->new("block", $self->{"block"}->{"stmts"}, "not_a_loop", 1);
            my @captures_ast = ();
            {
                my @captured;
                for my $stmt (@{$self->{"block"}->{"stmts"}}) {;
                    push(@captured, $stmt->get_captures())
                }
                my %dont_capture = map {;
                    $_->{"dont"} ? ($_->{"dont"}, 1) : ()
                } @captured;
                my %capture = map {;
                    $_->{"dont"} ? () : $dont_capture{$_->{"_id"}} ? () : ($_->{"_decl"} eq "local" || $_->{"_decl"} eq "global" || $_->{"_decl"} eq '') ? () : ($_->{"_id"}, $_)
                } @captured;
                my %seen = map {;
                    $_->{"_id"} => 1
                } @captures_ast;
                my @more = (grep {;
                    !$seen{$_->{"_id"}}
                } map {;
                    $capture{$_}
                } sort {;
                    $a cmp $b
                } keys(%capture));
                push(@captures_ast, @more)
            }
            local @Perlito5::CAPTURES = @captures_ast;
            my @captures_java = map {;
                $_->emit_java($level, "list")
            } @captures_ast;
            local %Perlito5::Java::Java_var_name;
            my $i = 0;
            for $_ (@captures_ast) {
                my $capture_name = "this.env[" . $i . "]";
                my $sigil = $_->{"_real_sigil"} || $_->{"sigil"};
                if ($sigil eq "\$") {;
                    $capture_name = "((PlLvalue)" . $capture_name . ")"
                }
                elsif ($sigil eq "\@") {;
                    $capture_name = "((PlArray)" . $capture_name . ")"
                }
                elsif ($sigil eq "%") {;
                    $capture_name = "((PlHash)" . $capture_name . ")"
                }
                $Perlito5::Java::Java_var_name{$_->{"_id"}} = $capture_name;
                $i++
            }
            my @js_block;
            if ($self->{"_do_block"}) {
                local $Perlito5::JAVA_CAN_RETURN = 0;
                @js_block = $block->emit_java($level + 3, "runtime")
            }
            elsif ($self->{"_eval_block"}) {
                $block->{"top_level"} = 1;
                $block->{"eval_block"} = 1;
                local $Perlito5::JAVA_CAN_RETURN = 1;
                @js_block = $block->emit_java($level + 3, "runtime")
            }
            else {
                local $Perlito5::JAVA_CAN_RETURN = 1;
                $block->{"top_level"} = 1;
                @js_block = $block->emit_java($level + 3, "runtime")
            }
            if (!@js_block) {;
                push(@js_block, "return PerlOp.context(want);")
            }
            my $captures = "null";
            if (@captures_java) {;
                $captures = "new PlObject[]{ " . join(", ", @captures_java) . " }"
            }
            my @closure_args = ($prototype, $captures, Perlito5::Java::pkg(), $is_defined);
            if (($self->{"_do_block"} || $self->{"_eval_block"}) && $outer_sub) {;
                push(@closure_args, $outer_sub)
            }
            my @perl_pos;
            if ($self->{"pos"}) {;
                @perl_pos = ("public String perlFileName() {", ["return " . Perlito5::Java::escape_string($self->{"pos"}->{"file"}) . ";"], "}", "public Integer perlLineNumber() {", ["return " . (0 + ($self->{"pos"}->{"line"})) . ";"], "}")
            }
            my $method_decl;
            if ($self->{"_do_block"}) {;
                $method_decl = "public PlObject apply_do_block(int want, int return_context, PlArray List__)"
            }
            else {
                $method_decl = "public PlObject apply(int want, PlArray List__)";
                unshift(@js_block, "int return_context = want;")
            }
            my @s = ("new PlClosure(" . join(", ", @closure_args) . ") {", [@perl_pos, "public StackTraceElement firstLine() {", ["return PlCx.mainThread.getStackTrace()[1];"], "}", "\@SuppressWarnings(\"unchecked\")", $method_decl . " {", [@js_block], "}", "public StackTraceElement lastLine() {", ["return PlCx.mainThread.getStackTrace()[1];"], "}"], "}");
            if ($self->{"name"}) {;
                return Perlito5::Java::emit_wrap_java($level, "PlV.cset(", [Perlito5::Java::escape_string(($self->{"namespace"}) . "::" . ($self->{"name"})) . ",", @s], ");")
            }
            else {;
                return '' . Perlito5::Java::emit_wrap_java($level, @s)
            }
        }
        sub Perlito5::AST::Sub::emit_java_get_decl {;
            ()
        }
        sub Perlito5::AST::Sub::emit_java_has_regex {;
            ()
        }
    }
    1
}
{
    package main;
    package Perlito5::AST::Apply;
    {
        sub Perlito5::AST::Apply::emit_qr_java {
            (my $regex, my $modifier, my $level) = @_;
            if ($modifier eq '' && ref($regex) eq "Perlito5::AST::Var" && $regex->{"sigil"} eq "\$") {;
                return $regex->emit_java($level)
            }
            my %flags = map {;
                $_ => 1
            } split(m//, $modifier);
            my $flag_string = join(" | ", ($flags{"i"} ? "Pattern.CASE_INSENSITIVE" : ()), ($flags{"x"} ? "Pattern.COMMENTS" : ()), ($flags{"m"} ? "Pattern.MULTILINE" : ()), ($flags{"s"} ? "Pattern.DOTALL" : ())) || 0;
            my $flag_xx = "false";
            $modifier =~ m/xx/ && ($flag_xx = "true");
            my $s = "new PlRegex(" . Perlito5::Java::to_str($regex) . ", " . $flag_string . ", " . $flag_xx . ")";
            if (ref($regex) eq "Perlito5::AST::Buf") {
                my $label = Perlito5::Java::get_label();
                push(@Perlito5::Java::Java_constants, "public static final PlRegex " . $label . " = " . $s . ";");
                return $label
            }
            return $s
        }
        sub Perlito5::AST::Apply::emit_regex_java {
            my $op = shift;
            my $var = shift;
            my $regex = shift;
            my $level = shift;
            my $wantarray = shift;
            $regex = Perlito5::Macro::preprocess_regex($regex);
            my $str;
            my $code = $regex->{"code"};
            my $regex_args = $regex->{"arguments"};
            my $modifier_global = "false";
            if ($code eq "p5:s") {
                my $replace = $regex_args->[1];
                my $modifier = $regex_args->[2]->{"buf"};
                my $replace_java;
                if (ref($replace) eq "Perlito5::AST::Buf") {
                    $replace_java = $replace->{"buf"};
                    $replace_java = Perlito5::Java::escape_string($replace_java)
                }
                else {
                    if (ref($replace) ne "Perlito5::AST::Block") {;
                        $replace = Perlito5::AST::Block::->new("stmts", [$replace])
                    }
                    $replace_java = Perlito5::AST::Sub::->new("block", $replace, "attributes", [], "_do_block", 1)->emit_java($level);
                    $modifier =~ s/e//g
                }
                my $modifier_replace = "true";
                if ($modifier =~ m/r/) {
                    $modifier_replace = "false";
                    $modifier =~ s/r//g
                }
                if ($modifier =~ m/g/) {
                    $modifier_global = "true";
                    $modifier =~ s/g//g
                }
                $str = "PerlOp.replace(" . $var->emit_java($level, "scalar", "lvalue") . ", " . Perlito5::AST::Apply::emit_qr_java($regex_args->[0], $modifier, $level) . ", " . $replace_java . ", " . Perlito5::Java::to_context($wantarray) . ", " . $modifier_global . ", " . $modifier_replace . ")"
            }
            elsif ($code eq "p5:m") {
                my $modifier = $regex_args->[1]->{"buf"};
                if ($modifier =~ m/g/) {
                    $modifier_global = "true";
                    $modifier =~ s/g//g
                }
                my $modifier_c = "false";
                if ($modifier =~ m/c/) {
                    $modifier_c = "true";
                    $modifier =~ s/c//g
                }
                $str = "PerlOp.match(" . $var->emit_java($level) . ", " . Perlito5::AST::Apply::emit_qr_java($regex_args->[0], $modifier, $level) . ", " . Perlito5::Java::to_context($wantarray) . ", " . $modifier_global . ", " . $modifier_c . ")"
            }
            elsif ($code eq "p5:tr") {
                my $search = $regex_args->[0];
                my $replace = $regex_args->[1];
                for my $node ($search, $replace) {;
                    if (ref($node) eq "Perlito5::AST::Buf") {;
                        $node->{"buf"} = Perlito5::Regex::expand_character_range($node->{"buf"})
                    }
                }
                $str = "PerlOp.tr(" . $var->emit_java($level) . ", " . $regex_args->[0]->emit_java($level) . ", " . $regex_args->[1]->emit_java($level) . ", " . Perlito5::Java::escape_string($regex_args->[2]->{"buf"}) . ", " . Perlito5::Java::to_context($wantarray) . ")"
            }
            else {;
                $str = "PerlOp.match(" . $var->emit_java($level) . ", " . $regex->emit_java($level) . ", " . Perlito5::Java::to_context($wantarray) . ", " . "false, false" . ")"
            }
            if ($op eq "=~") {;
                return $str
            }
            if ($op eq "!~") {;
                return "new PlBool(!(" . $str . ".to_boolean()))"
            }
            die("Error: regex emitter")
        }
        sub Perlito5::AST::Apply::emit_java_set {
            (my $self, my $arguments, my $level, my $wantarray) = @_;
            my $code = $self->{"code"};
            if ($code eq "vec") {;
                return $self->{"arguments"}->[0]->emit_java($level, "scalar", "lvalue") . ".vecSet(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ", " . $self->{"arguments"}->[2]->emit_java($level, "scalar") . ", " . $arguments->emit_java($level, "scalar") . ")"
            }
            if ($code eq "circumfix:<( )>") {
                if ($wantarray eq "void" || $wantarray eq "statement") {;
                    return "PlArray.static_list_set(" . join(", ", Perlito5::Java::to_list([$arguments], $level), map($_->emit_java($level, "list", "lvalue"), @{$self->{"arguments"}})) . ")"
                }
                return "PlArray.static_list_set(" . join(", ", Perlito5::Java::to_context($wantarray), Perlito5::Java::to_list([$arguments], $level), map($_->emit_java($level, "list", "lvalue"), @{$self->{"arguments"}})) . ")"
            }
            if ($code eq "pos") {
                my @lvalue = @{$self->{"arguments"}};
                if (!@lvalue) {;
                    push(@lvalue, Perlito5::AST::Var::SCALAR_ARG())
                }
                return $lvalue[0]->emit_java($level, "scalar") . ".set_pos(" . $arguments->emit_java($level, "scalar") . ")"
            }
            if ($code eq "prefix:<\$#>") {;
                return Perlito5::Java::emit_java_autovivify($self->{"arguments"}->[0], $level + 1, "array") . ".array_deref(" . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ").set_end_of_array_index(" . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")"
            }
            if ($code eq "prefix:<\$>") {;
                return Perlito5::Java::emit_java_autovivify($self->{"arguments"}->[0], $level + 1, "scalar") . ".scalar_deref_set(" . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ", " . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")"
            }
            if ($code eq "prefix:<\@>") {;
                return Perlito5::Java::emit_java_autovivify($self->{"arguments"}->[0], $level + 1, "array") . ".array_deref_set(" . Perlito5::Java::to_list([$arguments], $level + 1) . ")"
            }
            if ($code eq "prefix:<%>") {;
                return Perlito5::Java::emit_java_autovivify($self->{"arguments"}->[0], $level + 1, "hash") . ".hash_deref_set(" . Perlito5::Java::to_list([$arguments], $level + 1) . ")"
            }
            if ($code eq "prefix:<*>") {;
                return "PlV.glob_set(" . Perlito5::Java::to_scalar($self->{"arguments"}, $level + 1) . ", " . Perlito5::Java::to_scalar([$arguments], $level + 1) . ", " . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ")"
            }
            if ($code eq "ternary:<? :>") {;
                return $self->emit_java($level + 1) . ".set(" . $arguments->emit_java($level + 1) . ")"
            }
            if ($code eq "substr") {;
                return $self->emit_java($level + 1, "scalar", "lvalue") . ".set(" . $arguments->emit_java($level + 1) . ")"
            }
            my $open = $wantarray eq "void" || $wantarray eq "statement" ? '' : "(";
            my $close = $wantarray eq "void" || $wantarray eq "statement" ? '' : ")";
            $open . $self->emit_java($level + 1) . " = " . $arguments->emit_java($level + 1) . $close
        }
        my %emit_js = ("infix:<=~>", sub {
            (my $self, my $level, my $wantarray) = @_;
            Perlito5::AST::Apply::emit_regex_java("=~", $self->{"arguments"}->[0], $self->{"arguments"}->[1], $level, $wantarray)
        }, "infix:<!~>", sub {
            (my $self, my $level, my $wantarray) = @_;
            Perlito5::AST::Apply::emit_regex_java("!~", $self->{"arguments"}->[0], $self->{"arguments"}->[1], $level, $wantarray)
        }, "p5:s", sub {
            (my $self, my $level, my $wantarray) = @_;
            Perlito5::AST::Apply::emit_regex_java("=~", $self->{"arguments"}->[3], $self, $level, $wantarray)
        }, "p5:m", sub {
            (my $self, my $level, my $wantarray) = @_;
            Perlito5::AST::Apply::emit_regex_java("=~", $self->{"arguments"}->[2], $self, $level, $wantarray)
        }, "p5:tr", sub {
            (my $self, my $level, my $wantarray) = @_;
            Perlito5::AST::Apply::emit_regex_java("=~", $self->{"arguments"}->[3], $self, $level, $wantarray)
        }, "p5:qr", sub {
            (my $self, my $level, my $wantarray) = @_;
            return Perlito5::AST::Apply::emit_qr_java($self->{"arguments"}->[0], $self->{"arguments"}->[1]->{"buf"}, $level)
        }, "__PACKAGE__", sub {
            (my $self, my $level, my $wantarray) = @_;
            return Perlito5::AST::Buf::->new("buf", $Perlito5::PKG_NAME)->emit_java($level, "scalar")
        }, "__SUB__", sub {
            (my $self, my $level, my $wantarray) = @_;
            "this.getCurrentSub()"
        }, "wantarray", sub {
            (my $self, my $level, my $wantarray) = @_;
            "(return_context == PlCx.VOID ? PlCx.UNDEF : return_context == PlCx.SCALAR ? PlCx.EMPTY : PlCx.INT1)"
        }, "uc", sub {
            (my $self, my $level, my $wantarray) = @_;
            "new PlString(" . Perlito5::Java::to_native_str($self->{"arguments"}->[0], $level, "scalar") . ".toUpperCase())"
        }, "lc", sub {
            (my $self, my $level, my $wantarray) = @_;
            "new PlString(" . Perlito5::Java::to_native_str($self->{"arguments"}->[0], $level, "scalar") . ".toLowerCase())"
        }, "index", sub {
            (my $self, my $level, my $wantarray) = @_;
            if ($self->{"arguments"}->[2]) {;
                $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".index(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ", " . $self->{"arguments"}->[2]->emit_java($level, "scalar") . ")"
            }
            else {;
                $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".index(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ")"
            }
        }, "rindex", sub {
            (my $self, my $level, my $wantarray) = @_;
            if ($self->{"arguments"}->[2]) {;
                $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".rindex(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ", " . $self->{"arguments"}->[2]->emit_java($level, "scalar") . ")"
            }
            else {;
                $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".rindex(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ")"
            }
        }, "ord", sub {
            (my $self, my $level, my $wantarray) = @_;
            "PerlOp.ord(" . Perlito5::Java::to_str($self->{"arguments"}->[0], $level) . ")"
        }, "chr", sub {
            (my $self, my $level, my $wantarray) = @_;
            "new PlString(new String(Character.toChars(" . Perlito5::Java::to_native_int($self->{"arguments"}->[0]) . ")))"
        }, "vec", sub {
            (my $self, my $level, my $wantarray) = @_;
            $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".vec(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ", " . $self->{"arguments"}->[2]->emit_java($level, "scalar") . ")"
        }, "rand", sub {
            (my $self, my $level, my $wantarray) = @_;
            "PerlOp.rand(" . ($self->{"arguments"}->[0] ? $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".to_double()" : "1.0") . ")"
        }, "srand", sub {
            (my $self, my $level, my $wantarray) = @_;
            "PerlOp.srand(" . ($self->{"arguments"}->[0] ? $self->{"arguments"}->[0]->emit_java($level, "scalar") : '') . ")"
        }, (map {
            my $op = $_;
            ($op, sub {
                (my $self, my $level, my $wantarray) = @_;
                $self->{"arguments"}->[0]->emit_java($level, "scalar") . "." . $op . "()"
            })
        } "abs", "sqrt", "cos", "sin", "exp", "log", "ucfirst", "lcfirst", "quotemeta"), (map {
            my $op = $_;
            ($op, sub {
                (my $self, my $level, my $wantarray) = @_;
                $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".op_" . $op . "()"
            })
        } "int"), (map {
            (my $op, my $java_op, my $native_op) = @{$_};
            ($op, sub {
                (my $self, my $level, my $wantarray) = @_;
                my $op1 = $self->{"arguments"}->[0]->emit_java($level, "scalar");
                my $op2 = $self->{"arguments"}->[1]->emit_java($level, "scalar");
                if ($self->{"_integer"} && $native_op) {;
                    return "new PlInt(" . "(" . $op1 . ".to_long() " . $native_op . " " . $op2 . ".to_long()" . ")" . " & 4294967295L" . ")"
                }
                $op1 . "." . $java_op . "(" . $op2 . ")"
            })
        } (["infix:<%>", "mod", "%"], ["infix:<>>>", "int_shr"], ["infix:<<<>", "int_shl"], ["infix:<^>", "int_xor"], ["infix:<&>", "int_and"], ["infix:<|>", "int_or"], ["infix:<+>", "add", "+"], ["infix:<->", "sub", "-"], ["infix:<*>", "mul", "*"], ["infix:</>", "div", "/"], ["infix:<==>", "num_eq", "=="], ["infix:<!=>", "num_ne", "!="], ["infix:<>>", "num_gt", ">"], ["infix:<>=>", "num_ge", ">="], ["infix:<<>", "num_lt", "<"], ["infix:<<=>", "num_le", "<="], ["infix:<eq>", "str_eq"], ["infix:<ne>", "str_ne"], ["infix:<gt>", "str_gt"], ["infix:<ge>", "str_ge"], ["infix:<lt>", "str_lt"], ["infix:<le>", "str_le"], ["infix:<cmp>", "str_cmp"], ["infix:<<=>>", "num_cmp"], ["infix:<**>", "pow"], ["atan2", "atan2"], ["infix:<^.>", "str_xor"], ["infix:<&.>", "str_and"], ["infix:<|.>", "str_or"])), (map {
            (my $op, my $java_op, my $native_op) = @{$_};
            ($op, sub {
                (my $self, my $level, my $wantarray) = @_;
                my $op = $self->{"arguments"}->[0]->emit_java($level, "scalar", "lvalue");
                my $op1 = $self->{"arguments"}->[0]->emit_java($level, "scalar");
                my $op2 = $self->{"arguments"}->[1]->emit_java($level, "scalar");
                if ($self->{"_integer"} && $native_op) {;
                    return $op . ".set(" . "new PlInt(" . "(" . $op1 . ".to_long() " . $native_op . " " . $op2 . ".to_long()" . ")" . " & 4294967295L" . ")" . ")"
                }
                $op . "." . $java_op . "(" . $op2 . ")"
            })
        } (["infix:<%=>", "self_assign_mod", "%"], ["infix:<>>=>", "self_assign_int_shr"], ["infix:<<<=>", "self_assign_int_shl"], ["infix:<^=>", "self_assign_int_xor"], ["infix:<&=>", "self_assign_int_and"], ["infix:<|=>", "self_assign_int_or"], ["infix:<+=>", "self_assign_add", "+"], ["infix:<-=>", "self_assign_sub", "-"], ["infix:<*=>", "self_assign_mul", "*"], ["infix:</=>", "self_assign_div", "/"], ["infix:<**=>", "self_assign_pow"], ["infix:<x=>", "self_assign_string_replicate"], ["infix:<||=>", "self_assign_or"], ["infix:<&&=>", "self_assign_and"], ["infix:<^.=>", "self_assign_str_xor"], ["infix:<&.=>", "self_assign_str_and"], ["infix:<|.=>", "self_assign_str_or"])), "infix:<~~>", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @op;
            for my $arg (@{$self->{"arguments"}}) {
                if (((ref($arg) eq "Perlito5::AST::Var") && ($arg->{"sigil"} eq "\@")) || ((ref($arg) eq "Perlito5::AST::Apply") && ($arg->{"code"} eq "prefix:<\@>"))) {;
                    push(@op, $arg->emit_java($level, "list"))
                }
                else {;
                    push(@op, $arg->emit_java($level, "scalar"))
                }
            }
            $op[0] . ".smartmatch(" . $op[1] . ")"
        }, (map {
            my $op = $_;
            ($op, sub {
                (my $self, my $level, my $wantarray) = @_;
                if ($wantarray eq "statement") {
                    if (!(grep {;
                        $_->{"decl"} eq "local"
                    } $self->emit_java_get_decl())) {;
                        return Perlito5::AST::If::->new("cond", $self->{"arguments"}->[0], "body", Perlito5::AST::Block::->new("stmts", [$self->{"arguments"}->[1]]), "otherwise", Perlito5::AST::Block::->new("stmts", []))->emit_java($level, $wantarray)
                    }
                    return "PerlOp.context(" . Perlito5::Java::to_context("void") . ", " . "PerlOp.and1(" . $self->{"arguments"}->[0]->emit_java($level, "scalar") . ") ? " . $self->{"arguments"}->[1]->emit_java($level, $wantarray) . " : PlV.boolean_stack" . ")"
                }
                "(PerlOp.and1(" . $self->{"arguments"}->[0]->emit_java($level, "scalar") . ") ? " . $self->{"arguments"}->[1]->emit_java($level, $wantarray) . " : PlV.boolean_stack)"
            })
        } ("infix:<&&>", "infix:<and>")), (map {
            my $op = $_;
            ($op, sub {
                (my $self, my $level, my $wantarray) = @_;
                if ($wantarray eq "statement") {
                    if (!(grep {;
                        $_->{"decl"} eq "local"
                    } $self->emit_java_get_decl())) {;
                        return Perlito5::AST::If::->new("cond", $self->{"arguments"}->[0], "body", Perlito5::AST::Block::->new("stmts", []), "otherwise", Perlito5::AST::Block::->new("stmts", [$self->{"arguments"}->[1]]))->emit_java($level, $wantarray)
                    }
                    return "PerlOp.context(" . Perlito5::Java::to_context("void") . ", " . "(PerlOp.or1(" . $self->{"arguments"}->[0]->emit_java($level, "scalar") . ") ? PlV.boolean_stack : " . $self->{"arguments"}->[1]->emit_java($level, $wantarray) . ")"
                }
                "(PerlOp.or1(" . $self->{"arguments"}->[0]->emit_java($level, "scalar") . ") ? PlV.boolean_stack : " . $self->{"arguments"}->[1]->emit_java($level, $wantarray) . ")"
            })
        } ("infix:<||>", "infix:<or>")), "infix:<//>", sub {
            (my $self, my $level, my $wantarray) = @_;
            "(PerlOp.defined_or1(" . $self->{"arguments"}->[0]->emit_java($level, "scalar") . ") ? PlV.boolean_stack : " . $self->{"arguments"}->[1]->emit_java($level, $wantarray) . ")"
        }, "infix:<xor>", sub {
            (my $self, my $level, my $wantarray) = @_;
            "( " . Perlito5::Java::to_native_bool($self->{"arguments"}->[0], $level) . " ? new PlBool(!" . Perlito5::Java::to_native_bool($self->{"arguments"}->[1], $level) . ") : " . ($self->{"arguments"}->[1])->emit_java($level, $wantarray) . ")"
        }, "infix:<=>>", sub {
            (my $self, my $level, my $wantarray) = @_;
            Perlito5::AST::Lookup::->autoquote($self->{"arguments"}->[0])->emit_java($level) . ", " . $self->{"arguments"}->[1]->emit_java($level)
        }, "prefix:<!>", sub {
            my $self = shift;
            my $level = shift;
            "new PlBool(!(" . Perlito5::Java::to_native_bool($self->{"arguments"}->[0], $level) . "))"
        }, "prefix:<not>", sub {
            my $self = shift;
            my $level = shift;
            my $arg = pop(@{$self->{"arguments"}});
            if (!$arg) {;
                return "PlCx.TRUE"
            }
            "new PlBool(!( " . Perlito5::Java::to_native_bool($arg, $level) . "))"
        }, "prefix:<~>", sub {
            my $self = shift;
            my $level = shift;
            my $arg = $self->{"arguments"}->[0];
            $arg->emit_java($level, "scalar") . ".complement()"
        }, "prefix:<~.>", sub {
            my $self = shift;
            my $level = shift;
            my $arg = $self->{"arguments"}->[0];
            $arg->emit_java($level, "scalar") . ".str_complement()"
        }, "prefix:<->", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ((ref($arg) eq "Perlito5::AST::Int")) {
                $arg = Perlito5::AST::Int::->new("int", -$arg->{"int"});
                return $arg->emit_java($level, "scalar")
            }
            if ((ref($arg) eq "Perlito5::AST::Num")) {
                $arg = Perlito5::AST::Num::->new("num", -$arg->{"num"});
                return $arg->emit_java($level, "scalar")
            }
            if ((ref($arg) eq "Perlito5::AST::Apply") && $arg->{"bareword"}) {;
                $arg = Perlito5::AST::Buf::->new("buf", $arg->{"code"})
            }
            $arg->emit_java($level, "scalar") . ".neg()"
        }, "prefix:<+>", sub {
            (my $self, my $level, my $wantarray) = @_;
            $self->{"arguments"}->[0]->emit_java($level, $wantarray)
        }, "require", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ($arg->{"is_version_string"}) {
                my $code = Perlito5::AST::Buf::->new("buf", "Perlito5::test_perl_version")->emit_java($level, "scalar");
                return $code . ".apply(PlCx.VOID, new PlArray(" . $arg->emit_java($level, "scalar") . "))"
            }
            "PlCORE.require(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_str($self->{"arguments"}->[0]) . ", " . ($self->{"arguments"}->[0]->{"bareword"} ? "true" : "false") . ")"
        }, "prefix:<\$>", sub {
            (my $self, my $level, my $wantarray, my $autovivification_type) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ($autovivification_type eq "lvalue") {;
                return $arg->emit_java($level, "scalar", "lvalue") . ".scalar_deref_lvalue(" . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ")"
            }
            elsif ($self->{"_strict_refs"}) {;
                return $arg->emit_java($level, "scalar", "scalar") . ".scalar_deref_strict()"
            }
            return $arg->emit_java($level, "scalar", "scalar") . ".scalar_deref(" . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ")"
        }, "prefix:<\@>", sub {
            (my $self, my $level, my $wantarray, my $autovivification_type) = @_;
            my $arg = $self->{"arguments"}->[0];
            my $s;
            if ($autovivification_type eq "lvalue") {;
                $s = Perlito5::Java::emit_java_autovivify($arg, $level, "array") . ".array_deref_lvalue()"
            }
            elsif ($self->{"_strict_refs"}) {;
                $s = Perlito5::Java::emit_java_autovivify($arg, $level, "array") . ".array_deref_strict()"
            }
            else {;
                $s = Perlito5::Java::emit_java_autovivify($arg, $level, "array") . ".array_deref(" . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ")"
            }
            return $wantarray eq "scalar" ? $s . ".scalar()" : $s
        }, "prefix:<\$#>", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ($self->{"_strict_refs"}) {;
                return Perlito5::Java::emit_java_autovivify($arg, $level, "array") . ".array_deref_strict().end_of_array_index()"
            }
            return Perlito5::Java::emit_java_autovivify($arg, $level, "array") . ".array_deref(" . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ").end_of_array_index()"
        }, "prefix:<%>", sub {
            (my $self, my $level, my $wantarray, my $autovivification_type) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ($autovivification_type eq "lvalue") {;
                return Perlito5::Java::emit_java_autovivify($arg, $level, "hash") . ".hash_deref(" . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ")"
            }
            elsif ($self->{"_strict_refs"}) {;
                return Perlito5::Java::emit_java_autovivify($arg, $level, "hash") . ".hash_deref_strict()"
            }
            return Perlito5::Java::emit_java_autovivify($arg, $level, "hash") . ".hash_deref(" . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ")"
        }, "prefix:<&>", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $invocant = $self->{"arguments"}->[0]->emit_java($level);
            if (!$self->{"_strict_refs"}) {;
                $invocant = "PlV.code_lookup_by_name(" . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ", " . $invocant . ")"
            }
            return $invocant . ".apply(" . Perlito5::Java::to_context($wantarray) . ", " . "List__" . ")"
        }, "prefix:<*>", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0];
            return Perlito5::Java::to_filehandle($arg, $level + 1)
        }, "circumfix:<[ ]>", sub {
            (my $self, my $level, my $wantarray) = @_;
            return "new PlArrayRef(new PlArray(" . Perlito5::Java::to_list_for_push($self->{"arguments"}, $level) . "))"
        }, "circumfix:<{ }>", sub {
            (my $self, my $level, my $wantarray) = @_;
            "new PlHashRef(new PlHash(" . Perlito5::Java::to_list_for_push($self->{"arguments"}, $level) . "))"
        }, "prefix:<\\>", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ((ref($arg) eq "Perlito5::AST::Apply")) {
                if ($arg->{"code"} eq "prefix:<\@>") {;
                    return "new PlArrayRef(" . $arg->emit_java($level) . ")"
                }
                if ($arg->{"code"} eq "prefix:<%>") {;
                    return "new PlHashRef(" . $arg->emit_java($level) . ")"
                }
                if ($arg->{"code"} eq "circumfix:<( )>") {;
                    return "PlArray.construct_list_of_references(" . Perlito5::Java::to_list($arg->{"arguments"}, $level) . ")"
                }
                if ($arg->{"code"} eq "prefix:<&>") {;
                    return "PlV.code_lookup_by_name(" . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ", " . $arg->{"arguments"}->[0]->emit_java($level) . ")"
                }
            }
            if ((ref($arg) eq "Perlito5::AST::Var")) {
                if ($arg->{"sigil"} eq "\@") {;
                    return "new PlArrayRef(" . $arg->emit_java($level) . ")"
                }
                if ($arg->{"sigil"} eq "%") {;
                    return "new PlHashRef(" . $arg->emit_java($level) . ")"
                }
                if ($arg->{"sigil"} eq "*") {;
                    return "new PlGlobRef(" . $arg->emit_java($level) . ")"
                }
                if ($arg->{"sigil"} eq "&") {
                    my $namespace = $arg->{"namespace"} || $Perlito5::PKG_NAME;
                    return "PlV.cget(" . Perlito5::Java::escape_string($namespace . "::" . ($arg->{"name"})) . ")"
                }
            }
            return "PlV.make_reference(" . $arg->emit_java($level) . ")"
        }, "postfix:<++>", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0];
            if (ref($arg) eq "Perlito5::AST::Var" && $arg->{"_id"}) {
                my $id = $arg->{"_id"};
                my $Java_var = Perlito5::Java::get_java_var_info();
                my $type = $Java_var->{$id}->{"type"} || "PlLvalue";
                if ($type ne "PlLvalue") {;
                    return Perlito5::Java::to_native_num($arg, $level) . "++"
                }
            }
            $arg->emit_java($level, "scalar", "lvalue") . ".post_incr()"
        }, "postfix:<-->", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0];
            if (ref($arg) eq "Perlito5::AST::Var" && $arg->{"_id"}) {
                my $id = $arg->{"_id"};
                my $Java_var = Perlito5::Java::get_java_var_info();
                my $type = $Java_var->{$id}->{"type"} || "PlLvalue";
                if ($type ne "PlLvalue") {;
                    return Perlito5::Java::to_native_num($arg, $level) . "--"
                }
            }
            $arg->emit_java($level, "scalar", "lvalue") . ".post_decr()"
        }, "prefix:<++>", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0];
            if (ref($arg) eq "Perlito5::AST::Var" && $arg->{"_id"}) {
                my $id = $arg->{"_id"};
                my $Java_var = Perlito5::Java::get_java_var_info();
                my $type = $Java_var->{$id}->{"type"} || "PlLvalue";
                if ($type ne "PlLvalue") {;
                    return "++" . Perlito5::Java::to_native_num($arg, $level)
                }
            }
            $arg->emit_java($level, "scalar", "lvalue") . ".pre_incr()"
        }, "prefix:<-->", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0];
            if (ref($arg) eq "Perlito5::AST::Var" && $arg->{"_id"}) {
                my $id = $arg->{"_id"};
                my $Java_var = Perlito5::Java::get_java_var_info();
                my $type = $Java_var->{$id}->{"type"} || "PlLvalue";
                if ($type ne "PlLvalue") {;
                    return "--" . Perlito5::Java::to_native_num($arg, $level)
                }
            }
            $arg->emit_java($level, "scalar", "lvalue") . ".pre_decr()"
        }, "infix:<x>", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0];
            if (ref($arg) eq "Perlito5::AST::Apply" && ($arg->{"code"} eq "circumfix:<( )>" || $arg->{"code"} eq "list:<,>")) {;
                return "PerlOp.list_replicate(" . Perlito5::Java::to_list([$self->{"arguments"}->[0]], $level) . ", " . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ", " . Perlito5::Java::to_context($wantarray) . ")"
            }
            Perlito5::Java::to_str($self->{"arguments"}->[0], $level) . ".string_replicate(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ")"
        }, "list:<.>", sub {
            (my $self, my $level, my $wantarray) = @_;
            "new PlString(" . join(" + ", map(Perlito5::Java::to_native_str($_, $level, "scalar"), @{$self->{"arguments"}})) . ")"
        }, "list:<,>", sub {
            (my $self, my $level, my $wantarray) = @_;
            Perlito5::Java::to_list($self->{"arguments"}, $level)
        }, "infix:<..>", sub {
            (my $self, my $level, my $wantarray) = @_;
            return "new PerlRange(" . $self->{"arguments"}->[0]->emit_java($level) . ", " . $self->{"arguments"}->[1]->emit_java($level) . ").range(" . Perlito5::Java::to_context($wantarray) . ", " . "\"" . Perlito5::Java::get_label() . "\"" . ", " . 0 . ")"
        }, "infix:<...>", sub {
            (my $self, my $level, my $wantarray) = @_;
            return "new PerlRange(" . $self->{"arguments"}->[0]->emit_java($level) . ", " . $self->{"arguments"}->[1]->emit_java($level) . ").range(" . Perlito5::Java::to_context($wantarray) . ", " . "\"" . Perlito5::Java::get_label() . "\"" . ", " . 1 . ")"
        }, "delete", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ((ref($arg) eq "Perlito5::AST::Lookup")) {
                my $v = $arg->obj();
                if ((ref($v) eq "Perlito5::AST::Var") && $v->{"_real_sigil"} eq "%") {
                    $v = Perlito5::AST::Var::->new(%{$v}, "sigil", "%");
                    if (!defined($v->{"name"})) {
                        my $index = Perlito5::Java::escape_string(($v->{"namespace"}) . "::");
                        return "PerlOp.deleteSymbolTable(" . $index . ", " . $arg->autoquote($arg->{"index_exp"})->emit_java($level) . ")"
                    }
                    return $v->emit_java($level) . ".hdelete(" . Perlito5::Java::to_context($wantarray) . ", " . $arg->autoquote($arg->{"index_exp"})->emit_java($level) . ")"
                }
                if ((ref($v) eq "Perlito5::AST::Apply") && $v->{"code"} eq "prefix:<\$>") {;
                    $arg = Perlito5::AST::Call::->new("method", "postcircumfix:<{ }>", "invocant", $v->{"arguments"}->[0], "arguments", $arg->{"index_exp"})
                }
                else {;
                    return $v->emit_java($level, $wantarray, "hash") . ".hdelete(" . Perlito5::Java::to_context($wantarray) . ", " . $arg->autoquote($arg->{"index_exp"})->emit_java($level) . ")"
                }
            }
            if ((ref($arg) eq "Perlito5::AST::Index")) {
                my $v = $arg->obj();
                if ((ref($v) eq "Perlito5::AST::Var") && $v->{"_real_sigil"} eq "\@") {
                    $v = Perlito5::AST::Var::->new(%{$v}, "sigil", "\@");
                    return $v->emit_java($level) . ".adelete(" . Perlito5::Java::to_context($wantarray) . ", " . $arg->{"index_exp"}->emit_java($level) . ")"
                }
                if ((ref($v) eq "Perlito5::AST::Apply") && $v->{"code"} eq "prefix:<\$>") {;
                    $arg = Perlito5::AST::Call::->new("method", "postcircumfix:<[ ]>", "invocant", $v->{"arguments"}->[0], "arguments", $arg->{"index_exp"})
                }
                else {;
                    return $v->emit_java($level, $wantarray, "array") . ".adelete(" . Perlito5::Java::to_context($wantarray) . ", " . $arg->{"index_exp"}->emit_java($level) . ")"
                }
            }
            if ((ref($arg) eq "Perlito5::AST::Call")) {
                if ($arg->method() eq "postcircumfix:<{ }>") {;
                    return $arg->invocant()->emit_java($level, $wantarray, "hash") . ".hdelete(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::AST::Lookup::->autoquote($arg->{"arguments"})->emit_java($level) . ")"
                }
                if ($arg->method() eq "postcircumfix:<[ ]>") {;
                    return $arg->invocant()->emit_java($level, $wantarray, "array") . ".adelete(" . Perlito5::Java::to_context($wantarray) . ", " . $arg->{"arguments"}->emit_java($level) . ")"
                }
            }
            if ((ref($arg) eq "Perlito5::AST::Var") && $arg->{"sigil"} eq "&") {;
                die("TODO delete &code")
            }
            if ((ref($arg) eq "Perlito5::AST::Apply") && $arg->{"code"} eq "prefix:<&>") {;
                die("TODO delete &\$code")
            }
        }, "ternary:<? :>", sub {
            (my $self, my $level, my $wantarray) = @_;
            if ($wantarray eq "statement") {;
                return Perlito5::AST::If::->new("cond", $self->{"arguments"}->[0], "body", Perlito5::AST::Block::->new("stmts", [$self->{"arguments"}->[1]]), "otherwise", Perlito5::AST::Block::->new("stmts", [$self->{"arguments"}->[2]]))->emit_java($level, $wantarray)
            }
            "( " . Perlito5::Java::to_native_bool($self->{"arguments"}->[0], $level) . " ? " . ($self->{"arguments"}->[1])->emit_java($level, $wantarray) . " : " . ($self->{"arguments"}->[2])->emit_java($level, $wantarray) . ")"
        }, "scalar", sub {
            (my $self, my $level, my $wantarray, my $autovivification_type) = @_;
            my @args = @{$self->{"arguments"}};
            my $arg = pop(@args);
            my @out;
            if ($arg) {
                for my $arg (@args) {
                    if (ref($arg) eq "Perlito5::AST::Apply" && $arg->{"code"} eq "push") {;
                        push(@out, $arg->emit_java($level, "scalar"))
                    }
                    else {;
                        push(@out, $arg->emit_java($level, "void"))
                    }
                }
                push(@out, $arg->emit_java($level, "scalar", $autovivification_type))
            }
            @out == 1 && return $out[0];
            return "PerlOp.context(" . join(", ", Perlito5::Java::to_context("scalar"), @out) . ")"
        }, "circumfix:<( )>", sub {
            (my $self, my $level, my $wantarray, my $autovivification_type) = @_;
            my @args = @{$self->{"arguments"}};
            my $arg = pop(@args);
            my @out;
            if ($arg) {
                for my $arg (@args) {
                    my $context = ($wantarray eq "list" || $wantarray eq "runtime" || $wantarray eq "return") ? $wantarray : "void";
                    push(@out, $arg->emit_java($level, $context))
                }
                push(@out, $arg->emit_java($level, $wantarray, $autovivification_type))
            }
            @out == 1 && return $out[0];
            return "PerlOp.context(" . join(", ", Perlito5::Java::to_context($wantarray), @out) . ")"
        }, "infix:<=>", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $parameters = $self->{"arguments"}->[0];
            my $arguments = $self->{"arguments"}->[1];
            return $parameters->emit_java_set($arguments, $level + 1, $wantarray)
        }, "readpipe", sub {
            (my $self, my $level, my $wantarray) = @_;
            die("TODO - readpipe() not implemented")
        }, "waitpid", sub {
            (my $self, my $level, my $wantarray) = @_;
            die("TODO - waitpid() not implemented")
        }, "glob", sub {
            (my $self, my $level, my $wantarray) = @_;
            die("TODO - glob() not implemented")
        }, "break", sub {
            (my $self, my $level, my $wantarray) = @_;
            $Perlito5::THROW = 1;
            die("TODO - break() not implemented")
        }, "next", sub {
            (my $self, my $level, my $wantarray) = @_;
            $Perlito5::THROW = 1;
            my $label = Perlito5::Java::get_java_loop_label($self->{"arguments"}->[0]->{"code"});
            if ($label == 0) {;
                return "PerlOp.next()"
            }
            "PerlOp.next(" . $label . ")"
        }, "last", sub {
            (my $self, my $level, my $wantarray) = @_;
            $Perlito5::THROW = 1;
            my $label = Perlito5::Java::get_java_loop_label($self->{"arguments"}->[0]->{"code"});
            if ($label == 0) {;
                return "PerlOp.last()"
            }
            "PerlOp.last(" . $label . ")"
        }, "redo", sub {
            (my $self, my $level, my $wantarray) = @_;
            $Perlito5::THROW = 1;
            my $label = Perlito5::Java::get_java_loop_label($self->{"arguments"}->[0]->{"code"});
            "PerlOp.redo(" . $label . ")"
        }, "return", sub {
            (my $self, my $level, my $wantarray) = @_;
            if (($wantarray eq "void" || $wantarray eq "statement") && $Perlito5::JAVA_CAN_RETURN) {
                my $has_local = $Perlito5::JAVA_HAS_LOCAL;
                my $local_label = $Perlito5::JAVA_LOCAL_LABEL;
                if (!@{$self->{"arguments"}}) {;
                    return Perlito5::Java::LexicalBlock::emit_return($has_local, $local_label, "PerlOp.context(want)")
                }
                else {;
                    return Perlito5::Java::LexicalBlock::emit_return($has_local, $local_label, Perlito5::Java::to_runtime_context($self->{"arguments"}, $level + 1, "return"))
                }
            }
            $Perlito5::THROW_RETURN = 1;
            $wantarray = '';
            if (!$self->{"_return_from_block"}) {;
                $wantarray = "return"
            }
            if (!@{$self->{"arguments"}}) {;
                return "PerlOp.ret(PerlOp.context(" . Perlito5::Java::to_context($wantarray) . "))"
            }
            return "PerlOp.ret(" . Perlito5::Java::to_runtime_context($self->{"arguments"}, $level + 1, $wantarray) . ")"
        }, "goto", sub {
            (my $self, my $level, my $wantarray) = @_;
            $Perlito5::THROW_RETURN = 1;
            my $arg = $self->{"arguments"}->[0];
            if ((ref($arg) eq "Perlito5::AST::Var" && $arg->{"sigil"} eq "&") || (ref($arg) eq "Perlito5::AST::Apply" && $arg->{"code"} eq "prefix:<&>")) {;
                return "PerlOp.ret(" . $arg->emit_java($level) . ")"
            }
            return "PerlOp.gotoOp(" . Perlito5::Java::to_context($wantarray) . ", " . $arg->emit_java($level) . ", " . "List__" . ")"
        }, "caller", sub {
            (my $self, my $level, my $wantarray) = @_;
            return "PlCORE.caller(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_list($self->{"arguments"}, $level) . ")"
        }, "do", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ((ref($arg) eq "Perlito5::AST::Block")) {
                my $ast = Perlito5::AST::Sub::->new("block", $arg, "attributes", [], "_do_block", 1);
                return $ast->emit_java($level + 1, $wantarray) . ".apply_do_block(" . Perlito5::Java::to_context($wantarray) . ", " . "return_context, " . "List__" . ")"
            }
            my $ast = Perlito5::AST::Apply::->new("code", "eval", "namespace", '', "arguments", [Perlito5::AST::Apply::->new("code", "slurp_file", "namespace", "Perlito5::Grammar::Use", "arguments", $self->{"arguments"})], "_scope", Perlito5::Grammar::Scope::->new_base_scope(), "_hash_hints", {}, "_scalar_hints", 0);
            my $js = $ast->emit_java($level, $wantarray);
            return $js
        }, "eval", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0] || Perlito5::AST::Var::SCALAR_ARG();
            my $eval;
            if ((ref($arg) eq "Perlito5::AST::Block")) {
                $Perlito5::THROW = 1;
                my $ast = Perlito5::AST::Call::->new("method", "postcircumfix:<( )>", "invocant", Perlito5::AST::Sub::->new("block", $arg, "attributes", [], "_eval_block", 1), "arguments", [Perlito5::AST::Var::LIST_ARG()]);
                return $ast->emit_java($level + 1, $wantarray)
            }
            if (!$Perlito5::JAVA_EVAL) {;
                return "PlCORE.die(\"This script has eval string disabled - the 'java_eval' switch is turned off\")"
            }
            my %vars;
            for my $var (@{$self->{"_scope"}->{"block"}}, @Perlito5::CAPTURES) {;
                if ($var->{"_decl"} && $var->{"_decl"} ne "global" && $var->{"_decl"} ne "our") {
                    $var = Perlito5::AST::Var::->new(%{$var}, "sigil", ($var->{"_real_sigil"} || $var->{"sigil"}));
                    $vars{$var->{"sigil"}}->{$var->emit_java(0)} = $var
                }
            }
            my $scope = Perlito5::DumpToAST::dump_to_ast($self->{"_scope"}, {}, "s")->emit_java(0);
            $self->{"_hash_hints"} ||= {};
            my $hash_hints = Perlito5::DumpToAST::dump_to_ast($self->{"_hash_hints"}, {}, "s")->emit_java(0);
            my @out;
            {
                local %Perlito5::Java::Java_var_name;
                my %type = ("\$", "PlLvalue", "\@", "PlArray", "%", "PlHash");
                for my $sigil ("\$", "\@", "%") {
                    my @str;
                    my @val;
                    for my $var (keys(%{$vars{$sigil}})) {
                        $vars{$sigil}->{$var}->is_begin_scratchpad() && next;
                        push(@str, Perlito5::Java::escape_string($vars{$sigil}->{$var}->emit_java(0)));
                        push(@val, $var)
                    }
                    push(@out, "new String[]{" . join(", ", @str) . "}");
                    push(@out, "new " . $type{$sigil} . "[]{" . join(", ", @val) . "}")
                }
            }
            return "PlJavaCompiler.eval_perl_string(" . Perlito5::Java::to_native_str($arg, $level, $wantarray) . ", " . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ", " . Perlito5::Java::escape_string($wantarray) . ", " . "new PlInt(" . (0 + ($self->{"_scalar_hints"})) . "L), " . $hash_hints . ", " . $scope . ", " . join(", ", @out) . ", " . Perlito5::Java::to_context($wantarray) . ", " . "List__" . ")"
        }, "length", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = shift(@{$self->{"arguments"}});
            $arg->emit_java($level, "scalar") . ".length()"
        }, "substr", sub {
            (my $self, my $level, my $wantarray, my $autovivification_type) = @_;
            my $meth = "substr";
            $autovivification_type eq "lvalue" && ($meth = "lvalue_substr");
            my $arg = shift(@{$self->{"arguments"}});
            my @arglist = (Perlito5::Java::to_native_int(shift(@{$self->{"arguments"}}), $level, "scalar"));
            @{$self->{"arguments"}} && push(@arglist, Perlito5::Java::to_native_int(shift(@{$self->{"arguments"}}), $level, "scalar"));
            @{$self->{"arguments"}} && push(@arglist, $self->{"arguments"}->[0]->emit_java($level, "scalar"));
            return $arg->emit_java($level, "scalar") . "." . $meth . "(" . join(", ", @arglist) . ")"
        }, "undef", sub {
            (my $self, my $level, my $wantarray) = @_;
            if ($self->{"arguments"} && @{$self->{"arguments"}}) {
                my $arg = $self->{"arguments"}->[0];
                if (ref($arg) eq "Perlito5::AST::Var" && $arg->{"sigil"} eq "&") {
                    my $name = $arg->{"name"};
                    my $namespace = $arg->{"namespace"} || $Perlito5::PKG_NAME;
                    return "PlV.cset(" . Perlito5::Java::escape_string($namespace . "::" . $name) . ", PlCx.UNDEF)"
                }
                if (ref($arg) eq "Perlito5::AST::Apply" && $arg->{"code"} eq "prefix:<*>") {;
                    return $arg->emit_java($level, "scalar") . ".setUndef()"
                }
                $self->{"arguments"} = [];
                return $arg->emit_java_set($self, $level, $wantarray)
            }
            return "PlCx.UNDEF"
        }, "defined", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0];
            my $invocant;
            if (ref($arg) eq "Perlito5::AST::Apply" && $arg->{"code"} eq "prefix:<&>") {
                my $arg2 = $arg->{"arguments"}->[0];
                $invocant = "PlV.code_lookup_by_name_no_autoload(" . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ", " . $arg2->emit_java($level) . ")"
            }
            elsif (ref($arg) eq "Perlito5::AST::Var" && $arg->{"sigil"} eq "&") {
                my $name = $arg->{"name"};
                my $namespace = $arg->{"namespace"} || $Perlito5::PKG_NAME;
                $invocant = "PlV.cget_no_autoload(" . Perlito5::Java::escape_string($namespace . "::" . $name) . ")"
            }
            else {;
                $invocant = $arg->emit_java($level, "scalar")
            }
            "new PlBool(!" . $invocant . ".is_undef())"
        }, "shift", sub {
            (my $self, my $level, my $wantarray) = @_;
            if ($self->{"arguments"} && @{$self->{"arguments"}}) {;
                return $self->{"arguments"}->[0]->emit_java($level) . ".shift()"
            }
            if ($Perlito5::Java::is_inside_subroutine) {;
                return "List__.shift()"
            }
            return "PlV.array_get(\"main::ARGV\").shift()"
        }, "pop", sub {
            (my $self, my $level, my $wantarray) = @_;
            if ($self->{"arguments"} && @{$self->{"arguments"}}) {;
                return $self->{"arguments"}->[0]->emit_java($level) . ".pop()"
            }
            if ($Perlito5::Java::is_inside_subroutine) {;
                return "List__.pop()"
            }
            return "PlV.array_get(\"main::ARGV\").pop()"
        }, "unshift", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @arguments = @{$self->{"arguments"}};
            my $v = shift(@arguments);
            return $v->emit_java($level) . ".unshift(" . Perlito5::Java::to_list_for_push(\@arguments, $level) . ")"
        }, "push", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @arguments = @{$self->{"arguments"}};
            my $v = shift(@arguments);
            my $method = $wantarray eq "void" || $wantarray eq "statement" ? "push_void" : "push";
            if (@arguments == 1 && ref($arguments[0]) eq "Perlito5::AST::Var" && $arguments[0]->{"sigil"} eq "\$") {;
                return $v->emit_java($level) . ("." . $method . "(") . $arguments[0]->emit_java($level) . ")"
            }
            return $v->emit_java($level) . ("." . $method . "(") . Perlito5::Java::to_list_for_push(\@arguments, $level) . ")"
        }, "splice", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @arguments = @{$self->{"arguments"}};
            my $array = shift(@arguments);
            my $offset = shift(@arguments);
            my $length = shift(@arguments);
            "PlCORE.splice(" . Perlito5::Java::to_context($wantarray) . ", " . $array->emit_java($level) . ($offset ? (", " . $offset->emit_java($level)) : ()) . ($length ? (", " . $length->emit_java($level)) : ()) . (@arguments ? (", " . Perlito5::Java::to_list(\@arguments, $level)) : ()) . ")"
        }, "pos", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @arguments = @{$self->{"arguments"}};
            if (!@arguments) {;
                push(@arguments, Perlito5::AST::Var::SCALAR_ARG())
            }
            return $arguments[0]->emit_java($level, "scalar") . ".pos()"
        }, "tie", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @arguments = @{$self->{"arguments"}};
            my $v = shift(@arguments);
            if (ref($v) eq "Perlito5::AST::Decl") {;
                $v = $v->{"var"}
            }
            if (((ref($v) eq "Perlito5::AST::Var") && ($v->{"sigil"} eq "%" || $v->{"sigil"} eq "\@")) || ((ref($v) eq "Perlito5::AST::Apply") && ($v->{"code"} eq "prefix:<\@>" || $v->{"code"} eq "prefix:<%>"))) {;
                return $v->emit_java($level) . ".tie(" . Perlito5::Java::to_list(\@arguments, $level) . ")"
            }
            return $v->emit_java($level, "scalar", "lvalue") . ".tie(" . Perlito5::Java::to_list(\@arguments, $level) . ")"
        }, "untie", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @arguments = @{$self->{"arguments"}};
            my $v = shift(@arguments);
            return $v->emit_java($level) . ".untie()"
        }, "tied", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @arguments = @{$self->{"arguments"}};
            my $v = shift(@arguments);
            return $v->emit_java($level) . ".tied()"
        }, "print", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @arguments = @{$self->{"arguments"}};
            my $fun;
            if ($self->{"special_arg"}) {;
                $fun = Perlito5::Java::to_filehandle($self->{"special_arg"}, $level + 1)
            }
            else {;
                $fun = "PlV.STDOUT"
            }
            return "PlCORE.print(" . join(", ", Perlito5::Java::to_context($wantarray), $fun, map(Perlito5::Java::to_native_str($_, $level, "list"), @arguments)) . ")"
        }, "say", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @arguments = @{$self->{"arguments"}};
            my $fun;
            if ($self->{"special_arg"}) {;
                $fun = Perlito5::Java::to_filehandle($self->{"special_arg"}, $level + 1)
            }
            else {;
                $fun = "PlV.STDOUT"
            }
            return "PlCORE.say(" . join(", ", Perlito5::Java::to_context($wantarray), $fun, map(Perlito5::Java::to_native_str($_), @arguments)) . ")"
        }, "printf", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun;
            if ($self->{"special_arg"}) {;
                $fun = Perlito5::Java::to_filehandle($self->{"special_arg"}, $level + 1)
            }
            else {;
                $fun = "PlV.STDOUT"
            }
            my $list = "PlCORE.sprintf(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_list(\@in, $level) . ").toString()";
            "PlCORE.print(" . Perlito5::Java::to_context($wantarray) . ", " . $fun . ", " . $list . ")"
        }, "select", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @arguments = @{$self->{"arguments"}};
            if (@arguments == 1) {;
                return "PlCORE.select(" . Perlito5::Java::to_filehandle($arguments[0], $level + 1) . ")"
            }
            "PlCORE.select(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_list($self->{"arguments"}, $level) . ")"
        }, "mkdir", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @arguments = @{$self->{"arguments"}};
            if (@arguments < 1) {;
                push(@arguments, Perlito5::AST::Var::SCALAR_ARG())
            }
            if (@arguments < 2) {;
                push(@arguments, Perlito5::AST::Int::->new("int", 511))
            }
            "PlCORE.mkdir(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_list($self->{"arguments"}, $level) . ")"
        }, "rmdir", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @arguments = @{$self->{"arguments"}};
            if (@arguments < 1) {;
                push(@arguments, Perlito5::AST::Var::SCALAR_ARG())
            }
            "PlCORE.rmdir(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_list($self->{"arguments"}, $level) . ")"
        }, "chdir", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @arguments = @{$self->{"arguments"}};
            if (@arguments < 1) {;
                push(@arguments, Perlito5::AST::Var::SCALAR_ARG())
            }
            "PlCORE.chdir(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_list($self->{"arguments"}, $level) . ")"
        }, "unlink", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @arguments = @{$self->{"arguments"}};
            if (@arguments < 1) {;
                push(@arguments, Perlito5::AST::Var::SCALAR_ARG())
            }
            "PlCORE.unlink(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_list($self->{"arguments"}, $level) . ")"
        }, "getc", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun = shift(@in);
            if ($fun) {;
                $fun = Perlito5::Java::to_filehandle($fun, $level + 1)
            }
            else {;
                $fun = "PlV.STDIN"
            }
            "PlCORE.getc(" . Perlito5::Java::to_context($wantarray) . ", " . $fun . ", " . Perlito5::Java::to_param_list(\@in, $level + 1) . ")"
        }, "readline", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun = shift(@in) || bless({"arguments" => [], "bareword" => 1, "code" => "ARGV", "namespace" => "main", }, "Perlito5::AST::Apply");
            my $list = Perlito5::Java::to_list(\@in, $level);
            "PlCORE.readline(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_filehandle($fun, $level + 1) . ", " . $list . ")"
        }, "map", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun;
            if ($self->{"special_arg"}) {;
                $fun = $self->{"special_arg"}
            }
            else {;
                $fun = shift(@in)
            }
            my $list = Perlito5::Java::to_list(\@in, $level);
            if (ref($fun) eq "Perlito5::AST::Block") {;
                $fun = $fun->{"stmts"}
            }
            else {;
                $fun = [$fun]
            }
            my $sub = Perlito5::AST::Sub::->new("block", Perlito5::AST::Block::->new("stmts", $fun));
            "PerlOp.map(" . $sub->emit_java($level + 1) . ", " . $list . ", " . "List__, " . Perlito5::Java::to_context($wantarray) . ")"
        }, "grep", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun;
            if ($self->{"special_arg"}) {;
                $fun = $self->{"special_arg"}
            }
            else {;
                $fun = shift(@in)
            }
            my $list = Perlito5::Java::to_list(\@in, $level);
            if (ref($fun) eq "Perlito5::AST::Block") {;
                $fun = $fun->{"stmts"}
            }
            else {;
                $fun = [$fun]
            }
            my $sub = Perlito5::AST::Sub::->new("block", Perlito5::AST::Block::->new("stmts", $fun));
            "PerlOp.grep(" . $sub->emit_java($level + 1) . ", " . $list . ", " . "List__, " . Perlito5::Java::to_context($wantarray) . ")"
        }, "bless", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $items = Perlito5::Java::to_list_preprocess($self->{"arguments"});
            my @in = @{$items};
            my $ref = shift(@in);
            my $class = shift(@in);
            if ($class) {;
                $class = Perlito5::Java::to_native_str($class)
            }
            else {;
                $class = Perlito5::Java::escape_string($Perlito5::PKG_NAME)
            }
            return $ref->emit_java($level, "scalar") . ".bless(" . $class . ")"
        }, "sort", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun;
            my $list;
            if ($self->{"special_arg"}) {;
                $fun = $self->{"special_arg"}
            }
            elsif (ref($in[0]) eq "Perlito5::AST::Block") {;
                $fun = shift(@in)
            }
            my $sub;
            if (ref($fun) eq "Perlito5::AST::Block") {
                $fun = $fun->{"stmts"};
                $sub = Perlito5::AST::Sub::->new("block", Perlito5::AST::Block::->new("stmts", $fun))
            }
            else {;
                $sub = $fun
            }
            $list = Perlito5::Java::to_list(\@in, $level);
            "PerlOp.sort(" . $sub->emit_java($level + 1) . ", " . $list . ", " . "List__, " . Perlito5::Java::to_context($wantarray) . ")"
        }, "ref", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0];
            return $arg->emit_java($level, "scalar") . ".ref()"
        }, "exists", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ((ref($arg) eq "Perlito5::AST::Lookup")) {
                my $v = $arg->obj();
                if ((ref($v) eq "Perlito5::AST::Var") && $v->{"sigil"} eq "\$") {;
                    return $v->emit_java($level, $wantarray) . ".hexists(" . Perlito5::Java::to_native_str($arg->autoquote($arg->{"index_exp"}), $level) . ")"
                }
                if ((ref($v) eq "Perlito5::AST::Apply") && $v->{"code"} eq "prefix:<\$>") {;
                    $arg = Perlito5::AST::Call::->new("method", "postcircumfix:<{ }>", "invocant", $v->{"arguments"}->[0], "arguments", $arg->{"index_exp"})
                }
                else {;
                    return $v->emit_java($level, $wantarray, "hash") . ".hexists(" . Perlito5::Java::to_native_str($arg->autoquote($arg->{"index_exp"}), $level) . ")"
                }
            }
            if ((ref($arg) eq "Perlito5::AST::Index")) {
                my $v = $arg->obj();
                if ((ref($v) eq "Perlito5::AST::Var") && $v->{"sigil"} eq "\$") {;
                    return $v->emit_java($level, "array") . ".aexists(" . $arg->{"index_exp"}->emit_java($level) . ")"
                }
                if ((ref($v) eq "Perlito5::AST::Apply") && $v->{"code"} eq "prefix:<\$>") {;
                    $arg = Perlito5::AST::Call::->new("method", "postcircumfix:<[ ]>", "invocant", $v->{"arguments"}->[0], "arguments", $arg->{"index_exp"})
                }
                else {;
                    return $v->emit_java($level, $wantarray, "array") . ".aexists(" . $arg->{"index_exp"}->emit_java($level) . ")"
                }
            }
            if ((ref($arg) eq "Perlito5::AST::Call")) {
                if ($arg->method() eq "postcircumfix:<{ }>") {;
                    return $arg->invocant()->emit_java($level, $wantarray, "hash") . ".hexists(" . Perlito5::Java::to_native_str(Perlito5::AST::Lookup::->autoquote($arg->{"arguments"}), $level) . ")"
                }
                if ($arg->method() eq "postcircumfix:<[ ]>") {;
                    return $arg->invocant()->emit_java($level, $wantarray, "array") . ".aexists(" . $arg->{"arguments"}->emit_java($level) . ")"
                }
            }
            if ((ref($arg) eq "Perlito5::AST::Var") && $arg->{"sigil"} eq "&") {
                my $name = $arg->{"name"};
                my $namespace = $arg->{"namespace"} || $Perlito5::PKG_NAME;
                return "new PlBool(PlV.cget_no_autoload(" . Perlito5::Java::escape_string($namespace . "::" . $name) . ").is_coderef())"
            }
            if ((ref($arg) eq "Perlito5::AST::Apply") && $arg->{"code"} eq "prefix:<&>") {
                my $arg2 = $arg->{"arguments"}->[0];
                return "new PlBool(" . "PlV.code_lookup_by_name_no_autoload(" . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ", " . $arg2->emit_java($level) . ")" . ".is_coderef())"
            }
        }, "prototype", sub {
            (my $self, my $level, my $wantarray) = @_;
            my $arg = $self->{"arguments"}->[0];
            return "PerlOp.prototype(" . $arg->emit_java($level) . ", " . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ")"
        }, "split", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @arguments = @{$self->{"arguments"}};
            if (@arguments < 1) {;
                push(@arguments, Perlito5::AST::Buf::->new("buf", " "))
            }
            if (@arguments < 2) {;
                push(@arguments, Perlito5::AST::Var::SCALAR_ARG())
            }
            if (@arguments < 3) {;
                push(@arguments, Perlito5::AST::Int::->new("int", 0))
            }
            my @js;
            my $arg = $arguments[0];
            if ($arg && (ref($arg) eq "Perlito5::AST::Apply") && $arg->{"code"} eq "p5:m") {
                my $flags = $arg->{"arguments"}->[1]->{"buf"};
                $flags !~ m/m/ && ($flags .= "m");
                push(@js, Perlito5::AST::Apply::emit_qr_java($arg->{"arguments"}->[0], $flags));
                shift(@arguments)
            }
            return "PlCORE.split(" . join(", ", Perlito5::Java::to_context($wantarray), @js, map($_->emit_java($level), @arguments)) . ")"
        }, "join", sub {
            (my $self, my $level, my $wantarray) = @_;
            my @arguments = @{$self->{"arguments"}};
            my $arg = shift(@arguments);
            return "PlCORE.join(" . join(", ", Perlito5::Java::to_context($wantarray), Perlito5::Java::to_native_str($arg), map($_->emit_java($level, "list"), @arguments)) . ")"
        });
        for my $op ("binmode", "close", "closedir", "open", "opendir", "readdir", "seek", "seekdir", "read", "sysread", "write", "syswrite") {;
            $emit_js{$op} = sub {
                (my $self, my $level, my $wantarray) = @_;
                my @in = @{$self->{"arguments"}};
                my $fun = shift(@in);
                "PlCORE." . $op . "(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_filehandle($fun, $level + 1) . ", " . Perlito5::Java::to_param_list(\@in, $level + 1) . ")"
            }
        }
        for my $op ("chomp", "chop") {;
            $emit_js{$op} = sub {
                (my $self, my $level, my $wantarray) = @_;
                "PlCORE." . $op . "(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_param_list($self->{"arguments"}, $level + 1) . ")"
            }
        }
        for my $op ("hex", "oct", "fc", "values", "keys", "each") {;
            $emit_js{$op} = sub {
                (my $self, my $level, my $wantarray) = @_;
                "PlCORE." . $op . "(" . Perlito5::Java::to_context($wantarray) . ", " . $self->{"arguments"}->[0]->emit_java($level + 1) . ")"
            }
        }
        for my $op ("sleep", "exit", "warn", "die", "system", "qx", "pack", "unpack", "sprintf", "crypt", "reverse", "gmtime", "localtime", "time", "times", "rename") {;
            $emit_js{$op} = sub {
                (my $self, my $level, my $wantarray) = @_;
                "PlCORE." . $op . "(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_list($self->{"arguments"}, $level + 1) . ")"
            }
        }
        for my $op ("stat", "lstat") {;
            $emit_js{$op} = sub {
                (my $self, my $level, my $wantarray) = @_;
                my @in = @{$self->{"arguments"}};
                !@in && (@in = Perlito5::AST::Var::SCALAR_ARG());
                "PlCORE." . $op . "(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_list(\@in, $level) . ")"
            }
        }
        sub Perlito5::AST::Apply::emit_java_op_table {;
            return \%emit_js
        }
        sub Perlito5::AST::Apply::emit_java {
            (my $self, my $level, my $wantarray, my $autovivification_type) = @_;
            my $code = $self->{"code"};
            if (ref($code) ne '') {
                my $items = Perlito5::Java::to_list_preprocess($self->{"arguments"});
                if (ref($code) eq "Perlito5::AST::Apply" && $code->{"code"} eq "prefix:<&>") {
                    my $invocant = $code->{"arguments"}->[0]->emit_java($level);
                    if (!$code->{"_strict_refs"}) {;
                        $invocant = "PlV.code_lookup_by_name(" . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ", " . $invocant . ")"
                    }
                    return $invocant . ".apply(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_param_list($items, $level + 1) . ")"
                }
                return $self->{"code"}->emit_java($level) . ".apply(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_param_list($items, $level + 1) . ")"
            }
            if (!exists($emit_js{$code})) {
                my $apply = $self->op_assign();
                if ($apply) {;
                    return $apply->emit_java($level)
                }
                my $apply = $self->op_auto();
                if ($apply) {;
                    return $apply->emit_java($level)
                }
            }
            $code eq "package" && return '';
            exists($emit_js{$code}) && ($self->{"namespace"} eq '' || $self->{"namespace"} eq "CORE") && return $emit_js{$code}->($self, $level, $wantarray, $autovivification_type);
            if (exists($Perlito5::Java::op_prefix_js_str{$code})) {;
                return $Perlito5::Java::op_prefix_js_str{$code} . "(" . Perlito5::Java::to_str($self->{"arguments"}->[0]) . ")"
            }
            if ($self->{"namespace"}) {
                if ($self->{"namespace"} eq "Java" && $code eq "inline") {
                    my @args = @{$self->{"arguments"}};
                    if (@args != 1) {;
                        die("Java::inline needs a single argument")
                    }
                    if ($args[0]->isa("Perlito5::AST::Apply") && $args[0]->{"code"} eq "list:<.>") {
                        @args = @{$args[0]->{"arguments"}};
                        if (@args != 1) {;
                            die("Java::inline needs a string constant, got:", Perlito5::Dumper::Dumper(\@args))
                        }
                    }
                    if ($args[0]->isa("Perlito5::AST::Buf")) {;
                        return $args[0]->{"buf"}
                    }
                    else {;
                        die("Java::inline needs a string constant, got:", Perlito5::Dumper::Dumper(\@args))
                    }
                }
                if ($self->{"namespace"} eq "Perlito5") {;
                    if ($code eq "eval_ast") {;
                        $self->{"namespace"} = "Perlito5::Java::Runtime"
                    }
                }
                $code = ($self->{"namespace"}) . "::" . $code
            }
            else {;
                $code = $Perlito5::PKG_NAME . "::" . $code
            }
            my $sig;
            my $may_need_autoload;
            {
                my $name = $self->{"code"};
                my $namespace = $self->{"namespace"} || $Perlito5::PKG_NAME;
                my $effective_name = $namespace . "::" . ($self->{"code"});
                if (exists($Perlito5::PROTO->{$effective_name})) {;
                    $sig = $Perlito5::PROTO->{$effective_name}
                }
                elsif ((!$self->{"namespace"} || $namespace eq "CORE") && exists($Perlito5::CORE_PROTO->{"CORE::" . $name})) {
                    $effective_name = "CORE::" . $name;
                    $sig = $Perlito5::CORE_PROTO->{$effective_name}
                }
                else {
                    if ($self->{"bareword"}) {;
                        return Perlito5::AST::Buf::->new("buf", ($self->{"namespace"} ? ($self->{"namespace"}) . "::" : '') . $name)->emit_java($level + 1, "scalar")
                    }
                    $may_need_autoload = 1
                }
                (exists($self->{"proto"})) && ($sig = $self->{"proto"})
            }
            $self->{"ignore_proto"} && ($sig = '');
            if ($sig) {
                my @out = ();
                my @in = @{$self->{"arguments"} || []};
                my $optional = 0;
                while (length($sig)) {
                    my $c = substr($sig, 0, 1);
                    if ($c eq ";") {;
                        $optional = 1
                    }
                    elsif ($c eq "\$" || $c eq "_") {;
                        (@in || !$optional) && push(@out, shift(@in)->emit_java($level + 1, "scalar"))
                    }
                    elsif ($c eq "\@") {
                        (@in || !$optional) && push(@out, Perlito5::Java::to_list(\@in, $level + 1));
                        @in = ()
                    }
                    elsif ($c eq "&") {;
                        push(@out, shift(@in)->emit_java($level + 1, "scalar"))
                    }
                    elsif ($c eq "*") {;
                        if (@in || !$optional) {
                            my $arg = shift(@in);
                            if ($arg->{"bareword"}) {;
                                push(@out, Perlito5::AST::Buf::->new("buf", $arg->{"code"})->emit_java($level + 1, "scalar"))
                            }
                            else {;
                                push(@out, $arg->emit_java($level + 1, "scalar"))
                            }
                        }
                    }
                    elsif ($c eq "\\") {
                        if (substr($sig, 0, 2) eq "\\\$") {
                            $sig = substr($sig, 1);
                            (@in || !$optional) && push(@out, shift(@in)->emit_java($level + 1, "scalar"))
                        }
                        elsif (substr($sig, 0, 2) eq "\\\@" || substr($sig, 0, 2) eq "\\%") {
                            $sig = substr($sig, 1);
                            (@in || !$optional) && push(@out, shift(@in)->emit_java($level + 1, "list"))
                        }
                        elsif (substr($sig, 0, 5) eq "\\[\@%]") {
                            $sig = substr($sig, 4);
                            (@in || !$optional) && push(@out, shift(@in)->emit_java($level + 1, "list"))
                        }
                        elsif (substr($sig, 0, 6) eq "\\[\$\@%]") {
                            $sig = substr($sig, 5);
                            (@in || !$optional) && push(@out, shift(@in)->emit_java($level + 1, "list"))
                        }
                    }
                    $sig = substr($sig, 1)
                }
                $code = Perlito5::AST::Buf::->new("buf", $code)->emit_java($level, "scalar");
                return $code . ".apply(" . Perlito5::Java::to_context($wantarray) . ", PlArray.construct_list_of_aliases(" . join(", ", @out) . ")" . ")"
            }
            my $items = Perlito5::Java::to_list_preprocess($self->{"arguments"});
            $code = Perlito5::AST::Buf::->new("buf", $code)->emit_java($level, "scalar");
            return $code . ".apply(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_param_list($items, $level + 1) . ")"
        }
        sub Perlito5::AST::Apply::emit_java_get_decl {
            my $self = shift;
            my $code = $self->{"code"};
            if ($code ne "do" && $code ne "eval") {;
                $self->{"arguments"} && return (map(+$_->emit_java_get_decl(), @{$self->{"arguments"}}))
            }
            return ()
        }
        sub Perlito5::AST::Apply::emit_java_has_regex {
            my $self = shift;
            my $code = $self->{"code"};
            if ($code eq "p5:m" || $code eq "p5:s" || $code eq "infix:<=~>" || $code eq "infix:<!~>") {;
                return 1
            }
            return ()
        }
    }
    1
}
{
    package main;
    package Perlito5::Java;
    sub Perlito5::Java::init {;
        Perlito5::Java::init_java_class()
    }
    my %label;
    my %Java_class;
    our %Java_var_name;
    my %Java_var;
    our @Java_init;
    our $is_inside_subroutine;
    sub Perlito5::Java::pkg {;
        Perlito5::Java::escape_string($Perlito5::PKG_NAME)
    }
    sub Perlito5::Java::get_label {;
        "tmp" . ($Perlito5::ID++)
    }
    sub Perlito5::Java::tab {
        my $level = shift;
        "    " x $level
    }
    sub Perlito5::Java::get_java_class_info {;
        return \%Java_class
    }
    sub Perlito5::Java::get_java_var_info {;
        return \%Java_var
    }
    sub Perlito5::Java::set_java_class_defaults {
        (my $perl_package, my $java_import) = @_;
        my $Java_class = Perlito5::Java::get_java_class_info();
        my @parts = split(m/\./, $java_import);
        $Java_class->{$perl_package}->{"java_type"} //= $java_import;
        $Java_class->{$perl_package}->{"java_native_to_perl"} //= "p" . $parts[-1];
        $Java_class->{$perl_package}->{"java_native_to_perl"} =~ s/[<>]/_/g;
        $Java_class->{$perl_package}->{"perl_package"} = $perl_package
    }
    our %is_long_type = ("long", 1, "Long", 1, "java.lang.Long", 1);
    our %is_float_type = ("float", 1, "Float", 1, "java.lang.Float", 1);
    our %is_char_type = ("char", 1, "Character", 1, "java.lang.Character", 1);
    our %is_double_type = ("double", 1, "Double", 1, "java.lang.Double", 1);
    our %is_boolean_type = ("boolean", 1, "Boolean", 1, "java.lang.Boolean", 1);
    our %is_char_type = ("char", 1, "Character", 1, "java.lang.Character", 1);
    our %is_int_type = ("int", 1, "Integer", 1, "java.lang.Integer", 1);
    our %is_short_type = ("short", 1, "Short", 1, "java.lang.Short", 1);
    our %is_byte_type = ("byte", 1, "Byte", 1, "java.lang.Byte", 1);
    our %stringify = ("byte", "Byte.toString", "short", "Short.toString", "int", "Integer.toString", "long", "Long.toString", "float", "Float.toString", "double", "Double.toString", "char", "Character.toString", "boolean", "Boolean.toString");
    sub Perlito5::Java::init_java_class {
        my $Java_class = Perlito5::Java::get_java_class_info();
        $Java_class->{"String"} = {"java_type" => "String", "java_native_to_perl" => "PlString", "perl_to_java" => "toString", "perl_package" => "String", };
        $Java_class->{"Long"} = {"java_type" => "Long", "java_native_to_perl" => "PlInt", "perl_to_java" => "to_long", "perl_package" => "Long", };
        $Java_class->{"Integer"} = {"java_type" => "Integer", "java_native_to_perl" => "PlInt", "perl_to_java" => "to_int", "perl_package" => "Integer", };
        $Java_class->{"Boolean"} = {"java_type" => "Boolean", "java_native_to_perl" => "PlBool", "perl_to_java" => "to_boolean", "perl_package" => "Boolean", };
        $Java_class->{"Double"} = {"java_type" => "Double", "java_native_to_perl" => "PlDouble", "perl_to_java" => "to_double", "perl_package" => "Double", };
        $Java_class->{"Byte"} = {"java_type" => "Byte", "java_native_to_perl" => "PlInt", "perl_to_java" => "to_byte", "perl_package" => "Byte", };
        $Java_class->{"Short"} = {"java_type" => "Short", "java_native_to_perl" => "PlInt", "perl_to_java" => "to_short", "perl_package" => "Short", };
        $Java_class->{"Float"} = {"java_type" => "Float", "java_native_to_perl" => "PlDouble", "perl_to_java" => "to_float", "perl_package" => "Float", };
        $Java_class->{"Character"} = {"java_type" => "Character", "java_native_to_perl" => "PlString", "perl_to_java" => "to_char", "perl_package" => "Character", };
        $Java_class->{"long"} = {"java_type" => "long", "java_native_to_perl" => "PlInt", "perl_to_java" => "to_long", "perl_package" => "long", };
        $Java_class->{"int"} = {"java_type" => "int", "java_native_to_perl" => "PlInt", "perl_to_java" => "to_int", "perl_package" => "int", };
        $Java_class->{"short"} = {"java_type" => "short", "java_native_to_perl" => "PlInt", "perl_to_java" => "to_long", "perl_package" => "short", };
        $Java_class->{"byte"} = {"java_type" => "byte", "java_native_to_perl" => "PlInt", "perl_to_java" => "to_long", "perl_package" => "byte", };
        $Java_class->{"boolean"} = {"java_type" => "boolean", "java_native_to_perl" => "PlBool", "perl_to_java" => "to_boolean", "perl_package" => "boolean", };
        $Java_class->{"double"} = {"java_type" => "double", "java_native_to_perl" => "PlDouble", "perl_to_java" => "to_double", "perl_package" => "double", };
        $Java_class->{"float"} = {"java_type" => "float", "java_native_to_perl" => "PlDouble", "perl_to_java" => "to_float", "perl_package" => "float", };
        $Java_class->{"char"} = {"java_type" => "char", "java_native_to_perl" => "PlString", "perl_to_java" => "to_char", "perl_package" => "char", }
    }
    our %Java_loop_label;
    sub Perlito5::Java::get_java_loop_label {
        my $s = shift;
        !$s && return 0;
        exists($Java_loop_label{$s}) && return $Java_loop_label{$s};
        my $label = $Perlito5::ID++;
        $Java_loop_label{$s} = $label;
        return $label
    }
    our %Java_constant_seen;
    sub Perlito5::Java::get_constant {
        (my $type, my $create) = @_;
        if (exists($Java_constant_seen{$create})) {;
            return $Java_constant_seen{$create}
        }
        my $label = Perlito5::Java::get_label();
        push(@Perlito5::Java::Java_constants, "public static final " . $type . " " . $label . " = " . $create . ";");
        $Java_constant_seen{$create} = $label;
        return $label
    }
    our %op_prefix_js_str = ("prefix:<-A>", "PerlOp.p5atime", "prefix:<-C>", "PerlOp.p5ctime", "prefix:<-M>", "PerlOp.p5mtime", "prefix:<-d>", "PerlOp.p5is_directory", "prefix:<-e>", "PerlOp.p5file_exists", "prefix:<-f>", "PerlOp.p5is_file", "prefix:<-s>", "PerlOp.p5size", "prefix:<-l>", "PerlOp.p5is_symbolic_link", "prefix:<-r>", "PerlOp.p5is_readable", "prefix:<-w>", "PerlOp.p5is_writable", "prefix:<-x>", "PerlOp.p5is_executable", "prefix:<-p>", "PerlOp.p5is_named_pipe");
    our %op_infix_js_str = ("infix:<eq>", " == ", "infix:<ne>", " != ", "infix:<le>", " <= ", "infix:<ge>", " >= ", "infix:<lt>", " < ", "infix:<gt>", " > ");
    our %op_to_boolean = map(+($_, 1), "prefix:<!>", "infix:<!=>", "infix:<==>", "infix:<<=>", "infix:<>=>", "infix:<>>", "infix:<<>", "infix:<eq>", "infix:<ne>", "infix:<ge>", "infix:<le>", "infix:<gt>", "infix:<lt>", "prefix:<not>", "exists", "defined");
    our %op_to_str = map(+($_, 1), "substr", "join", "list:<.>", "chr", "lc", "uc", "lcfirst", "ucfirst", "ref");
    our %op_to_num = map(+($_, 1), "length", "index", "rindex", "ord", "oct", "int", "infix:<->", "infix:<+>", "infix:<*>", "infix:</>", "infix:<%>", "infix:<**>", "infix:<|>", "infix:<&>");
    our %op_to_scalar = map(+($_, 1), (keys(%op_to_str), keys(%op_to_num), keys(%op_to_boolean), "circumfix:<[ ]>", "circumfix:<{ }>", "infix:<cmp>", "infix:<<=>>", "postfix:<++>", "postfix:<-->", "prefix:<++>", "prefix:<-->", "bless"));
    our %native_op = ("infix:<->", "-", "infix:<+>", "+", "infix:<*>", "*", "infix:</>", "/", "infix:<!=>", "!=", "infix:<==>", "==", "infix:<<=>", "<=", "infix:<>=>", ">=", "infix:<>>", ">", "infix:<<>", "<");
    our %native_op_unary = ("postfix:<++>", 1, "postfix:<-->", 1, "prefix:<++>", 1, "prefix:<-->", 1);
    our %native_op_to_boolean = ("infix:<!=>", "!=", "infix:<==>", "==", "infix:<<=>", "<=", "infix:<>=>", ">=", "infix:<>>", ">", "infix:<<>", "<");
    our %valid_java_statement = ("delete", 1, "die", 1, "do", 1, "infix:<=>", 1, "last", 1, "next", 1, "postfix:<++>", 1, "postfix:<-->", 1, "prefix:<++>", 1, "prefix:<-->", 1, "print", 1, "printf", 1, "push", 1, "redo", 1, "return", 1, "say", 1, "shift", 1, "tie", 1, "unshift", 1, "untie", 1, "warn", 1);
    our %special_scalar = ("_", "Scalar_ARG", "\\", "Scalar_OUTPUT_RECORD_SEPARATOR", "|", "Scalar_AUTOFLUSH", "\@", "Scalar_EVAL_ERROR");
    my %safe_char = ("\\", "\\\\", "\"", "\\\"", chr(10), "\\n", chr(13), "\\r", map {;
        $_ => $_
    } ("A" .. "Z", "a" .. "z", 0 .. 9, " ", "!", "#", "\$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", ":", ";", "<", "=", ">", "?", "\@", "[", "]", "^", "_", "`", "{", "|", "}", "~"));
    sub Perlito5::Java::escape_string {
        my $s = shift;
        my @out = "\"";
        my $has_char = 0;
        $s eq '' && return "\"\"";
        my $v;
        for my $c (split('', $s)) {
            $v = $safe_char{$c};
            if (!defined($v)) {
                if (ord($c) > 65535) {;
                    $v = $safe_char{$c} = "\" + new String(Character.toChars(" . ord($c) . ")) + \""
                }
                else {;
                    $v = $safe_char{$c} = "\" + (char)" . ord($c) . " + \""
                }
            }
            push(@out, $v)
        }
        push(@out, "\"");
        return join('', @out)
    }
    sub Perlito5::Java::is_native {
        my $self = shift;
        if (ref($self) eq "Perlito5::AST::Var") {
            my $id = $self->{"_id"};
            my $sigil = $self->{"_real_sigil"} || $self->{"sigil"};
            if ($sigil eq "\$" && $id) {
                my $Java_var = Perlito5::Java::get_java_var_info();
                my $type = $Java_var->{$id}->{"type"} || "PlLvalue";
                if ($type ne "PlLvalue") {;
                    return 1
                }
            }
        }
        if (ref($self) eq "Perlito5::AST::Call") {
            if (ref($self->{"invocant"}) eq "Perlito5::AST::Var" && $self->{"invocant"}->{"sigil"} eq "::") {
                my $Java_class = Perlito5::Java::get_java_class_info();
                if (exists($Java_class->{$self->{"invocant"}->{"namespace"}})) {;
                    return 1
                }
            }
            if (ref($self->{"invocant"}) eq "Perlito5::AST::Var" && $self->{"invocant"}->{"_id"}) {
                my $id = $self->{"invocant"}->{"_id"};
                my $Java_var = Perlito5::Java::get_java_var_info();
                my $type = $Java_var->{$id}->{"type"} || "PlLvalue";
                if ($type ne "PlLvalue") {;
                    return 1
                }
            }
            if (Perlito5::Java::is_native($self->{"invocant"})) {;
                return 1
            }
            my $meth = $self->{"method"};
            if ($meth =~ m/^to/) {
                my $Java_class = Perlito5::Java::get_java_class_info();
                for my $info (values(%{$Java_class})) {;
                    if ($meth eq $info->{"perl_to_java"}) {;
                        return 1
                    }
                }
            }
        }
        return 0
    }
    sub Perlito5::Java::is_native_bool {
        my $self = shift;
        if (Perlito5::Java::is_native_args([$self])) {;
            return 1
        }
        my $is_apply = (ref($self) eq "Perlito5::AST::Apply") && $self->{"arguments"} && @{$self->{"arguments"}};
        if ($is_apply && exists($native_op_to_boolean{$self->{"code"}}) && Perlito5::Java::is_native_args($self->{"arguments"})) {;
            return 1
        }
        return 0
    }
    sub Perlito5::Java::to_native_arg {
        my $cond = shift;
        my $level = shift;
        my $java_type = shift // '';
        my $wantarray = "scalar";
        ($is_long_type{$java_type} || $is_int_type{$java_type}) && return Perlito5::Java::to_native_int($cond, $level, $java_type);
        ($is_float_type{$java_type} || $is_double_type{$java_type}) && return Perlito5::Java::to_native_num($cond, $level, $java_type);
        $is_boolean_type{$java_type} && return Perlito5::Java::to_native_bool($cond, $level, $java_type);
        $is_char_type{$java_type} && return Perlito5::Java::to_native_char($cond, $level, $java_type);
        $is_short_type{$java_type} && return Perlito5::Java::to_native_short($cond, $level, $java_type);
        $is_byte_type{$java_type} && return Perlito5::Java::to_native_byte($cond, $level, $java_type);
        my $is_apply = (ref($cond) eq "Perlito5::AST::Apply") && $cond->{"arguments"} && @{$cond->{"arguments"}};
        if ($is_apply && exists($native_op{$cond->{"code"}})) {;
            return "(" . Perlito5::Java::to_native_num($cond->{"arguments"}->[0], $level) . " " . $native_op{$cond->{"code"}} . " " . Perlito5::Java::to_native_num($cond->{"arguments"}->[1], $level) . ")"
        }
        elsif ($is_apply && exists($op_to_num{$cond->{"code"}})) {
            if (@{$cond->{"arguments"}} == 2) {;
                return "(" . $cond->emit_java($level, $wantarray) . ")." . ($cond->{"arguments"}->[0]->isa("Perlito5::AST::Num") || $cond->{"arguments"}->[1]->isa("Perlito5::AST::Num") ? "to_double()" : "to_long()")
            }
            if (@{$cond->{"arguments"}} == 1) {;
                return "(" . $cond->emit_java($level, $wantarray) . ")." . ($cond->{"arguments"}->[0]->isa("Perlito5::AST::Num") ? "to_double()" : "to_long()")
            }
        }
        elsif ($is_apply && exists($op_to_str{$cond->{"code"}})) {;
            return "(" . $cond->emit_java($level, $wantarray) . ").toString()"
        }
        elsif ((ref($cond) eq "Perlito5::AST::Apply") && $cond->{"code"} eq "undef") {;
            return "null"
        }
        elsif ((ref($cond) eq "Perlito5::AST::Buf")) {;
            return Perlito5::Java::escape_string($cond->{"buf"})
        }
        elsif ((ref($cond) eq "Perlito5::AST::Int")) {;
            return $cond->{"int"}
        }
        elsif ((ref($cond) eq "Perlito5::AST::Num")) {;
            return $cond->{"num"}
        }
        return $cond->emit_java($level, $wantarray)
    }
    sub Perlito5::Java::to_native_args {
        my $args = shift;
        my $level = shift;
        my $java_type = shift;
        my @out;
        for my $cond (@{$args}) {
            if (ref($cond) eq "Perlito5::AST::Apply" && $cond->{"arguments"} && $cond->{"code"} eq "circumfix:<( )>") {;
                push(@out, Perlito5::Java::to_native_args($cond->{"arguments"}, $level, $java_type))
            }
            else {;
                push(@out, Perlito5::Java::to_native_arg($cond, $level, $java_type))
            }
        }
        return join(", ", @out)
    }
    sub Perlito5::Java::is_native_args {
        my $args = shift;
        my $wantarray = "scalar";
        my $s = '';
        my @out;
        for my $cond (@{$args}) {
            my $is_apply = (ref($cond) eq "Perlito5::AST::Apply") && $cond->{"arguments"} && @{$cond->{"arguments"}};
            if ($is_apply && $cond->{"code"} eq "circumfix:<( )>") {;
                Perlito5::Java::is_native_args($cond->{"arguments"}) || return 0
            }
            elsif ($is_apply && exists($native_op{$cond->{"code"}})) {;
                Perlito5::Java::is_native_args($cond->{"arguments"}) || return 0
            }
            elsif ($is_apply && exists($native_op_unary{$cond->{"code"}})) {;
                Perlito5::Java::is_native_args($cond->{"arguments"}) || return 0
            }
            elsif ((ref($cond) eq "Perlito5::AST::Int")) {}
            elsif ((ref($cond) eq "Perlito5::AST::Num")) {}
            elsif (ref($cond) eq "Perlito5::AST::Var" && $cond->{"_id"}) {
                my $id = $cond->{"_id"};
                my $Java_var = Perlito5::Java::get_java_var_info();
                my $type = $Java_var->{$id}->{"type"} || "PlLvalue";
                if ($type eq "PlLvalue") {;
                    return 0
                }
            }
            else {;
                Perlito5::Java::is_native($cond) || return 0
            }
        }
        @{$args} && return 1;
        return 0
    }
    sub Perlito5::Java::to_native_num {
        my $cond = shift;
        my $level = shift;
        my $java_type = shift // '';
        if ((ref($cond) eq "Perlito5::AST::Apply") && $cond->{"code"} eq "circumfix:<( )>" && $cond->{"arguments"} && @{$cond->{"arguments"}}) {;
            return Perlito5::Java::to_native_num($cond->{"arguments"}->[0], $level, $java_type)
        }
        elsif ((ref($cond) eq "Perlito5::AST::Buf")) {
            my $type_spec = "D";
            $is_float_type{$java_type} && ($type_spec = "F");
            return (0 + ($cond->{"buf"})) . $type_spec
        }
        elsif ((ref($cond) eq "Perlito5::AST::Int")) {
            my $type_spec = "D";
            $is_float_type{$java_type} && ($type_spec = "F");
            return ($cond->{"int"}) . $type_spec
        }
        elsif ((ref($cond) eq "Perlito5::AST::Num")) {
            my $type_spec = "D";
            $is_float_type{$java_type} && ($type_spec = "F");
            return ($cond->{"num"}) . $type_spec
        }
        else {;
            return Perlito5::Java::to_native_args([$cond], $level)
        }
    }
    sub Perlito5::Java::to_native_char {
        my $cond = shift;
        my $level = shift;
        my $java_type = shift // '';
        $java_type eq "char" && return "(char)(" . Perlito5::Java::to_native_int($cond, $level, "int") . ")";
        return "(new Character((char)" . Perlito5::Java::to_native_int($cond, $level, "int") . "))"
    }
    sub Perlito5::Java::to_native_byte {
        my $cond = shift;
        my $level = shift;
        my $java_type = shift // '';
        return "(byte)(" . Perlito5::Java::to_native_int($cond, $level, "int") . ")"
    }
    sub Perlito5::Java::to_native_short {
        my $cond = shift;
        my $level = shift;
        my $java_type = shift // '';
        return "(short)(" . Perlito5::Java::to_native_int($cond, $level, "int") . ")"
    }
    sub Perlito5::Java::to_native_str {
        my $cond = shift;
        my $level = shift;
        my $wantarray = shift;
        if ((ref($cond) eq "Perlito5::AST::Apply") && $cond->{"arguments"} && @{$cond->{"arguments"}}) {
            if ($cond->{"code"} eq "circumfix:<( )>") {;
                return Perlito5::Java::to_native_str($cond->{"arguments"}->[0], $level, $wantarray)
            }
            if ($cond->{"code"} eq "ref") {;
                return $cond->{"arguments"}->[0]->emit_java($level, $wantarray) . ".ref_str()"
            }
            if ($cond->{"code"} eq "list:<.>") {;
                return "(" . join(" + ", map(Perlito5::Java::to_native_str($_, $level, "scalar"), @{$cond->{"arguments"}})) . ")"
            }
        }
        if ((ref($cond) eq "Perlito5::AST::Buf")) {;
            return Perlito5::Java::escape_string($cond->{"buf"})
        }
        elsif ((ref($cond) eq "Perlito5::AST::Int")) {;
            return Perlito5::Java::escape_string($cond->{"int"})
        }
        elsif ((ref($cond) eq "Perlito5::AST::Num")) {;
            return Perlito5::Java::escape_string($cond->{"num"})
        }
        elsif (ref($cond) eq "Perlito5::AST::Var" && $cond->{"_id"}) {
            my $id = $cond->{"_id"};
            my $Java_var = Perlito5::Java::get_java_var_info();
            my $type = $Java_var->{$id}->{"type"} || "PlLvalue";
            if ($type ne "PlLvalue") {;
                $stringify{$type} && return $stringify{$type} . "(" . $cond->emit_java($level, $wantarray) . ")"
            }
        }
        return $cond->emit_java($level, $wantarray) . ".toString()"
    }
    sub Perlito5::Java::to_native_int {
        my $cond = shift;
        my $level = shift;
        my $java_type = shift // "int";
        my $wantarray = "scalar";
        my $type_spec = '';
        $is_long_type{$java_type} && ($type_spec = "L");
        my $cast = ".to_int()";
        $is_long_type{$java_type} && ($cast = ".to_long()");
        my $is_apply = (ref($cond) eq "Perlito5::AST::Apply") && $cond->{"arguments"} && @{$cond->{"arguments"}};
        if ($is_apply) {
            if ($cond->{"code"} eq "circumfix:<( )>") {;
                return Perlito5::Java::to_native_int($cond->{"arguments"}->[0], $level, $java_type)
            }
            if ($cond->{"code"} eq "infix:<+>" && ($cond->{"arguments"}->[0]->isa("Perlito5::AST::Int") || $cond->{"arguments"}->[1]->isa("Perlito5::AST::Int"))) {;
                return Perlito5::Java::to_native_int($cond->{"arguments"}->[0], $level, $java_type) . " + " . Perlito5::Java::to_native_int($cond->{"arguments"}->[1], $level, $java_type)
            }
        }
        if ((ref($cond) eq "Perlito5::AST::Apply") && $cond->{"code"} eq "undef") {;
            return 0 . $type_spec
        }
        if ((ref($cond) eq "Perlito5::AST::Buf")) {;
            return int(0 + ($cond->{"buf"})) . $type_spec
        }
        elsif ((ref($cond) eq "Perlito5::AST::Int")) {;
            return int(0 + ($cond->{"int"})) . $type_spec
        }
        elsif ((ref($cond) eq "Perlito5::AST::Num")) {;
            return int(0 + ($cond->{"num"})) . $type_spec
        }
        Perlito5::Java::is_native($cond) && return $cond->emit_java($level, $wantarray);
        return $cond->emit_java($level, $wantarray) . $cast
    }
    sub Perlito5::Java::to_str {
        my $cond = shift;
        my $level = shift;
        my $wantarray = "scalar";
        if ((ref($cond) eq "Perlito5::AST::Apply") && $cond->{"code"} eq "circumfix:<( )>" && $cond->{"arguments"} && @{$cond->{"arguments"}}) {;
            return Perlito5::Java::to_str($cond->{"arguments"}->[0], $level)
        }
        if (((ref($cond) eq "Perlito5::AST::Buf")) || ((ref($cond) eq "Perlito5::AST::Apply") && exists($op_to_str{$cond->{"code"}}))) {;
            return $cond->emit_java($level, $wantarray)
        }
        else {;
            return "new PlString(" . Perlito5::Java::to_native_str($cond, $level, $wantarray) . ")"
        }
    }
    sub Perlito5::Java::to_num {
        my $cond = shift;
        my $level = shift;
        my $type = shift;
        my $wantarray = "scalar";
        if ((ref($cond) eq "Perlito5::AST::Int") || (ref($cond) eq "Perlito5::AST::Num") || ((ref($cond) eq "Perlito5::AST::Apply") && exists($op_to_num{$cond->{"code"}}))) {;
            return $cond->emit_java($level, $wantarray)
        }
        else {
            if ($type eq "int") {;
                return "new PlInt(" . $cond->emit_java($level, $wantarray) . ".to_long())"
            }
            return "new PlDouble(" . $cond->emit_java($level, $wantarray) . ".to_double())"
        }
    }
    sub Perlito5::Java::to_native_bool {
        my $cond = shift;
        my $level = shift;
        my $wantarray = "scalar";
        my $class = ref($cond);
        if ($class eq "Perlito5::AST::Apply") {
            if ($cond->{"code"} eq "circumfix:<( )>" && $cond->{"arguments"} && @{$cond->{"arguments"}}) {;
                if (@{$cond->{"arguments"}} == 1) {;
                    return Perlito5::Java::to_native_bool($cond->{"arguments"}->[0], $level)
                }
            }
            if ($cond->{"code"} eq "undef") {;
                return "false"
            }
            if ($cond->{"code"} eq "ref" && $cond->{"arguments"} && @{$cond->{"arguments"}}) {;
                return $cond->{"arguments"}->[0]->emit_java($level, $wantarray) . ".ref_boolean()"
            }
            if ($cond->{"code"} eq "infix:<&&>" || $cond->{"code"} eq "infix:<and>") {;
                return "(" . Perlito5::Java::to_native_bool($cond->{"arguments"}->[0], $level) . " && " . Perlito5::Java::to_native_bool($cond->{"arguments"}->[1], $level) . ")"
            }
            if ($cond->{"code"} eq "infix:<||>" || $cond->{"code"} eq "infix:<or>") {;
                return "(" . Perlito5::Java::to_native_bool($cond->{"arguments"}->[0], $level) . " || " . Perlito5::Java::to_native_bool($cond->{"arguments"}->[1], $level) . ")"
            }
            if ($cond->{"code"} eq "prefix:<!>" || $cond->{"code"} eq "prefix:<not>") {;
                if (@{$cond->{"arguments"}} == 1) {;
                    return "!" . Perlito5::Java::to_native_bool($cond->{"arguments"}->[0], $level)
                }
            }
            if ($cond->{"code"} eq "infix:<eq>") {;
                return Perlito5::Java::to_native_str($cond->{"arguments"}->[0], $level, "scalar") . ".equals(" . Perlito5::Java::to_native_str($cond->{"arguments"}->[1], $level, "scalar") . ")"
            }
            if ($cond->{"code"} eq "infix:<ne>") {;
                return "!" . Perlito5::Java::to_native_str($cond->{"arguments"}->[0], $level, "scalar") . ".equals(" . Perlito5::Java::to_native_str($cond->{"arguments"}->[1], $level, "scalar") . ")"
            }
            if ($cond->{"code"} eq "infix:<le>") {;
                return "(" . Perlito5::Java::to_native_str($cond->{"arguments"}->[0], $level, "scalar") . ".compareTo(" . Perlito5::Java::to_native_str($cond->{"arguments"}->[1], $level, "scalar") . ") <= 0)"
            }
            if ($cond->{"code"} eq "infix:<ge>") {;
                return "(" . Perlito5::Java::to_native_str($cond->{"arguments"}->[0], $level, "scalar") . ".compareTo(" . Perlito5::Java::to_native_str($cond->{"arguments"}->[1], $level, "scalar") . ") >= 0)"
            }
            if ($cond->{"code"} eq "infix:<lt>") {;
                return "(" . Perlito5::Java::to_native_str($cond->{"arguments"}->[0], $level, "scalar") . ".compareTo(" . Perlito5::Java::to_native_str($cond->{"arguments"}->[1], $level, "scalar") . ") < 0)"
            }
            if ($cond->{"code"} eq "infix:<gt>") {;
                return "(" . Perlito5::Java::to_native_str($cond->{"arguments"}->[0], $level, "scalar") . ".compareTo(" . Perlito5::Java::to_native_str($cond->{"arguments"}->[1], $level, "scalar") . ") > 0)"
            }
            if (exists($native_op_to_boolean{$cond->{"code"}}) && Perlito5::Java::is_native_args($cond->{"arguments"})) {;
                return "(" . Perlito5::Java::to_native_num($cond->{"arguments"}->[0], $level) . " " . $native_op_to_boolean{$cond->{"code"}} . " " . Perlito5::Java::to_native_num($cond->{"arguments"}->[1], $level) . ")"
            }
            if ($cond->{"code"} eq "defined") {
                my $arg = $cond->{"arguments"}->[0];
                if (ref($arg) eq "Perlito5::AST::Apply" && $arg->{"code"} eq "prefix:<&>") {
                    my $arg2 = $arg->{"arguments"}->[0];
                    return "!PlV.code_lookup_by_name_no_autoload(" . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ", " . $arg2->emit_java($level) . ").is_undef()"
                }
                elsif (ref($arg) eq "Perlito5::AST::Var" && $arg->{"sigil"} eq "&") {
                    my $name = $arg->{"name"};
                    my $namespace = $arg->{"namespace"} || $Perlito5::PKG_NAME;
                    return "!PlV.cget_no_autoload(" . Perlito5::Java::escape_string($namespace . "::" . $name) . ").is_undef()"
                }
                if (Perlito5::Java::is_native($arg)) {;
                    return $arg->emit_java($level, "scalar") . " != null"
                }
                return "!" . $arg->emit_java($level, "scalar") . ".is_undef()"
            }
        }
        if ($class eq "Perlito5::AST::Var" && $cond->{"sigil"} eq "\@") {;
            return $cond->emit_java($level, "list") . ".length_of_array_boolean()"
        }
        elsif ($class eq "Perlito5::AST::Int") {
            if ($cond->{"int"} == 0) {;
                return "false"
            }
            return "(" . ($cond->{"int"}) . " != 0)"
        }
        elsif ($class eq "Perlito5::AST::Num") {
            if ($cond->{"num"} == 0.0) {;
                return "false"
            }
            return "(" . ($cond->{"num"}) . " != 0.0)"
        }
        Perlito5::Java::is_native($cond) && return $cond->emit_java($level, $wantarray);
        if ($class eq "Perlito5::AST::Apply" && exists($op_to_boolean{$cond->{"code"}})) {;
            return $cond->emit_java($level, $wantarray) . ".to_boolean()"
        }
        else {;
            return $cond->emit_java($level, $wantarray) . ".to_boolean()"
        }
    }
    sub Perlito5::Java::is_scalar {;
        $_[0]->isa("Perlito5::AST::Int") || $_[0]->isa("Perlito5::AST::Num") || $_[0]->isa("Perlito5::AST::Buf") || Perlito5::AST::Sub::is_anon_sub($_[0]) || ($_[0]->isa("Perlito5::AST::Var") && $_[0]->{"sigil"} eq "\$") || ($_[0]->isa("Perlito5::AST::Apply") && (exists($op_to_scalar{$_[0]->{"code"}})))
    }
    sub Perlito5::Java::to_filehandle {
        (my $item, my $level) = @_;
        if (ref($item) eq "Perlito5::AST::Block") {
            my $stmts = $item->{"stmts"};
            if (@{$stmts} == 1) {;
                $item = $stmts->[0]
            }
        }
        return "PerlOp.get_filehandle(" . $item->emit_java($level) . ", " . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ")"
    }
    sub Perlito5::Java::to_method_call_param_list {
        (my $this, my $items, my $level) = @_;
        my $items = Perlito5::Java::to_list_preprocess($items);
        if ((ref($this) eq "Perlito5::AST::Var") && $this->{"sigil"} eq "::") {;
            $this = Perlito5::AST::Buf::->new("buf", $this->{"namespace"})
        }
        "PlArray.construct_list_of_aliases(" . join(", ", $this->emit_java($level, "scalar", "lvalue"), map($_->emit_java($level, "list", "lvalue"), @{$items})) . ")"
    }
    sub Perlito5::Java::to_param_list {
        my $items = Perlito5::Java::to_list_preprocess($_[0]);
        my $level = $_[1];
        if (@{$items} == 0) {;
            return "new PlArray()"
        }
        if (@{$items} == 1) {
            my $item = $items->[0];
            if ((ref($item) eq "Perlito5::AST::Apply") && ($item->{"code"} eq "infix:<..>")) {;
                return "(PlArray)(" . $item->emit_java($level, "list") . ")"
            }
        }
        "PlArray.construct_list_of_aliases(" . join(", ", map($_->emit_java($level, "list", "lvalue"), @{$items})) . ")"
    }
    sub Perlito5::Java::to_list_for_push {
        my $items = Perlito5::Java::to_list_preprocess($_[0]);
        my $level = $_[1];
        if (@{$items} == 0) {;
            return ''
        }
        my $item = $items->[0];
        if (@{$items} == 1 && (ref($item) eq "Perlito5::AST::Var") && ($item->{"sigil"} eq "\@")) {;
            return $item->emit_java($level, "list")
        }
        return join(", ", map($_->emit_java($level, "list"), @{$items}))
    }
    sub Perlito5::Java::to_list {
        my $items = Perlito5::Java::to_list_preprocess($_[0]);
        my $level = $_[1];
        if (@{$items} == 0) {;
            return "new PlArray()"
        }
        my $item = $items->[0];
        if (@{$items} == 1 && (ref($item) eq "Perlito5::AST::Var") && ($item->{"sigil"} eq "\@")) {;
            return $item->emit_java($level, "list")
        }
        return "new PlArray(" . join(", ", map($_->emit_java($level, "list"), @{$items})) . ")"
    }
    sub Perlito5::Java::to_list_preprocess {
        my @items;
        for my $item (@{$_[0]}) {
            if ((ref($item) eq "Perlito5::AST::Apply") && ($item->{"code"} eq "circumfix:<( )>" || $item->{"code"} eq "list:<,>" || $item->{"code"} eq "infix:<=>>")) {
                if ((ref($item) eq "Perlito5::AST::Apply") && $item->{"code"} eq "infix:<=>>") {;
                    $item->{"arguments"}->[0] = Perlito5::AST::Lookup::->autoquote($item->{"arguments"}->[0])
                }
                for my $arg (@{Perlito5::Java::to_list_preprocess($item->{"arguments"})}) {;
                    push(@items, $arg)
                }
            }
            else {;
                push(@items, $item)
            }
        }
        return \@items
    }
    sub Perlito5::Java::to_scalar {
        my $items = Perlito5::Java::to_scalar_preprocess($_[0]);
        my $level = $_[1];
        my $wantarray = "scalar";
        @{$items} ? "(" . join(", ", map($_->emit_java($level, $wantarray), @{$items})) . ")" : "null"
    }
    sub Perlito5::Java::to_scalar_preprocess {
        my @items;
        for my $item (@{$_[0]}) {
            if ((ref($item) eq "Perlito5::AST::Apply") && ($item->{"code"} eq "list:<,>" || $item->{"code"} eq "infix:<=>>")) {
                if ((ref($item) eq "Perlito5::AST::Apply") && $item->{"code"} eq "infix:<=>>") {;
                    $item->{"arguments"}->[0] = Perlito5::AST::Lookup::->autoquote($item->{"arguments"}->[0])
                }
                for my $arg (@{Perlito5::Java::to_scalar_preprocess($item->{"arguments"})}) {;
                    push(@items, $arg)
                }
            }
            else {;
                push(@items, $item)
            }
        }
        return \@items
    }
    sub Perlito5::Java::to_runtime_context {
        my $items = Perlito5::Java::to_scalar_preprocess($_[0]);
        my $level = $_[1];
        my $wantarray = $_[2];
        my @s = grep {;
            $_ ne ''
        } map($_->emit_java($level, $wantarray), @{$items});
        @s == 0 && return "PerlOp.context(want)";
        @s == 1 && Perlito5::Java::is_scalar($items->[0]) && return $s[0];
        if (@s == 1 && $items->[0]->isa("Perlito5::AST::Apply") && ($items->[0]->{"code"} eq "circumfix:<( )>" && @{$items->[0]->{"arguments"}} == 0)) {;
            return $s[0]
        }
        if (@s == 1 && $items->[0]->isa("Perlito5::AST::Apply") && ($items->[0]->{"code"} && $items->[0]->{"namespace"})) {;
            return $s[0]
        }
        if (@s == 1 && $items->[0]->isa("Perlito5::AST::Call")) {;
            return $s[0]
        }
        "PerlOp.context(" . Perlito5::Java::to_context($wantarray) . ", " . join(", ", @s) . ")"
    }
    sub Perlito5::Java::to_context {
        my $wantarray = shift;
        $wantarray eq "list" ? "PlCx.LIST" : $wantarray eq "scalar" ? "PlCx.SCALAR" : $wantarray eq "void" ? "PlCx.VOID" : $wantarray eq "statement" ? "PlCx.VOID" : $wantarray eq "return" ? "return_context" : $wantarray eq "runtime" ? "want" : "want"
    }
    sub Perlito5::Java::autoquote {
        my $index = shift;
        my $level = shift;
        $index = Perlito5::AST::Lookup::->autoquote($index);
        return Perlito5::Java::to_native_str($index, $level)
    }
    sub Perlito5::Java::emit_java_autovivify {
        my $obj = shift;
        my $level = shift;
        my $type = shift;
        if ((ref($obj) eq "Perlito5::AST::Index") || (ref($obj) eq "Perlito5::AST::Lookup") || (ref($obj) eq "Perlito5::AST::Call")) {;
            return $obj->emit_java($level, 0, $type)
        }
        $obj->emit_java($level)
    }
    sub Perlito5::Java::emit_java_list_with_tabs {
        (my $level, my $argument) = @_;
        my $tab = Perlito5::Java::tab($level);
        return map {;
            ref($_) eq "ARRAY" ? Perlito5::Java::emit_java_list_with_tabs($level + 1, $_) : $tab . $_
        } @{$argument}
    }
    sub Perlito5::Java::emit_wrap_java {
        (my $level, my @argument) = @_;
        wantarray && return @argument;
        my $s;
        !ref($argument[0]) && ($s = shift(@argument));
        return join("
", ($s ? $s : ()), Perlito5::Java::emit_java_list_with_tabs($level, [\@argument]))
    }
    sub Perlito5::Java::emit_wrap_statement_java {
        (my $level, my $wantarray, my $argument) = @_;
        if ($wantarray eq "void" || $wantarray eq "statement") {;
            return $argument
        }
        Perlito5::Java::emit_wrap_java($level, $argument)
    }
    sub Perlito5::Java::emit_wrap_last_exception_java {
        (my $self, my $stmts, my $wantarray) = @_;
        my $block_label = Perlito5::Java::get_java_loop_label($self->{"label"});
        my $test_label = "e.label_id != 0";
        $block_label && ($test_label = "e.label_id != " . $block_label . " && e.label_id != 0");
        my @str = ("try {", [@{$stmts}], "}", "catch(PlLastException e) {", ["if (" . $test_label . ") {", ["throw e;"], "}"], "}");
        if ($wantarray ne "void" && $wantarray ne "statement") {;
            push(@str, "return PlCx.UNDEF;")
        }
        return @str
    }
    1
}
{
    package main;
    package Perlito5::Java::CORE;
    my %FileFunc = ("open", ("        int argCount = List__.to_int();
        Path path = null; 
        String mode = \"\";
        String s = \"\";
        try {
            PlFileHandle.allOpenFiles.add(fh);
            fh.readlineBuffer = new StringBuilder();
            fh.flush();
            fh.eof = false;
            if (fh.outputStream != null) {
                fh.outputStream.close();
            }
            if (fh.reader != null) {
                fh.reader.close();
            }
            // PlCORE.say(\"open \" + List__.toString());
            if (argCount == 0) {
                // As a shortcut a one-argument call takes the filename from the
                // global scalar variable of the same name as the filehandle
                PlCORE.die(\"TODO - not implemented: single argument open()\");
            }
            else if (argCount == 1) {

                if (List__.aget(0).ref().str_eq(new PlString(\"SCALAR\")).to_boolean()) {
                    PlObject o = List__.aget(0).scalar_deref(\"main\");
                    fh.reader = new PlStringReader(o);
                    fh.reader.mark(o.toString().length());
                    fh.outputStream = null;
                    return PlCx.INT1;
                }

                // EXPR
                s = List__.aget(0).toString();
                if (s.length() > 0 && s.charAt(0) == '+') {
                    mode = mode + s.substring(0, 1);
                    s = s.substring(1);
                }
                if (s.length() > 1 && s.substring(0, 2).equals(\">>\")) {
                    mode = mode + s.substring(0, 2);
                    s = s.substring(2);
                }
                else if (s.length() > 0 && (s.charAt(0) == '>' || s.charAt(0) == '<')) {
                    mode = mode + s.substring(0, 1);
                    s = s.substring(1);
                }
                while (s.length() > 0 && (s.charAt(0) == ' ' || s.charAt(0) == '\\t')) {
                    s = s.substring(1);
                }
            }
            else if (argCount > 1) {
                // MODE,EXPR,LIST?
                mode = List__.aget(0).toString();

                if (List__.aget(1).ref().str_eq(new PlString(\"SCALAR\")).to_boolean()) {
                    // TODO - input stream, charset

                    PlObject o = List__.aget(1).scalar_deref(\"main\");
                    fh.reader = new PlStringReader(o);
                    fh.reader.mark(o.toString().length());
                    fh.outputStream = null;
                    return PlCx.INT1;
                }

                s = List__.aget(1).toString();
            }

            String charset = \"ISO-8859-1\";
            int pos;
            pos = mode.indexOf(\":raw\");
            if (pos > 0) {
                charset = \"ISO-8859-1\";
                if ((pos + 4) > mode.length()) {
                    mode = mode.substring(0, pos).trim();
                }
                else {
                    mode = ( mode.substring(0, pos) + mode.substring(pos + 4) ).trim();
                }
            }
            pos = mode.indexOf(\":bytes\");
            if (pos > 0) {
                charset = \"ISO-8859-1\";
                if ((pos + 6) > mode.length()) {
                    mode = mode.substring(0, pos).trim();
                }
                else {
                    mode = ( mode.substring(0, pos) + mode.substring(pos + 6) ).trim();
                }
            }
            pos = mode.indexOf(\":encoding(\");
            if (pos > 0) {
                // extract the charset specification
                int last = mode.indexOf(\")\", pos);
                if (last > 0) {
                    charset = mode.substring(pos + 10, last);
                    if ((last + 1) > mode.length()) {
                        mode = mode.substring(0, pos).trim();
                    }
                    else {
                        mode = ( mode.substring(0, pos) + mode.substring(last + 1) ).trim();
                    }

                    if (charset.equals(\"Latin1\")) {
                        charset = \"ISO-8859-1\";
                    }
                    if (charset.equals(\"utf8\")) {
                        charset = \"UTF-8\";
                    }
                    if (charset.equals(\"utf16\")) {
                        charset = \"UTF-16\";
                    }
                }
            }
            pos = mode.indexOf(\":utf8\");
            if (pos > 0) {
                charset = \"UTF-8\";
                if ((pos + 5) > mode.length()) {
                    mode = mode.substring(0, pos).trim();
                }
                else {
                    mode = ( mode.substring(0, pos) + mode.substring(pos + 5) ).trim();
                }
            }
            // PlCORE.say(\"charset [\" + charset + \"] mode [\" + mode + \"]\");

            path = PlV.path.resolve(s);

            // save the info for binmode()
            fh.path = path;     // filename
            fh.mode = mode;     // \">\", \"+<\"
            fh.charset = charset;   // \"UTF-8\"

            // PlCORE.say(\"path \" + mode + \" \" + path.toString());
            if (mode.equals(\"<\") || mode.equals(\"\")) {
                fh.reader = Files.newBufferedReader(path, Charset.forName(charset));
                fh.outputStream = null;
            }
            else if (mode.equals(\">\")) {
                fh.reader = null;
                fh.outputStream = Files.newOutputStream(path, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE);
            }
            else if (mode.equals(\">>\")) {
                fh.reader = null;
                fh.outputStream = Files.newOutputStream(path, StandardOpenOption.CREATE, StandardOpenOption.APPEND, StandardOpenOption.WRITE);
            }
            else if (mode.equals(\"+<\")) {
                // read/write
                // TODO - share the IO buffer for reads and writes
                fh.reader = Files.newBufferedReader(path, Charset.forName(charset));
                PlCORE.die(\"TODO - not implemented: open() mode '\" + mode + \"'\");
            }
            else if (mode.equals(\"+>\")) {
                // read/write, truncate first
                // TODO - share the IO buffer for reads and writes
                fh.reader = Files.newBufferedReader(path, Charset.forName(charset));
                PlCORE.die(\"TODO - not implemented: open() mode '\" + mode + \"'\");
            }
            else if (mode.equals(\"<-\")) {
                //   In the two-argument (and one-argument) form, opening \"<-\" or
                //   \"-\" opens STDIN and opening \">-\" opens STDOUT.
                PlCORE.die(\"TODO - not implemented: open() mode '\" + mode + \"'\");
            }
            else if (mode.equals(\">-\")) {
                //   In the two-argument (and one-argument) form, opening \"<-\" or
                //   \"-\" opens STDIN and opening \">-\" opens STDOUT.
                PlCORE.die(\"TODO - not implemented: open() mode '\" + mode + \"'\");
            }
            else if (mode.equals(\"|-\")) {
                //   For three or more arguments if MODE is \"|-\", the filename is
                //   interpreted as a command to which output is to be piped, and if
                //   MODE is \"-|\", the filename is interpreted as a command that
                //   pipes output to us.  In the two-argument (and one-argument)
                //   form, one should replace dash (\"-\") with the command.  See
                //   \"Using open() for IPC\" in perlipc for more examples of this.
                PlCORE.die(\"TODO - not implemented: open() mode '\" + mode + \"'\");
            }
            else if (mode.equals(\"-|\")) {
                //   For three or more arguments if MODE is \"|-\", the filename is
                //   interpreted as a command to which output is to be piped, and if
                //   MODE is \"-|\", the filename is interpreted as a command that
                //   pipes output to us.  In the two-argument (and one-argument)
                //   form, one should replace dash (\"-\") with the command.  See
                //   \"Using open() for IPC\" in perlipc for more examples of this.
                PlCORE.die(\"TODO - not implemented: open() mode '\" + mode + \"'\");
            }
            else {
                PlCORE.die(\"TODO - not implemented: open() mode '\" + mode + \"'\");
            }
            path = path.toRealPath();
            // PlCORE.say(\"path \" + mode + \" \" + path.toString());

            // success
            return PlCx.INT1;
        }
        catch(NoSuchFileException e) {
            PlV.sset(\"main::!\", new PlString(\"No such file or directory\"));
        }
        catch(Exception e) {
            PlV.sset(\"main::!\", new PlStringLazyError(e));
        }
        return PlCx.UNDEF;
"), "close", ("        try {
            fh.close();

            // success
            return PlCx.INT1;
        }
        catch(IOException e) {
            PlV.sset(\"main::!\", new PlStringLazyError(e));
        }
        return PlCx.UNDEF;
"), "binmode", ("        String layer;
        int arg_count = List__.length_of_array_int();
        if (arg_count == 0) {
            // layer = \":raw\";
            fh.binmode = true;
            return PlCx.INT1;
        }
        else {
            layer = List__.aget(0).toString();
        }
        return PlCORE.open(want, fh, new PlArray(
            new PlString(fh.mode + layer),
            new PlString(fh.path.toString()) 
        ));
"), "opendir", ("        try {
            String s = List__.aget(0).toString();
            Path path = PlV.path.resolve(s).toRealPath();

            fh.directoryStream = Files.newDirectoryStream(path);
            fh.directoryIterator = fh.directoryStream.iterator();

            // success
            return PlCx.INT1;
        }
        catch(IOException e) {
            PlV.sset(\"main::!\", new PlStringLazyError(e));
        }
        return PlCx.UNDEF;
"), "readdir", ("        Iterator<Path> iter = fh.directoryIterator;
        if (want == PlCx.LIST) {
            // read all lines
            PlArray res = new PlArray();
            while (iter.hasNext()) {
                res.push_void(new PlString(iter.next().getFileName().toString()));
            }
            res.push_void(new PlString(\".\"));
            res.push_void(new PlString(\"..\"));
            return res;
        }
        if (!iter.hasNext()) {
            return PlCx.UNDEF;
        }
        Path entry = iter.next();
        return new PlString(entry.getFileName().toString());
"), "closedir", ("        try {
            fh.readlineBuffer = new StringBuilder();
            fh.flush();
            fh.eof = true;
            if (fh.directoryStream != null) {
                fh.directoryStream.close();
            }
        }
        catch(IOException e) {
            PlV.sset(\"main::!\", new PlStringLazyError(e));
            return PlCx.UNDEF;
        }
        return PlCx.INT1;
"), "syswrite", ("        int argCount = List__.to_int();
        if (argCount < 1) {
            PlCORE.die(\"Not enough arguments for syswrite\");
        }
        PlObject st = PlCx.EMPTY;
        if (argCount == 1) {
            st = List__.aget(0);
        }
        else if (argCount == 2) {
            // syswrite(FILEHANDLE,SCALAR,LENGTH)
            st = List__.aget(0).substr(0, List__.aget(1).to_int());
        }
        else {
            // syswrite(FILEHANDLE,SCALAR,LENGTH,OFFSET)
            st = List__.aget(0).substr(List__.aget(2).to_int(), List__.aget(1).to_int());
        }
        int count = 0;
        try {
            String s = st.toString();

            if (fh.binmode) {
                for (int i = 0; i < s.length(); i++) {
                    fh.outputStream.write(s.charAt(i));
                    count++;
                }
            }
            else {
                byte[] bytes = s.getBytes(fh.charset);
                fh.outputStream.write(bytes);
                count += bytes.length;
            }
            fh.outputStream.flush();
        }
        catch(Exception e) {
            PlV.sset(\"main::!\", new PlStringLazyError(e));
        }
        return new PlInt(count);
"), "write", ("        return PlCORE.die(\"write() not implemented\");
"), "readline", ("        if (want == PlCx.LIST) {
            // read all lines
            PlArray res = new PlArray();
            PlObject s;
            while (!(s = PlCORE.readline(PlCx.SCALAR, fh, List__)).is_undef()) {
                res.push_void(s);
            }
            return res;
        }
        PlObject plsep = PlV.sget(\"main::/\");
        boolean slurp = false;
        if (plsep.is_undef()) {
            slurp = true;
        }
        if (fh.eof) {
            if (fh.is_argv) {
                // \"ARGV\" is special
                PlArray argv = PlV.array_get(\"main::ARGV\");
                PlFileHandle in = new PlFileHandle();
                if (argv.to_int() > 0) {
                    // arg list contains file name
                    PlCORE.open(PlCx.VOID, in, new PlArray(new PlString(\"<\"), argv.shift()));
                }
                else {
                    // read from STDIN
                    fh.is_argv = false;     // clear the magic bit
                    in  = PlV.STDIN;
                }
                fh.readlineBuffer   = in.readlineBuffer;
                fh.eof              = in.eof;
                fh.outputStream     = in.outputStream;
                fh.reader           = in.reader;
            }
            if (fh.eof) {
                return PlCx.UNDEF;
            }
        }
        String sep = plsep.toString();
        StringBuilder buf = fh.readlineBuffer;
        // read from filehandle until \"sep\" or eof()
        int pos = slurp ? -1 : buf.indexOf(sep);
        while (pos < 0 && !fh.eof) {
            // read more
            int len = 1000;
            char[] c = new char[len];
            int num_chars = 0;
            try {
                num_chars = fh.reader.read(c, 0, len);
                if (num_chars > 0) {
                    // TODO - use: new String(bytes,\"UTF-8\")
                    String s = new String(c, 0, num_chars);
                    buf.append(s);
                }
            }
            catch(IOException e) {
                PlV.sset(\"main::!\", new PlStringLazyError(e));
                return PlCx.UNDEF;
            }
            if (num_chars > 0) {
                if (!slurp) {
                    pos = buf.indexOf(sep);
                }
            }
            else {
                // eof
                fh.eof = true;
            }
        }
        String s;
        if (fh.eof || pos < 0) {
            s = buf.toString();
            fh.readlineBuffer = new StringBuilder();
            fh.eof = true;
            if (s.length() == 0) {
                return PlCx.UNDEF;
            }
        }
        else {
            pos += sep.length();
            s = buf.substring(0, pos);
            fh.readlineBuffer = new StringBuilder(buf.substring(pos));
        }
        return new PlString(s);
"), "getc", ("        PlLvalue buf = new PlLvalue();
        PlCORE.sysread(want, fh, PlArray.construct_list_of_aliases(buf, PlCx.INT1));
        return buf;
"), "read", ("        return PlCORE.sysread(want, fh, List__);
"), "sysread", ("        int leng = List__.aget(1).to_int();
        int ofs = List__.aget(2).to_int();

        if (fh.eof) {
            return PlCx.UNDEF;
        }
        StringBuilder buf = fh.readlineBuffer;
        // read from filehandle until \"len\"
        int pos = buf.length();
        while (pos < leng && !fh.eof) {
            // read more
            int len = 1000;
            char[] c = new char[len];
            int num_chars = 0;
            try {
                num_chars = fh.reader.read(c, 0, len);
                if (num_chars > 0) {
                    // TODO - use: new String(bytes,\"UTF-8\")
                    String s = new String(c, 0, num_chars);
                    buf.append(s);
                }
            }
            catch(IOException e) {
                PlV.sset(\"main::!\", new PlStringLazyError(e));
                return PlCx.UNDEF;
            }
            if (num_chars > 0) {
                pos = buf.length();
            }
            else {
                // eof
                fh.eof = true;
            }
        }
        String s;
        if (fh.eof || pos < leng) {
            s = buf.toString();
            fh.readlineBuffer = new StringBuilder();
            fh.eof = true;
            if (s.length() == 0) {
                return PlCx.UNDEF;
            }
        }
        else {
            s = buf.substring(0, leng);
            fh.readlineBuffer = new StringBuilder(buf.substring(leng));
        }

        leng = s.length();
        if (ofs == 0) {
            List__.aset(0, s);
        }
        else {
            die(\"TODO: sysread with OFFSET\");
        }
        return new PlInt(leng);
"), "seek", ("        int position = List__.aget(0).to_int();
        int whence   = List__.aget(1).to_int();
        try {

            // TODO - random access files, more tests
            // See: http://stackoverflow.com/questions/262618/java-bufferedreader-back-to-the-top-of-a-text-file

            // position = 0
            if (fh.reader == null) {
                PlV.sset(\"main::!\", new PlString(\"File is not open\"));
                return PlCx.UNDEF;
            }
            fh.reader.reset();
            fh.readlineBuffer = new StringBuilder();
            fh.eof = false;

            if (position > 0) {
                PlCORE.read(PlCx.VOID, fh, new PlArray(PlCx.UNDEF, new PlInt(position)));
            }

        }
        catch(IOException e) {
            PlV.sset(\"main::!\", new PlStringLazyError(e));
            return PlCx.UNDEF;
        }
        return PlCx.INT1;
"));
    sub Perlito5::Java::CORE::emit_java {;
        return ("
class PlCORE {
"), (map {;
            "    public static final PlObject " . $_ . "(int want, PlFileHandle fh, PlArray List__) {
" . $FileFunc{$_} . "    }
"
        } sort {;
            $a cmp $b
        } keys(%FileFunc)), ("
    public static final PlObject print(int want, PlFileHandle fh, String... args) {
        try {
            StringBuilder printBuffer = fh.printBuffer;
            for (String s : args) {
                printBuffer.append(s);
            }
            if (!PlV.Scalar_OUTPUT_RECORD_SEPARATOR.is_undef()) {
                printBuffer.append(PlV.Scalar_OUTPUT_RECORD_SEPARATOR.toString());
            }
            if (fh.output_autoflush) {
                // \$| autoflush is active
                fh.flush();
            }
            else {
                int s_length = printBuffer.length();
                if (s_length > 0) {
                    char cc = printBuffer.charAt(s_length-1);
                    if (cc == '\\n' || cc == '\\r') {
                        fh.flush();
                    }
                    else if (s_length > PlFileHandle.BUFFER_THRESHOLD) {
                        fh.flush();
                    }
                }
            }
            return PlCx.INT1;
        }
        catch(Exception e) {
            PlV.sset(\"main::!\", new PlStringLazyError(e));
            return PlCx.UNDEF;
        }
    }
    public static final PlObject say(int want, PlFileHandle fh, String... args) {
        PlObject sep = PlV.Scalar_OUTPUT_RECORD_SEPARATOR.get();
        PlV.Scalar_OUTPUT_RECORD_SEPARATOR.set(new PlString(\"\\n\"));
        PlObject ret = PlCORE.print(want, fh, args);
        PlV.Scalar_OUTPUT_RECORD_SEPARATOR.set(sep);
        return ret;
    }

"), ("
    // shortcut functions for internal use: say, warn, die
    public static final PlObject say(String s) {
        return PlCORE.say(PlCx.VOID, PlV.STDOUT, s);
    }
    public static final PlObject warn(String s) {
        return PlCORE.warn(PlCx.VOID, new PlArray(new PlString(s)));
    }
    public static final PlObject die(String s) {
        return PlCORE.die(PlCx.VOID, new PlArray(new PlString(s)));
    }
    public static final PlObject die(PlObject s) {
        return PlCORE.die(PlCx.VOID, new PlArray(s));
    }

    public static final PlObject mkdir(int want, PlArray List__) {
        try {
            Path path = PlV.path.resolve(List__.aget(0).toString());
            int mask = List__.aget(1).to_int();
            Set<PosixFilePermission> perms = PerlOp.MaskToPermissions(mask);
            FileAttribute<Set<PosixFilePermission>> attr = PosixFilePermissions.asFileAttribute(perms);
            Files.createDirectory(path, attr);
            return PlCx.INT1;
        }
        catch(IOException e) {
            PlV.sset(\"main::!\", new PlStringLazyError(e));
        }
        return PlCx.UNDEF;
    }
    public static final PlObject require(int want, PlObject file, boolean is_bareword) {
        // TODO - require-version
        if (is_bareword) {
            file = new PlString(\"Perlito5::Grammar::Use::modulename_to_filename\").apply(PlCx.SCALAR, new PlArray(file));
        }
        return new PlString(\"Perlito5::Grammar::Use::require\").apply(want, new PlArray(file));
    }
    public static final PlObject rmdir(int want, PlArray List__) {
        try {
            Path path = PlV.path.resolve(List__.aget(0).toString()).toRealPath();
            Files.delete(path);
            return PlCx.INT1;
        }
        catch(NoSuchFileException e) {
            PlV.sset(\"main::!\", new PlString(\"No such file or directory\"));
        }
        catch(DirectoryNotEmptyException e) {
            PlV.sset(\"main::!\", new PlString(\"Directory not empty\"));
        }
        catch(IOException e) {
            PlV.sset(\"main::!\", new PlStringLazyError(e));
        }
        return PlCx.UNDEF;
    }
    public static final PlObject chdir(int want, PlArray List__) {
        try {
            Path path = PlV.path.resolve(List__.aget(0).toString()).toRealPath();
            PlV.path = path;
            // TODO - test that the destination is a directory
            return PlCx.INT1;
        }
        catch(NoSuchFileException e) {
            PlV.sset(\"main::!\", new PlString(\"No such file or directory\"));
        }
        catch(DirectoryNotEmptyException e) {
            PlV.sset(\"main::!\", new PlString(\"Directory not empty\"));
        }
        catch(IOException e) {
            PlV.sset(\"main::!\", new PlStringLazyError(e));
        }
        return PlCx.UNDEF;
    }
    public static final PlObject unlink(int want, PlArray List__) {
        try {
            for (int i = 0; i < List__.to_int(); i++) {
                Path path = PlV.path.resolve(List__.aget(i).toString()).toRealPath();
                Files.delete(path);
            }
            return PlCx.INT1;
        }
        catch(NoSuchFileException e) {
            PlV.sset(\"main::!\", new PlString(\"No such file or directory\"));
        }
        catch(DirectoryNotEmptyException e) {
            PlV.sset(\"main::!\", new PlString(\"Directory not empty\"));
        }
        catch(IOException e) {
            PlV.sset(\"main::!\", new PlStringLazyError(e));
        }
        return PlCx.UNDEF;
    }
    public static final PlObject rename(int want, PlArray List__) {
        try {
            Files.move(
                PlV.path.resolve( List__.aget(0).toString() ),
                PlV.path.resolve( List__.aget(1).toString() ),
                java.nio.file.StandardCopyOption.REPLACE_EXISTING
            );
            return PlCx.INT1;
        }
        catch(NoSuchFileException e) {
            PlV.sset(\"main::!\", new PlString(\"No such file or directory\"));
        }
        catch(IOException e) {
            PlV.sset(\"main::!\", new PlStringLazyError(e));
        }
        return PlCx.UNDEF;
    }
    public static final PlObject lstat(int want, PlArray List__) {
        // TODO
        return PlCORE.stat(want, List__);
    }
    public static final PlObject stat(int want, PlArray List__) {
        // TODO - \"_\" filehandle
        PlArray res = new PlArray();
        PlObject arg = List__.aget(0);
        try {
            //     0 dev      device number of filesystem
            //     1 ino      inode number
            //     2 mode     file mode  (type and permissions)
            //     3 nlink    number of (hard) links to the file
            //     4 uid      numeric user ID of file's owner
            //     5 gid      numeric group ID of file's owner
            //     6 rdev     the device identifier (special files only)
            //     7 size     total size of file, in bytes
            //     8 atime    last access time in seconds since the epoch
            //     9 mtime    last modify time in seconds since the epoch
            //    10 ctime    inode change time in seconds since the epoch (*)
            //    11 blksize  preferred I/O size in bytes for interacting with the
            //                file (may vary from file to file)
            //    12 blocks   actual number of system-specific blocks allocated
            //                on disk (often, but not always, 512 bytes each)
            res.aset(7, PerlOp.p5size(arg));
            res.aset(9, PerlOp.p5mtime(arg));
            if (want == PlCx.SCALAR) {
                return PlCx.TRUE;
            }
            return res;
        }
        catch(Exception e) {
            PlV.sset(\"main::!\", new PlStringLazyError(e));
        }
        if (want == PlCx.SCALAR) {
            return PlCx.FALSE;
        }
        return res;
    }
    public static final PlObject select(PlFileHandle fh) {
        // select FILEHANDLE
        PlFileHandle fOld = PlV.STDOUT;
        PlV.STDOUT = fh;
        return fOld;
    }
    public static final PlObject select(int want, PlArray List__) {
        int arg_count = List__.length_of_array_int();
        if (arg_count == 0) {
            // Returns the currently selected filehandle
            return PlV.STDOUT;
        }
        if (arg_count == 4) {
            if (List__.aget(0).is_undef() && List__.aget(1).is_undef() && List__.aget(2).is_undef()) {
                // You can effect a sleep of 250 milliseconds this way: select(undef, undef, undef, 0.25);
                PlCORE.sleep(want, new PlArray(List__.aget(3)));
                return PlCx.INT0;
            }
        }
        return PlCORE.die(\"select() not implemented\");
    }
    public static final PlObject exit(int want, PlArray List__) {
        int arg = List__.aget(0).to_int();

        PlV.teardown();
        System.exit(arg);
        return PlCx.UNDEF;
    }
    public static final PlObject warn(int want, PlArray List__) {
        try {
            int arg_count = List__.length_of_array_int();
            if (arg_count == 0) {
                List__.push_void(\"Warning: something's wrong\");
            }
            if (arg_count != 1 || !List__.aget(0).is_ref()) {
                String s = List__.toString();
                int s_length = s.length();
                if (s_length > 0 && (s.charAt(s_length-1) == '\\n' || s.charAt(s_length-1) == '\\r')) {
                    // don't add file+line
                }
                else {
                    // TODO - add module name, line number
                    s = s + \" at \" + PlV.sget(\"main::0\") + \"\\n\";
                }
                List__.set(new PlArray(new PlString(s)));
            }
            if (PlV.hash_get(\"main::SIG\").hget(\"__WARN__\").is_coderef()) {
                // execute \$SIG{__WARN__}
                // localize \$SIG{__WARN__} during the call
                int tmp = PerlOp.local_length();
                PlObject c = PlV.hash_get(\"main::SIG\").hget(\"__WARN__\");
                PlV.hash_get(\"main::SIG\").hget_lvalue_local(\"__WARN__\");
                c.apply(want, List__);
                PerlOp.cleanup_local(tmp, PlCx.UNDEF);
            }
            else {
                String s = List__.toString();
                byte[] bytes = s.getBytes(PlV.STDERR.charset);
                PlV.STDERR.outputStream.write(bytes);
                PlV.STDERR.outputStream.flush();
            }
            return PlCx.INT1;
        }
        catch(Exception e) {
            PlV.sset(\"main::!\", new PlStringLazyError(e));
            return PlCx.UNDEF;
        }
    }
    public static final PlObject die(int want, PlArray List__) {
        int arg_count = List__.length_of_array_int();
        if (arg_count == 0) {
            List__.push_void(\"Died\");
        }
        if (arg_count != 1 || !List__.aget(0).is_ref()) {
            String s = List__.toString();
            int s_length = s.length();
            if (s_length > 0 && (s.charAt(s_length-1) == '\\n' || s.charAt(s_length-1) == '\\r')) {
                // don't add file+line
            }
            else {
                // TODO - add module name, line number
                s = s + \" at \" + PlV.sget(\"main::0\") + \"\\n\";
                // Java stack trace
                s = s + Arrays.toString(new Throwable().getStackTrace());
            }
            List__.set(new PlArray(new PlString(s)));
        }
        if (PlV.hash_get(\"main::SIG\").hget(\"__DIE__\").is_coderef()) {
            // execute \$SIG{__DIE__}
            // localize \$SIG{__DIE__} during the call
            int tmp = PerlOp.local_length();
            PlObject c = PlV.hash_get(\"main::SIG\").hget(\"__DIE__\");
            PlV.hash_get(\"main::SIG\").hget_lvalue_local(\"__DIE__\");
            c.apply(want, List__);
            PerlOp.cleanup_local(tmp, PlCx.UNDEF);
        }
        PlObject arg = List__.aget(0);
        throw new PlDieException(arg);
    }
    // public static final PlString ref(int want, PlArray List__) {
    //     return List__.aget(0).ref();
    // }
    public static final PlObject values(int want, PlObject List__) {
        return want == PlCx.LIST ? List__.values() : List__.values().scalar();
    }
    public static final PlObject keys(int want, PlObject List__) {
        return want == PlCx.LIST ? List__.keys() : List__.keys().scalar();
    }
    public static final PlObject each(int want, PlObject List__) {
        return want == PlCx.LIST ? List__.each() : List__.each().aget(0);
    }
    public static final PlObject chomp(int want, PlObject Object__) {
        String sep = PlV.sget(\"main::/\").toString();
        int sepSize = sep.length();
        int result = 0;
        String toChomp = Object__.toString();
        if(toChomp.substring(toChomp.length() - sepSize, toChomp.length()).equals(sep)) {
            toChomp = toChomp.substring(0, toChomp.length() - sepSize);
            result += sepSize;
        }

        Object__.set(new PlString(toChomp));
            
        return new PlInt(result);
    }
    public static final PlObject chomp(int want, PlArray List__) {
        int result = 0;
        for(int i = 0; i < List__.to_int(); ++i) {
            PlObject item = List__.aget_lvalue(i);
            result += chomp(want, item).to_int();
        }

        return new PlInt(result);
    }
    public static final PlString chop(int want, PlObject Object__) {
        String str = Object__.toString();
        String returnValue = \"\";
        if (str.length() > 0) {
            returnValue = str.substring(str.length() -1);
            Object__.set(new PlString(str.substring(0, str.length()-1)));
        }

        return new PlString(returnValue);
    }
    public static final PlObject chop(int want, PlArray List__) {
        PlString result = PlCx.EMPTY;
        for(int i = 0; i < List__.to_int(); ++i) {
            PlObject item = List__.aget_lvalue(i);
            result = chop(want, item);
        }

        return result;
    }
    public static final PlScalarImmutable scalar(int want, PlArray List__) {
        if (List__.to_int() == 0) {
            return PlCx.UNDEF;
        }
        return List__.aget(-1).scalar();
    }
    public static final PlObject splice(int want, PlArray List__) {
        PlArray res = new PlArray(List__);
        List__.a.clear();
        if (want == PlCx.LIST) {
            return res;
        }
        if (res.to_int() == 0) {
            return PlCx.UNDEF;
        }
        return res.aget(-1);
    }
    public static final PlObject split(int want, PlObject plReg, PlObject plArg, PlObject plCount) {
        if (want == PlCx.SCALAR) {
            return PlCORE.split(PlCx.LIST, plReg, plArg, plCount).length_of_array();
        }
        int limit = plCount.to_int();
        PlArray res = new PlArray();
        if (limit == 0) {

            // TODO - possible optimization for: split(\"\", \$str)
            // if (plReg.is_string() && plReg.toString().length() == 0) {
            //     // split \"\", \$string, 0
            //     return new PlArray(plArg.toString().toCharArray());
            // }

            // strip trailing empty strings and undef
            res = (PlArray)PlCORE.split(PlCx.LIST, plReg, plArg, PlCx.MIN1);
            while (res.to_int() > 0) {
                PlObject item = res.aget(-1);
                if (item.is_undef() || item.toString().length() == 0) {
                    res.pop();
                }
                else {
                    return res;
                }
            }
            return res;
        }
        String arg = plArg.toString();
        if (arg.length() == 0) {
            return res;
        }
        // make sure pattern is a RegExp
        if (plReg.is_lvalue()) {
            plReg = plReg.get();
        }

        // --- TODO ---

        if (!plReg.is_regex()) {
            String regs = plReg.toString();
            if (regs.equals(\" \")) {

                // ltrim
                int i = 0;
                while (i < arg.length() && Character.isWhitespace(arg.charAt(i))) {
                    i++;
                }
                if (i > 0) {
                    arg = arg.substring(i);
                }

                plReg = PlCx.SPLIT_SPACE;
            }
            else {
                plReg = new PlRegex(regs, Pattern.MULTILINE, false);
            }
        }

        Pattern pat = ((PlRegex)plReg).p;

        //      // make sure pattern is a RegExp
        //      if (typeof pattern === \"object\" && (pattern instanceof RegExp)) {
        //          pattern = pattern.source;
        //      }
        //      else {
        //          pattern = p5str(pattern);
        //          if (pattern == \" \") {
        //              // single space string is special
        //              pattern = \"(?: |\\t|\\n)+\";
        //              s = s.replace(/^(?: |\\t|\\n)+/, \"\");
        //          }
        //      }
        //      // add \"g\", \"m\" modifiers
        //      var flags = \"g\";
        //      if (pattern.substr(0, 1) == \"^\" || pattern.substr(-1,1) == \"\$\") {
        //          flags = flags + \"m\";
        //      }
        // --- /TODO ---

        int pos = 0;
        int next = pos;
        int count = 1;
        String cap;
        Matcher matcher = pat.matcher(arg).useTransparentBounds(true);
        while (pos < arg.length() && !(limit > 0 && count >= limit) && matcher.find(next)) {
            boolean matched = true;
            if (matcher.end() == pos) {
                // pointer didn't move
                next++;
                matched = matcher.find(next);
            }
            if (matched) {
                cap = arg.substring(pos, matcher.start());
                res.push_void(cap);
                pos = matcher.end();
                next = pos;
                // PlCORE.say(\"match: match [\" + cap + \"] next pos \" + pos);
                count++;
                for (int i = 1; i <= matcher.groupCount(); i++) {
                    cap = matcher.group(i);
                    if (cap == null) {
                        res.push_void(PlCx.UNDEF);
                    }
                    else {
                        res.push_void(cap);
                    }
                }
            }
        }
        if ( pos >= arg.length()) {
            cap = \"\";
        }
        else {
            cap = arg.substring(pos);
        }
        res.push_void(cap);
        return res;
    }
    public static final PlObject splice(int want, PlArray List__, PlObject offset) {
        int size = List__.to_int();
        int pos  = offset.to_int();
        if (pos < 0) {
            pos = List__.a.size() + pos;
        }
        if (pos < 0 || pos > List__.a.size()) {
            return PlCx.UNDEF;
        }
        PlArray res = new PlArray();
        for (int i = pos; i < size; i++) {
            res.unshift(List__.pop());
        }
        if (want == PlCx.LIST) {
            return res;
        }
        if (res.to_int() == 0) {
            return PlCx.UNDEF;
        }
        return res.aget(-1);
    }
    public static final PlObject splice(int want, PlArray List__, PlObject offset, PlObject length) {
        int size = List__.to_int();
        int pos  = offset.to_int();
        if (pos < 0) {
            pos = List__.a.size() + pos;
        }
        if (pos < 0 || pos > List__.a.size()) {
            return PlCx.UNDEF;
        }

        int last = length.to_int();
        if (last < 0) {
            last = List__.a.size() + last;
        }
        else {
            last = pos + last;
        }
        if (last < 0) {
            return PlCx.UNDEF;
        }
        if (last > size) {
            last = size;
        }

        int diff = last - pos;
        PlArray res = new PlArray();
        for (int i = pos; i < last; i++) {
            res.push_void(List__.a.get(i));
        }
        for (int i = pos; i < (size - diff); i++) {
            List__.a.set(i, List__.a.get(i+diff));
        }
        for (int i = 0; i < diff; i++) {
            List__.pop();
        }
        if (want == PlCx.LIST) {
            return res;
        }
        if (res.to_int() == 0) {
            return PlCx.UNDEF;
        }
        return res.aget(-1);
    }
    public static final PlObject splice(int want, PlArray List__, PlObject offset, PlObject length, PlArray list) {
        int size = List__.to_int();
        int pos  = offset.to_int();
        if (pos < 0) {
            pos = List__.a.size() + pos;
        }
        if (pos < 0 || pos > List__.a.size()) {
            return PlCx.UNDEF;
        }

        int last = length.to_int();
        if (last < 0) {
            last = List__.a.size() + last;
        }
        else {
            last = pos + last;
        }
        if (last < 0) {
            return PlCx.UNDEF;
        }
        if (last > size) {
            last = size;
        }

        int diff = last - pos;
        PlArray res = new PlArray();

        for (int i = pos; i < last; i++) {
            res.push_void(List__.a.get(i));
        }
        for (int i = pos; i < (size - diff); i++) {
            List__.a.set(i, List__.a.get(i+diff));
        }
        for (int i = 0; i < diff; i++) {
            List__.pop();
        }

        List__.a.addAll(pos, list.a);
        if (want == PlCx.LIST) {
            return res;
        }
        if (res.to_int() == 0) {
            return PlCx.UNDEF;
        }
        return res.aget(-1);
    }

"), ("
    public static final PlInt hex(int want, PlObject List__) {
        String s = List__.toString();

        final int length = s.length();
        int c;

        for (int i = 0; i < length; i++ ) {
            c = s.codePointAt(i);
            if (c > 254) {
                PlCORE.die(\"Wide character in hex\");
            }
        }

        if (s.startsWith(\"0x\") || s.startsWith(\"0X\")) {
            s = s.substring(2);
        }
        else if (s.startsWith(\"x\") || s.startsWith(\"X\")) {
            s = s.substring(1);
        }
        s = s.replace(\"_\",\"\");
        try {
            return new PlInt(Long.parseLong(s, 16));
        } catch (java.lang.NumberFormatException e) {
            // result = e.getMessage();
        }
        return new PlInt(0);
    }
    public static final PlInt oct(int want, PlObject List__) {
        String s = List__.toString();
        return new PlInt(PerlOp.oct(s));
    }
    public static final PlString sprintf(int want, PlObject List__) {
        String format = List__.aget(0).toString();
        // \"%3s\"
        int length = format.length();
        int offset = 0;
        int args_max = List__.to_int();
        int args_index = 0;
        Object args[] = new Object[args_max];
        String detail = \"\";
        int start_detail = -1;
        for ( ; offset < length; ) {
            int c = format.codePointAt(offset);
            switch (c) {
                case '%':
                    offset++;
                    boolean scanning = true;
                    start_detail = offset;
                    for ( ; offset < length && scanning ; ) {
                        c = format.codePointAt(offset);
                        switch (c) {
                            case '%':
                                scanning = false;
                                offset++;
                                break;
                            case 'v':
                                // TODO - format value like \"v1.v2.v3\"
                                // replace \"%v\" with \"%s\"
                                StringBuilder sbv = new StringBuilder();
                                if (offset > 0) {
                                    sbv.append(format.substring(0, offset));
                                }
                                sbv.append(\"s\");
                                if (offset + 1 < format.length()) {
                                    sbv.append(format.substring(offset + 1));
                                }
                                format = sbv.toString();
                                break;
                            case 'c': case 's': case 'd': case 'u': case 'o':
                            case 'x': case 'e': case 'f': case 'g':
                            case 'X': case 'E': case 'G': case 'b':
                            case 'B': case 'p': case 'n':
                            case 'i': case 'D': case 'U': case 'O': case 'F':
                                scanning = false;
                                switch (c) {
                                    case 's':
                                        args[args_index] = List__.aget(args_index+1).toString();
                                        break;
                                    case 'd': case 'o': case 'x': case 'X':
                                    case 'u': case 'b': case 'B': case 'p':
                                    case 'c':
                                        args[args_index] = List__.aget(args_index+1).to_long();

                                        if (c == 'u') {
                                            long arg = (long)(args[args_index]);
                                            arg = arg & 4294967295L; // 0xFFFFFFFF;
                                            args[args_index] = arg;
                                            StringBuilder sb = new StringBuilder();
                                            if (offset > 0) {
                                                sb.append(format.substring(0, offset));
                                            }
                                            sb.append(\"d\");
                                            if (offset + 1 < format.length()) {
                                                sb.append(format.substring(offset + 1));
                                            }
                                            format = sb.toString();
                                            //PlCORE.say(\"format [\" + format + \"]\");
                                        }

                                        break;
                                    case 'f': case 'e': case 'g':
                                    case 'E': case 'G':
                                        detail = format.substring(start_detail, offset);
                                        if (detail.equals(\".\") || detail.equals(\"+.\")) {
                                            StringBuilder sb = new StringBuilder();
                                            sb.append(format.substring(0, offset));
                                            sb.append(\"0\");
                                            sb.append(format.substring(offset));
                                            format = sb.toString();
                                        }
                                        args[args_index] = List__.aget(args_index+1).to_double();
                                        break;
                                    default:
                                        break;
                                }
                                args_index++;
                                if (args_index > args_max) {
                                    // panic
                                    offset = length;
                                }
                                offset++;
                                break;
                            default:
                                offset++;
                                break;
                        }
                    }
                    break;
                default:
                    offset++;
                    break;
            }
        }
        return new PlString(String.format(format, args));
    }
    public static final PlString crypt(int want, PlArray List__) {
        if(List__.to_int() < 2) {
            die(\"Not enough arguments for crypt\");
        }
        if(List__.to_int() > 2) {
            die(\"Too many arguments for crypt\");
        }
        String plainText = List__.shift().toString();
        String salt = List__.shift().toString();

        while(salt.length() < 2) {
            salt = salt.concat(\".\");
        }
        
        return new PlString(PlCrypt.crypt(salt, plainText));
    }
    public static final PlString join(int want, String s1, PlObject... args) {
        StringBuilder sb = new StringBuilder();
        boolean first = true;
        for (PlObject s : args) {
            if (s.is_hash()) {
                // \@x = %x;
                s = s.to_array();
            }
            if (s.is_array()) {
                // \@x = ( \@x, \@y );
                for (int i = 0; i < s.to_long(); i++) {
                    if (first)
                        first = false;
                    else
                        sb.append(s1);
                    sb.append(s.aget(i).toString());
                }
            }
            else {
                if (first)
                    first = false;
                else
                    sb.append(s1);
                sb.append(s.toString());
            }
        }
        return new PlString(sb.toString());
    }
    public static final PlObject reverse(int want, PlArray List__) {
        if (want == PlCx.LIST) {
            PlArray ret = PlArray.construct_list_of_aliases(List__);
            Collections.reverse(ret.a);
            return ret;
        }
        StringBuilder sb = new StringBuilder();
        if (List__.to_int() == 0) {
            sb.append( PlV.Scalar_ARG.get() );
        }
        else {
            for (int i = 0; i < List__.to_int(); i++) {
                sb.append( List__.aget(i).toString() );
            }
        }
        return new PlString(sb.reverse().toString());
    }
    public static final PlString fc(int want,  PlObject Object__) {
        return new PlString(Object__.toString().toLowerCase());
    }
    public static final PlObject pack(int want, PlArray List__) {
        String template = List__.shift().toString();
        StringBuilder result = new StringBuilder();

        // Character mode is the default unless the format string starts with \"U\"
        boolean characterMode = true;
        if (template.length() > 0 && template.charAt(0) == 'U') {
            characterMode = false;
        }

        for(int i = 0; i < template.length(); ++i) {
            int size;
            if (template.length() > (i+1) && template.charAt(i+1) == '*') {
                size = List__.to_int();
            }
            else {
                size = pack_size(template, i);
            }

            switch(template.charAt(i)) {
            case 'a':
            {
                result.append(pack_a(List__.shift().toString(), size));
                break;
            }
            case 'A':
            {    
                result.append(pack_A(List__.shift().toString(), size));
                break;
            }
            case 'Z':
            {
                result.append(pack_Z(List__.shift().toString(), size));
                break;
            }
            case 'b':
            {
                result.append(pack_b(List__.shift().toString(), size));
                break;
            }
            case 'B':
            {
                result.append(pack_B(List__.shift().toString(), size));
                break;
            }
            case 'h':
            {
                result.append(pack_h(List__.shift().toString(), size));
                break;
            }
            case 'H':
            {
                result.append(pack_H(List__.shift().toString(), size));
                break;        
            }
            case 'c':
            {
                result.append(pack_c(List__.shift().toString()));
                break;        
            }
            case 'C':
            {
                if (size == 0) {
                    // C0
                    characterMode = true;
                }
                for (int j = 0; j < size; j++) {
                    result.append(pack_C(List__.shift().toString()));
                }
                break;        
            }
            case 'W':
            {
                for (int j = 0; j < size; j++) {
                    result.appendCodePoint( List__.shift().to_int() );
                }
                break;        
            }
            case 'U':
            {
                if (size == 0) {
                    // U0
                    characterMode = false;
                }
                if (characterMode) {
                    // character mode C0
                    StringBuilder sb = new StringBuilder();
                    for (int j = 0; j < size; j++) {
                        sb.appendCodePoint( List__.shift().to_int() );
                    }
                    byte[] bytes = sb.toString().getBytes(PlCx.UTF8);
                    for (byte b : bytes) {
                        int ub = b < 0 ? 256 + b : b;
                        result.appendCodePoint(ub);
                    }
                }
                else {
                    // U0 mode
                    for (int j = 0; j < size; j++) {
                        result.appendCodePoint( List__.shift().to_int() );
                    }
                }
                break;        
            }
            case 's':
            {
                result.append(pack_s(List__.shift().to_int()));
                break;        
            }
            case 'S':
            {
                result.append(pack_S(List__.shift().to_int()));
                break;        
            }
            case 'l':
            {
                result.append(pack_l(List__.shift().to_int()));
                break;        
            }
            case 'L':
            {
                result.append(pack_L(List__.shift().to_int()));
                break;        
            }
            case 'q':
            {
                result.append(pack_q(List__.shift().to_int()));
                break;        
            }
            case 'Q':
            {
                result.append(pack_Q(List__.shift().to_int()));
                break;        
            }
            case 'i':
            {
                result.append(pack_i(List__.shift().to_int()));
                break;        
            }
            case 'I':
            {
                result.append(pack_I(List__.shift().to_int()));
                break;        
            }
            case 'n':
            {
                for (int j = 0; j < size; j++) {
                    result.append(pack_n(List__.shift().to_int()));
                }
                break;        
            }
            case 'N':
            {
                result.append(pack_N(List__.shift().to_int()));
                break;        
            }
            case 'v':   
            {
                for (int j = 0; j < size; j++) {
                    result.append(pack_v(List__.shift().to_int()));
                }
                break;        
            }
            case 'V':   
            {
                result.append(pack_V(List__.shift().to_int()));
                break;        
            }
            case 'j':   
            {
                result.append(pack_j(List__.shift().to_int()));
                break;        
            }
            case 'J':   
            {
                result.append(pack_J(List__.shift().to_int()));
                break;        
            }
            case 'f':
            {
                result.append(pack_f(List__.shift().to_double()));
                break;        
            }
            case 'd':
            case 'F':
            {
                result.append(pack_d(List__.shift().to_double()));
                break;        
            }
            case 'p':
            {
                for(int k = 0; k < size; ++k) {
                    PlObject o = List__.shift();
                    if(o.is_undef()) {
                        result.append(pack_q(0));
                    
                    } else {
                        result.append(pack_p(o.toString()));
                    }
                }
            }
            case 'u':
            {
                result.append(pack_u(List__.shift().toString()));
                break;
            }
            case 'w':
            {
                String[] input = new String[size];
                for(int j = 0; j < size; ++j) {
                    input[j] = List__.shift().toString();
                }
                result.append(pack_w(input, size));
                break;        
            }
            case 'x':
            {
                result.append(pack_x(size));
                break;        
            }
            case 'X':
            {
                int length = result.length();
                result.delete(Math.max(0,length - size), length);
                break;        
            }
            case '\@':
            {
                int length = result.length();
                if(size > length) {
                    result.append(new char[size - length]);
                }
                break;        
            }
            case '.':
            {
                int length = result.length();
                if(size > length) {
                    result.append(new char[size - length]);
                }
                break;        
            }
            default:
            }
        }

        return new PlString(result.toString());
    }
    public static final PlObject unpack(int want, PlArray List__) {
        String template = List__.aget(0).toString();
        String input = List__.aget(1).toString();
        PlArray result = new PlArray();
        int inputIndex = 0;

        // Character mode is the default unless the format string starts with \"U\"
        boolean characterMode = true;
        if (template.length() > 0 && template.charAt(0) == 'U') {
            characterMode = false;
        }

        for(int i = 0; i < template.length(); ++i) {
            int size;
            if (template.length() > (i+1) && template.charAt(i+1) == '*') {
                size = -1;
            }
            else {
                size = pack_size(template, i);
            }

            switch(template.charAt(i)) {
            case 'a':
            {
                // TODO
                // result.push_void(unpack_a(List__.shift().toString(), size));
                break;
            }
            case 'A':
            {
                // TODO
                // result.push_void(unpack_A(List__.shift().toString(), size));
                break;
            }
            case 'Z':
            {
                // TODO
                // result.push_void(unpack_Z(List__.shift().toString(), size));
                break;
            }
            case 'b':
            {
                // TODO
                // result.push_void(unpack_b(List__.shift().toString(), size));
                break;
            }

            case 'C':
            {
                if (size == 0) {
                    // C0
                    characterMode = true;
                }
                if (size < 0) {
                        while (inputIndex < input.length()) {
                            result.push_void( new PlInt( input.charAt(inputIndex++) & 0xFF ) );
                        }
                }
                else {
                    for (int j = 0; j < size; j++) {
                        if (inputIndex < input.length()) {
                            result.push_void( new PlInt( input.charAt(inputIndex++) & 0xFF ) );
                        }
                    }
                }
                break;        
            }
            case 'W':
            {
                // TODO
                // for (int j = 0; j < size; j++) {
                //     result.pushCodePoint( List__.shift().to_int() );
                // }
                break;        
            }
            case 'U':
            {
                if (size == 0) {
                    // U0
                    characterMode = false;
                    break;
                }
                if (characterMode) {
                    // character mode C0

                    if (inputIndex >= input.length()) {
                        break;
                    }

                    // decode from UTF-8 (\"bytes\") to internal representation
                    String s = input.substring(inputIndex);
                    char[] chars = s.toCharArray();
                    byte[] bytes = new byte[chars.length];
                    for (int j = 0; j < bytes.length; j++){
                        bytes[j] = (byte)(chars[j]);
                    }
                    String internal = new String(bytes, PlCx.UTF8);
                    int internalIndex = 0;
 
                    // unpack
                    StringBuilder sb = new StringBuilder();
                    if (size < 0) {
                            while (internalIndex < internal.length()) {
                                int ichar = internal.charAt(internalIndex++);
                                sb.appendCodePoint(ichar);
                                result.push_void( new PlInt(ichar) );
                            }
                    }
                    else {
                        for (int j = 0; j < size; j++) {
                            if (internalIndex < internal.length()) {
                                int ichar = internal.charAt(internalIndex++);
                                sb.appendCodePoint(ichar);
                                result.push_void( new PlInt(ichar) );
                            }
                        }
                    }

                    // move the input pointer by the number of \"bytes\" consumed (not chars)
                    byte[] bytesUsed = sb.toString().getBytes(PlCx.UTF8);
                    inputIndex += bytesUsed.length;

                    break;        
                }
                else {
                    // U0 mode
                    if (size < 0) {
                            while (inputIndex < input.length()) {
                                result.push_void( new PlInt( input.charAt(inputIndex++) ) );
                            }
                    }
                    else {
                        for (int j = 0; j < size; j++) {
                            if (inputIndex < input.length()) {
                                result.push_void( new PlInt( input.charAt(inputIndex++) ) );
                            }
                        }
                    }
                    break;        
                }
            }

            default:
            }
        }
        return result;
    }
    private static final int pack_size(String s, int pos) {
        int howMany = 0;
        while(s.length() > (pos + 1 + howMany) && java.lang.Character.isDigit(s.charAt(pos + 1 + howMany))) {
            ++howMany;
        }
        if(howMany != 0) {
            return java.lang.Integer.parseInt(s.substring(pos + 1, pos + 1 + howMany));
        }
        return 1;
    }
    private static final String pack_a(String s, int size) {
        if(s.length() >= size) {
            return s.substring(0,size);
        }
        String padding = new String(new char[size - s.length()]);
        return s + padding;    
    }
    private static final String unpack_a(String s, int size) {
        if(s.length() >= size) {
            return s.substring(0,size);
        }
        return s; 
    }
    private static final String pack_A(String s, int size) {
        if(s.length() >= size) {
            return s.substring(0,size);
        }
        String padding = new String(new char[size - s.length()]).replace('\\0', ' ');
        return s + padding;    
    }
    private static final String unpack_A(String s, int size) {
        if(s.length() >= size) {
            return s.substring(0,size);
        }
        return s; 
    }
    private static final String pack_Z(String s, int size) {
        s = s.substring(0, java.lang.Math.min(size - 1, s.length()));
        return s +  new String(new char[size - s.length()]);
    }
    private static final String unpack_Z(String s, int size) {
        if(s.length() >= size) {
            return s.substring(0,size);
        }
        return s; 
    }
    private static final String pack_b(String s, int size) {
        s = s.substring(0, Math.min(size, s.length()));
        int wanted8strings = (size + 7) / 8;
        s += new String(new char[(wanted8strings * 8) - s.length()]).replace('\\0', '0');
        StringBuilder input = new StringBuilder();
        for(int i = 0; i < s.length(); ++i) {
            if(s.codePointAt(i) % 2 == 1) {
                input.append(\"1\");
            }
            else {
                input.append(\"0\");
            }
        }
        StringBuilder result = new StringBuilder();
        s = input.toString();
        for(int i = 0; i < wanted8strings; ++i) {
            String part = s.substring(i * 8, i * 8 + 8);
            int first = java.lang.Integer.parseInt(new StringBuilder(part.substring(0,4)).reverse().toString(), 2);
            int second = java.lang.Integer.parseInt(new StringBuilder(part.substring(4,8)).reverse().toString(), 2);
            result.append(Character.toString((char)(first + second * 16)));
        }
        return result.toString();
    }
    private static final String unpack_b(String s, int size) {
        byte[] bytes = s.getBytes();
        StringBuilder result = new StringBuilder();
        byte mask = (byte)128;
        for(int i = 0; i < size; ++i) {
            byte b = bytes[i / 8];
            if((b & mask) > 0) {
                result.append(\"1\");
            } else {
                result.append(\"0\");
            }
            if(mask == 1) {
                mask = (byte)128;
            } else {
                mask /= 2;
            }
        }
        return result.toString();
    }
    private static final String pack_B(String s, int size) {
        s = s.substring(0, Math.min(size, s.length()));
        int wanted8strings = (size + 7) / 8;
        s += new String(new char[(wanted8strings * 8) - s.length()]).replace('\\0', '0');
        StringBuilder input = new StringBuilder();
        for(int i = 0; i < s.length(); ++i) {
            if(s.codePointAt(i) % 2 == 1) {
                input.append(\"1\");
            }
            else {
                input.append(\"0\");
            }
        }
        StringBuilder result = new StringBuilder();
        s = input.toString();
        for(int i = 0; i < wanted8strings; ++i) {
            String part = s.substring(i * 8, i * 8 + 8);
            int ascii = java.lang.Integer.parseInt(part, 2);
            result.append(Character.toString((char)ascii));
        }
        return result.toString();
    }
    private static final String pack_h(String s, int size) {
        int index  = 0;
        if(s.length() < size * 2) {
            s += new String(new char[size * 2 - s.length()]).replace('\\0', '0');
        }
        StringBuilder result = new StringBuilder();
        while(index < size) {
            String part = s.substring(index + 1, index + 2) + s.substring(index, index + 1);
            int ascii = java.lang.Integer.parseInt(part, 16);
            result.append(Character.toString((char)ascii));
            index += 2;
        }
        return result.toString();
    }
    private static final String pack_H(String s, int size) {
        int index  = 0;
        if(s.length() < size * 2) {
            s += new String(new char[size * 2 - s.length()]).replace('\\0', '0');
        }
        StringBuilder result = new StringBuilder();
        while(index < size) {
            String part = s.substring(index, index + 2);
            int ascii = java.lang.Integer.parseInt(part, 16);
            result.append(Character.toString((char)ascii));
            index += 2;
        }
        return result.toString();
    }
    private static String pack_c(String s) {
        try {
            int ascii = java.lang.Integer.parseInt(s) % 128;
            return Character.toString((char)ascii);
        } catch(Exception e) {
            return \"\";
        }
    }
    private static String pack_C(String s) {
        try {
            int ascii = (java.lang.Integer.parseInt(s) + 256) % 256;
            return Character.toString((char)ascii);
        } catch(Exception e) {
            return \"\";
        }
    }
    private static String pack_number_2_string(long value, int size, boolean signed) {
        StringBuilder result = new StringBuilder();
        for(int i = 0; i < size; ++i) {
            result.append((char)((value / (int)Math.pow(2,8*i)) % 256));
        }
        return result.toString();        
    }
    private static String pack_s(long s) {
        return pack_number_2_string(s, 2, true);
    }
    private static String pack_S(long s) {
        return pack_number_2_string(s, 2, false);
    }
    public static final String pack_l(long s) {
        return pack_number_2_string(s, 4, true);
    }
    public static final String pack_L(long s) {
        return pack_number_2_string(s, 4, false);
    }
    public static final String pack_q(long s) {
        return pack_number_2_string(s, 8, true);
    }
    public static final String pack_Q(long s) {
        return pack_number_2_string(s, 8, false);
    }
    public static final String pack_i(long s) {
        return pack_number_2_string(s, 4, true);
    }
    public static final String pack_I(long s) {
        return pack_number_2_string(s, 4, false);
    }
    public static final String pack_n(long s) {
        return new StringBuilder(pack_number_2_string(s, 2, false)).reverse().toString();
    }
    public static final String pack_N(long s) {
        return new StringBuilder(pack_number_2_string(s, 4, false)).reverse().toString();
    }
    public static final String pack_v(long s) {
        return pack_number_2_string(s, 2, false);
    }
    public static final String pack_V(long s) {
        return pack_number_2_string(s, 4, false);
    }
    public static final String pack_j(long s) {
        return pack_number_2_string(s, 8, true);
    }
    public static final String pack_J(long s) {
        return pack_number_2_string(s, 8, false);
    }
    public static final String pack_f(double d) {
        float f = (float)d;
        int intBits = java.lang.Float.floatToRawIntBits(f); 
        char one = (char)(intBits / (int)Math.pow(2, 24));
        char two = (char)((intBits / (int)Math.pow(2, 16)) % 256);
        char three = (char)((intBits / (int)Math.pow(2, 8)) % 256);
        char four = (char)(intBits % 256);
        StringBuilder result = new StringBuilder();
        result.append(Character.toString(four));
        result.append(Character.toString(three));
        result.append(Character.toString(two));
        result.append(Character.toString(one));
        return result.toString();        
    }
    public static final String pack_d(double d) {
        long intBits = java.lang.Double.doubleToRawLongBits(d);
        char one =  (char)(intBits / (long)Math.pow(2, 56));
        char two = (char)((intBits / (long)Math.pow(2, 48)) % 256);
        char three = (char)((intBits / (long)Math.pow(2, 40)) % 256);
        char four = (char)((intBits / (long)Math.pow(2, 32)) % 256);
        char five = (char)((intBits / (long)Math.pow(2, 24)) % 256);
        char six = (char)((intBits / (long)Math.pow(2, 16)) % 256);
        char seven = (char)((intBits / (long)Math.pow(2, 8)) % 256);
        char eight = (char)(intBits % 256);
        StringBuilder result = new StringBuilder();
        result.append(eight);
        result.append(seven);
        result.append(six);
        result.append(five);
        result.append(four);
        result.append(three);
        result.append(two);
        result.append(one);
        return result.toString();        
    }
    private static StringBuilder pack_pointers = new StringBuilder();
    private static Map<Long, Integer> pack_pointers_size = new HashMap<Long, Integer>();
    private static final long pack_pointers_magic_value = 654321;
    public static final String pack_p(String s) {
        long pointer = pack_pointers.length() + pack_pointers_magic_value;
        pack_pointers.append(s);

        pack_pointers_size.put(pointer, s.length());
        return pack_q((long)(pointer));
    }
    public static final String pack_u(String s) {
        int index = 0;
        StringBuilder result = new StringBuilder();
        StringBuilder line = new StringBuilder();
        int tooMany = 0;
        while(s.length() > index * 3) {
            String cur = s.substring(index * 3, Math.min(index * 3 + 3, s.length()));
            while(cur.length() < 3) {
                ++tooMany;
                cur += '\\0';
            }
            byte[] bytes = cur.getBytes();
            char value1 = (char)((bytes[0] >> 2) + 32);
            char value2 = (char)(((bytes[0] & 3) << 4) + (bytes[1] >> 4) + 32);
            char value3 = (char)(((bytes[1] & 15) << 2) + (bytes[2] >> 6) + 32);
            char value4 = (char)((bytes[2] & 63) + 32);

            line.append(value1);
            line.append(value2);
            line.append(value3);
            line.append(value4);
            
            if(line.length() == 60 && index != 0) {
                line.insert(0, (char)(32 + (45 - tooMany)));
                line.append(\"\\n\");
                result.append(line.toString());
                line = new StringBuilder();
            }
            ++index;
        }
        if(line.length() > 0) {
            line.insert(0, (char)(32 + ((index * 3 - tooMany) % 45)));
            line.append(\"\\n\");
            result.append(line);
        }

        return result.toString().replaceAll(\" \", \"`\");
    }
    public static final String pack_w(String[] s, int size) {
        java.math.BigInteger max_byte = new java.math.BigInteger(\"128\");
        StringBuilder result = new StringBuilder();
        for(int i = 0; i < size; ++i) {
            java.math.BigInteger current = new java.math.BigInteger(s[i]);
            if(current.signum() < 0) {
                throw new PlDieException(new PlString(\"Cannot compress negative numbers in pack\"));
            }
            while(current.compareTo(max_byte) > 0) {
                int part = current.mod(max_byte).intValue();
                result.append((char) (part + 128));
                current = current.divide(max_byte);
            }
            result.append((char)current.intValue());
        }

        return result.toString();
    }
    public static final String pack_x(int size) {
        return new String(new char[size]);
    }
    public static final PlObject times(int want, PlArray List__) {
        ThreadMXBean bean = ManagementFactory.getThreadMXBean( );
        long cpu = bean.isCurrentThreadCpuTimeSupported( ) ?
            bean.getCurrentThreadCpuTime( ) : 0L;
        long user = bean.isCurrentThreadCpuTimeSupported( ) ?
            bean.getCurrentThreadUserTime( ) : 0L;
        long system = cpu - user;
        return new PlArray(
            new PlDouble( user / 1000000000.0 ),
            new PlDouble( system / 1000000000.0 ),
            new PlDouble( 0.0 ),
            new PlDouble( 0.0 )
        );
    }
    public static final PlObject localtime(int want, PlArray List__) {
        PlArray res = new PlArray();
\x{9}\x{9}ZonedDateTime date;
        if (List__.to_boolean()) {
        \x{9}long arg = List__.aget(0).to_long();
            date = Instant.ofEpochSecond(arg).atZone(ZoneId.systemDefault());
        }
        else {
\x{9}\x{9}\x{9}date = ZonedDateTime.now();
        }
        if (want == PlCx.SCALAR) {
            return new PlString(date.format( DateTimeFormatter.RFC_1123_DATE_TIME ));
        }
        //      0    1    2     3     4    5     6     7     8
        //   (\$sec,\$min,\$hour,\$mday,\$mon,\$year,\$wday,\$yday,\$isdst)
\x{9}\x{9}res.push_void(date.getSecond());
\x{9}\x{9}res.push_void(date.getMinute());
\x{9}\x{9}res.push_void(date.getHour());
\x{9}\x{9}res.push_void(date.getDayOfMonth());
\x{9}\x{9}res.push_void(date.getMonth().getValue() - 1);
\x{9}\x{9}res.push_void(date.getYear() - 1900);
\x{9}\x{9}res.push_void(date.getDayOfWeek().getValue());
\x{9}\x{9}res.push_void(date.getDayOfYear() - 1);
\x{9}\x{9}res.push_void(
            date.getZone().getRules().isDaylightSavings(date.toInstant()) ? PlCx.INT1 : PlCx.INT0
        );
        return res;
    }
    public static final PlObject gmtime(int want, PlArray List__) {
        PlArray res = new PlArray();
\x{9}\x{9}ZonedDateTime date;
        if (List__.to_boolean()) {
        \x{9}long arg = List__.aget(0).to_long();
            date = Instant.ofEpochSecond(arg).atZone(ZoneId.of(\"UTC\"));
        }
        else {
\x{9}\x{9}\x{9}date = ZonedDateTime.now(ZoneOffset.UTC);
        }
        if (want == PlCx.SCALAR) {
            return new PlString(date.format( DateTimeFormatter.RFC_1123_DATE_TIME ));
        }
        //      0    1    2     3     4    5     6     7     8
        //   (\$sec,\$min,\$hour,\$mday,\$mon,\$year,\$wday,\$yday,\$isdst)
\x{9}\x{9}res.push_void(date.getSecond());
\x{9}\x{9}res.push_void(date.getMinute());
\x{9}\x{9}res.push_void(date.getHour());
\x{9}\x{9}res.push_void(date.getDayOfMonth());
\x{9}\x{9}res.push_void(date.getMonth().getValue() - 1);
\x{9}\x{9}res.push_void(date.getYear() - 1900);
\x{9}\x{9}res.push_void(date.getDayOfWeek().getValue());
\x{9}\x{9}res.push_void(date.getDayOfYear() - 1);
\x{9}\x{9}res.push_void(
            date.getZone().getRules().isDaylightSavings(date.toInstant()) ? PlCx.INT1 : PlCx.INT0
        );
        return res;
    }
    public static final PlInt time(int want, PlArray List__) {
        return new PlInt( (long)Math.floor(System.currentTimeMillis() * 0.001 + 0.5));
    }
    public static final PlDouble sleep(int want, PlArray List__) {
        long s = ((Double)(List__.shift().to_double() * 1000)).longValue();
        try {
            TimeUnit.MILLISECONDS.sleep(s);
        } catch (InterruptedException e) {
            //Handle exception
            PlCORE.die(\"interrupted\");
        }
        return new PlDouble(s / 1000.0);
    }
    public static final PlObject system(int want, PlArray List__) {
        // TODO - see perldoc -f system
        try {
            Process p;
            if (List__.to_int() > 1) {
                String[] args = new String[List__.to_int()];
                int i = 0;
                for (PlObject s : List__.a) {
                    args[i++] = s.toString();
                }
                p = Runtime.getRuntime().exec(args);
            }
            else {
                p = Runtime.getRuntime().exec(List__.aget(0).toString());
            }
            // String s = null;
            // BufferedReader stdInput = new BufferedReader(new InputStreamReader(p.getInputStream()));
            // BufferedReader stdError = new BufferedReader(new InputStreamReader(p.getErrorStream()));
            // System.out.println(\"STDOUT\\n\");
            // while ((s = stdInput.readLine()) != null) {
            //     System.out.println(\"  \" + s);
            // }
            // System.out.println(\"STDERR\\n\");
            // while ((s = stdError.readLine()) != null) {
            //     System.out.println(\"  \" + s);
            // }
            int ret = p.waitFor() * 256;
            PlV.sset(\"main::?\", new PlInt(ret));
            return new PlInt(ret);
        } catch (InterruptedException e) {
            //Handle exception
            return PlCORE.die(\"interrupted\");
        }
        catch (IOException e) {
            // System.out.println(\"IOexception: \");
            // e.printStackTrace();
            PlV.sset(\"main::!\", new PlStringLazyError(e));
            return PlCx.MIN1;
        }
    }
    public static final PlObject qx(int want, PlArray List__) {
        // TODO - see perldoc -f qx
        try {
            String[] args = new String[List__.to_int()];
            int i = 0;
            for (PlObject s : List__.a) {
                args[i++] = s.toString();
            }
            PlArray res = new PlArray();
            String s = null;
            Process p = Runtime.getRuntime().exec(args);
            // ??? set PlCx.UTF8
            BufferedReader stdInput = new BufferedReader(new InputStreamReader(p.getInputStream()));
            // System.out.println(\"STDOUT\\n\");
            while ((s = stdInput.readLine()) != null) {
                // System.out.println(\"  \" + s);
                res.push_void(s + \"\\n\");
            }
            // BufferedReader stdError = new BufferedReader(new InputStreamReader(p.getErrorStream()));
            // System.out.println(\"STDERR\\n\");
            // while ((s = stdError.readLine()) != null) {
            //     System.out.println(\"  \" + s);
            // }
            if (want == PlCx.LIST) {
                return res;
            }
            return PlCORE.join(want, \"\", res);
        }
        catch (IOException e) {
            // System.out.println(\"IOexception: \");
            // e.printStackTrace();
            return PlCx.UNDEF;
        }
    }
    public static final PlObject caller(int wantarray, PlArray List__) {
        PlObject arg = List__.aget(0);
        boolean argDefined = !arg.is_undef();
        int item = arg.to_int();

        PlArray callerName = PlV.array_get(\"Perlito5::CALLER\");
        if (callerName.length_of_array().to_boolean()) {
            // maybe we are inside an import() subroutine

            PlObject arr = callerName.aget(0);  // XXX this should be \"item\"
                                            // XXX FIXME TODO - workaround for \"export to level\"
            if (arr.is_arrayref()) {
                if (wantarray == PlCx.LIST) {
                    return arr.array_deref_strict();
                }
                return arr.aget(0);
            }
            // fallback to normal caller()
        };

        String fullName = \"\";

        // A StackTraceElement has getClassName(), getFileName(), getLineNumber() and getMethodName().
        // The last element of the array represents the bottom of the stack,
        // which is the least recent method invocation in the sequence.
        callerName = new PlArray();
        PlArray codeRef = new PlArray();
        Thread t = Thread.currentThread();
        StackTraceElement[] stackTraceElements = t.getStackTrace();
        for (StackTraceElement elem : stackTraceElements) {
            // PlCORE.say(
            //     elem.getClassName()  + \" \\t\" +
            //     elem.getMethodName() + \" \\t\" +
            //     elem.getFileName()   + \" \\t\" +
            //     elem.getLineNumber()
            // );
            if (elem.getMethodName().equals(\"apply\")) {
                // stack trace element comes from PlClosure.apply()
                // TODO - move this inner loop outside, this is very expensive
                // TODO - this code doesn't account for inner-subs - it might match an outer sub instead
                // TODO - this code doesn't account for package name changes inside a sub
                // TODO - this code skips anonymous subroutines
                // TODO - the \"perlSubName\" resolution is ambiguous,
                //        because a sub can be exported to several namespaces:
                //        Exporter::import and MyClass::import can point to the same Java code
                // this loop does a symbol table scan - PlV.cvar
              SCAN_SUBNAME:
                for (String name : PlStringConstant.constants.keySet()) {
                    PlObject value = PlV.cget_no_autoload(name);
                    if (value.is_lvalue()) {
                        value = value.get();
                    }
                    if (value.is_coderef()) {
                        PlClosure code = (PlClosure)value;
                        if ( code.javaClassName() != null &&
                             elem.getClassName().equals(code.javaClassName()) &&
                             elem.getLineNumber() > code.firstLineNumber() &&
                             elem.getLineNumber() < code.lastLineNumber() &&
                             !code.pkg_name.startsWith(\"Perlito5::\")
                        ) {
                            // PlCORE.say(
                            //     elem.getClassName()  + \" \\t\" +
                            //     elem.getMethodName() + \" \\t\" +
                            //     elem.getFileName()   + \" \\t\" +
                            //     elem.getLineNumber()
                            // );
                            // PlCORE.say(\"\\tPerl sub &\" + perlSubName.toString());
                            callerName.push_void(new PlString(name));
                            codeRef.push_void(value);
                            break SCAN_SUBNAME;
                        }
                    }
                }
            }
        }

        PlObject plCoderef = codeRef.aget(item);
        PlObject plCallerCoderef = codeRef.aget(item + 1);
        PlObject packageName = PlCx.UNDEF;
        if (plCallerCoderef.is_coderef()) {
            packageName = new PlString(((PlClosure)plCallerCoderef).pkg_name);
        }
        else if (plCoderef.is_coderef()) {
            packageName = new PlString(\"main\");
        }

        if (wantarray != PlCx.LIST) {
\x{9}\x{9}\x{9}// caller() in scalar or void context
            return packageName;
        }

        PlObject plFullName = callerName.aget(item);    // \"subroutine\" comes from the current level
        PlObject lineNumber = PlCx.UNDEF;
        String fileName = \"\";
        if (plCoderef.is_coderef()) {
            lineNumber = new PlInt(((PlClosure)plCoderef).perlLineNumber());
            fileName   = ((PlClosure)plCoderef).perlFileName();
        }


        if (!argDefined) {
\x{9}\x{9}\x{9}// caller() in list context, without args
            return new PlArray( packageName, new PlString(fileName), lineNumber );
        }

\x{9}\x{9}// caller(EXPR) in list context, with args
        // TODO - add other components
        //   #  0         1          2      3            4
        //   (\$package, \$filename, \$line, \$subroutine, \$hasargs,
        //   #  5          6          7            8       9         10
        //   \$wantarray, \$evaltext, \$is_require, \$hints, \$bitmask, \$hinthash)
        return new PlArray( packageName, new PlString(fileName), lineNumber, plFullName );
    }
}

")
    }
    1
}
{
    package main;
    package Perlito5::Java::Crypt;
    sub Perlito5::Java::Crypt::emit_java {;
        return ("
/****************************************************************************
 * Java-based implementation of the unix crypt(3) command
 *
 * Based upon C source code written by Eric Young, eay\@psych.uq.oz.au
 * Java conversion by John F. Dumas, jdumas\@zgs.com
 *
 * Found at http://locutus.kingwoodcable.com/jfd/crypt.html
 * Found at http://cseweb.ucsd.edu/classes/sp12/cse130-a/static/pa5/Crypt.java
 * Minor optimizations by Wes Biggs, wes\@cacas.org
 *
 * Eric's original code is licensed under the BSD license.  As this is
 * derivative, the same license applies.
 *
 * Note: Crypt.class is much smaller when compiled with javac -O
 ****************************************************************************/

class PlCrypt {
  private PlCrypt() {} // defined so class can't be instantiated.

  private static final int ITERATIONS = 16;

  private static final boolean shifts2[] = {
    false, false, true, true, true, true, true, true,
    false, true,  true, true, true, true, true, false
  };

  private static final int skb[][] = {
    {
      /* for C bits (numbered as per FIPS 46) 1 2 3 4 5 6 */
      0x00000000, 0x00000010, 0x20000000, 0x20000010, 
      0x00010000, 0x00010010, 0x20010000, 0x20010010, 
      0x00000800, 0x00000810, 0x20000800, 0x20000810, 
      0x00010800, 0x00010810, 0x20010800, 0x20010810, 
      0x00000020, 0x00000030, 0x20000020, 0x20000030, 
      0x00010020, 0x00010030, 0x20010020, 0x20010030, 
      0x00000820, 0x00000830, 0x20000820, 0x20000830, 
      0x00010820, 0x00010830, 0x20010820, 0x20010830, 
      0x00080000, 0x00080010, 0x20080000, 0x20080010, 
      0x00090000, 0x00090010, 0x20090000, 0x20090010, 
      0x00080800, 0x00080810, 0x20080800, 0x20080810, 
      0x00090800, 0x00090810, 0x20090800, 0x20090810, 
      0x00080020, 0x00080030, 0x20080020, 0x20080030, 
      0x00090020, 0x00090030, 0x20090020, 0x20090030, 
      0x00080820, 0x00080830, 0x20080820, 0x20080830, 
      0x00090820, 0x00090830, 0x20090820, 0x20090830, 
    },
    {
      /* for C bits (numbered as per FIPS 46) 7 8 10 11 12 13 */
      0x00000000, 0x02000000, 0x00002000, 0x02002000, 
      0x00200000, 0x02200000, 0x00202000, 0x02202000, 
      0x00000004, 0x02000004, 0x00002004, 0x02002004, 
      0x00200004, 0x02200004, 0x00202004, 0x02202004, 
      0x00000400, 0x02000400, 0x00002400, 0x02002400, 
      0x00200400, 0x02200400, 0x00202400, 0x02202400, 
      0x00000404, 0x02000404, 0x00002404, 0x02002404, 
      0x00200404, 0x02200404, 0x00202404, 0x02202404, 
      0x10000000, 0x12000000, 0x10002000, 0x12002000, 
      0x10200000, 0x12200000, 0x10202000, 0x12202000, 
      0x10000004, 0x12000004, 0x10002004, 0x12002004, 
      0x10200004, 0x12200004, 0x10202004, 0x12202004, 
      0x10000400, 0x12000400, 0x10002400, 0x12002400, 
      0x10200400, 0x12200400, 0x10202400, 0x12202400, 
      0x10000404, 0x12000404, 0x10002404, 0x12002404, 
      0x10200404, 0x12200404, 0x10202404, 0x12202404, 
    },
    {
      /* for C bits (numbered as per FIPS 46) 14 15 16 17 19 20 */
      0x00000000, 0x00000001, 0x00040000, 0x00040001, 
      0x01000000, 0x01000001, 0x01040000, 0x01040001, 
      0x00000002, 0x00000003, 0x00040002, 0x00040003, 
      0x01000002, 0x01000003, 0x01040002, 0x01040003, 
      0x00000200, 0x00000201, 0x00040200, 0x00040201, 
      0x01000200, 0x01000201, 0x01040200, 0x01040201, 
      0x00000202, 0x00000203, 0x00040202, 0x00040203, 
      0x01000202, 0x01000203, 0x01040202, 0x01040203, 
      0x08000000, 0x08000001, 0x08040000, 0x08040001, 
      0x09000000, 0x09000001, 0x09040000, 0x09040001, 
      0x08000002, 0x08000003, 0x08040002, 0x08040003, 
      0x09000002, 0x09000003, 0x09040002, 0x09040003, 
      0x08000200, 0x08000201, 0x08040200, 0x08040201, 
      0x09000200, 0x09000201, 0x09040200, 0x09040201, 
      0x08000202, 0x08000203, 0x08040202, 0x08040203, 
      0x09000202, 0x09000203, 0x09040202, 0x09040203, 
    },
    {
      /* for C bits (numbered as per FIPS 46) 21 23 24 26 27 28 */
      0x00000000, 0x00100000, 0x00000100, 0x00100100, 
      0x00000008, 0x00100008, 0x00000108, 0x00100108, 
      0x00001000, 0x00101000, 0x00001100, 0x00101100, 
      0x00001008, 0x00101008, 0x00001108, 0x00101108, 
      0x04000000, 0x04100000, 0x04000100, 0x04100100, 
      0x04000008, 0x04100008, 0x04000108, 0x04100108, 
      0x04001000, 0x04101000, 0x04001100, 0x04101100, 
      0x04001008, 0x04101008, 0x04001108, 0x04101108, 
      0x00020000, 0x00120000, 0x00020100, 0x00120100, 
      0x00020008, 0x00120008, 0x00020108, 0x00120108, 
      0x00021000, 0x00121000, 0x00021100, 0x00121100, 
      0x00021008, 0x00121008, 0x00021108, 0x00121108, 
      0x04020000, 0x04120000, 0x04020100, 0x04120100, 
      0x04020008, 0x04120008, 0x04020108, 0x04120108, 
      0x04021000, 0x04121000, 0x04021100, 0x04121100, 
      0x04021008, 0x04121008, 0x04021108, 0x04121108, 
    },
    {
      /* for D bits (numbered as per FIPS 46) 1 2 3 4 5 6 */
      0x00000000, 0x10000000, 0x00010000, 0x10010000, 
      0x00000004, 0x10000004, 0x00010004, 0x10010004, 
      0x20000000, 0x30000000, 0x20010000, 0x30010000, 
      0x20000004, 0x30000004, 0x20010004, 0x30010004, 
      0x00100000, 0x10100000, 0x00110000, 0x10110000, 
      0x00100004, 0x10100004, 0x00110004, 0x10110004, 
      0x20100000, 0x30100000, 0x20110000, 0x30110000, 
      0x20100004, 0x30100004, 0x20110004, 0x30110004, 
      0x00001000, 0x10001000, 0x00011000, 0x10011000, 
      0x00001004, 0x10001004, 0x00011004, 0x10011004, 
      0x20001000, 0x30001000, 0x20011000, 0x30011000, 
      0x20001004, 0x30001004, 0x20011004, 0x30011004, 
      0x00101000, 0x10101000, 0x00111000, 0x10111000, 
      0x00101004, 0x10101004, 0x00111004, 0x10111004, 
      0x20101000, 0x30101000, 0x20111000, 0x30111000, 
      0x20101004, 0x30101004, 0x20111004, 0x30111004, 
    },
    {
      /* for D bits (numbered as per FIPS 46) 8 9 11 12 13 14 */
      0x00000000, 0x08000000, 0x00000008, 0x08000008, 
      0x00000400, 0x08000400, 0x00000408, 0x08000408, 
      0x00020000, 0x08020000, 0x00020008, 0x08020008, 
      0x00020400, 0x08020400, 0x00020408, 0x08020408, 
      0x00000001, 0x08000001, 0x00000009, 0x08000009, 
      0x00000401, 0x08000401, 0x00000409, 0x08000409, 
      0x00020001, 0x08020001, 0x00020009, 0x08020009, 
      0x00020401, 0x08020401, 0x00020409, 0x08020409, 
      0x02000000, 0x0A000000, 0x02000008, 0x0A000008, 
      0x02000400, 0x0A000400, 0x02000408, 0x0A000408, 
      0x02020000, 0x0A020000, 0x02020008, 0x0A020008, 
      0x02020400, 0x0A020400, 0x02020408, 0x0A020408, 
      0x02000001, 0x0A000001, 0x02000009, 0x0A000009, 
      0x02000401, 0x0A000401, 0x02000409, 0x0A000409, 
      0x02020001, 0x0A020001, 0x02020009, 0x0A020009, 
      0x02020401, 0x0A020401, 0x02020409, 0x0A020409, 
    },
    {
      /* for D bits (numbered as per FIPS 46) 16 17 18 19 20 21 */
      0x00000000, 0x00000100, 0x00080000, 0x00080100, 
      0x01000000, 0x01000100, 0x01080000, 0x01080100, 
      0x00000010, 0x00000110, 0x00080010, 0x00080110, 
      0x01000010, 0x01000110, 0x01080010, 0x01080110, 
      0x00200000, 0x00200100, 0x00280000, 0x00280100, 
      0x01200000, 0x01200100, 0x01280000, 0x01280100, 
      0x00200010, 0x00200110, 0x00280010, 0x00280110, 
      0x01200010, 0x01200110, 0x01280010, 0x01280110, 
      0x00000200, 0x00000300, 0x00080200, 0x00080300, 
      0x01000200, 0x01000300, 0x01080200, 0x01080300, 
      0x00000210, 0x00000310, 0x00080210, 0x00080310, 
      0x01000210, 0x01000310, 0x01080210, 0x01080310, 
      0x00200200, 0x00200300, 0x00280200, 0x00280300, 
      0x01200200, 0x01200300, 0x01280200, 0x01280300, 
      0x00200210, 0x00200310, 0x00280210, 0x00280310, 
      0x01200210, 0x01200310, 0x01280210, 0x01280310, 
    },
    {
      /* for D bits (numbered as per FIPS 46) 22 23 24 25 27 28 */
      0x00000000, 0x04000000, 0x00040000, 0x04040000, 
      0x00000002, 0x04000002, 0x00040002, 0x04040002, 
      0x00002000, 0x04002000, 0x00042000, 0x04042000, 
      0x00002002, 0x04002002, 0x00042002, 0x04042002, 
      0x00000020, 0x04000020, 0x00040020, 0x04040020, 
      0x00000022, 0x04000022, 0x00040022, 0x04040022, 
      0x00002020, 0x04002020, 0x00042020, 0x04042020, 
      0x00002022, 0x04002022, 0x00042022, 0x04042022, 
      0x00000800, 0x04000800, 0x00040800, 0x04040800, 
      0x00000802, 0x04000802, 0x00040802, 0x04040802, 
      0x00002800, 0x04002800, 0x00042800, 0x04042800, 
      0x00002802, 0x04002802, 0x00042802, 0x04042802, 
      0x00000820, 0x04000820, 0x00040820, 0x04040820, 
      0x00000822, 0x04000822, 0x00040822, 0x04040822, 
      0x00002820, 0x04002820, 0x00042820, 0x04042820, 
      0x00002822, 0x04002822, 0x00042822, 0x04042822, 
    }
  };
  
  private static final int SPtrans[][] = {
    {
      /* nibble 0 */
      0x00820200, 0x00020000, 0x80800000, 0x80820200,
      0x00800000, 0x80020200, 0x80020000, 0x80800000,
      0x80020200, 0x00820200, 0x00820000, 0x80000200,
      0x80800200, 0x00800000, 0x00000000, 0x80020000,
      0x00020000, 0x80000000, 0x00800200, 0x00020200,
      0x80820200, 0x00820000, 0x80000200, 0x00800200,
      0x80000000, 0x00000200, 0x00020200, 0x80820000,
      0x00000200, 0x80800200, 0x80820000, 0x00000000,
      0x00000000, 0x80820200, 0x00800200, 0x80020000,
      0x00820200, 0x00020000, 0x80000200, 0x00800200,
      0x80820000, 0x00000200, 0x00020200, 0x80800000,
      0x80020200, 0x80000000, 0x80800000, 0x00820000,
      0x80820200, 0x00020200, 0x00820000, 0x80800200,
      0x00800000, 0x80000200, 0x80020000, 0x00000000,
      0x00020000, 0x00800000, 0x80800200, 0x00820200,
      0x80000000, 0x80820000, 0x00000200, 0x80020200,
    },
    {
      /* nibble 1 */
      0x10042004, 0x00000000, 0x00042000, 0x10040000,
      0x10000004, 0x00002004, 0x10002000, 0x00042000,
      0x00002000, 0x10040004, 0x00000004, 0x10002000,
      0x00040004, 0x10042000, 0x10040000, 0x00000004,
      0x00040000, 0x10002004, 0x10040004, 0x00002000,
      0x00042004, 0x10000000, 0x00000000, 0x00040004,
      0x10002004, 0x00042004, 0x10042000, 0x10000004,
      0x10000000, 0x00040000, 0x00002004, 0x10042004,
      0x00040004, 0x10042000, 0x10002000, 0x00042004,
      0x10042004, 0x00040004, 0x10000004, 0x00000000,
      0x10000000, 0x00002004, 0x00040000, 0x10040004,
      0x00002000, 0x10000000, 0x00042004, 0x10002004,
      0x10042000, 0x00002000, 0x00000000, 0x10000004,
      0x00000004, 0x10042004, 0x00042000, 0x10040000,
      0x10040004, 0x00040000, 0x00002004, 0x10002000,
      0x10002004, 0x00000004, 0x10040000, 0x00042000,
    },
    {
      /* nibble 2 */
      0x41000000, 0x01010040, 0x00000040, 0x41000040,
      0x40010000, 0x01000000, 0x41000040, 0x00010040,
      0x01000040, 0x00010000, 0x01010000, 0x40000000,
      0x41010040, 0x40000040, 0x40000000, 0x41010000,
      0x00000000, 0x40010000, 0x01010040, 0x00000040,
      0x40000040, 0x41010040, 0x00010000, 0x41000000,
      0x41010000, 0x01000040, 0x40010040, 0x01010000,
      0x00010040, 0x00000000, 0x01000000, 0x40010040,
      0x01010040, 0x00000040, 0x40000000, 0x00010000,
      0x40000040, 0x40010000, 0x01010000, 0x41000040,
      0x00000000, 0x01010040, 0x00010040, 0x41010000,
      0x40010000, 0x01000000, 0x41010040, 0x40000000,
      0x40010040, 0x41000000, 0x01000000, 0x41010040,
      0x00010000, 0x01000040, 0x41000040, 0x00010040,
      0x01000040, 0x00000000, 0x41010000, 0x40000040,
      0x41000000, 0x40010040, 0x00000040, 0x01010000,
    },
    {
      /* nibble 3 */
      0x00100402, 0x04000400, 0x00000002, 0x04100402,
      0x00000000, 0x04100000, 0x04000402, 0x00100002,
      0x04100400, 0x04000002, 0x04000000, 0x00000402,
      0x04000002, 0x00100402, 0x00100000, 0x04000000,
      0x04100002, 0x00100400, 0x00000400, 0x00000002,
      0x00100400, 0x04000402, 0x04100000, 0x00000400,
      0x00000402, 0x00000000, 0x00100002, 0x04100400,
      0x04000400, 0x04100002, 0x04100402, 0x00100000,
      0x04100002, 0x00000402, 0x00100000, 0x04000002,
      0x00100400, 0x04000400, 0x00000002, 0x04100000,
      0x04000402, 0x00000000, 0x00000400, 0x00100002,
      0x00000000, 0x04100002, 0x04100400, 0x00000400,
      0x04000000, 0x04100402, 0x00100402, 0x00100000,
      0x04100402, 0x00000002, 0x04000400, 0x00100402,
      0x00100002, 0x00100400, 0x04100000, 0x04000402,
      0x00000402, 0x04000000, 0x04000002, 0x04100400,
    },
    {
      /* nibble 4 */
      0x02000000, 0x00004000, 0x00000100, 0x02004108,
      0x02004008, 0x02000100, 0x00004108, 0x02004000,
      0x00004000, 0x00000008, 0x02000008, 0x00004100,
      0x02000108, 0x02004008, 0x02004100, 0x00000000,
      0x00004100, 0x02000000, 0x00004008, 0x00000108,
      0x02000100, 0x00004108, 0x00000000, 0x02000008,
      0x00000008, 0x02000108, 0x02004108, 0x00004008,
      0x02004000, 0x00000100, 0x00000108, 0x02004100,
      0x02004100, 0x02000108, 0x00004008, 0x02004000,
      0x00004000, 0x00000008, 0x02000008, 0x02000100,
      0x02000000, 0x00004100, 0x02004108, 0x00000000,
      0x00004108, 0x02000000, 0x00000100, 0x00004008,
      0x02000108, 0x00000100, 0x00000000, 0x02004108,
      0x02004008, 0x02004100, 0x00000108, 0x00004000,
      0x00004100, 0x02004008, 0x02000100, 0x00000108,
      0x00000008, 0x00004108, 0x02004000, 0x02000008,
    },
    {
      /* nibble 5 */
      0x20000010, 0x00080010, 0x00000000, 0x20080800,
      0x00080010, 0x00000800, 0x20000810, 0x00080000,
      0x00000810, 0x20080810, 0x00080800, 0x20000000,
      0x20000800, 0x20000010, 0x20080000, 0x00080810,
      0x00080000, 0x20000810, 0x20080010, 0x00000000,
      0x00000800, 0x00000010, 0x20080800, 0x20080010,
      0x20080810, 0x20080000, 0x20000000, 0x00000810,
      0x00000010, 0x00080800, 0x00080810, 0x20000800,
      0x00000810, 0x20000000, 0x20000800, 0x00080810,
      0x20080800, 0x00080010, 0x00000000, 0x20000800,
      0x20000000, 0x00000800, 0x20080010, 0x00080000,
      0x00080010, 0x20080810, 0x00080800, 0x00000010,
      0x20080810, 0x00080800, 0x00080000, 0x20000810,
      0x20000010, 0x20080000, 0x00080810, 0x00000000,
      0x00000800, 0x20000010, 0x20000810, 0x20080800,
      0x20080000, 0x00000810, 0x00000010, 0x20080010,
    },
    {
      /* nibble 6 */
      0x00001000, 0x00000080, 0x00400080, 0x00400001,
      0x00401081, 0x00001001, 0x00001080, 0x00000000,
      0x00400000, 0x00400081, 0x00000081, 0x00401000,
      0x00000001, 0x00401080, 0x00401000, 0x00000081,
      0x00400081, 0x00001000, 0x00001001, 0x00401081,
      0x00000000, 0x00400080, 0x00400001, 0x00001080,
      0x00401001, 0x00001081, 0x00401080, 0x00000001,
      0x00001081, 0x00401001, 0x00000080, 0x00400000,
      0x00001081, 0x00401000, 0x00401001, 0x00000081,
      0x00001000, 0x00000080, 0x00400000, 0x00401001,
      0x00400081, 0x00001081, 0x00001080, 0x00000000,
      0x00000080, 0x00400001, 0x00000001, 0x00400080,
      0x00000000, 0x00400081, 0x00400080, 0x00001080,
      0x00000081, 0x00001000, 0x00401081, 0x00400000,
      0x00401080, 0x00000001, 0x00001001, 0x00401081,
      0x00400001, 0x00401080, 0x00401000, 0x00001001,
    },
    {
      /* nibble 7 */
      0x08200020, 0x08208000, 0x00008020, 0x00000000,
      0x08008000, 0x00200020, 0x08200000, 0x08208020,
      0x00000020, 0x08000000, 0x00208000, 0x00008020,
      0x00208020, 0x08008020, 0x08000020, 0x08200000,
      0x00008000, 0x00208020, 0x00200020, 0x08008000,
      0x08208020, 0x08000020, 0x00000000, 0x00208000,
      0x08000000, 0x00200000, 0x08008020, 0x08200020,
      0x00200000, 0x00008000, 0x08208000, 0x00000020,
      0x00200000, 0x00008000, 0x08000020, 0x08208020,
      0x00008020, 0x08000000, 0x00000000, 0x00208000,
      0x08200020, 0x08008020, 0x08008000, 0x00200020,
      0x08208000, 0x00000020, 0x00200020, 0x08008000,
      0x08208020, 0x00200000, 0x08200000, 0x08000020,
      0x00208000, 0x00008020, 0x08008020, 0x08200000,
      0x00000020, 0x08208000, 0x00208020, 0x00000000,
      0x08000000, 0x08200020, 0x00008000, 0x00208020
    }
  };
  
  private static final int byteToUnsigned(byte b) {
    int value = (int) b;
    return (value >= 0) ? value : value + 256;
  }

  private static int fourBytesToInt(byte b[], int offset) {
    return byteToUnsigned(b[offset++]) 
      | (byteToUnsigned(b[offset++]) <<  8) 
      | (byteToUnsigned(b[offset++]) << 16) 
      | (byteToUnsigned(b[offset]) << 24);
  }

  private static final void intToFourBytes(int iValue, byte b[], int offset) {
    b[offset++] = (byte)((iValue)        & 0xff);
    b[offset++] = (byte)((iValue >>> 8 ) & 0xff);
    b[offset++] = (byte)((iValue >>> 16) & 0xff);
    b[offset] = (byte)((iValue >>> 24) & 0xff);
  }
  
  private static final void PERM_OP(int a, int b, int n, int m, int results[]) {
    int t;

    t = ((a >>> n) ^ b) & m;
    a ^= t << n;
    b ^= t;

    results[0] = a;
    results[1] = b;
  }

  private static final int HPERM_OP(int a, int n, int m) {
    int t;
    
    t = ((a << (16 - n)) ^ a) & m;
    a = a ^ t ^ (t >>> (16 - n));
    
    return a;
  }

  private static int [] des_set_key(byte key[]) {
    int schedule[] = new int [ITERATIONS * 2];
    
    int c = fourBytesToInt(key, 0);
    int d = fourBytesToInt(key, 4);
    
    int results[] = new int[2];

    PERM_OP(d, c, 4, 0x0f0f0f0f, results);
    d = results[0]; c = results[1];
    
    c = HPERM_OP(c, -2, 0xcccc0000);
    d = HPERM_OP(d, -2, 0xcccc0000);
    
    PERM_OP(d, c, 1, 0x55555555, results);
    d = results[0]; c = results[1];
    
    PERM_OP(c, d, 8, 0x00ff00ff, results);
    c = results[0]; d = results[1];
    
    PERM_OP(d, c, 1, 0x55555555, results);
    d = results[0]; c = results[1];
    
    d = (((d & 0x000000ff) <<  16) |  (d & 0x0000ff00)     |
     ((d & 0x00ff0000) >>> 16) | ((c & 0xf0000000) >>> 4));
    c &= 0x0fffffff;
    
    int s, t;
    int j = 0;
    
    for(int i = 0; i < ITERATIONS; i ++) {
      if(shifts2[i]) {
    c = (c >>> 2) | (c << 26);
    d = (d >>> 2) | (d << 26);
      } else {
    c = (c >>> 1) | (c << 27);
    d = (d >>> 1) | (d << 27);
      }
      
      c &= 0x0fffffff;
      d &= 0x0fffffff;
      
      s = skb[0][ (c       ) & 0x3f                       ]|
    skb[1][((c >>>  6) & 0x03) | ((c >>>  7) & 0x3c)]|
    skb[2][((c >>> 13) & 0x0f) | ((c >>> 14) & 0x30)]|
    skb[3][((c >>> 20) & 0x01) | ((c >>> 21) & 0x06) |
                   ((c >>> 22) & 0x38)];

      t = skb[4][ (d     )  & 0x3f                       ]|
    skb[5][((d >>> 7) & 0x03) | ((d >>>  8) & 0x3c)]|
    skb[6][ (d >>>15) & 0x3f                       ]|
    skb[7][((d >>>21) & 0x0f) | ((d >>> 22) & 0x30)];
      
      schedule[j++] = ((t <<  16) | (s & 0x0000ffff)) & 0xffffffff;
      s             = ((s >>> 16) | (t & 0xffff0000));
      
      s             = (s << 4) | (s >>> 28);
      schedule[j++] = s & 0xffffffff;
    }
    return schedule;
  }

  private static final int D_ENCRYPT(int L, int R, int S, int E0, int E1, int s[]) {
    int t, u, v;
    
    v = R ^ (R >>> 16);
    u = v & E0;
    v = v & E1;
    u = (u ^ (u << 16)) ^ R ^ s[S];
    t = (v ^ (v << 16)) ^ R ^ s[S + 1];
    t = (t >>> 4) | (t << 28);
    
    L ^= SPtrans[1][(t       ) & 0x3f] |
      SPtrans[3][(t >>>  8) & 0x3f] |
      SPtrans[5][(t >>> 16) & 0x3f] |
      SPtrans[7][(t >>> 24) & 0x3f] |
      SPtrans[0][(u       ) & 0x3f] |
      SPtrans[2][(u >>>  8) & 0x3f] |
      SPtrans[4][(u >>> 16) & 0x3f] |
      SPtrans[6][(u >>> 24) & 0x3f];

    return L;
  }
  
  private static final int [] body(int schedule[], int Eswap0, int Eswap1) {
    int left = 0;
    int right = 0;
    int t     = 0;

    for (int j = 0; j < 25; j ++) {
      for (int i = 0; i < ITERATIONS * 2; i += 4) {
    left  = D_ENCRYPT(left,  right, i,     Eswap0, Eswap1, schedule);
    right = D_ENCRYPT(right, left,  i + 2, Eswap0, Eswap1, schedule);
      }
      t     = left; 
      left  = right; 
      right = t;
    }
    
    t = right;

    right = (left >>> 1) | (left << 31);
    left  = (t    >>> 1) | (t    << 31);
    
    left  &= 0xffffffff;
    right &= 0xffffffff;

    int results[] = new int[2];

    PERM_OP(right, left, 1, 0x55555555, results); 
    right = results[0]; left = results[1];
    
    PERM_OP(left, right, 8, 0x00ff00ff, results); 
    left = results[0]; right = results[1];

    PERM_OP(right, left, 2, 0x33333333, results); 
    right = results[0]; left = results[1];
    
    PERM_OP(left, right, 16, 0x0000ffff, results);
    left = results[0]; right = results[1];
    
    PERM_OP(right, left, 4, 0x0f0f0f0f, results);
    right = results[0]; left = results[1];
    
    int out[] = new int[2];
    
    out[0] = left; 
    out[1] = right;
    
    return out;
  }

  public static final String alphabet = \"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";

  public static final String crypt(String salt, String original) {
    // wwb -- Should do some sanity checks: salt needs to be 2 chars, in alpha.
    while(salt.length() < 2)
      salt += \"A\";

    char[] buffer = new char [13];

    char charZero = salt.charAt(0);
    char charOne  = salt.charAt(1);
    
    buffer[0] = charZero;
    buffer[1] = charOne;

    int Eswap0 = alphabet.indexOf(charZero);
    int Eswap1 = alphabet.indexOf(charOne) << 4;
    byte key[] = new byte[8];
    
    for(int i = 0; i < key.length; i ++)
      key[i] = (byte)0;
    
    for(int i = 0; i < key.length && i < original.length(); i ++)
      key[i] = (byte) (((int) original.charAt(i)) << 1);

    int schedule[] = des_set_key(key);
    int out[]      = body(schedule, Eswap0, Eswap1);
    
    byte b[] = new byte[9];
    
    intToFourBytes(out[0], b, 0);
    intToFourBytes(out[1], b, 4);
    b[8] = 0;

    for(int i = 2, y = 0, u = 0x80; i < 13; i ++) {
      for(int j = 0, c = 0; j < 6; j ++) {
        c <<= 1;

        if(((int)b[y] & u) != 0)
          c |= 1;

        u >>>= 1;
        
        if (u == 0) {
          y++;
          u = 0x80;
        }
        buffer[i] = alphabet.charAt(c);
      }
    }
    return new String(buffer);
  }
}
")
    }
    1
}
{
    package main;
    package Perlito5::Java::JavaCompiler;
    sub Perlito5::Java::JavaCompiler::emit_java_imports {;
        return ("import java.io.ByteArrayOutputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.net.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import javax.tools.FileObject;
import javax.tools.ForwardingJavaFileManager;
import javax.tools.JavaCompiler;
import javax.tools.JavaFileManager;
import javax.tools.JavaFileObject;
import javax.tools.SimpleJavaFileObject;
import javax.tools.ToolProvider;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import org.perlito.Perlito5.*;

")
    }
    sub Perlito5::Java::JavaCompiler::emit_java {;
        return ("
/****************************************************************************/
// Credits for the PlJavaCompiler idea:
//
// http://udn.yyuap.com/doc/jdk6-api-zh/javax/tools/JavaCompiler.html         
//  * idea to reuse the same file manager to allow caching of jar files
// https://github.com/turpid-monkey/InMemoryJavaCompiler
// https://github.com/trung/InMemoryJavaCompiler
//  * provided a working example
//  * Apache License, Version 2.0 - http://www.apache.org/licenses/LICENSE-2.0.txt
// http://stackoverflow.com/questions/1563909/how-to-set-classpath-when-i-use-javax-tools-javacompiler-compile-the-source
//  * set classpath
/****************************************************************************/

class PlJavaCompiler {
    private PlJavaCompiler() {} // defined so class can't be instantiated.

    static ArrayList<SourceCode> compilationUnits;
    static ExtendedStandardJavaFileManager fileManager;
    static public DynamicClassLoader classLoader;
    static JavaCompiler javac;
    static Boolean initDone;
    static List<String> optionList;

    public static void init() throws Exception
    {
        // System.out.println(\"initializing Perlito5.LibPerl\");
        // try {
        //     LibPerl.main( new String[]{} );
        // }
        // catch(Exception e) {
        //     System.out.println(\"Errors in main()\");
        // }

        javac = ToolProvider.getSystemJavaCompiler();
        classLoader = new DynamicClassLoader( new PlArray().getClass().getClassLoader() );
        // classLoader = new DynamicClassLoader(ClassLoader.getSystemClassLoader());
        compilationUnits = new ArrayList<SourceCode>();

        optionList = new ArrayList<String>();
        // set compiler's classpath to be same as the runtime's
        StringBuilder cp = new StringBuilder();
        int cpCount = 0;
        try {
            for (URL url : ((URLClassLoader) (Thread.currentThread().getContextClassLoader())).getURLs()) {
                // System.out.println(\"url: \" + url.getFile());
                if (cpCount++ != 0) {
                    cp.append(\":\");
                }
                cp.append(url.getFile());
            }
        }
        catch (Exception e) {
            // java.base/jdk.internal.loader.ClassLoaders\$AppClassLoader cannot be cast to
            //      java.base/java.net.URLClassLoader
        }
        String systemCp = System.getProperty(\"java.class.path\");
        if (! systemCp.equals(\"\")) {
            if (cpCount++ != 0) {
                cp.append(\":\");
            }
            cp.append(systemCp);
        }
        optionList.addAll(Arrays.asList(\"-classpath\", cp.toString()));
        optionList.addAll(Arrays.asList(\"-source\",    \"7\"));
        // optionList.addAll(Arrays.asList(\"-Xlint:deprecation\"));
    }

    public static PlObject eval_java_string(PlArray List__)
    {

        String className = List__.shift().toString();
        String source    = List__.shift().toString();
        String constants = List__.shift().toString();

        if (source.equals(\"\")) {
            return PlCx.UNDEF;
        }

        try {
            if (initDone == null) {
                PlJavaCompiler.init();
                // System.out.println(\"eval_string: init\");
                initDone = true;
            }

            // TODO - test local(); initialize local() stack if needed

            StringBuilder source5 = new StringBuilder();
            source5.append(constants);
            source5.append(\"    \@SuppressWarnings(\\\"unchecked\\\")\");
            source5.append(\"    public static PlObject runEval(int want, PlArray List__) {\\n\");
            source5.append(\"        int return_context = want;\\n\");
            source5.append(\"        try {\\n\");
            source5.append(\"        \" + source + \"\\n\");
            source5.append(\"        }\\n\");
            source5.append(\"        catch(PlReturnException e) {\\n\");
            source5.append(\"            return e.ret;\\n\");
            source5.append(\"        }\\n\");
            source5.append(\"        catch(PlNextException e) {\\n\");
            source5.append(\"            throw(e);\\n\");
            source5.append(\"        }\\n\");
            source5.append(\"        catch(PlLastException e) {\\n\");
            source5.append(\"            throw(e);\\n\");
            source5.append(\"        }\\n\");
            source5.append(\"        catch(PlRedoException e) {\\n\");
            source5.append(\"            throw(e);\\n\");
            source5.append(\"        }\\n\");
            source5.append(\"        catch(Exception e) {\\n\");
            // source5.append(\"            e.printStackTrace();\\n\");
            source5.append(\"            String message = e.getMessage();\\n\");
            source5.append(\"            PlV.Scalar_EVAL_ERROR.set(new PlString(\\\"\\\" + message));\\n\");
            source5.append(\"            return PerlOp.context(want);\\n\");
            source5.append(\"        }\\n\");
            source5.append(\"    }\\n\");
            source5.append(\"}\\n\");
            String cls5 = source5.toString();

            if ( PlV.sget(\"Perlito5::Java::DEBUG\").get().to_boolean() ) {
                System.out.println(\"\\neval_ast:\\n\" + cls5 + \"\\n\");
            }

            // TODO - retrieve errors in Java->bytecode
            Class<?> class5 = compileClassInMemory(
                className,
                cls5
            );
            Method method5 = class5.getMethod(\"runEval\", new Class[]{int.class, PlArray.class});
            PlObject out = (org.perlito.Perlito5.PlObject)method5.invoke(null, PlCx.VOID, List__);
            // System.out.println(\"eval_string result: \" + out.toString());
            return out;
        }
        catch(PlReturnException e) {
            return e.ret;
        }
        catch(PlNextException e) {
            throw(e);
        }
        catch(PlLastException e) {
            throw(e);
        }
        catch(PlRedoException e) {
            throw(e);
        }
        catch(Exception e) {
            // e.printStackTrace();
            String message = e.getMessage();
            // System.out.println(\"Exception in eval_string: \" + message);
            PlV.Scalar_EVAL_ERROR.set(new PlString(\"\" + message));
        }
        return PlCx.UNDEF;
    }

    public static PlObject eval_perl_string(
        String      source, 
        String      namespace, 
        String      wantarray, 
        PlInt       scalar_hints,   // \$^H
        PlHashRef   hash_hints,     // \\%^H
        PlObject    scope,          // \"my\" declarations
        String[]    scalar_name,    // new String[]{\"x_100\"};   capture name
        PlLvalue[]  scalar_val,     // new PlLvalue[]{x_100};   capture value
        String[]    array_name,     // new String[]{\"xx_101\"};
        PlArray[]   array_val,      // new PlArray[]{xx_101};
        String[]    hash_name,      // new String[]{};
        PlHash[]    hash_val,       // new PlHash[]{}         
        int         want,
        PlArray     List__
    )
    {
        // System.out.println(\"eval_string: enter\");
        // (new Throwable()).printStackTrace();

        String className;
        String outJava;
        String constants;
        PlObject tmp_scalar_hints = PlV.sget(\"main::\" + (char)8).get();   // save \$^H
        PlHash   tmp_hash_hints   = new PlHash(PlV.hash_get(\"main::\" + (char)8));  // save %^H
        try {

            PlV.sset(\"main::\" + (char)8, scalar_hints);                   // \$^H
            PlV.hash_set(\"main::\" + (char)8, hash_hints.hash_deref_strict());    // %^H
            // Perlito5::Java::JavaCompiler::perl5_to_java(\$source, \$namespace, \$want, \$scope_java)
            PlObject code[] = org.perlito.Perlito5.LibPerl.apply(
                \"Perlito5::Java::Runtime::perl5_to_java\",
                new PlString(source),
                new PlString(namespace),
                new PlString(wantarray),
                scope
            );
            className = code[0].toString();
            outJava   = code[1].toString();
            constants = code[2].toString();
            // System.out.println(\"eval_string: from Perlito5::Java::JavaCompiler::perl5_to_java \\n[[[ \" + outJava + \" ]]\");
            // System.out.println(\"eval_string: constants \\n[[[ \" + constants + \" ]]\");
        }
        catch(Exception e) {
            // e.printStackTrace();
            String message = e.getMessage();
            // System.out.println(\"Exception in eval_string: \" + message);
            PlV.Scalar_EVAL_ERROR.set(new PlString(\"\" + message));
            PlV.sset(\"main::\" + (char)8, tmp_scalar_hints);     // restore \$^H
            PlV.hash_set(\"main::\" + (char)8, tmp_hash_hints);   // restore %^H
            return PlCx.UNDEF;
        }
        PlV.sset(\"main::\" + (char)8, tmp_scalar_hints);     // restore \$^H
        PlV.hash_set(\"main::\" + (char)8, tmp_hash_hints);   // restore %^H

        // return eval_java_string(outJava.toString());

        if (source.equals(\"\")) {
            PlV.Scalar_EVAL_ERROR.set(PlCx.EMPTY);
            return PlCx.UNDEF;
        }

        try {
            if (initDone == null) {
                PlJavaCompiler.init();
                // System.out.println(\"eval_string: init\");
                initDone = true;
            }

            // TODO - test local(); initialize local() stack if needed

            StringBuilder source5 = new StringBuilder();
            source5.append(constants);
            source5.append(\"    \@SuppressWarnings(\\\"unchecked\\\")\");
            source5.append(\"    public static PlObject runEval(int want, Object scalar_val, Object array_val, Object hash_val, PlArray List__) {\\n\");
            source5.append(\"        int return_context = want;\\n\");
            for (int i = 0; i < scalar_name.length; i++) {
            source5.append(\"        PlLvalue \" + scalar_name[i] + \" = ((PlLvalue[])(scalar_val))[\" + i + \"];\\n\");
            }
            for (int i = 0; i < array_name.length; i++) {
            source5.append(\"        PlArray \" + array_name[i] + \" = ((PlArray[])(array_val))[\" + i + \"];\\n\");
            }
            for (int i = 0; i < hash_name.length; i++) {
            source5.append(\"        PlHash \" + hash_name[i] + \" = ((PlHash[])(hash_val))[\" + i + \"];\\n\");
            }
            source5.append(\"        try {\\n\");
            source5.append(\"            PlObject ret = \" + outJava + \";\\n\");
            source5.append(\"            PlV.Scalar_EVAL_ERROR.set(PlCx.EMPTY);\\n\");
            source5.append(\"            return ret;\\n\");
            source5.append(\"        }\\n\");
            source5.append(\"        catch(PlReturnException e) {\\n\");
            source5.append(\"            PlV.Scalar_EVAL_ERROR.set(PlCx.EMPTY);\\n\");
            source5.append(\"            return e.ret;\\n\");
            source5.append(\"        }\\n\");
            source5.append(\"        catch(PlNextException e) {\\n\");
            source5.append(\"            PlV.Scalar_EVAL_ERROR.set(PlCx.EMPTY);\\n\");
            source5.append(\"            throw(e);\\n\");
            source5.append(\"        }\\n\");
            source5.append(\"        catch(PlLastException e) {\\n\");
            source5.append(\"            PlV.Scalar_EVAL_ERROR.set(PlCx.EMPTY);\\n\");
            source5.append(\"            throw(e);\\n\");
            source5.append(\"        }\\n\");
            source5.append(\"        catch(PlRedoException e) {\\n\");
            source5.append(\"            PlV.Scalar_EVAL_ERROR.set(PlCx.EMPTY);\\n\");
            source5.append(\"            throw(e);\\n\");
            source5.append(\"        }\\n\");
            source5.append(\"        catch(Exception e) {\\n\");
            // source5.append(\"            e.printStackTrace();\\n\");
            source5.append(\"            String message = e.getMessage();\\n\");
            source5.append(\"            PlV.Scalar_EVAL_ERROR.set(new PlString(\\\"\\\" + message));\\n\");
            source5.append(\"            return PerlOp.context(want);\\n\");
            source5.append(\"        }\\n\");
            source5.append(\"    }\\n\");
            source5.append(\"}\\n\");
            String cls5 = source5.toString();

            if ( PlV.sget(\"Perlito5::Java::DEBUG\").get().to_boolean() ) {
                System.out.println(\"\\neval_perl_string:\\n\" + cls5 + \"\\n\");
            }

            // TODO - retrieve errors in Java->bytecode
            Class<?> class5 = compileClassInMemory(
                className,
                cls5
            );
            Method method5 = class5.getMethod(\"runEval\", new Class[]{int.class, Object.class, Object.class, Object.class, PlArray.class});
            PlObject out = (org.perlito.Perlito5.PlObject)method5.invoke(null, want, scalar_val, array_val, hash_val, List__);
            // System.out.println(\"eval_string result: \" + out.toString());
            return out;
        }
        catch(PlReturnException e) {
            return e.ret;
        }
        catch(PlNextException e) {
            throw(e);
        }
        catch(PlLastException e) {
            throw(e);
        }
        catch(PlRedoException e) {
            throw(e);
        }
        catch(Exception e) {
            // e.printStackTrace();
            String message = e.getMessage();
            // System.out.println(\"Exception in eval_string: \" + message);
            PlV.Scalar_EVAL_ERROR.set(new PlString(\"\" + message));
        }
        return PlCx.UNDEF;
    }

    static Class<?> compileClassInMemory(String className, String classSourceCode) throws Exception
    {
        SourceCode sourceCodeObj = new SourceCode(className, classSourceCode);
        // System.out.println(\"PlJavaCompiler.compileClassInMemory: name=\" + className);
        classLoader.customCompiledCode.put(className, new CompiledCode(className));
        if (fileManager == null) {
            // initializing the file manager
            compilationUnits.add(sourceCodeObj);
            fileManager = new ExtendedStandardJavaFileManager(
                    javac.getStandardFileManager(null, null, null), classLoader);
        }
        else {
            // reusing the file manager; replace the source code
            compilationUnits.set(0, sourceCodeObj);
        }

        // run the compiler
        JavaCompiler.CompilationTask task = javac.getTask(null, fileManager,
                null, optionList, null, compilationUnits);
        boolean result = task.call();
        if (!result)
            throw new RuntimeException(\"Unknown error during compilation.\");
        return classLoader.loadClass(className);
    }

}

class ExtendedStandardJavaFileManager extends ForwardingJavaFileManager<JavaFileManager> {
    private DynamicClassLoader cl;

    protected ExtendedStandardJavaFileManager(JavaFileManager fileManager, DynamicClassLoader cl) {
        super(fileManager);
        this.cl = cl;
    }

    \@Override
    public JavaFileObject getJavaFileForOutput(JavaFileManager.Location location, String className, JavaFileObject.Kind kind, FileObject sibling) throws IOException {
        // System.out.println(\"ExtendedStandardJavaFileManager.getJavaFileForOutput: name=\" + className);
        CompiledCode cc = cl.customCompiledCode.get(className);
        if (cc != null) {
            return cc;
        }
        // source file not found for this output class: this is ok, because we can have a class like 'PlEval\$1'
        // System.out.println(\"ExtendedStandardJavaFileManager.getJavaFileForOutput: create name=\" + className);
        try {
            cc = new CompiledCode(className);
        }
        catch(Exception e) {
            throw new FileNotFoundException(\"Error creating output file for class \" + className );
        }
        cl.customCompiledCode.put(className, cc);
        return cc;
    }

    \@Override
    public ClassLoader getClassLoader(JavaFileManager.Location location) {
        return cl;
    }
}

class CompiledCode extends SimpleJavaFileObject {
    private ByteArrayOutputStream baos = new ByteArrayOutputStream();
    private String className;

    public CompiledCode(String className) throws Exception {
        super(new URI(className), Kind.CLASS);
        this.className = className;
    }
    
    public String getClassName() {
        // System.out.println(\"CompiledCode.getClassName: name=\" + className);
        return className;
    }

    \@Override
    public OutputStream openOutputStream() throws IOException {
        // System.out.println(\"CompiledCode.openOutputStream()\");
        return baos;
    }

    public byte[] getByteCode() {
        return baos.toByteArray();
    }
}

class DynamicClassLoader extends ClassLoader {
    public Map<String, CompiledCode> customCompiledCode = new HashMap<String, CompiledCode>();

    public DynamicClassLoader(ClassLoader parent) {
        super(parent);
    }

    public void addCode(CompiledCode cc) {
        // System.out.println(\"DynamicClassLoader.addCode: name=\" + cc.getName());
        customCompiledCode.put(cc.getName(), cc);
    }

    \@Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        // System.out.println(\"DynamicClassLoader.findClass: name=\" + name);
        CompiledCode cc = customCompiledCode.get(name);
        if (cc == null) {
            return super.findClass(name);
        }
        byte[] byteCode = cc.getByteCode();
        return defineClass(name, byteCode, 0, byteCode.length);
    }
}

class SourceCode extends SimpleJavaFileObject {
    private String contents = null;
    private String className;

    public SourceCode(String className, String contents) throws Exception {
        super(URI.create(\"string:///\" + className.replace('.', '/') + Kind.SOURCE.extension), Kind.SOURCE);
        this.contents = contents;
        this.className = className;
    }

    public String getClassName() {
        return className;
    }

    public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {
        return contents;
    }
}

")
    }
    1
}
{
    package main;
    package Perlito5::Java::Runtime;
    sub Perlito5::Java::Runtime::perl5_to_java {
        (my $source, my $namespace, my $want, my $scope_java) = @_;
        local $_;
        local ${^GLOBAL_PHASE};
        local @Perlito5::BASE_SCOPE = ($scope_java);
        local @Perlito5::SCOPE_STMT;
        local $Perlito5::CLOSURE_SCOPE = 0;
        local $Perlito5::PKG_NAME = $namespace;
        local @Perlito5::UNITCHECK_BLOCK;
        local @Perlito5::Java::Java_constants;
        local %Perlito5::Java::Java_constant_seen;
        my $match = Perlito5::Grammar::exp_stmts($source, 0);
        if (!$match || $match->{"to"} < length($source)) {;
            die("Syntax error in eval near pos ", $match->{"to"})
        }
        while (@Perlito::ANNOTATION) {
            my $ann = shift(@Perlito::ANNOTATION);
            my $str = Perlito5::AST::CompUnit::process_java_import_statement(@{$ann})
        }
        my $ast = Perlito5::AST::Call::->new("method", "postcircumfix:<( )>", "arguments", [], "invocant", Perlito5::AST::Sub::->new("block", Perlito5::AST::Block::->new("stmts", $match->{"capture"})));
        $ast = $ast->emit_begin_scratchpad();
        my $java_code = $ast->emit_java(2, $want);
        my $java_classes = Perlito5::Java::get_java_class_info() // {};
        my $className = "PlEval" . ($Perlito5::ID++);
        my $constants = '';
        $constants .= "import org.perlito.Perlito5.*;
" . "import java.util.regex.Pattern;
" . "public class " . $className . " {
";
        for my $s (@Perlito5::Java::Java_constants) {;
            $constants .= "    " . $s . ";
"
        }
        $constants .= "    public " . $className . "() {
" . "    }
";
        Perlito5::set_global_phase("UNITCHECK");
        $_->()
            while $_ = shift(@Perlito5::UNITCHECK_BLOCK);
        return ($className, $java_code, $constants)
    }
    sub Perlito5::Java::Runtime::eval_ast {
        (my $ast) = @_;
        my $want = 0;
        while (@Perlito::ANNOTATION) {
            my $ann = shift(@Perlito::ANNOTATION);
            my $str = Perlito5::AST::CompUnit::process_java_import_statement(@{$ann})
        }
        $ast = $ast->emit_begin_scratchpad();
        my $java_code = $ast->emit_java(2, $want);
        Perlito5::set_global_phase("UNITCHECK");
        $_->()
            while $_ = shift(@Perlito5::UNITCHECK_BLOCK);
        my $java_classes = Perlito5::Java::get_java_class_info() // {};
        my $className = "PlEval" . ($Perlito5::ID++);
        my $constants = '';
        $constants .= "import org.perlito.Perlito5.*;
" . "import java.util.regex.Pattern;
" . "public class " . $className . " {
";
        for my $s (@Perlito5::Java::Java_constants) {;
            $constants .= "    " . $s . ";
"
        }
        $constants .= "    public " . $className . "() {
" . "    }
";
        @_ = ($className, $java_code, $constants);
        return Java::inline("PlJavaCompiler.eval_java_string(List__)")
    }
    sub Perlito5::Java::Runtime::emit_java_extends {
        (my $class, my $java_classes) = @_;
        my @out;
        my $java_decl = $class->{"decl"} // [];
        if ($class->{"extends"}) {;
            push(@out, join(${"\""}, @{$java_decl}) . " class " . ($class->{"java_type"}) . " extends " . ($class->{"extends_java_type"}) . " {")
        }
        else {;
            push(@out, join(${"\""}, @{$java_decl}) . " class " . ($class->{"java_type"}) . " implements " . ($class->{"implements_java_type"}) . " {")
        }
        $class->{"Java::inline"} && push(@out, $class->{"Java::inline"});
        while (@{$class->{"variables"}}) {
            my $method = shift(@{$class->{"variables"}});
            my $data = shift(@{$class->{"variables"}})
        }
        while (@{$class->{"methods"}}) {
            my $method = shift(@{$class->{"methods"}});
            my $data = shift(@{$class->{"methods"}});
            my $decl = $data->{"decl"};
            my $code = $data->{"code"} or die("Java extends: missing 'code' argument in method '" . $method . "'");
            my $return = $data->{"return"} or die("Java extends: missing 'return' argument in method '" . $method . "'");
            my @args;
            my $var = 0;
            for my $arg (@{$data->{"args"}}) {
                my $type = $java_classes->{$arg};
                push(@args, ($type->{"java_type"}) . " param" . $var);
                $var++
            }
            my @java_decl = @{$decl};
            my $return_type = $return;
            if ($return ne "void") {
                my $type = $java_classes->{$return};
                $return_type = $type->{"java_type"}
            }
            my $throws = '';
            if ($data->{"throws"}) {;
                $throws = "throws " . join(${"\""}, @{$data->{"throws"}})
            }
            push(@out, "    " . join(${"\""}, @java_decl) . " " . $return_type . " " . $method . "(" . join(", ", @args) . (") " . $throws . " {"));
            @args = ();
            if (grep {;
                $_ eq "static"
            } @{$decl}) {;
                push(@args, "new PlString(\"" . ($class->{"perl_package"}) . "\")")
            }
            else {;
                push(@args, "new " . ($class->{"java_native_to_perl"}) . "(this)")
            }
            $var = 0;
            for my $arg (@{$data->{"args"}}) {
                my $type = $java_classes->{$arg};
                push(@args, "new " . ($type->{"java_native_to_perl"}) . "(param" . $var . ")");
                $var++
            }
            push(@out, "        PlObject[] res = Main.apply(\"" . $code . "\", " . join(", ", @args) . ");");
            if ($return eq "void") {;
                push(@out, "        return;")
            }
            else {
                my $type = $java_classes->{$return} or die("Java class '" . $return . "' is not imported");
                push(@out, "        return res[0]." . ($type->{"perl_to_java"}) . "();")
            }
            push(@out, "    }")
        }
        push(@out, "}
");
        return join("
", @out)
    }
    sub Perlito5::Java::Runtime::emit_java {
        (my $self, my %args) = @_;
        my %java_classes = %{$args{"java_classes"} // {}};
        if ($Perlito5::JAVA_EVAL) {;
            return (("
// use perlito5-lib.jar
import org.perlito.Perlito5.*;
import java.util.regex.Pattern;
import java.time.*;
import java.time.format.*;
import java.lang.management.*;
"))
        }
        my @number_unary = ("op_int", "neg", "complement", "abs", "sqrt", "cos", "sin", "exp", "log");
        my @boolean_unary = ("is_int", "is_num", "is_string", "is_bool", "is_undef", "is_regex", "is_filehandle", "is_ref", "is_arrayref", "is_coderef", "is_hashref", "is_scalarref", "is_typeglobref");
        my %number_binop = ("add", {"op" => "+", "returns" => "PlInt", "num_returns" => "PlDouble", }, "sub", {"op" => "-", "returns" => "PlInt", "num_returns" => "PlDouble", }, "mul", {"op" => "*", "returns" => "PlInt", "num_returns" => "PlDouble", }, "div", {"op" => "/", "returns" => "PlDouble", "num_returns" => "PlDouble", }, "num_eq", {"op" => "==", "returns" => "PlBool", "num_returns" => "PlBool", }, "num_ne", {"op" => "!=", "returns" => "PlBool", "num_returns" => "PlBool", }, "num_lt", {"op" => "<", "returns" => "PlBool", "num_returns" => "PlBool", }, "num_le", {"op" => "<=", "returns" => "PlBool", "num_returns" => "PlBool", }, "num_gt", {"op" => ">", "returns" => "PlBool", "num_returns" => "PlBool", }, "num_ge", {"op" => ">=", "returns" => "PlBool", "num_returns" => "PlBool", }, "int_and", {"op" => "&", "returns" => "PlInt", "num_returns" => "PlInt", }, "int_or", {"op" => "|", "returns" => "PlInt", "num_returns" => "PlInt", }, "int_xor", {"op" => "^", "returns" => "PlInt", "num_returns" => "PlInt", }, "int_shr", {"op" => ">>>", "returns" => "PlInt", "num_returns" => "PlInt", }, "int_shl", {"op" => "<<", "returns" => "PlInt", "num_returns" => "PlInt", });
        my %string_binop = ("str_eq", {"op" => "==", "str_op" => "eq", "returns" => "PlBool", }, "str_ne", {"op" => "!=", "str_op" => "ne", "returns" => "PlBool", }, "str_lt", {"op" => "<", "str_op" => "lt", "returns" => "PlBool", }, "str_le", {"op" => "<=", "str_op" => "le", "returns" => "PlBool", }, "str_gt", {"op" => ">", "str_op" => "gt", "returns" => "PlBool", }, "str_ge", {"op" => ">=", "str_op" => "ge", "returns" => "PlBool", });
        my %native_to_perl = ("long", "PlInt", "double", "PlDouble", "boolean", "PlBool", "String", "PlString");
        for $_ (values(%java_classes)) {;
            if ($_->{"perl_to_java"}) {;
                if ($_->{"import"} || $_->{"extends"} || $_->{"implements"}) {;
                    $native_to_perl{$_->{"java_type"}} = $_->{"java_native_to_perl"}
                }
            }
        }
        my %self_assign_number_binop = ("add", {"op" => "+=", }, "sub", {"op" => "-=", }, "mul", {"op" => "*=", }, "div", {"op" => "/=", }, "mod", {"op" => "%=", }, "int_or", {"op" => "|=", }, "int_and", {"op" => "&=", }, "int_xor", {"op" => "^=", }, "int_shr", {"op" => ">>=", }, "int_shl", {"op" => "<<=", }, "pow", {"op" => "**=", });
        my %special_var_index = ("_", [4, "PlLvalue"], "\\", [5, "PlLvalue"], "|", [6, "PlLvalueSpecialVarAutoflush"], "\@", [7, "PlLvalue"]);
        return (("// start Perl-Java runtime
// this is generated code - see: lib/Perlito5/Java/Runtime.pm

import java.lang.Math;
import java.lang.System;
import java.util.*;
import java.io.*;
import java.lang.management.*;
import java.nio.file.*;
import java.nio.file.attribute.*;
import java.nio.charset.*;
import java.nio.ByteBuffer;
import static java.nio.file.attribute.PosixFilePermission.*;
import java.time.*;
import java.time.format.*;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.concurrent.TimeUnit;
import java.lang.reflect.*;
"), ($Perlito5::BOOTSTRAP_JAVA_EVAL ? Perlito5::Java::JavaCompiler::->emit_java_imports() : ()), ((map {
            my $class = $java_classes{$_};
            $class->{"extends"} || $class->{"implements"} ? Perlito5::Java::Runtime::emit_java_extends($class, \%java_classes) : ()
        } sort {;
            $a cmp $b
        } keys(%java_classes))), Perlito5::Java::CORE::->emit_java(), ("class PlControlException extends RuntimeException {
}
class PlNextException    extends PlControlException {
    public int label_id;

    public PlNextException(int i) {
        this.label_id = i;
    }
}
class PlLastException    extends PlControlException {
    public int label_id;

    public PlLastException(int i) {
        this.label_id = i;
    }
}
class PlRedoException    extends PlControlException {
    public int label_id;

    public PlRedoException(int i) {
        this.label_id = i;
    }
}
class PlReturnException  extends PlControlException {
    public PlObject ret;

    public PlReturnException(PlObject ret) {
        this.ret = ret;
    }
}
class PlDieException  extends PlControlException {
    public PlObject ret;

    public PlDieException(PlObject ret) {
        this.ret = ret;
    }
    public String getMessage() {
        return this.ret.toString();
    }
}
class PlCx {
    public static final Thread mainThread = Thread.currentThread();
    public static final int     VOID   = 0;
    public static final int     SCALAR = 1;
    public static final int     LIST   = 2;
    public static final PlUndef  UNDEF  = new PlUndef();
    public static final PlBool   TRUE   = new PlBool(true);
    public static final PlBool   FALSE  = new PlBool(false);
    public static final Charset UTF8        = Charset.forName(\"UTF-8\");
    public static final PlString EMPTY  = new PlString(\"\");
    public static final PlNextException NEXT = new PlNextException(0);
    public static final PlLastException LAST = new PlLastException(0);
    public static final String OVERLOAD_STRING   = \"(\\\"\\\"\";  // (\"\"
    public static final String OVERLOAD_NUM      = \"(0+\";
    public static final String OVERLOAD_BOOL     = \"(bool\";
    public static final String OVERLOAD_NOMETHOD = \"(nomethod\";
    public static final PlRegex SPLIT_SPACE      = new PlRegex(\"\\\\s+\", Pattern.MULTILINE, false);
"), "    " . join("
    ", map {;
            "public static final PlInt " . ($_ < 0 ? "MIN" : "INT") . abs($_) . (" = new PlInt(" . $_ . ");")
        } (-2 .. 9)) . "
", "    " . join("
    ", @{$args{"java_constants"} // []}) . "
", ("}
"), Perlito5::Java::Crypt::->emit_java(), ($Perlito5::BOOTSTRAP_JAVA_EVAL ? Perlito5::Java::JavaCompiler::->emit_java() : ()), ("class PerlCompare implements Comparator<PlObject> {
    public PlClosure sorter;
    public PlLvalue v_a;
    public PlLvalue v_b;
    public PlArray  list__;
    public PerlCompare (PlClosure sorter, PlLvalue a, PlLvalue b, PlArray list__) {
        this.sorter = sorter;
        this.v_a = a;
        this.v_b = b;
        this.list__ = list__;
    }
    public int compare (PlObject a, PlObject b) {
        v_a.set(a);
        v_b.set(b);
        return this.sorter.apply( PlCx.SCALAR, list__ ).to_int();
    }
}
class PerlRangeString implements Iterator<PlObject> {
    public PlString v_start;
    public String   v_end;
    public PerlRangeString(PlString v_start, String v_end) {
        this.v_start = v_start;
        this.v_end = v_end;
    }
    public PlObject next() {
        PlString ret = v_start;
        PlObject incr = v_start._incr();
        if (incr.is_string()) {
            v_start = (PlString)incr;
        }
        else {
            v_start = new PlString(incr.toString());
        }
        return new PlLvalue(ret);
    }
    public boolean hasNext() {
        return (  (v_start.int_length() < v_end.length())
               || (v_start.int_length() == v_end.length() && v_start.boolean_str_le(v_end)) );
    }
}
class PerlRangeInt implements Iterator<PlObject> {
    public long     v_start;
    public long     v_end;
    public PerlRangeInt(long v_start, long v_end) {
        this.v_start = v_start;
        this.v_end = v_end;
    }
    public PlObject next() {
        PlInt ret = new PlInt(v_start);
        v_start++;
        return new PlLvalue(ret);
    }
    public boolean hasNext() {
        return v_start <= v_end;
    }
}
class PlLvalueIterator implements Iterator<PlObject> {
    public PlLvalue v_start;
    public PlLvalueIterator(PlLvalue v_start) {
        this.v_start = v_start;
    }
    public PlObject next() {
        PlObject ret = v_start;
        v_start = null;
        return ret;
    }
    public boolean hasNext() {
        return (v_start != null);
    }
}
class PerlRange0 implements Iterator<PlObject> {
    public PerlRange0() {
    }
    public PlObject next() {
        return new PlObject();
    }
    public boolean hasNext() {
        return false;
    }
}
class PerlRange implements Iterable<PlObject> {
    public PlObject v_start;
    public PlObject v_end;
    private static HashMap<String, Integer> flip_flop = new HashMap<String, Integer>();
    public PerlRange(PlObject v_start, PlObject v_end) {
        this.v_start = v_start;
        this.v_end = v_end;
    }
    public Iterator<PlObject> iterator() {
        if (this.v_start.is_string() && this.v_end.is_string()) {
            String s = v_start.toString();
            final int length = s.length();
            if (length > 0) {
                boolean is_num_start = PerlOp.looks_like_number(s);
                boolean is_num_end = PerlOp.looks_like_number(this.v_end.toString());
                if (is_num_start && is_num_end && s.codePointAt(0) != '0') {
                    if (!this.v_start.is_integer_range() || !this.v_end.is_integer_range()) {
                        PlCORE.die(\"Range iterator outside integer range\");
                    }
                    return new PerlRangeInt(this.v_start.to_long(), this.v_end.to_long());
                }
                // If the initial value specified isn't part of a magical increment sequence
                // (that is, a non-empty string matching /^[a-zA-Z]*[0-9]*\\z/ ),
                // only the initial value will be returned.
                boolean is_incrementable = true;
                for (int offset = 0; offset < length; offset++) {
                    int c = s.codePointAt(offset);
                    if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {
                        // good
                    }
                    else {
                        for ( ; offset < length; offset++) {
                            c = s.codePointAt(offset);
                            if (c >= '0' && c <= '9') {
                                // good
                            }
                            else {
                                is_incrementable = false;
                                offset = length;  // exit loop
                            }
                        }
                    }
                }
                if (is_incrementable) {
                    return new PerlRangeString(new PlString(s), this.v_end.toString());
                }
            }
            if (length > this.v_end.toString().length()) {
                return new PerlRange0();
            }
            return new PlLvalueIterator(new PlLvalue(new PlString(s)));
        }

        if (!this.v_start.is_integer_range() || !this.v_end.is_integer_range()) {
            PlCORE.die(\"Range iterator outside integer range\");
        }
        return new PerlRangeInt(this.v_start.to_long(), this.v_end.to_long());
    }
    public final PlObject range(int want, String id, int three_dots) {
        if (want == PlCx.LIST) {
            PlArray ret = new PlArray();
            for (PlObject i : this) {
                ret.a.add(i);
            }
            return ret;
        }
        // http://perldoc.perl.org/perlop.html#Range-Operators
        Integer v = flip_flop.get(id);
        if (v != null && v != 0) {
            v++;
            if (v_end.to_boolean()) {
                flip_flop.put(id, 0);
                return new PlString(\"\" + v + \"E0\");
            }
            else {
                flip_flop.put(id, v);
                return new PlInt(v);
            }
        }
        else {
            if (v_start.to_boolean()) {
                v = 1;
            }
            else {
                v = 0;
            }
            if (v != 0 && three_dots == 0 && v_end.to_boolean()) {
                flip_flop.put(id, 0);
                return new PlString(\"\" + v + \"E0\");
            }
            else {
                flip_flop.put(id, v);
                if (v == 0) {
                    return PlCx.EMPTY;
                }
                return new PlInt(v);
            }
        }
    }
}
class PerlArgumentLookupResult {
    // public ArrayList<Class[]> params;
    public Object arg;
    public Class cl;

    public PerlArgumentLookupResult(Object arg, Class cl) {
        // , ArrayList<Class[]> params) {
        this.arg    = arg;
        this.cl     = cl;
        // this.params = params;
    }
}
class PerlOp {
    // PerlOp implements operators: && ||
    //      and auxiliary functions
    //
    // note: '+' add() and '-' sub() are PlObject methods, not implemented here.
    //
    // TODO - see Perlito5/JavaScript2/Runtime.pm for more operator implementations

    // symbol tables
    // like %Module::
    public static final PlObject getSymbolTable(String nameSpace) {
        // TODO - create the typeglobs that link to \"inner\" namespaces, like *Java:: in %Perlito5::Java::
        int pos = nameSpace.lastIndexOf(\"::\");
        boolean isMain = nameSpace.equals(\"main::\");
        PlHash out = new PlHash();
        getSymbolTableScan(out, PlStringConstant.constants, nameSpace, pos, isMain);
        return out;
    }

    private static final void getSymbolTableScan(PlHash out, HashMap<String, PlStringConstant> vars, String nameSpace, int pos, boolean isMain) {
        if (isMain) {
            for (String name : vars.keySet()) {
                if (name.length() > pos + 2 && name.indexOf(nameSpace) == 0 && name.lastIndexOf(\"::\") == pos) {
                    // normal variable like \"ARGV\" in \$main::ARGV
                    out.hset(name.substring(pos+2), PlV.fget(name));
                }
                else {
                    // \"inner\" namespace
                    String inner = name.substring(0, name.indexOf(\"::\")+2);
                    out.hset(inner, PlV.fget(inner));
                }
            }
        }
        else {
            for (String name : vars.keySet()) {
                if (name.length() > pos + 2 && name.indexOf(nameSpace) == 0) {
                    if (name.lastIndexOf(\"::\") == pos) {
                        // normal variable like \"ARGV\" in \$main::ARGV
                        out.hset(name.substring(pos+2), PlV.fget(name));
                    }
                    else {
                        // \"inner\" namespace
                        String inner = name.substring(pos+2, name.indexOf(\"::\", pos+2)+2);
                        out.hset(inner, PlV.fget(name.substring(0, name.indexOf(\"::\", pos+2)+2)));
                    }
                }
            }
        }
    }

    public static final PlObject deleteSymbolTable(String nameSpace, PlObject index) {
        // delete \$Foo::{foo}
        String sname = nameSpace + index.toString();
        PlString name = new PlString(sname);
        PlStringConstant glob = PlStringConstant.getConstant(sname);
        glob.codeRef.set(PlCx.UNDEF);
        glob.scalarRef.set(PlCx.UNDEF);
        glob.arrayRef.set(new PlArrayRef());
        glob.hashRef.set(new PlHashRef());
        glob.fileRef.set(new PlFileHandle(sname));
        return PlCx.UNDEF; 
    }

    // filehandles
    public static final PlFileHandle get_filehandle(PlObject fh, String nameSpace) {
        if (fh.is_lvalue()) {
            if (fh.is_undef()) {
                // \$fh autovivification to filehandle
                fh.set(new PlFileHandle(nameSpace));
            }
            fh = fh.get();
        }
        if (fh.is_filehandle()) {
            // *FILE
            return (PlFileHandle)fh;
        }
        if (fh.is_typeglobref()) {
            // \\*FILE
            return ((PlGlobRef)fh).filehandle;
        }
        return get_filehandle(fh.toString(), nameSpace);    // get \"GLOB\" by name
    }
    public static final PlFileHandle get_filehandle(String s, String nameSpace) {
        int pos = s.indexOf(\"::\");
        if (pos == 0) {
            // ::x
            s = \"main\" + s;
        }
        if (pos == -1) {
            if (s.equals(\"STDOUT\")) {
                s = \"main::STDOUT\";
            }
            else if (s.equals(\"STDERR\")) {
                s = \"main::STDERR\";
            }
            else if (s.equals(\"STDIN\")) {
                s = \"main::STDIN\";
            }
            else if (s.equals(\"ARGV\")) {
                s = \"main::ARGV\";
            }
            else {
                s = nameSpace + \"::\" + s;
            }
        }
        while (s.startsWith(\"main::main::\")) {
            s = s.substring(6);
        }
        PlObject fh = PlV.fget(s);    // get \"GLOB\" by name
        return (PlFileHandle)(fh.get());
    }
    public static final Set<PosixFilePermission> MaskToPermissions(int mask) {
        final Set<PosixFilePermission> perm = new HashSet<PosixFilePermission>();
        // TODO - provide a workaround
        // if ((mask & 04000)==0) PlCORE.die(\"setuid bit not implemented\");
        // if ((mask & 02000)==0) PlCORE.die(\"setgid bit not implemented\");
        // if ((mask & 01000)==0) PlCORE.die(\"sticky bit not implemented\");
        if ((mask & 00400)==0) perm.add(OWNER_READ);
        if ((mask & 00200)==0) perm.add(OWNER_WRITE);
        if ((mask & 00100)==0) perm.add(OWNER_EXECUTE);
        if ((mask & 00040)==0) perm.add(GROUP_READ);
        if ((mask & 00020)==0) perm.add(GROUP_WRITE);
        if ((mask & 00010)==0) perm.add(GROUP_EXECUTE);
        if ((mask & 00004)==0) perm.add(OTHERS_READ);
        if ((mask & 00002)==0) perm.add(OTHERS_WRITE);
        if ((mask & 00001)==0) perm.add(OTHERS_EXECUTE);
        return perm;
    }

    // objects

    public static final PlObject callSuper( String method, String packageName, PlArray args, int context ) {
        // SUPER calls:  \$v->SUPER::x;
        PlObject methodCode = PlCx.UNDEF;
      ISA:
        for (PlObject className : PlV.array_get(packageName + \"::ISA\")) {
            methodCode = PlClass.getInstance(className).method_lookup(method, 0);
            if (!methodCode.is_undef()) {
                break ISA;
            }
        }
        if (methodCode.is_undef()) {
            PlCORE.die( \"Can't locate object method \\\"\" + method
                + \"\\\" via package \\\"\" + packageName + \"\\\"\");
        }
        return PerlOp.call(methodCode, args, context);
    }

    // coderef methods can be called on ANY invocant
    //  \$m = sub {...};
    //  \$a->\$m
    public static final PlObject call( PlObject method, PlArray args, int context ) {
        if ( method.is_coderef() ) {
            return method.apply(context, args);
        }
        else if ( method.is_lvalue() ) {
            return call( method.get(), args, context );
        }
        else {
            return call( method.toString(), args, context );
        }
    }
    public static final PlObject call( PlStringConstant method, PlArray args, int context ) {
        return call( method.toString(), args, context );
    }
    public static final PlObject call( String method, PlArray args, int context ) {
        PlObject invocant = args.aget(0);

        PlClass pClass = invocant.blessed_class();

        if ( pClass != null ) {
            // invocant is a normal Perl object instance
            PlObject methodCode = pClass.method_lookup(method, 0);
            if (methodCode.is_undef()) {
                String className = pClass.className();
                return PlCORE.die( \"Can't locate object method \\\"\" + method
                    + \"\\\" via package \\\"\" + className
                    + \"\\\" (perhaps you forgot to load \\\"\" + className + \"\\\"?)\" );
            }
            return methodCode.apply(context, args);
        }

        if ( invocant.is_lvalue() ) {
            invocant = invocant.get();
        }
        if ( invocant.is_JavaObject() ) {
            args.shift();   // remove invocant
            Object obj = ((PlJavaObject)invocant).toJava();
            PlLvalue ret = new PlLvalue();
            Class cl;
            if (obj instanceof Class) {
                cl = (Class)obj;
            }
            else {
                cl = obj.getClass();
            }

            int argCount = args.to_int();
            if (argCount == 0) {
                // no arguments; this may be a \"field\"
                try {
                    Field fi = cl.getField(method);
                    if (obj instanceof Class) {
                        // obj is Class; method is \"field\"
                        ret.set( fi.get(null) );
                    }
                    else {
                        // obj is instance; method is \"field\"
                        ret.set( fi.get(obj) );
                    }
                    return ret;
                }
                catch (NoSuchFieldException e) {
                    // Array \"length\" is special
                    if (method.equals(\"length\")) {
                        try {
                            ret.set(Array.getLength(obj));
                            return ret;
                        }
                        catch (Exception e2) {
                        }
                    }
                }
                catch (Exception e) {
                    return PlCORE.die(new PlStringLazyError(e));
                }
            }

            ArrayList<Class[]> params = new ArrayList<Class[]>();
            for (Method m : cl.getMethods()) {
                if (m.getName().equals(method)) {
                    Class[] mArgs = m.getParameterTypes();
                    if (mArgs.length > 0 && mArgs.length <= argCount) {
                        params.add(mArgs);
                    }
                }
            }
            if (method.equals(\"new\")) {

                if (cl.isArray() && args.to_int() == 1) {
                    // \$ArrayClass->new(10)
                    ret.set( java.lang.reflect.Array.newInstance(cl.getComponentType(), args.aget(0).to_int()) );
                    return ret;
                }

                for (Constructor m : cl.getConstructors()) {
                    Class[] mArgs = m.getParameterTypes();
                    if (mArgs.length > 0 && mArgs.length <= argCount) {
                        params.add(mArgs);
                    }
                }
            }

            // TODO - overloading
            //   - sort constructors by specificity
            //   - See: https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2
            //          http://www.xyzws.com/javafaq/what-is-a-mostspecific-method/8
            //   - type promotion: byte -> short -> int -> long -> float -> double
            //   - boxing / unboxing
            //   - method arity: consider variable arity (Object...) \"[Ljava.lang.Object;\"
            //
            //          perl> eval { \$aa = Java::inline q{ Class.forName(\"java.lang.String\") }}
            //          Class(0xf3fcd59)
            //          perl> \$aa->format(\"aaa\", 123)
            //              java.lang.String    - param #1
            //              [Ljava.lang.Object; - param #2, ...
            //
            //   - check Class.getSuperclass()
            //   - special case when arglist is empty, but (Object...)
            //   - Creating arrays via Java Reflection is done using the java.lang.reflect.Array:
            //     See: http://tutorials.jenkov.com/java-reflection/arrays.html
            //
            //          cl.isArray()            // true
            //          cl.getComponentType()   // int.class
            //          int[] intArray = (int[]) Array.newInstance(int.class, 3);
            //

            // System.out.println(\"Candidate methods \" + method);
            // for(int i = 0; i < params.size(); i++) {
            //     System.out.println(\"  params:\");
            //     for(Class c : params.get(i)) {
            //         System.out.println(\"    \" + c.getName());
            //     }
            // }

            int paramPos = 0;
            ArrayList<Class[]> param2;
            ArrayList<Class> classArgs = new ArrayList<Class>();
            ArrayList<Object> objArgs = new ArrayList<Object>();
            PerlArgumentLookupResult newArg;

          ARGS:
            while (args.to_int() > 0) {
                PlObject v = args.shift();
                newArg = v.castToClass( params, paramPos );
                // System.out.println(\"Closest class \" + newArg.cl.getName());

                if (newArg.arg == null && newArg.cl.isArray()) {
                    // varargs
                    // System.out.println(\"Start varargs\");
                    args.unshift(v);    // cast the argument again
                    Class varargsArrayClass = newArg.cl;
                    Class varargsClass = varargsArrayClass.getComponentType();
                    Object[] varargs = (Object[])java.lang.reflect.Array.newInstance(varargsClass, args.to_int());
                    params = new ArrayList<Class[]>();
                    params.add( new Class[]{ varargsClass } );
                    paramPos = 0;
                    int varargsPos = 0;
                    while (args.to_int() > 0) {
                        v = args.shift();
                        newArg = v.castToClass( params, paramPos );
                        // System.out.println(\"varargs: Closest class \" + newArg.cl.getName());
                        varargs[varargsPos++] = newArg.arg;
                    }
                    classArgs.add(varargsArrayClass);
                    objArgs.add(varargs);
                    break ARGS;
                }

                classArgs.add(newArg.cl);
                objArgs.add(newArg.arg);

                // prune candidates
                param2 = new ArrayList<Class[]>();
                for (Class[] mArgs : params) {
                    if (mArgs[paramPos].equals(newArg.cl)) {
                        param2.add(mArgs);
                    }
                }
                params = param2;
                paramPos++;

                // System.out.println(\"Candidate methods \" + method);
                // for(int i = 0; i < params.size(); i++) {
                //     System.out.println(\"  params:\");
                //     for(Class c : params.get(i)) {
                //         System.out.println(\"    \" + c.getName());
                //     }
                // }
            }

            try {
                Method meth = ((Class<?>)cl).getMethod(method, classArgs.toArray(new Class[classArgs.size()]));
                ret.set( meth.invoke(obj, objArgs.toArray(new Object[objArgs.size()])));
                return ret;
            }
            catch (NoSuchMethodException e) {
            }
            catch (Exception e) {
                return PlCORE.die(new PlStringLazyError(e));
            }
            if (method.equals(\"new\")) {
                try {
                    Constructor co = ((Class<?>)cl).getConstructor(classArgs.toArray(new Class[classArgs.size()]));
                    ret.set( co.newInstance(objArgs.toArray(new Object[objArgs.size()])) );
                    return ret;
                }
                catch (NoSuchMethodException e) {
                }
                catch (Exception e) {
                    return PlCORE.die(new PlStringLazyError(e));
                }
            }
            return PlCORE.die( \"Can't locate object method \\\"\" + method
                + \"\\\" via Java class \\\"\" + cl.getCanonicalName()
                + \"\\\" (perhaps the parameter types don\\'t match?)\" );
        }
        if ( invocant.is_undef() ) {
            return PlCORE.die( \"Can't call method \\\"\" + method + \"\\\" on an undefined value\" );
        }
        if (invocant.is_typeglobref()) {
            // \\*FILE
            invocant = ((PlGlobRef)invocant).filehandle;
        }

        if (invocant.is_ref()) {
            return PlCORE.die( \"Can't call method \\\"\" + method + \"\\\" on unblessed reference\" );
        }

        if (invocant.is_filehandle()) {
            // invocant can be a nonref-typeglob
            // *FILE
            // \$fh->print() is allowed, even if \$fh is unblessed
            if (method.equals(\"print\")) {
                args.shift();   // TODO - keep filehandle in arg list
                return PlCORE.print(context, (PlFileHandle)invocant, args.toString());
            }
        }

        // invocant can be a package name
        String invocant_str = invocant.toString();
        if ( invocant_str.equals(\"\") ) {
            return PlCORE.die( \"Can't call method \\\"\" + method + \"\\\" on an undefined value\" );
        }
        PlObject methodCode = PlClass.getInstance(invocant_str).method_lookup(method, 0);
        if (methodCode.is_undef()) {
            return PlCORE.die( \"Can't locate object method \\\"\" + method
                + \"\\\" via package \\\"\" + invocant_str
                + \"\\\" (perhaps you forgot to load \\\"\" + invocant_str + \"\\\"?)\" );
        }
        return methodCode.apply(context, args);
    }

    // local()
    public static final PlObject push_local(PlHash container, String index) {
        PlV.local_stack.a.add(container);
        PlV.local_stack.a.add(new PlString(index));
        PlLvalue empty = new PlLvalue();
        PlV.local_stack.a.add(container.hget_lvalue(index));
        PlV.local_stack.a.add(PlCx.INT0);
        container.hset_alias(index, empty);
        return empty;
    }
    public static final PlObject push_local(PlArray container, int index) {
        PlV.local_stack.a.add(container);
        PlV.local_stack.a.add(new PlInt(index));
        PlLvalue empty = new PlLvalue();
        PlV.local_stack.a.add(container.aget_lvalue(index));
        PlV.local_stack.a.add(PlCx.INT1);
        container.aset_alias(index, empty);
        return empty;
    }
    public static final void push_local_regex_result() {
        PlRegexResult match = PlV.regex_result;
        PlV.local_stack.a.add(match);
        PlV.local_stack.a.add(PlCx.INT2);
        PlRegexResult new_match = new PlRegexResult();
        new_match.matcher = match.matcher;
        new_match.regex_string = match.regex_string;
        PlV.regex_result = new_match;
    }
    public static final PlObject push_local_named_sub(PlObject value, String name) {
        PlStringConstant glob = PlStringConstant.getConstant(name);
        PlV.local_stack.a.add(new PlString(name));
        PlV.local_stack.a.add(glob.codeRef);
        PlV.local_stack.a.add(PlCx.INT3);
        PlLvalue newValue = new PlLvalue();
        newValue.set(value);
        glob.codeRef = newValue;
        return newValue;
    }
    public static final PlObject push_local_scalar(PlObject value, String name) {
        PlStringConstant glob = PlStringConstant.getConstant(name);
        PlV.local_stack.a.add(new PlString(name));
        PlV.local_stack.a.add(glob.scalarRef);
        PlV.local_stack.a.add(new PlInt(20));       // XXX magic number
        PlLvalue newValue = new PlLvalue();
        newValue.set(value);
        glob.scalarRef = newValue;
        return newValue;
    }
    public static final PlObject push_local_array(PlObject value, String name) {
        PlStringConstant glob = PlStringConstant.getConstant(name);
        PlV.local_stack.a.add(new PlString(name));
        PlV.local_stack.a.add(glob.arrayRef);
        PlV.local_stack.a.add(new PlInt(21));       // XXX magic number
        PlLvalue newValue = new PlLvalue();
        newValue.set(value);
        glob.arrayRef = newValue;
        return newValue;
    }
    public static final PlObject push_local_hash(PlObject value, String name) {
        PlStringConstant glob = PlStringConstant.getConstant(name);
        PlV.local_stack.a.add(new PlString(name));
        PlV.local_stack.a.add(glob.hashRef);
        PlV.local_stack.a.add(new PlInt(22));       // XXX magic number
        PlLvalue newValue = new PlLvalue();
        newValue.set(value);
        glob.hashRef = newValue;
        return newValue;
    }
    public static final PlObject push_local_file(PlObject value, String name) {
        PlStringConstant glob = PlStringConstant.getConstant(name);
        PlV.local_stack.a.add(new PlString(name));
        PlV.local_stack.a.add(glob.fileRef);
        PlV.local_stack.a.add(new PlInt(23));       // XXX magic number
        PlLvalue newValue = new PlLvalue();
        newValue.set(value);
        glob.fileRef = newValue;
        return newValue;
    }

    // localizers for special variables like \$_ \$\\
"), ((map {
            my $java_name = $Perlito5::Java::special_scalar{$_};
            my $index = $special_var_index{$_}->[0];
            my $class = $special_var_index{$_}->[1];
            "
    public static final void push_local_special_var_" . $java_name . "() {
        PlV.local_stack.a.add(PlV." . $java_name . ");
        PlV.local_stack.a.add(PlCx.INT" . $index . ");
        PlV." . $java_name . " = new " . $class . "();
    }
"
        } sort {;
            $a cmp $b
        } keys(%Perlito5::Java::special_scalar))), ("
    public static final int local_length() {
        return PlV.local_stack.to_int();
    }
    public static final PlObject cleanup_local(int pos, PlObject ret) {
        while (PlV.local_stack.to_int() > pos) {
            int t = PlV.local_stack.pop().to_int();
            PlObject v = PlV.local_stack.pop();
            PlObject index;
            PlObject container;
            switch (t) {
                case 0:
                    index     = PlV.local_stack.pop();
                    container = PlV.local_stack.pop();
                    ((PlHash)container).hset_alias(index.toString(), (PlLvalue)v);
                    break;
                case 1:
                    index     = PlV.local_stack.pop();
                    container = PlV.local_stack.pop();
                    ((PlArray)container).aset_alias(index.to_int(), (PlLvalue)v);
                    break;
                case 2:
                    PlV.regex_result = (PlRegexResult)v;
                    break;
                case 3:
                    index     = PlV.local_stack.pop();
                    PlStringConstant.getConstant(index.toString()).codeRef = (PlLvalue)v;
                    break;
                case 20:      // XXX magic number
                    index     = PlV.local_stack.pop();
                    PlStringConstant.getConstant(index.toString()).scalarRef = (PlLvalue)v;
                    break;
                case 21:      // XXX magic number
                    index     = PlV.local_stack.pop();
                    PlStringConstant.getConstant(index.toString()).arrayRef = (PlLvalue)v;
                    break;
                case 22:      // XXX magic number
                    index     = PlV.local_stack.pop();
                    PlStringConstant.getConstant(index.toString()).hashRef = (PlLvalue)v;
                    break;
                case 23:      // XXX magic number
                    index     = PlV.local_stack.pop();
                    PlStringConstant.getConstant(index.toString()).fileRef = (PlLvalue)v;
                    break;
"), ((map {
            my $java_name = $Perlito5::Java::special_scalar{$_};
            my $index = $special_var_index{$_}->[0];
            my $class = $special_var_index{$_}->[1];
            "
                case " . $index . ":
                    PlV." . $java_name . " = (" . $class . ")v;
                    break;
"
        } sort {;
            $a cmp $b
        } keys(%Perlito5::Java::special_scalar))), ("
            }
        }
        return ret;
    }

    // context()
    //      - handles run-time scalar/list/void context in expression results
    public static final PlObject context(int want, PlObject arg) {
        if (want == PlCx.LIST) {
            return arg;
        }
        return arg.scalar();
    }
    public static final PlObject context(int want, Object o) {
        PlObject arg = PlJavaObject.fromObject(o);
        if (want == PlCx.LIST) {
            return arg;
        }
        return arg.scalar();
    }
    public static final PlObject context(int want) {
        if (want == PlCx.LIST) {
            return new PlArray();
        }
        return PlCx.UNDEF;
    }
    public static final PlObject context(int want, PlObject... args) {
        if (want == PlCx.LIST) {
            return new PlArray(args);
        }
        return args[args.length-1].scalar();
    }
    public static final PlObject context(int want, String arg) {
        if (want == PlCx.LIST) {
            return new PlArray(new PlString(arg));
        }
        return new PlString(arg);
    }

    // process id
    public static PlObject getPID() {
      String processName =
        java.lang.management.ManagementFactory.getRuntimeMXBean().getName();
      return new PlString(processName.split(\"\@\")[0]);
    }

    // statement()
    //      - workaround for \"Error: not a statement\"
    //      - this is the compile-time version of context(null, arg)
    public static final void statement(PlObject... args) { }
    public static final void statement() { }

    // control-flow exceptions
    public static final PlObject next() {
        throw PlCx.NEXT;
    }
    public static final PlObject next(int label_id) {
        throw new PlNextException(label_id);
    }
    public static final PlObject last() {
        throw PlCx.LAST;
    }
    public static final PlObject last(int label_id) {
        throw new PlLastException(label_id);
    }
    public static final PlObject redo(int label_id) {
        throw new PlRedoException(label_id);
    }
    public static final PlObject ret(PlObject ret) {
        throw new PlReturnException(ret);
    }

    public static final PlObject gotoOp(int ctx, PlObject s, PlArray List__) {
        if (s.is_coderef()) {
            // goto &subr;
            throw new PlReturnException(s.apply(ctx, List__));
        }
        return PlCORE.die(\"goto() not implemented\");
    }

"), ("
    public static final PlObject mod(PlInt aa, PlObject bb) {
        long a = aa.to_long();
        long b = bb.to_long();
        long res = Math.abs(a) % Math.abs(b);
        // PlCORE.say(\"mod \" + a + \" % \" + b + \" = \" + res);
        if (a < 0 && b > 0) {
            return new PlInt(b - res);
        }
        if (a > 0 && b < 0) {
            return new PlInt(b + res);
        }
        if (a < 0 && b < 0) {
            return new PlInt(- res);
        }
        return new PlInt(res);
    }
    public static final PlObject mod(PlDouble aa, PlObject bb) {
        double a = aa.to_double();
        double b = bb.to_double();
        double res = Math.abs(a) % Math.abs(b);
        // PlCORE.say(\"mod \" + a + \" % \" + b + \" = \" + res);
        if (a < 0.0 && b > 0.0) {
            return new PlDouble(b - res);
        }
        if (a > 0.0 && b < 0.0) {
            return new PlDouble(b + res);
        }
        if (a < 0.0 && b < 0.0) {
            return new PlDouble(- res);
        }
        return new PlDouble(res);
    }

    public static final PlObject srand() {
        PlV.random = new Random();
        return PlCx.UNDEF;
    }
    public static final PlObject srand(PlObject o) {
        if (!o.is_integer_range()) {
            PlCORE.warn(PlCx.VOID, new PlArray(new PlString(\"Integer overflow in srand\")));
        }
        long s = o.to_long();
        PlV.random = new Random(s);
        if (s == 0) {
            return new PlString(\"0E0\");
        }
        return new PlInt(s);
    }

    public static final PlObject rand(double s) {
        if (s == 0.0) {
            s = 1.0;
        }
        return new PlDouble(s * PlV.random.nextDouble());
    }

    // and1(x) ? y : and3()
    public static final boolean and1(PlObject arg1) {
        if (arg1.to_boolean()) {
            return true;
        }
        else {
            PlV.boolean_stack = arg1;
            return false;
        }
    }
    public static final PlObject and3() {
        return PlV.boolean_stack;
    }

    // or1(x) ? or2() : y
    public static final boolean or1(PlObject arg1) {
        if (arg1.to_boolean()) {
            PlV.boolean_stack = arg1;
            return true;
        }
        else {
            return false;
        }
    }
    public static final PlObject or2() {
        return PlV.boolean_stack;
    }

    // defined_or1(x) ? defined_or2() : y
    public static final boolean defined_or1(PlObject arg1) {
        if (!arg1.is_undef()) {
            PlV.boolean_stack = arg1;
            return true;
        }
        else {
            return false;
        }
    }
    public static final PlObject defined_or2() {
        return PlV.boolean_stack;
    }

    public static final PlInt ord(PlObject s) {
        String item = s.toString();
        return new PlInt(item.length() > 0 ? Character.codePointAt(item, 0) : 0);
    }

    //    'prefix:<-A>' => 'PerlOp.p5atime',
    //    'prefix:<-C>' => 'PerlOp.p5ctime',
    //    'prefix:<-M>' => 'PerlOp.p5mtime',
    //    'prefix:<-d>' => 'PerlOp.p5is_directory',
    //    'prefix:<-e>' => 'PerlOp.p5file_exists',
    //    'prefix:<-f>' => 'PerlOp.p5is_file',
    //    'prefix:<-s>' => 'PerlOp.p5size',

    public static final Path resolve_file(PlObject s) throws IOException {
        String name = s.toString();
        if (name.equals(\"_\") && PlV.lastStat != null) {
            return PlV.path.resolve(PlV.lastStat).toRealPath();
        }
        PlV.lastStat = name;
        return PlV.path.resolve(name).toRealPath();
    }

    public static final PlObject p5atime(PlObject s) {
        return PlCORE.die(\"-A not implemented\");
    }
    public static final PlObject p5ctime(PlObject s) {
        return PlCORE.die(\"-C not implemented\");
    }
    public static final PlObject p5mtime(PlObject s) {
        try {
            // TODO - \"Script start time minus file modification time, in days\"
            return new PlDouble(new File(resolve_file(s).toString()).lastModified() / 86400.0);
        }
        catch(IOException e) {
            PlV.sset(\"main::!\", new PlStringLazyError(e));
            return PlCx.UNDEF;
        }
        catch(RuntimeException e) {
            PlV.sset(\"main::!\", new PlStringLazyError(e));
            return PlCx.UNDEF;
        }
    }
    public static final PlObject p5is_directory(PlObject s) {
        try {
            return new PlBool(new File(resolve_file(s).toString()).isDirectory());
        }
        catch(IOException e) {
            PlV.sset(\"main::!\", new PlStringLazyError(e));
            return PlCx.UNDEF;
        }
        catch(RuntimeException e) {
            PlV.sset(\"main::!\", new PlStringLazyError(e));
            return PlCx.UNDEF;
        }
    }
    public static final PlObject p5file_exists(PlObject s) {
        try {
            return new PlBool(new File(resolve_file(s).toString()).exists());
        }
        catch(IOException e) {
            PlV.sset(\"main::!\", new PlStringLazyError(e));
            return PlCx.UNDEF;
        }
        catch(RuntimeException e) {
            PlV.sset(\"main::!\", new PlStringLazyError(e));
            return PlCx.UNDEF;
        }
    }
    public static final PlObject p5is_file(PlObject s) {
        try {
            return new PlBool(new File(resolve_file(s).toString()).isFile());
        }
        catch(IOException e) {
            PlV.sset(\"main::!\", new PlStringLazyError(e));
            return PlCx.UNDEF;
        }
        catch(RuntimeException e) {
            PlV.sset(\"main::!\", new PlStringLazyError(e));
            return PlCx.UNDEF;
        }
    }
    public static final PlObject p5size(PlObject s) {
        try {
            return new PlInt(new File(resolve_file(s).toString()).length());
        }
        catch(IOException e) {
            PlV.sset(\"main::!\", new PlStringLazyError(e));
            return PlCx.UNDEF;
        }
        catch(RuntimeException e) {
            PlV.sset(\"main::!\", new PlStringLazyError(e));
            return PlCx.UNDEF;
        }
    }
    public static final PlObject p5is_symbolic_link(PlObject s) {
        try {
            return new PlBool(Files.isSymbolicLink(resolve_file(s)));
        }
        catch(IOException e) {
            PlV.sset(\"main::!\", new PlStringLazyError(e));
            return PlCx.UNDEF;
        }
        catch(RuntimeException e) {
            PlV.sset(\"main::!\", new PlStringLazyError(e));
            return PlCx.UNDEF;
        }
    }
    public static final PlObject p5is_writable(PlObject s) {
        try {
            return new PlBool(Files.isWritable(resolve_file(s)));
        }
        catch(IOException e) {
            PlV.sset(\"main::!\", new PlStringLazyError(e));
            return PlCx.UNDEF;
        }
        catch(RuntimeException e) {
            PlV.sset(\"main::!\", new PlStringLazyError(e));
            return PlCx.UNDEF;
        }
    }
    public static final PlObject p5is_readable(PlObject s) {
        try {
            return new PlBool(Files.isReadable(resolve_file(s)));
        }
        catch(IOException e) {
            PlV.sset(\"main::!\", new PlStringLazyError(e));
            return PlCx.UNDEF;
        }
        catch(RuntimeException e) {
            PlV.sset(\"main::!\", new PlStringLazyError(e));
            return PlCx.UNDEF;
        }
    }
    public static final PlObject p5is_executable(PlObject s) {
        try {
            return new PlBool(Files.isExecutable(resolve_file(s)));
        }
        catch(IOException e) {
            PlV.sset(\"main::!\", new PlStringLazyError(e));
            return PlCx.UNDEF;
        }
        catch(RuntimeException e) {
            PlV.sset(\"main::!\", new PlStringLazyError(e));
            return PlCx.UNDEF;
        }
    }

    public static final PlObject p5is_named_pipe(PlObject s) {
        // TODO \"-p\"
        return new PlBool(false);
    }

    public static final PlObject list_replicate(PlArray o, PlObject c, int wantarray) {
        if (wantarray == PlCx.SCALAR) {
            return o.aget(-1).string_replicate(c);
        }
        int count = c.to_int();
        PlArray arr = new PlArray();
        int olength = o.to_int();
        if (count > 0) {
            for (int ci = 0; ci < count; ci++) {
                for (int oi = 0; oi < olength; oi++) {
                    // this pushes an alias to the original value, as discussed in
                    // https://beta.nntp.perl.org/group/perl.perl5.porters/2013/06/msg203177.html
                    arr.a.add( o.aget_lvalue(oi) );
                }
            }
        }
        return arr;
    }
    public static final PlObject grep(PlClosure c, PlArray a, PlArray list__, int wantarray) {
        PlArray ret = new PlArray();
        int size = a.to_int();
        PlLvalue v__ref = PlV.Scalar_ARG;
        PlObject v__val = v__ref.get();
        for (int i = 0; i < size; i++) {
            boolean result;
            PlObject temp = a.aget(i);
            v__ref.set(temp);
            result = c.apply(PlCx.SCALAR, list__).to_boolean();
            if (result) {
                ret.push_void(temp);
            }
        }
        v__ref.set(v__val);
        return (wantarray == PlCx.LIST ) ? ret : ret.length_of_array();
    }
    public static final PlObject map(PlClosure c, PlArray a, PlArray list__, int wantarray) {
        if (wantarray == PlCx.LIST ) {
            PlArray ret = new PlArray();
            int size = a.to_int();
            PlLvalue v__ref = PlV.Scalar_ARG;
            PlObject v__val = v__ref.get();
            for (int i = 0; i < size; i++) {
                v__ref.set(a.aget(i));
                ret.push_void(c.apply(PlCx.LIST, list__));
            }
            v__ref.set(v__val);
            return ret;
        }
        else {
            int ret = 0;
            int size = a.to_int();
            PlLvalue v__ref = PlV.Scalar_ARG;
            PlObject v__val = v__ref.get();
            for (int i = 0; i < size; i++) {
                v__ref.set(a.aget(i));
                ret += c.apply(PlCx.LIST, new PlArray()).length_of_array_int();
            }
            v__ref.set(v__val);
            return new PlInt(ret);
        }
    }
    public static final PlObject sort(PlClosure c, PlArray a, PlArray list__, int wantarray) {
        String pkg = c.pkg_name;
        PlArray ret = new PlArray(a);
        PlLvalue v_a_ref = (PlLvalue)PlV.sget(pkg + \"::a\");
        PlLvalue v_b_ref = (PlLvalue)PlV.sget(pkg + \"::b\");
        PerlCompare comp = new PerlCompare(c, v_a_ref, v_b_ref, list__);
        PlObject v_a_val = v_a_ref.get();
        PlObject v_b_val = v_b_ref.get();
        Collections.sort(ret.a, comp);
        v_a_ref.set(v_a_val);
        v_b_ref.set(v_b_val);
        return (wantarray == PlCx.LIST ) ? ret : ret.length_of_array();
    }
    public static final PlObject sort(PlObject c, PlArray a, PlArray list__, int wantarray) {
        if (c.is_coderef()) {
            if (c.is_lvalue()) {
                c = c.get();
            }
            return sort((PlClosure)c, a, list__, wantarray);
        }
        return PlCORE.die(\"Not implemented: first argument to sort() is not a closure\");
    }

    public static PlObject prototype(PlObject arg, String packageName) {
        if (arg.is_coderef()) {
            if (arg.is_lvalue()) {
                arg = arg.get();
            }
            return ((PlClosure)arg).prototype();
        }
        String method = arg.toString();
        PlObject methodCode;
        if (method.indexOf(\"::\") == -1) {
            methodCode = PlV.cget(packageName + \"::\" + method);
        }
        else {
            // fully qualified name
            methodCode = PlV.cget(method);
        }
        if (methodCode.is_coderef()) {
            return prototype(methodCode, packageName); 
        }
        return PlCx.UNDEF;
    }

    private static int _regex_character_class_escape(int offset, String s, StringBuilder sb, int length, boolean flag_xx,
        StringBuilder rejected)
    {
        // inside [ ... ]
        //      space    becomes: \"\\ \" unless the /xx flag is used (flag_xx)
        //      \\120     becomes: \\0120 - Java requires octal sequences to start with zero
        //      \\0       becomes: \\00 - Java requires the extra zero
        //      \\b       is rejected, Java doesn't support \\b inside [...]
        boolean first = true;
        for ( ; offset < length; ) {
            final int c = s.codePointAt(offset);
            switch (c) {
                case ']':
                    if (first) {
                        sb.append(\"\\\\]\");
                        break;
                    }
                    else {
                        sb.append(Character.toChars(c));
                        return offset;
                    }
                case '[':
                    sb.append(\"\\\\[\");
                    break;
                case '\\\\':  // escape - \\[ \\120

                    if (offset < length) {
                        if (s.codePointAt(offset + 1) == 'b') {
                            rejected.append(\"\\\\b\");      // Java doesn't support \\b inside [...]
                            offset++;
                            break;
                        }
                    }

                    sb.append(Character.toChars(c));
                    if (offset < length) {
                        offset++;
                        int c2 = s.codePointAt(offset);
                        if (c2 >= '1' && c2 <= '3') {
                            if (offset < length+1) {
                                int off = offset;
                                int c3 = s.codePointAt(off++);
                                int c4 = s.codePointAt(off++);
                                if ((c3 >= '0' && c3 <= '7') && (c4 >= '0' && c4 <= '7')) {
                                    // a \\000 octal sequence
                                    sb.append('0');
                                }
                            }
                        }
                        else if (c2 == '0') {
                            // rewrite \\0 to \\00
                            sb.append('0');
                        }
                        sb.append(Character.toChars(c2));
                    }
                    break;
                case ' ':
                    if (flag_xx) {
                        sb.append(Character.toChars(c));
                    }
                    else {
                        sb.append(\"\\\\ \");   // make this space a \"token\", even inside /x
                    }
                    break;
                default:
                    sb.append(Character.toChars(c));
                    break;
            }
            first = false;
            offset++;
        }
        return offset;
    }
    private static int _regex_skip_comment(int offset, String s, int length) {
        // [ ... ]
        int offset3 = offset;
        for ( ; offset3 < length; ) {
            final int c3 = s.codePointAt(offset3);
            switch (c3) {
                case ')':
                    return offset3;
                case '\\\\':
                    offset3++;
                    break;
                default:
                    break;
            }
            offset3++;
        }
        return offset;  // possible error - end of comment not found
    }

    // regex escape rules:
    //
    // \\[       as-is
    // [xx xx]  becomes: [xx\\ xx] - this will make sure space is a token, even when /x modifier is set
    // \\120     becomes: \\0120 - Java requires octal sequences to start with zero
    // \\0       becomes: \\00 - Java requires the extra zero
    // (?#...)  inline comment is removed
    // [xx \\b xx]  becomes: (?:[xx xx]|\\b) - java doesn't support \\b as a character
    //
    public static String regex_escape(String s, boolean flag_xx) {
        // escape spaces in character classes
        final int length = s.length();
        StringBuilder sb = new StringBuilder();
        StringBuilder rejected = new StringBuilder();
        for (int offset = 0; offset < length; ) {
            final int c = s.codePointAt(offset);
            switch (c) {
                case '\\\\':  // escape - \\[ \\120
                            sb.append(Character.toChars(c));
                            if (offset < length) {
                                offset++;
                                int c2 = s.codePointAt(offset);
                                if (c2 >= '1' && c2 <= '3') {
                                    if (offset < length+1) {
                                        int off = offset;
                                        int c3 = s.codePointAt(off++);
                                        int c4 = s.codePointAt(off++);
                                        if ((c3 >= '0' && c3 <= '7') && (c4 >= '0' && c4 <= '7')) {
                                            // a \\000 octal sequence
                                            sb.append('0');
                                        }
                                    }
                                }
                                else if (c2 == '0') {
                                    // rewrite \\0 to \\00
                                    sb.append('0');
                                }
                                sb.append(Character.toChars(c2));
                            }
                            break;
                case '[':   // character class
                            int len = sb.length();
                            sb.append(Character.toChars(c));
                            offset++;
                            offset = _regex_character_class_escape(offset, s, sb, length, flag_xx, rejected);
                            if (rejected.length() > 0) {
                                // process \\b inside character class
                                String subseq;
                                if ((sb.length() - len) == 2) {
                                    subseq = \"(?:\" + rejected.toString() + \")\";
                                }
                                else {
                                    subseq = \"(?:\" + sb.substring(len) + \"|\" + rejected.toString() + \")\";
                                }
                                // PlCORE.warn(PlCx.VOID, new PlArray(new PlString(\"Rejected: \" + subseq)));
                                rejected.setLength(0);
                                sb.setLength(len);
                                sb.append(subseq);
                            }
                            break;
                case '(':   
                            boolean append = true;
                            if (offset < length - 3) {
                                int c2 = s.codePointAt(offset+1);
                                int c3 = s.codePointAt(offset+2);
                                int c4 = s.codePointAt(offset+3);
                                if (c2 == '?' && c3 == '#') {
                                    // comment (?# ... )
                                    offset = _regex_skip_comment(offset, s, length);
                                    append = false;
                                }
                                else if (c2 == '?' && c3 == '<' &&
                                        ((c4 >= 'A' && c4 <= 'F') || (c4 >= 'a' && c4 <= 'f') || (c4 == '_'))
                                        )
                                {
                                    // named capture (?<one> ... )
                                    // TODO - replace underscore in name
                                    int endName = s.indexOf(\">\", offset+3);
                                    if (endName > offset) {
                                        String name = s.substring(offset+3, endName);
                                        // PlCORE.say(\"name [\" + name + \"]\");
                                        name = name.replace(\"_\", \"UnderScore\"); // See: regex_named_capture()
                                        sb.append(\"(?<\");
                                        sb.append(name);
                                        sb.append(\">\");
                                        offset = endName;
                                        append = false;
                                    }
                                }
                            }
                            if (append) {
                                sb.append(Character.toChars(c));
                            }
                            break;
                default:    // normal char
                            sb.append(Character.toChars(c));
                            break;
            }
            offset++;
        }
        return sb.toString();
    }

    public static final PlObject set_pos(PlObject vv, PlObject value, PlRegexResult matcher, String str) {
        if (!vv.is_lvalue()) {
            return value;
        }
        PlLvalue var = (PlLvalue)vv;

        if (value.is_undef()) {
            var.pos = null;
            var.regex_zero_length_flag = false;
            return value;
        }

        int pos = value.to_int();

        // check for zero-length match
        int old_pos = var.pos().to_int();

        if (old_pos == pos) {
            // PlCORE.say(\"zero length match\");
            if (var.regex_zero_length_flag) {
                if (matcher.matcher.find()) {
                    matcher.regex_string = str;
                    pos = matcher.matcher.end();

                    // TODO - \$&
                    // String cap1 = str.substring(old_pos, pos);
                    // String cap = str.substring(matcher.start(), matcher.end());
                    // PlCORE.say(\"zero length match [true]: [\" + cap + \"] [\"+ cap1+\"] pos=\" + pos + \" start=\"+matcher.start() + \" end=\"+matcher.end());

                    var.regex_zero_length_flag = false;
                }
                else {
                    reset_match();
                    var.pos = null;
                    return PlCx.UNDEF;
                }
            }
            else {
                var.regex_zero_length_flag = true;
            }
        }

        // TODO - test that pos < string length
        value = new PlInt(pos);
        var.pos = pos;
        return value;
    }

    // ****** regex variables
    // class PlRegexResult
    //     public Matcher matcher;      // regex captures
    //     public String  regex_string; // last string used in a regex

    public static final PlRegexResult set_match(Matcher m, String s) {
        PlRegexResult match = PlV.regex_result;
        match.matcher = m;
        match.regex_string = s;
        return match;
    }
    public static final void reset_match() {
        PlRegexResult match = PlV.regex_result;
        match.matcher = null;
        match.regex_string = null;
    }
    public static final PlObject regex_var(int var_number) {
        if (var_number == 0) {
            return PlV.sget(\"main::0\");
        }
        Matcher matcher = PlV.regex_result.matcher;
        if (matcher == null || var_number > matcher.groupCount() || var_number < 1) {
            return PlCx.UNDEF;
        }
        String cap = matcher.group(var_number);
        if (cap == null) {
            return PlCx.UNDEF;
        }
        return new PlString(cap);
    }
    public static final PlObject regex_var(String var_name) {
        PlRegexResult match = PlV.regex_result;
        Matcher matcher = match.matcher;
        String str = match.regex_string;
        if (matcher == null || str == null) {
            return PlCx.UNDEF;
        }
        if (var_name.equals(\"&\")) {    // \$&
            return new PlString( str.substring(matcher.start(), matcher.end()) );
        }
        if (var_name.equals(\"`\")) {    // \$`
            return new PlString( str.substring(0, matcher.start()) );
        }
        if (var_name.equals(\"'\")) {    // \$'
            return new PlString( str.substring(matcher.end()) );
        }
        return PlCx.UNDEF;
    }
    public static final PlObject regex_named_capture(String var_name) {
        if (var_name == null) {
            return PlCx.UNDEF;
        }
        Matcher matcher = PlV.regex_result.matcher;
        if (matcher == null) {
            return PlCx.UNDEF;
        }
        try {
            var_name = var_name.replace(\"_\", \"UnderScore\"); // See: regex_escape()
            String cap = matcher.group(var_name);
            if (cap == null) {
                return PlCx.UNDEF;
            }
            return new PlString(cap);
        } catch (Exception e) {
        }
        return PlCx.UNDEF;
    }

    // ****** end regex variables

    public static final PlObject match(PlObject input, PlRegex pat, int want, boolean global, boolean c_flag) {
        // 'want'    context (PlCx.LIST, PlCx.SCALAR, PlCx.VOID)
        // 'global'  g  - globally match the pattern repeatedly in the string
        // 'c_flag'  c  - keep the current position during repeated matching

        String str = input.toString();
        if (want != PlCx.LIST) {
            Matcher matcher = pat.p.matcher(str);
            if (global) {
                // scalar context, global match
                PlObject pos = input.pos();
                boolean find;
                if (pos.is_undef()) {
                    find = matcher.find();
                }
                else {
                    find = matcher.find(pos.to_int());
                }
                if (find) {
                    PlRegexResult match = set_match(matcher, str);
                    set_pos(input, new PlInt(matcher.end()), match, str);
                    return PlCx.TRUE;
                }
                else {
                    // reset_match();
                    if (!c_flag) {
                        set_pos(input, PlCx.UNDEF, null, null);
                    }
                    return PlCx.FALSE;
                }
            }
            else {
                // scalar context, non-global match
                if (matcher.find()) {
                    set_match(matcher, str);
                    return PlCx.TRUE;
                }
                else {
                    // reset_match();
                    return PlCx.FALSE;
                }
            }
        }
        // list context
        Matcher matcher = pat.p.matcher(str);
        PlArray ret = new PlArray();
        if (global) {
            // list context, global match
            // Note: if there are no captures, then return the matched substrings
            boolean found = false;
            while (matcher.find()) {
                found = true;
                int count = matcher.groupCount();
                if (count > 0) {
                    for (int i = 1; i <= count; i++) {
                        String cap = matcher.group(i);
                        if (cap == null) {
                            ret.push_void(PlCx.UNDEF);
                        }
                        else {
                            ret.push_void(cap);
                        }
                    }
                }
                else {
                    String cap = matcher.group();
                    if (cap == null) {
                        ret.push_void(PlCx.UNDEF);
                    }
                    else {
                        ret.push_void(cap);
                    }
                }
            }
            if (found) {
                set_match(matcher, str);
            }
            else {
                // reset_match();
            }
            set_pos(input, PlCx.UNDEF, null, null);
            return ret;
        }
        else {
            // list context, non-global match
            if (matcher.find()) {
                set_match(matcher, str);
                for (int i = 1; i <= matcher.groupCount(); i++) {
                    String cap = matcher.group(i);
                    if (cap == null) {
                        ret.push_void(PlCx.UNDEF);
                    }
                    else {
                        ret.push_void(cap);
                    }
                }
            }
            else {
                // reset_match();
            }
            return ret;
        }
    }
    public static final PlObject match(PlObject s, PlLvalue pat, int want, boolean global, boolean c_flag) {
        return match(s, pat.get(), want, global, c_flag);
    }
    public static final PlObject match(PlObject s, PlObject pat, int want, boolean global, boolean c_flag) {
        // TODO - cache the compiled pattern
        return match(s, new PlRegex(pat, 0, false), want, global, c_flag);
    }

    public static final PlObject replace(PlLvalue s, PlRegex pat, PlClosure rep, int want, boolean global, boolean replace_flag) {
        String str = s.toString();
        int count = 0;
        Matcher matcher = pat.p.matcher(str);
        if (global) {
            final StringBuilder buf = new StringBuilder(str.length() + 256);
            int pos = 0;
            while (matcher.find()) {
                count++;
                set_match(matcher, str);
                int start = matcher.start();
                int end   = matcher.end();
                String replace = rep.apply_do_block(PlCx.SCALAR, want, new PlArray()).toString();
                if (start > pos) {
                    buf.append( str.substring(pos, start) );
                }
                if (replace.length() > 0) {
                    buf.append( replace );
                }
                pos = end;
            }
            if (count > 0) {
                if (pos <= str.length()) {
                    buf.append( str.substring(pos) );
                }
                if (replace_flag) {
                    s.set(new PlString(buf.toString()));
                }
            }
        }
        else {
            if (matcher.find()) {
                count++;
                set_match(matcher, str);
                int start = matcher.start();
                int end   = matcher.end();
                String replace = rep.apply_do_block(PlCx.SCALAR, want, new PlArray()).toString();
                final StringBuilder buf = new StringBuilder(str.length() + replace.length());
                if (start > 0) {
                    buf.append( str.substring(0, start) );
                }
                if (replace.length() > 0) {
                    buf.append( replace );
                }
                if (end <= str.length()) {
                    buf.append( str.substring(end) );
                }
                if (replace_flag) {
                    s.set(new PlString(buf.toString()));
                }
            }
        }
        if (count == 0) {
            // no match
            return PlCx.FALSE;
        }
        return new PlInt(count);
    }
    public static final PlObject replace(PlLvalue s, PlRegex pat, String replace, int want, boolean global, boolean replace_flag) {
        String str = s.toString();
        int count = 0;
        Matcher matcher = pat.p.matcher(str);
        if (global) {
            final StringBuilder buf = new StringBuilder(str.length() + 256);
            int pos = 0;
            while (matcher.find()) {
                count++;
                set_match(matcher, str);
                int start = matcher.start();
                int end   = matcher.end();
                if (start > pos) {
                    buf.append( str.substring(pos, start) );
                }
                if (replace.length() > 0) {
                    buf.append( replace );
                }
                pos = end;
            }
            if (count > 0) {
                if (pos <= str.length()) {
                    buf.append( str.substring(pos) );
                }
                if (replace_flag) {
                    s.set(new PlString(buf.toString()));
                }
            }
        }
        else {
            if (matcher.find()) {
                count++;
                set_match(matcher, str);
                int start = matcher.start();
                int end   = matcher.end();
                final StringBuilder buf = new StringBuilder(str.length() + replace.length());
                if (start > 0) {
                    buf.append( str.substring(0, start) );
                }
                if (replace.length() > 0) {
                    buf.append( replace );
                }
                if (end <= str.length()) {
                    buf.append( str.substring(end) );
                }
                if (replace_flag) {
                    s.set(new PlString(buf.toString()));
                }
            }
        }
        if (count == 0) {
            // no match
            return PlCx.FALSE;
        }
        return new PlInt(count);
    }

    public static final PlObject replace(PlLvalue s, PlRegex pat, PlObject rep, int want, boolean global, boolean replace_flag) {
        if (rep.is_coderef()) {
            return replace(s, pat, (PlClosure)rep, want, global, replace_flag);
        }
        return replace(s, pat, rep.toString(), want, global, replace_flag);
    }
    public static final PlObject replace(PlObject s, PlObject pat, PlObject rep, int want, boolean global, boolean replace_flag) {
        if (!s.is_lvalue()) {
            if (!replace_flag) {
                PlLvalue lv = new PlLvalue(s);
                return replace(lv, new PlRegex(pat, 0, false), rep, want, global, replace_flag);
            }
            PlCORE.die(\"Can't modify constant item in substitution (s///)\");
        }
        // TODO - cache the compiled pattern
        return replace((PlLvalue)s, new PlRegex(pat, 0, false), rep, want, global, replace_flag);
    }
    public static final PlObject replace(PlObject s, PlObject pat, String rep, int want, boolean global, boolean replace_flag) {
        if (!s.is_lvalue()) {
            if (!replace_flag) {
                PlLvalue lv = new PlLvalue(s);
                return replace(lv, new PlRegex(pat, 0, false), rep, want, global, replace_flag);
            }
            PlCORE.die(\"Can't modify constant item in substitution (s///)\");
        }
        // TODO - cache the compiled pattern
        return replace((PlLvalue)s, new PlRegex(pat, 0, false), rep, want, global, replace_flag);
    }

    // \$v =~ tr/xyz/abc/i
    // PerlOp.tr(v_v_100, new PlString(\"xyz\"), new PlString(\"abc\"), \"\", PlCx.VOID)
    public static final PlObject tr(PlObject pstr, PlObject psearchChars, PlObject preplaceChars, String modifier, int want) {
        String str          = pstr.toString();
        String searchChars  = psearchChars.toString();
        String replaceChars = preplaceChars.toString();
        boolean complement   = modifier.indexOf(\"c\") < 0 ? false : true;  // c = complement
        boolean replace_flag = modifier.indexOf(\"r\") < 0 ? true : false;  // r = replace flag
        int modified = 0;
        final int replaceCharsLength = replaceChars.length();
        final int strLength = str.length();
        final StringBuilder buf = new StringBuilder(strLength);

        if (complement) {
            for (int i = 0; i < strLength; i++) {
                final char ch = str.charAt(i);
                final int index = searchChars.indexOf(ch);
                if (index < 0) {
                    // not found
                    modified++;
                    if (replaceCharsLength > 0) {
                        buf.append(replaceChars.charAt(replaceCharsLength - 1));
                    }
                } else {
                    buf.append(ch);
                }
            }
        }
        else {
            for (int i = 0; i < strLength; i++) {
                final char ch = str.charAt(i);
                final int index = searchChars.indexOf(ch);
                if (index >= 0) {
                    modified++;
                    if (index < replaceCharsLength) {
                        buf.append(replaceChars.charAt(index));
                    }
                } else {
                    buf.append(ch);
                }
            }
        }

        if (modified > 0 && replace_flag) {
            pstr.set(new PlString(buf.toString()));
        }
        return new PlInt(modified);
    }


    // looks_like_number
    private static int _parse_space(String s, int length, int offset) {
        for ( ; offset < length; offset++ ) {
            final int c3 = s.codePointAt(offset);
            switch (c3) {
                case ' ': case '\\t': case '\\n': case '\\r':
                    break;
                default:
                    return offset;
            }
        }
        return offset;
    }
    private static boolean _parse_space_to_end(String s, int length, int offset) {
        for ( ; offset < length; offset++ ) {
            final int c3 = s.codePointAt(offset);
            switch (c3) {
                case ' ': case '\\t': case '\\n': case '\\r':
                    break;
                default:
                    return false;
            }
        }
        return true;
    }
    private static boolean _parse_exp(String s, int length, int offset) {
        // 123.45E^^^
        final int c = s.codePointAt(offset);
        if (c == '+' || c == '-') {
            offset++;
            if (offset >= length) {
                return false;
            }
        }
        for ( ; offset < length; offset++ ) {
            final int c3 = s.codePointAt(offset);
            switch (c3) {
                case '0': case '1': case '2': case '3': case '4':
                case '5': case '6': case '7': case '8': case '9':
                    break;
                default:
                    return _parse_space_to_end(s, length, offset);
            }
        }
        return true;
    }
    private static boolean _parse_dot(String s, int length, int offset) {
        // 123.^^^
        for ( ; offset < length; offset++ ) {
            final int c3 = s.codePointAt(offset);
            switch (c3) {
                case '0': case '1': case '2': case '3': case '4':
                case '5': case '6': case '7': case '8': case '9':
                    break;
                case 'E': case 'e':
                    return _parse_exp(s, length, offset+1);
                default:
                    return _parse_space_to_end(s, length, offset);
            }
        }
        return true;
    }
    private static boolean _parse_int(String s, int length, int offset) {
        // 123
        for ( ; offset < length; offset++ ) {
            final int c3 = s.codePointAt(offset);
            switch (c3) {
                case '0': case '1': case '2': case '3': case '4':
                case '5': case '6': case '7': case '8': case '9':
                    break;
                case '.':
                    return _parse_dot(s, length, offset+1);
                case 'E': case 'e':
                    return _parse_exp(s, length, offset+1);
                default:
                    return _parse_space_to_end(s, length, offset);
            }
        }
        return true;
    }
    public static boolean looks_like_number(String s) {
        final int length = s.length();
        int offset = _parse_space(s, length, 0);
        if (offset >= length) {
            return false;
        }
        int c = s.codePointAt(offset);
        if (c == '+' || c == '-') {
            offset++;
            if (offset >= length) {
                return false;
            }
            c = s.codePointAt(offset);
        }
        switch (c) {
            case 'i': case 'I':
                        return s.substring(offset, offset+3).equalsIgnoreCase(\"inf\");
            case 'n': case 'N':
                        return s.substring(offset, offset+3).equalsIgnoreCase(\"nan\");
            case '.':
                        offset++;
                        if (offset >= length) {
                            return false;
                        }
                        final int c3 = s.codePointAt(offset);
                        switch (c3) {
                            case '0': case '1': case '2': case '3': case '4':
                            case '5': case '6': case '7': case '8': case '9':
                                return _parse_dot(s, length, offset+1);
                        }
            case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':
                        return _parse_int(s, length, offset+1);
        }
        return false;
    }
    public static boolean looks_like_number(PlObject arg) {
        if (arg.is_num() || arg.is_int()) {
            return true;
        }
        return looks_like_number(arg.toString());
    }
    public static long _parse_oct(String s, int base) {
        try {
            s = s.replace(\"_\",\"\");
            return Long.parseLong(s, base);
        } catch (NumberFormatException n) {
        } catch (Exception e) {
        }
        return 0;
    }
    public static long oct(String s) {
        final int length = s.length();
        int c;

        for (int i = 0; i < length; i++ ) {
            c = s.codePointAt(i);
            if (c > 254) {
                PlCORE.die(\"Wide character in oct\");
            }
        }

        int offset = _parse_space(s, length, 0);
        if (offset >= length) {
            return 0;
        }
        int start = offset;
        c = s.codePointAt(offset);
        if (c == '0') {
            start++;
            offset++;
            if (offset >= length) {
                return 0;
            }
            c = s.codePointAt(offset);
        }
        boolean ul = false;
        switch (c) {
            case 'x': case 'X':
                    start++;
                    offset++;
                    for ( ; offset < length; offset++ ) {
                        c = s.codePointAt(offset);
                        if (c == '_') {
                            if (ul) {
                                return _parse_oct(s.substring(start, offset), 16);
                            }
                            ul = true;
                        }
                        else if ((c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f') || (c >= '0' && c <= '9')) {
                            ul = false;
                        }
                        else {
                            return _parse_oct(s.substring(start, offset), 16);
                        }
                    }
                    return _parse_oct(s.substring(start, offset), 16);
            case 'b': case 'B':
                    start++;
                    offset++;
                    for ( ; offset < length; offset++ ) {
                        c = s.codePointAt(offset);
                        switch (c) {
                            case '_':
                                if (ul) {
                                    return _parse_oct(s.substring(start, offset), 2);
                                }
                                ul = true;
                                break;
                            case '0': case '1':
                                ul = false;
                                break;
                            default:
                                return _parse_oct(s.substring(start, offset), 2);
                        }
                    }
                    return _parse_oct(s.substring(start, offset), 2);
            case '0': case '1': case '2': case '3': case '4':
            case '5': case '6': case '7': case '_':
                    for ( ; offset < length; offset++ ) {
                        c = s.codePointAt(offset);
                        switch (c) {
                            case '_':
                                if (ul) {
                                    return _parse_oct(s.substring(start, offset), 8);
                                }
                                ul = true;
                                break;
                            case '0': case '1': case '2': case '3': case '4':
                            case '5': case '6': case '7':
                                ul = false;
                                break;
                            default:
                                return _parse_oct(s.substring(start, offset), 8);
                        }
                    }
                    return _parse_oct(s.substring(start, offset), 8);
        }
        return 0;
    }

}

"), ("
class PlV {
    // PlV implements namespaces and global variables
    //
    // TODO - import CORE subroutines in new namespaces, if needed

    public static PlRegexResult regex_result = new PlRegexResult();
    public static Path path;
    public static PlFileHandle STDIN  = (PlFileHandle)PlStringConstant.getConstant(\"main::STDIN\").fileRef.o;
    public static PlFileHandle STDOUT = (PlFileHandle)PlStringConstant.getConstant(\"main::STDOUT\").fileRef.o;
    public static PlFileHandle STDERR = (PlFileHandle)PlStringConstant.getConstant(\"main::STDERR\").fileRef.o;

    // initialize special variables like \$_ \$\\
"), ((map {
            my $java_name = $Perlito5::Java::special_scalar{$_};
            my $index = $special_var_index{$_}->[0];
            my $class = $special_var_index{$_}->[1];
            "
    public static " . $class . " " . $java_name . " = new " . $class . "();    // \$" . $_ . "
"
        } sort {;
            $a cmp $b
        } keys(%Perlito5::Java::special_scalar))), ("
    public static PlObject boolean_stack;
    public static PlArray local_stack = new PlArray();
    public static Random random = new Random();
    public static String lastStat = null;

    public static final void init(String[] args) {
        // \@ARGV
        PlV.array_set(\"main::ARGV\", new PlArray(args));               // args is String[]
        // %ENV
        PlV.hash_set(\"main::ENV\",   new PlArray(System.getenv()));    // env  is Map<String, String>
        // \$\" = \" \"
        PlV.sset(\"main::\" + (char)34, new PlString(\" \"));
        // \$^O = \"Unix\"; default = \"perlito5\"
        PlV.sset(\"main::\" + (char)15, new PlString( System.getProperty(\"os.name\", \"perlito5\") ));
        // \$/ = \"\\n\"
        PlV.sset(\"main::/\", new PlString( System.getProperty(\"line.separator\", \"\\n\") ));
        // \$; = \\034
        PlV.sset(\"main::;\", new PlString((char)28));
        // \$^T = time at start
        PlV.sset(\"main::\" + (char)20, PlCORE.time(PlCx.SCALAR, new PlArray()));

        PlV.STDIN.inputStream   = System.in;
        PlV.STDIN.reader        = new BufferedReader(new InputStreamReader(System.in));
        PlV.STDIN.eof           = false;
        PlV.STDIN.typeglob_name = \"main::STDIN\";
        PlV.STDIN.charset       = \"UTF-8\";
        PlFileHandle.allOpenFiles.add(PlV.STDIN);

        PlV.STDOUT.outputStream = System.out;
        PlV.STDOUT.typeglob_name = \"main::STDOUT\";
        PlV.STDOUT.charset       = \"UTF-8\";
        PlFileHandle.allOpenFiles.add(PlV.STDOUT);

        PlV.STDERR.outputStream = System.err;
        PlV.STDERR.typeglob_name = \"main::STDERR\";
        PlV.STDERR.charset       = \"UTF-8\";
        PlFileHandle.allOpenFiles.add(PlV.STDERR);

        try {
            PlV.path = Paths.get(\".\").toRealPath();
        }
        catch (IOException e) {
            // don't know what to do
        }

        PlV.fset(\"main::STDIN\",  PlV.STDIN);                             // \"GLOB\"
        PlV.fset(\"main::STDOUT\", PlV.STDOUT);
        PlV.fset(\"main::STDERR\", PlV.STDERR);

        PlV.cset(\"UNIVERSAL::can\", new PlClosure(PlCx.UNDEF, new PlObject[]{  }, \"UNIVERSAL\", true) {
            public PlObject apply(int want, PlArray List__) {
                PlObject self = List__.shift();
                String method_name = List__.shift().toString();
                PlClass bless = self.blessed_class();
                if ( bless != null ) {
                    PlObject methodCode = bless.method_lookup(method_name, 0);
                    if (methodCode.is_coderef()) {
                        return methodCode;
                    }
                    return PlCx.UNDEF;
                }

                // calling can() as a class method
                PlObject methodCode = PlClass.getInstance(self).method_lookup(method_name, 0);
                if (methodCode.is_coderef()) {
                    return methodCode;
                }

                return PlCx.UNDEF;
            }
        });
        PlV.cset(\"UNIVERSAL::isa\", new PlClosure(PlCx.UNDEF, new PlObject[]{  }, \"UNIVERSAL\", true) {
            public PlObject apply(int want, PlArray List__) {
                PlObject self = List__.shift();
                String class_name = List__.shift().toString();
                PlClass bless = self.blessed_class();
                if ( bless != null ) {
                    return bless.isa(class_name, 0);
                }

                // reftype == \"ARRAY\"
                if (self.reftype().toString().equals(class_name)) {
                    return PlCx.INT1;
                }

                // calling isa() as a class method
                bless = PlClass.getInstance(self);
                if ( bless != null ) {
                    return bless.isa(class_name, 0);
                }

                return PlCx.UNDEF;
            }
        });

        PerlOp.reset_match();
    }
    public static final void teardown() {

        // TODO - catch error in END
        // Perlito5::set_global_phase(\"END\");
        // eval {
        //     \$_->() for \@Perlito5::END_BLOCK;
        //     1;
        // }
        // or warn \"\$\@\\nEND failed--call queue aborted.\\n\"

        // Perlito5::set_global_phase(\"END\");
        PlV.sset(\"main::\" + (char)7 + \"LOBAL_PHASE\", new PlStringConstant(\"END\"));

        // \$_->() for \@Perlito5::END_BLOCK;
        for (PlObject tmp : PlArray.construct_list_of_aliases(PlV.array_get(\"Perlito5::END_BLOCK\"))) {
            tmp.apply(PlCx.VOID, new PlArray());
        }

        PlFileHandle.close_all_files();
    }

    // scalar
    public static final PlLvalue sget(String name) {
        return PlStringConstant.getConstant(name).scalarRef;
    }
    public static final PlLvalue sget_local(String name) {
        return (PlLvalue)PerlOp.push_local_scalar(PlCx.UNDEF, name);
    }
    public static final PlObject sset(String name, PlObject v) {
        return PlStringConstant.getConstant(name).scalarRef.set(v);
    }
    public static final PlObject sset(String name, Object o) {
        return PlStringConstant.getConstant(name).scalarRef.set(PlJavaObject.fromObject(o));
    }
    public static final PlObject sset_local(String name, PlObject v) {
        return PerlOp.push_local_scalar(v, name);
    }
    public static final void sset_alias(String name, PlLvalue v) {
        PlStringConstant.getConstant(name).scalarRef = v;
    }

    // accessors for special variables like \$_ \$\\
"), ((map {
            my $java_name = $Perlito5::Java::special_scalar{$_};
            my $index = $special_var_index{$_}->[0];
            my $class = $special_var_index{$_}->[1];
            "
    public static final PlLvalue sget_local_" . $java_name . "() {
        PerlOp.push_local_special_var_" . $java_name . "();
        return " . $java_name . ";
    }
    public static final PlObject sset_local_" . $java_name . "(PlObject v) {
        PerlOp.push_local_special_var_" . $java_name . "();
        return " . $java_name . ".set(v);
    }
    public static final void sset_alias_" . $java_name . "(" . $class . " v) {
        " . $java_name . " = v;
    }
"
        } sort {;
            $a cmp $b
        } keys(%Perlito5::Java::special_scalar))), ("
    public static final PlLvalue cget(String name) {
        // this implements \" \\&name \"
        PlLvalue code = PlStringConstant.getConstant(name).codeRef;
        if ( code.is_coderef() ) {
            return code;
        }
        int pos = name.lastIndexOf(\"::\");
        if (pos == -1) {
            return code;
        }
        String namespace = name.substring(0, pos);
        PlLvalue autoload = PlV.cget_no_autoload(namespace + \"::AUTOLOAD\");
        if ( autoload.is_coderef() ) {
            PlV.sset(namespace + \"::AUTOLOAD\", new PlString(name));
            return autoload;
        }
        return code;
    }
    public static final PlLvalue cget_local(String name) {
        return (PlLvalue)PerlOp.push_local_named_sub(PlCx.UNDEF, name);
    }
    public static final PlLvalue cget_no_autoload(String name) {
        return PlStringConstant.getConstant(name).codeRef;
    }
    public static final PlObject cset(String name, PlObject v) {
        return PlStringConstant.getConstant(name).codeRef.set(v);
    }
    public static final PlObject cset_local(String name, PlObject v) {
        return PerlOp.push_local_named_sub(v, name);
    }
    public static final void cset_alias(String name, PlLvalue v) {
        PlStringConstant.getConstant(name).codeRef = v;
    }

    // hash
    public static final PlHash hash_get(String name) {
        return PlStringConstant.getConstant(name).hashRef.hash_deref_strict();
    }
    public static final PlHash hash_get_local(String name) {
        PlLvalue o = (PlLvalue)PerlOp.push_local_hash(new PlHashRef(), name);
        return o.hash_deref_strict();
    }
    public static final PlObject hash_set(String name, PlObject v) {
        PlLvalue o = PlStringConstant.getConstant(name).hashRef;
        return o.hash_deref_set(v);
    }
    public static final PlObject hash_set_local(String name, PlObject v) {
        PlLvalue o = (PlLvalue)PerlOp.push_local_hash(new PlHashRef(), name);
        return o.hash_deref_set(v);
    }
    public static final PlLvalue hget(String name) {
        return PlStringConstant.getConstant(name).hashRef;
    }
    public static final PlLvalue hget_local(String name) {
        return (PlLvalue)PerlOp.push_local_hash(new PlHashRef(), name);
    }
    public static final PlObject hset(String name, PlObject v) {
        return PlStringConstant.getConstant(name).hashRef.set(v);
    }
    public static final PlObject hset(String name, PlLvalue v) {
        return PlStringConstant.getConstant(name).hashRef.set(v);
    }
    public static final PlObject hset_local(String name, PlObject v) {
        return (PlLvalue)PerlOp.push_local_hash(v, name);
    }
    public static final void hset_alias(String name, PlHash v) {
        PlStringConstant.getConstant(name).hashRef = new PlLvalue(v);
    }

    // array
    public static final PlArray array_get(String name) {
        return PlStringConstant.getConstant(name).arrayRef.array_deref_strict();
    }
    public static final PlArray array_get_local(String name) {
        PlLvalue o = (PlLvalue)PerlOp.push_local_array(new PlArrayRef(), name);
        return o.array_deref_strict();
    }
    public static final PlObject array_set(String name, PlObject v) {
        PlLvalue o = PlStringConstant.getConstant(name).arrayRef;
        return o.array_deref_set(v);
    }
    public static final PlObject array_set_local(String name, PlObject v) {
        PlLvalue o = (PlLvalue)PerlOp.push_local_array(new PlArrayRef(), name);
        return o.array_deref_set(v);
    }
    public static final PlLvalue aget(String name) {
        return PlStringConstant.getConstant(name).arrayRef;
    }
    public static final PlLvalue aget_local(String name) {
        return (PlLvalue)PerlOp.push_local_array(new PlArrayRef(), name);
    }
    public static final PlObject aset(String name, PlObject v) {
        return PlStringConstant.getConstant(name).arrayRef.set(v);
    }
    public static final PlObject aset_local(String name, PlObject v) {
        return (PlLvalue)PerlOp.push_local_array(v, name);
    }
    public static final void aset_alias(String name, PlArray v) {
        PlStringConstant.getConstant(name).arrayRef = new PlLvalue(v);
    }

    // filehandle
    public static final PlLvalue fget(String name) {
        return PlStringConstant.getConstant(name).fileRef;
    }
    public static final PlLvalue fget_local(String name) {
        return (PlLvalue)PerlOp.push_local_array(new PlFileHandle(name), name);
    }
    public static final PlObject fset(String name, PlObject v) {
        return PlStringConstant.getConstant(name).fileRef.set(v);
    }
    public static final PlObject fset_local(String name, PlObject v) {
        return (PlLvalue)PerlOp.push_local_array(v, name);
    }

    // code
    public static final PlObject code_lookup_by_name(String nameSpace, PlObject name) {
        if (name.is_coderef()) {
            return name;
        }
        if (name.is_bool() && name.to_boolean()) {
            // RT #63790:  calling PL_sv_yes as a sub is special-cased to silently
            // return (so Foo->import() silently fails if import() doesn't exist),
            return name;
        }
        String s = name.toString();
        if (s.indexOf(\"::\") == -1) {
            s = nameSpace + \"::\" + s;
        }
        return PlV.cget(s);
    }
    public static final PlObject code_lookup_by_name_no_autoload(String nameSpace, PlObject name) {
        if (name.is_coderef()) {
            return name;
        }
        String s = name.toString();
        if (s.indexOf(\"::\") == -1) {
            s = nameSpace + \"::\" + s;
        }
        return PlV.cget_no_autoload(s);
    }

    // glob
    public static final PlObject glob_set(PlObject name, PlObject value, String nameSpace) {
        return glob_set(name.toString(), value, nameSpace);
    }
    public static final PlObject glob_set(String name, PlObject value, String nameSpace) {
        if (value.is_lvalue()) {
            value = value.get();
        }
        if (value.is_coderef()) {
            PlV.cset(name, value);
        }
        else if (value.is_hashref()) {
            PlV.hset(name, value);
        }
        else if (value.is_arrayref()) {
            PlV.aset(name, value);
        }
        else if (value.is_scalarref()) {
            PlV.sset(name, value.scalar_deref(nameSpace));
        }
        else if (value.is_typeglobref()) {
            // *x = \\*y
            PlGlobRef gl = (PlGlobRef)value;
            return glob_set(name, gl.filehandle, nameSpace);
        }
        else if (value.is_filehandle()) {
            // *x = *y
            PlFileHandle fh = (PlFileHandle)value;
            String typeglob_name = fh.typeglob_name;
            if (typeglob_name == null) {
                PlCORE.die(\"not implemented assign anonymous typeglob to typeglob\");
            }
            return glob_set(name, new PlString(typeglob_name), nameSpace);
        }
        else if (!value.is_ref()) {
            String typeglob_name = value.toString();
            if (typeglob_name.indexOf(\"::\") == -1) {
                typeglob_name = nameSpace + \"::\" + typeglob_name;
            }
            // TODO - share lvalue containers (alias)
            PlV.fset(name, PlV.fget(typeglob_name));
            PlV.cset_alias(name, PlV.cget(typeglob_name));
            PlV.sset_alias(name, PlV.sget(typeglob_name));
            PlV.aset(name, PlV.aget(typeglob_name));
            PlV.hset(name, PlV.hget(typeglob_name));
        }
        else {
            PlCORE.die(\"not implemented assign \" + value.ref() + \" to typeglob\");
        }
        return value;
    }
    public static final PlObject glob_set_local(PlString name, PlObject value, String nameSpace) {
        return glob_set_local(name.toString(), value, nameSpace);
    }
    public static final PlObject glob_set_local(String name, PlObject value, String nameSpace) {
        if (value.is_coderef()) {
            PlV.cset_local(name, value);
        }
        else if (value.is_hashref()) {
            PlV.hset_local(name, value);
        }
        else if (value.is_arrayref()) {
            PlV.aset_local(name, value);
        }
        else if (value.is_scalarref()) {
            PlV.sset_local(name, value);
        }
        else if (value.is_typeglobref()) {
            // local *x = \\*y
            PlGlobRef gl = (PlGlobRef)value;
            return glob_set_local(name, gl.filehandle, nameSpace);
        }
        else if (value.is_filehandle()) {
            // local *x = *y
            PlFileHandle fh = (PlFileHandle)value;
            String typeglob_name = fh.typeglob_name;
            if (typeglob_name == null) {
                PlCORE.die(\"not implemented assign anonymous typeglob to typeglob\");
            }
            return glob_set_local(name, new PlString(typeglob_name), nameSpace);
        }
        else if (!value.is_ref()) {
            String typeglob_name = value.toString();
            if (typeglob_name.indexOf(\"::\") == -1) {
                typeglob_name = nameSpace + \"::\" + typeglob_name;
            }
            // TODO - share lvalue containers (alias)
            PlV.fset_local(name, PlV.fget(typeglob_name));
            PlV.cset_local(name, PlCx.UNDEF);
            PlV.cset_alias(name, PlV.cget(typeglob_name));
            PlV.sset_local(name, PlCx.UNDEF);
            PlV.sset_alias(name, PlV.sget(typeglob_name));
            PlV.aset_local(name, PlV.aget(typeglob_name));
            PlV.hset_local(name, PlV.hget(typeglob_name));
        }
        else {
            PlCORE.die(\"not implemented assign \" + value.ref() + \" to typeglob\");
        }
        return value;
    }
    public static final PlObject make_reference(PlObject value) {
        if (value.is_filehandle()) {
            return new PlGlobRef(value);
        }
        return new PlLvalueRef(value);
    }
    public static final PlObject make_reference(PlLvalue value) {
        if (value.is_filehandle()) {
            return new PlGlobRef(value);
        }
        return new PlLvalueRef(value);
    }

}
class PlObject implements Cloneable, Iterable<PlObject> {
    public static final String REF_str = new String(\"\");
    public static final PlStringConstant REF = new PlStringConstant(REF_str);

    public Iterator<PlObject> iterator() {
        // if (this.is_array()) {
        //     return ((PlArray)this).iterator();
        // }
        // if (this.is_hash()) {
        //     return ((PlHash)this).iterator();
        // }
        // if (this.is_lvalue()) {
        //     return ((PlLvalue)this).iterator();
        // }
        return new PlLvalueIterator(new PlROvalue(this)); 
    }

    public PlObject() {
    }
"), ((map {
            my $class = $java_classes{$_};
            my $java_class_name = $class->{"java_type"};
            my $perl_to_java = $class->{"perl_to_java"};
            $class->{"import"} || $class->{"extends"} || $class->{"implements"} ? "    public " . $java_class_name . " " . $perl_to_java . "() {
" . ("        PlCORE.die(\"error ." . $perl_to_java . "!\");
") . "        return null;
" . "    }
" : ()
        } grep {;
            $java_classes{$_}->{"perl_to_java"}
        } sort {;
            $a cmp $b
        } keys(%java_classes))), ("    // public String toString() {
    //     return this.toString();
    // }
    public PerlArgumentLookupResult castToClass(ArrayList<Class[]> params, int pos) {
        // want String
        for (Class[] cl : params) {
            if (cl[pos].equals( \"\".getClass() )) {
                return new PerlArgumentLookupResult( this.toString(), cl[pos] );
            }
        }
        // want int
        for (Class[] cl : params) {
            if (cl[pos].equals( java.lang.Integer.TYPE )) {
                return new PerlArgumentLookupResult( this.to_int(), cl[pos] );
            }
        }
        // want long
        for (Class[] cl : params) {
            if (cl[pos].equals( java.lang.Long.TYPE )) {
                return new PerlArgumentLookupResult( this.to_long(), cl[pos] );
            }
        }
        // want boolean
        for (Class[] cl : params) {
            if (cl[pos].equals( java.lang.Boolean.TYPE )) {
                return new PerlArgumentLookupResult( this.to_boolean(), cl[pos] );
            }
        }
        // want double
        for (Class[] cl : params) {
            if (cl[pos].equals( java.lang.Double.TYPE )) {
                return new PerlArgumentLookupResult( this.to_double(), cl[pos] );
            }
        }
        // want float
        for (Class[] cl : params) {
            if (cl[pos].equals( java.lang.Float.TYPE )) {
                return new PerlArgumentLookupResult( this.to_float(), cl[pos] );
            }
        }
        // want array
        for (Class[] cl : params) {
            if (cl[pos].isArray() && pos == (cl.length - 1)) {
                // varargs
                return new PerlArgumentLookupResult( null, cl[pos] );
            }
        }

        // default: return the Perl class
        return new PerlArgumentLookupResult( this, this.getClass() );
    }
    public int to_int() {
        long v = this.to_long();
        if (v > Integer.MAX_VALUE || v < Integer.MIN_VALUE) {
            PlCORE.die(\"numeric overflow converting to int\");
        }
        return (int)v;
    }
    public byte to_byte() {
        long v = this.to_long();
        if (v > Byte.MAX_VALUE || v < Byte.MIN_VALUE) {
            PlCORE.die(\"numeric overflow converting to byte\");
        }
        return (byte)v;
    }
    public short to_short() {
        long v = this.to_long();
        if (v > Short.MAX_VALUE || v < Short.MIN_VALUE) {
            PlCORE.die(\"numeric overflow converting to short\");
        }
        return (short)v;
    }
    public float to_float() {
        double v = this.to_double();
        if (v > Float.MAX_VALUE || v < Float.MIN_VALUE) {
            PlCORE.die(\"numeric overflow converting to float\");
        }
        return (float)v;
    }
    public long to_long() {
        return 0;
    }
    public double to_double() {
        return 0.0;
    }
    public boolean to_boolean() {
        return false;
    }
    public PlObject to_num() {
        return PlCx.INT0;
    }
    public char to_char() {
        return (char)(this.to_int());
    }
    public PlObject pos() {
        return PlCx.UNDEF;
    }
    public PlObject set_pos(PlObject value) {
        return PlCORE.die(\"Can't modify constant item in match position\");
    }

    public PlObject end_of_array_index() {
        return PlCORE.die(\"Not an ARRAY reference\");
    }
    public PlObject set_end_of_array_index(PlObject o) {
        return PlCORE.die(\"Not an ARRAY reference\");
    }
    public PlObject apply(int want, PlArray List__) {
        // \$ perl -e ' \$a = 5; \$a->() '
        // Undefined subroutine &main::5 called
        String name = this.toString();
        PlObject code = PlStringConstant.getConstant(name).codeRef;
        if ( code.is_coderef() ) {
            return code.apply(want, List__);
        }
        int pos = name.lastIndexOf(\"::\");
        if (pos != -1) {
            String namespace = name.substring(0, pos);
            PlLvalue autoload = PlV.cget_no_autoload(namespace + \"::AUTOLOAD\");
            if ( autoload.is_coderef() ) {
                PlV.sset(namespace + \"::AUTOLOAD\", new PlString(name));
                return autoload.apply(want, List__);
            }
        }
        return PlCORE.die(\"Undefined subroutine &\" + name + \" called\");
    }

    public PlScalarImmutable length() {
        return new PlInt(this.toString().length());
    }
    public PlObject get_arrayref() {
        return PlCORE.die(\"Not an ARRAY reference\");
    }

    public PlObject shift() {
        return PlCORE.die(\"Not an ARRAY reference\");
    }

    public PlObject get_hashref() {
        return PlCORE.die(\"Not a HASH reference\");
    }

    public PlObject hget_scalarref(String i) {
        PlCORE.die(\"Not a SCALAR reference\");
        return this;
    }
    public PlObject scalar_deref_lvalue(String namespace) {
        return PlCORE.die(\"Not a SCALAR reference\");
    }
    public PlObject scalar_deref(String namespace) {
        return PlCORE.die(\"Not a SCALAR reference\");
    }
    public PlObject scalar_deref_strict() {
        return PlCORE.die(\"Not a SCALAR reference\");
    }
    public PlObject scalar_deref_set(String namespace, PlObject v) {
        return PlCORE.die(\"Not a SCALAR reference\");
    }
    public PlObject aget_list_of_aliases(int want, PlArray a) {
        if (this.is_array()) {
            return ((PlArray)this).aget_list_of_aliases(want, a);
        }
        return PlCORE.die(\"Not an ARRAY\");
    }
    public PlObject aget_lvalue(int i) {
        return PlCORE.die(\"Not an ARRAY reference\");
    }
    public PlObject aget_scalarref(int i) {
        PlCORE.die(\"Not a SCALAR reference\");
        return this;
    }

    public PlArray array_deref_lvalue() {
        PlCORE.die(\"Not an ARRAY reference\");
        return (PlArray)this;
    }
    public PlArray array_deref(String namespace) {
        PlCORE.die(\"Not an ARRAY reference\");
        return (PlArray)this;
    }
    public PlArray array_deref_strict() {
        PlCORE.die(\"Not an ARRAY reference\");
        return (PlArray)this;
    }
    public PlObject array_deref_set(PlObject i) {
        PlCORE.die(\"Not an ARRAY reference\");
        return this;
    }

    public PlObject hget_arrayref(String i) {
        PlCORE.die(\"Not a HASH reference\");
        return this;
    }
    public PlObject hget_hashref(String i) {
        PlCORE.die(\"Not a HASH reference\");
        return this;
    }

    public PlObject aget_arrayref(int i) {
        PlCORE.die(\"Not an ARRAY reference\");
        return this;
    }
    public PlObject aget_hashref(int i) {
        PlCORE.die(\"Not an ARRAY reference\");
        return this;
    }

    public PlObject hash_deref(String namespace) {
        PlCORE.die(\"Not a HASH reference\");
        return this;
    }
    public PlHash hash_deref_strict() {
        PlCORE.die(\"Not a HASH reference\");
        return (PlHash)this;
    }
    public PlObject hash_deref_set(PlObject i) {
        PlCORE.die(\"Not a HASH reference\");
        return this;
    }

    public PlObject hget(String i) {
        PlCORE.die(\"Not a HASH reference\");
        return this;
    }
    public PlObject hget_lvalue(String i) {
        PlCORE.die(\"Not a HASH reference\");
        return this;
    }
    public PlObject hget_lvalue_local(String i) {
        PlCORE.die(\"Not a HASH reference\");
        return this;
    }

    public PlObject hset(String s, PlObject v) {
        PlCORE.die(\"Not a HASH reference\");
        return this;
    }
    public PlObject hset(String s, PlLvalue v) {
        PlCORE.die(\"Not a HASH reference\");
        return this;
    }

    public PlObject aget(int i) {
        PlCORE.die(\"Not an ARRAY reference\");
        return this;
    }
    public PlObject aset(int i, PlObject v) {
        PlCORE.die(\"Not an ARRAY reference\");
        return this;
    }

    public PlObject to_array() {
        PlCORE.die(\"Not an ARRAY reference\");
        return this;
    }
    public PlScalarImmutable length_of_array() {
        PlCORE.die(\"Not an ARRAY reference\");
        return PlCx.UNDEF;
    }
    public boolean length_of_array_boolean() {
        PlCORE.die(\"Not an ARRAY reference\");
        return false;
    }
    public int length_of_array_int() {
        return 1;
    }
    public PlObject values() {
        PlCORE.die(\"Type of argument to values on reference must be unblessed hashref or arrayref\");
        return this;
    }
    public PlObject keys() {
        PlCORE.die(\"Type of argument to keys on reference must be unblessed hashref or arrayref\");
        return this;
    }
    public PlObject each() {
        PlCORE.die(\"Type of argument to each on reference must be unblessed hashref or arrayref\");
        return this;
    }
    public PlObject aexists(PlObject i) {
        PlCORE.die(\"exists argument is not a HASH or ARRAY element or a subroutine\");
        return this;
    }
    public PlObject hexists(String i) {
        PlCORE.die(\"exists argument is not a HASH or ARRAY element or a subroutine\");
        return this;
    }
    public PlObject hexists(PlObject i) {
        return this.hexists(i.toString());
    }
    public PlObject adelete(int want, PlObject i) {
        PlCORE.die(\"delete argument is not a HASH or ARRAY element or slice\");
        return this;
    }
    public PlObject hdelete(int want, PlObject i) {
        PlCORE.die(\"delete argument is not a HASH or ARRAY element or slice\");
        return this;
    }
    public PlObject set(PlObject o) {
        PlCORE.die(\"Modification of a read-only value attempted\");
        return this;
    }
    public PlObject vecSet(PlObject pOffset, PlObject pBits, PlObject pValue) {
        PlCORE.die(\"Can't modify constant item in scalar assignment\");
        return this;
    }
    public PlObject vec(PlObject pOffset, PlObject pBits) {
        // vec(\$i,  0, 32)
        String sb  = this.toString();
        int offset = pOffset.to_int();
        if (offset < 0) {
            return PlCORE.die(\"Negative offset to vec in lvalue context: \" + offset);
        }
        int bits   = pBits.to_int();
        if (bits == 1) {
            int byteOfs = offset / 8;
            int bitOfs  = offset - 8 * byteOfs;
            long mask = 0b0001;
            if (byteOfs < sb.length()) {
                return new PlInt((sb.charAt(byteOfs) >> bitOfs) & mask);
            }
            else {
                return PlCx.INT0;
            }
        }
        if (bits == 2) {
            int byteOfs = offset / 4;
            int bitOfs  = 2 * (offset - 4 * byteOfs);
            long mask = 0b0011;
            if (byteOfs < sb.length()) {
                return new PlInt((sb.charAt(byteOfs) >> bitOfs) & mask);
            }
            else {
                return PlCx.INT0;
            }
        }
        if (bits == 4) {
            int byteOfs = offset / 2;
            int bitOfs  = 4 * (offset - 2 * byteOfs);
            long mask = 0b1111;
            if (byteOfs < sb.length()) {
                return new PlInt((sb.charAt(byteOfs) >> bitOfs) & mask);
            }
            else {
                return PlCx.INT0;
            }
        }
        if (bits == 8) {
            if (offset < sb.length()) {
                return new PlInt(sb.charAt(offset) & 0xFF);
            }
            else {
                return PlCx.INT0;
            }
        }
        if (bits == 16) {
            long b0 = offset < sb.length() ? (sb.charAt(offset) & 0xFF) << 8 : 0;
            offset++;
            long b1 = offset < sb.length() ? sb.charAt(offset) & 0xFF : 0;
            long res = b0 + b1;
            if (res < 0) {
                res = 4294967296L + res;
            }
            return new PlInt(res);
        }
        if (bits == 32) {
            long b0 = offset < sb.length() ? (sb.charAt(offset) & 0xFF) << 24 : 0;
            offset++;
            long b1 = offset < sb.length() ? (sb.charAt(offset) & 0xFF) << 16 : 0;
            offset++;
            long b2 = offset < sb.length() ? (sb.charAt(offset) & 0xFF) << 8  : 0;
            offset++;
            long b3 = offset < sb.length() ? sb.charAt(offset) & 0xFF : 0;
            long res = b0 + b1 + b2 + b3;
            if (res < 0) {
                res = 4294967296L + res;
            }
            return new PlInt(res);
        }
        return PlCORE.die(\"Illegal number of bits in vec: \" + bits);
    }
    public PlScalarImmutable get() {
        return (PlScalarImmutable)this;
    }
    public PlObject mod(PlObject o) {
        return this.to_num().mod(o);
    }

"), ((map {
            my $op = $_;
            "    public boolean " . $op . "() {
        return false;
    }
"
        } sort {;
            $a cmp $b
        } @boolean_unary)), ("
    public boolean is_JavaObject() {
        return false;
    }
    public Object toJava() {
        return this;
    }
 
    public boolean is_hash() {
        return false;
    }
    public boolean is_slice() {
        return false;
    }
    public boolean is_array() {
        return false;
    }
    public boolean is_lvalue() {
        return false;
    }
    public boolean is_regex_result() {
        return false;
    }
    public boolean is_integer_range() {
        return new PlDouble(this.to_double()).is_integer_range();
    }
    public PlObject tie(PlArray args) {
        if (this.is_lvalue()) {
            return ((PlLvalue)this).tie(args);
        }
        return PlCORE.die(\"Can't modify constant item in tie\");
    }
    public PlString ref() {
        return REF;
    }
    public String ref_str() {
        return REF_str;
    }
    public boolean ref_boolean() {
        return false;
    }
    public PlObject refaddr() {
        // Scalar::Util::refaddr()
        return PlCx.UNDEF;
    }
    public PlObject reftype() {
        // Scalar::Util::reftype()
        return PlCx.UNDEF;
    }
    public PlObject refstring() {
        if (this.is_ref()) {
            StringBuilder sb = new StringBuilder();
            PlClass bless = this.blessed_class();
            if ( bless != null ) {
                sb.append(this.ref_str());
                sb.append(\"=\");
            }
            sb.append(this.reftype().toString());
            sb.append(\"(0x\");
            sb.append(Integer.toHexString(this.refaddr().to_int()));
            sb.append(\")\");
            return new PlString(sb.toString());
        }
        return PlCx.EMPTY;
    }
    public PlObject blessed() {
        // Scalar::Util::blessed()
        return PlCx.UNDEF;
    }
    public PlObject tied() {
        return PlCx.UNDEF;
    }
    public PlObject _decr() {
        // --\$x
        return PlCx.MIN1;
    }
    public PlObject _incr() {
        // ++\$x
        return PlCx.INT1;
    }

    public PlObject op_int() {
        return new PlInt(this.to_long());
    }
    public PlObject neg() {
        return new PlInt(-this.to_long());
    }
    public PlObject complement() {
        long v = this.to_long();
        return new PlInt(v < 0 ? ~v : 4294967295L - v);
    }
    public PlObject str_complement() {
        return PlCORE.die(\"~. not implemented\");
    }
    public PlObject abs() {
        long c = this.to_long();
        return new PlInt(c < 0 ? -c : c);
    }

    public PlObject sqrt() { return new PlDouble(Math.sqrt(this.to_double())); }
    public PlObject cos()  { return new PlDouble(Math.cos(this.to_double())); }
    public PlObject sin()  { return new PlDouble(Math.sin(this.to_double())); }
    public PlObject exp()  { return new PlDouble(Math.exp(this.to_double())); }
    public PlObject log()  { return new PlDouble(Math.log(this.to_double())); }
    public PlObject pow(PlObject arg)    { return new PlDouble(Math.pow(this.to_double(), arg.to_double()));   }
    public PlObject atan2(PlObject arg)  { return new PlDouble(Math.atan2(this.to_double(), arg.to_double())); }

    public PlObject pre_decr() {
        // --\$x
        PlCORE.die(\"Can't modify constant item in predecrement (--)\");
        return this;
    }
    public PlObject post_decr() {
        // \$x--
        PlCORE.die(\"Can't modify constant item in postdecrement (--)\");
        return this;
    }
    public PlObject pre_incr() {
        // ++\$x
        PlCORE.die(\"Can't modify constant item in preincrement (++)\");
        return this;
    }
    public PlObject post_incr() {
        // \$x++
        PlCORE.die(\"Can't modify constant item in postincrement (++)\");
        return this;
    }

    public PlObject lcfirst() {
        String s = this.toString();
        int len = s.length();
        if (len == 0) {
            return new PlString(s);
        }
        if (len == 1) {
            return new PlString(s.toLowerCase());
        }
        return new PlString( s.substring(0,1).toLowerCase() + s.substring(1) );
    }
    public PlObject ucfirst() {
        String s = this.toString();
        int len = s.length();
        if (len == 0) {
            return new PlString(s);
        }
        if (len == 1) {
            return new PlString(s.toUpperCase());
        }
        return new PlString( s.substring(0,1).toUpperCase() + s.substring(1) );
    }
    public PlObject quotemeta() {
        String s = this.toString();
        final int length = s.length();
        StringBuilder sb = new StringBuilder();
        for (int offset = 0; offset < length; offset++) {
            final int c = s.codePointAt(offset);
            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9')) {
                // good
            }
            else {
                sb.append(\"\\\\\");
            }
            sb.append(Character.toChars(c));
        }
        return new PlString(sb.toString());
    }
    public PlInt index(PlObject substr) {
        String s = this.toString();
        String s1 = substr.toString();
        return new PlInt(s.indexOf(s1));
    }
    public PlInt index(PlObject substr, PlObject position) {
        String s = this.toString();
        String s1 = substr.toString();
        int i = position.to_int();
        if (i < 0) {
            i = 0;
        }
        return new PlInt(s.indexOf(s1, i));
    }
    public PlInt rindex(PlObject substr) {
        String s = this.toString();
        String s1 = substr.toString();
        return new PlInt(s.lastIndexOf(s1));
    }
    public PlInt rindex(PlObject substr, PlObject position) {
        String s = this.toString();
        String s1 = substr.toString();
        int i = position.to_int();
        if (i < 0) {
            if (s1.length() == 0) {
                return PlCx.INT0;
            }
            return PlCx.MIN1;
        }
        return new PlInt(s.lastIndexOf(s1, i));
    }
    public PlObject substr(int offset) {
        // substr EXPR,OFFSET
        String s = this.toString();
        int ofs = offset;
        if (ofs < 0) {
            ofs = s.length() + ofs;
        }
        if (ofs < 0) {
            ofs = 0;
        }
        if (ofs >= s.length()) {
            return PlCx.UNDEF;
        }
        return new PlString(s.substring(ofs));
    }
    public PlObject substr(int offset, int length) {
        // substr EXPR,OFFSET,LENGTH
        String s = this.toString();
        int ofs = offset;
        int len = length;
        if (ofs < 0) {
            ofs = s.length() + ofs;
        }
        if (ofs >= s.length()) {
            return PlCx.UNDEF;
        }

        if (len < 0) {
            len = s.length() + len;
        }
        else {
            len = ofs + len;
        }

        if (len >= s.length()) {
            len = s.length();
        }
        if (len <= 0) {
            return PlCx.UNDEF;
        }
        if (ofs < 0) {
            ofs = 0;
        }
        return new PlString(s.substring(ofs, len));
    }
    public PlObject substr(int offset, int length, PlObject replacement) {
        // substr EXPR,OFFSET,LENGTH,REPLACEMENT
        String s = this.toString();
        int ofs = offset;
        int len = length;
        if (ofs < 0) {
            ofs = s.length() + ofs;
        }
        if (ofs >= s.length()) {
            return PlCORE.die(\"substr outside of string\");
        }

        if (len < 0) {
            len = s.length() + len;
        }
        else {
            len = ofs + len;
        }

        if (len >= s.length()) {
            len = s.length();
        }
        if (len <= 0) {
            return PlCx.UNDEF;
        }
        if (ofs < 0) {
            ofs = 0;
        }

        PlObject ret = new PlString(s.substring(ofs, len));
        String start = \"\";
        String end = \"\";
        
        if (ofs > 0) {
            start = s.substring(0, ofs);
        }
        if (len < s.length()) {
            end = s.substring(len);
        }
        this.set( new PlString( start + replacement.toString() + end ) );
        return ret;
    }
    public PlObject lvalue_substr(int offset) {
        return this.lvalue_substr(offset, this.toString().length());
    }
    public PlObject lvalue_substr(int offset, int length) {
        if (this.is_lvalue()) {
            return new PlLvalueSubstring(this, offset, length);
        }
        return this.substr(offset, length);
    }
    public PlObject bless(String className) {
        PlCORE.die(\"Can't bless non-reference value\");
        return this;
    }
    public PlClass blessed_class() {
        return null;
    }
    public PlScalarImmutable scalar() {
        return (PlScalarImmutable)this;
    }
    public PlObject clone() throws CloneNotSupportedException {
        return this;
    }
    public PlObject string_replicate(PlObject c) {
        int count = c.to_int();
        if ( count < 1 ) {
            return new PlString(\"\");
        }
        else {
            String raw_s = this.toString();
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < count; i++) {
                sb.append(raw_s);
            }
            return new PlString(sb.toString());
        }
    }
    public PlObject str_cmp(PlObject b) {
        int c = this.toString().compareTo(b.toString());
        return (c == 0 ? PlCx.INT0 : c < 0 ? PlCx.MIN1 : PlCx.INT1);
    }
    public PlObject num_cmp(PlObject b) {
        return b.num_cmp2(this);
    }
    public PlObject num_cmp2(PlObject b) {
        if (b.is_num()) {
            return ((PlDouble)b).num_cmp(this);
        }
        Long blong = b.to_long();
        int c = blong.compareTo(this.to_long());
        return (c == 0 ? PlCx.INT0 : c < 0 ? PlCx.MIN1 : PlCx.INT1);
    }
    public PlObject str_xor(PlObject b) {
        return PlCORE.die(\"^. not implemented\");
    }
    public PlObject str_and(PlObject b) {
        return PlCORE.die(\"&. not implemented\");
    }
    public PlObject str_or(PlObject b) {
        return PlCORE.die(\"|. not implemented\");
    }
    public PlObject smartmatch(PlObject arg2) {
        if (arg2.is_undef()) {
            return this.is_undef() ? PlCx.TRUE : PlCx.FALSE;
        }
        if (arg2.is_string()) {
            return this.str_eq(arg2);
        }
        if (arg2.is_num() || arg2.is_int()) {
            return this.num_eq(arg2);
        }
        if (arg2.is_ref()) {
            PlClass bless = arg2.blessed_class();
            if ( bless != null ) {
                // TODO - right side is object: invoke ~~ overloading on Object, or die
            }
        }
        if (arg2.is_array()) {
            // TODO - right side is array
            PlArray ret = new PlArray();
            for (PlObject aa : arg2) {
                PlObject rr = this.smartmatch(aa);
                if (rr.to_boolean()) {
                    ret.push_void(rr);
                }
            }
            return ret;
        }
        if (arg2.is_hash()) {
            // TODO - right side is hash
        }
        if (arg2.is_coderef()) {
            // TODO - right side is code
        }
        if (arg2.is_regex()) {
            // TODO - right side is regex
        }
        return PlCORE.die(PlCx.VOID, new PlArray(new PlString(\"Not implemented: smartmatch operator with argument type '\"), arg2.ref(), new PlString(\"'\")));
    }

"), ((map {
            my $perl = $_;
            my $native = $number_binop{$perl}->{"op"};
            my $returns = $number_binop{$perl}->{"returns"};
            "    public PlObject " . $perl . "(PlObject s) {
        return s." . $perl . "2(this);
    }
" . ($returns eq "PlDouble" ? "    public PlObject " . $perl . "2(PlObject s) {
        return new " . $returns . "( s.to_double() " . $native . " this.to_double() );
    }
" : "    public PlObject " . $perl . "2(PlObject s) {
        return new " . $returns . "( s.to_long() " . $native . " this.to_long() );
    }
")
        } sort {;
            $a cmp $b
        } keys(%number_binop))), ((map {
            my $perl = $_;
            my $native = $string_binop{$perl}->{"op"};
            my $returns = $string_binop{$perl}->{"returns"};
            "    public PlObject " . $perl . "(PlObject b) {
        return new " . $returns . "(this.toString().compareTo(b.toString()) " . $native . " 0);
    }
"
        } sort {;
            $a cmp $b
        } keys(%string_binop))), ((map {
            my $perl = $_;
            "    public PlObject self_assign_" . $perl . "(PlObject s) {
        return PlCORE.die(\"Can't modify constant item\");
    }
"
        } sort {;
            $a cmp $b
        } ("string_replicate", "and", "or", "str_and", "str_or", "str_xor", keys(%self_assign_number_binop)))), ((map {
            my $perl = $_;
            "    public PlObject _self_" . $perl . "(PlObject s) {
        return this." . $perl . "(s);
    }
"
        } sort {;
            $a cmp $b
        } ("string_replicate", keys(%self_assign_number_binop)))), ("}
class PlScalarObject extends PlObject {
    public PlScalarObject() {
    }
}
class PlScalarImmutable extends PlScalarObject {
    public PlScalarImmutable() {
    }

    public PlScalarImmutable get() {
        return this;
    }
    public PlScalarImmutable scalar() {
        return this;
    }
}
class PlReference extends PlScalarImmutable {
    public static final String REF_str = new String(\"REF\");
    public static final PlStringConstant REF = new PlStringConstant(REF_str);
    public PlClass bless;

    public boolean is_ref() {
        return true;
    }
    public PlReference bless(String className) {
        this.bless = PlClass.getInstance(className);
        return this;
    }
    public PlClass blessed_class() {
        return this.bless;
    }

    public PlString ref() {
        if ( this.bless == null ) {
            return this.REF;
        }
        else {
            return this.bless.plClassName();
        }
    }
    public String ref_str() {
        if ( this.bless == null ) {
            return this.REF_str;
        }
        else {
            return this.bless.className();
        }
    }
    public boolean ref_boolean() {
        return true;
    }

    public PlInt refaddr() {
        // Scalar::Util::refaddr()
        return new PlInt(this.hashCode());
    }
    public PlObject blessed() {
        // Scalar::Util::blessed()
        if ( this.bless == null ) {
            return PlCx.UNDEF;
        }
        else {
            return this.bless.plClassName();
        }
    }
    public PlObject reftype() {
        // Scalar::Util::reftype()
        return REF;
    }

    // overload
    public String toString() {
        return PlClass.overload_to_string(this).toString();
    }
    public boolean to_boolean() {
        return PlClass.overload_to_boolean(this).to_boolean();
    }
    public double to_double() {
        return PlClass.overload_to_number(this).to_double();
    }
    public PlObject to_num() {
        return PlClass.overload_to_number(this);
    }
    public int to_int() {
        return PlClass.overload_to_number(this).to_int();
    }
    public long to_long() {
        return PlClass.overload_to_number(this).to_long();
    }
"), ((map {
            my $perl = $_;
            "    public PlObject " . $perl . "2(PlObject s) {
        return PlClass.overload_" . $perl . "(this, s, PlCx.INT1);
    }
"
        } sort {;
            $a cmp $b
        } ("num_cmp", keys(%number_binop)))), ((map {
            my $op = $_;
            "    public PlObject " . $op . "() {
        return PlClass.overload_" . $op . "(this);
    }
"
        } sort {;
            $a cmp $b
        } ("_decr", "_incr", @number_unary))), ((map {
            my $perl = $_;
            "    public PlObject " . $perl . "(PlObject s) {
        return PlClass.overload_" . $perl . "(this, s, PlCx.UNDEF);
    }
"
        } sort {;
            $a cmp $b
        } ("str_cmp", "pow", "atan2", "mod", "num_cmp", "string_replicate", "smartmatch", keys(%string_binop), keys(%number_binop), (map {;
            "_self_" . $_
        } keys(%self_assign_number_binop))))), ("}
class PlGlobRef extends PlReference {
    public static final String REF_str = new String(\"GLOB\");
    public static final PlStringConstant REF = new PlStringConstant(REF_str);
    public PlFileHandle filehandle;

    public PlGlobRef(PlFileHandle filehandle) {
        this.filehandle = filehandle;
    }
    public PlGlobRef(PlLvalue v) {
        PlObject o = v.get();
        this.filehandle = (PlFileHandle)o;
    }
    public PlGlobRef(PlObject o) {
        this.filehandle = (PlFileHandle)o;
    }
    public boolean is_typeglobref() {
        return true;
    }
    public PlString ref() {
        if ( this.bless == null ) {
            return REF;
        }
        else {
            return this.bless.plClassName();
        }
    }
    public String ref_str() {
        if ( this.bless == null ) {
            return REF_str;
        }
        else {
            return this.bless.className();
        }
    }
    public boolean ref_boolean() {
        return true;
    }

    public PlObject reftype() {
        return REF;
    }
    public PlObject hget(String i) {
        // *{ \$name }{CODE}->()
        // PlCORE.say( \"PlGlobRef.hget \" + i + \" \" + this.filehandle.hget(i) );
        return this.filehandle.hget(i);
    }
    public PlObject hset(String s, PlObject v) {
        return this.filehandle.hset(s, v);
    }
    public PlObject hset(String s, PlLvalue v) {
        return this.filehandle.hset(s, v.get());
    }
}

class PlStringReader extends Reader{
    // read from string
    String s;
    int pos;
    int mark;

    PlStringReader(PlObject o) {
        this.s = o.toString();
        this.pos = 0;
        this.mark = 0;
    }
    public int read(char[] cbuf, int off, int len) {
        if (pos >= s.length()) {
            return -1;
        }
        len = Math.min(len, s.length() - pos);
        int count = 0;
        while (count < len) {
            cbuf[off++] = s.charAt(pos++);
            count++;
        }
        return count;
    }

    public boolean markSupported() {
        return true;
    }
    public void mark(int readlimit) {
        mark = pos;
        return;
    }
    public void reset() {
        pos = mark;
    }
    public void close() {
        return;
    }
}

class PlFileHandle extends PlScalarImmutable {
    // public static final String REF_str = new String(\"GLOB\");
    // public static final PlStringConstant REF = new PlStringConstant(REF_str);
    public String  typeglob_name;
    public OutputStream outputStream;    // System.out, System.err
    public InputStream inputStream;     // System.in
    public Iterator<Path> directoryIterator;
    public DirectoryStream<Path> directoryStream;
    public Reader  reader;       // Console.reader
    public StringBuilder readlineBuffer;
    public StringBuilder printBuffer;
    public boolean eof;
    public boolean is_argv;
    public Path    path;     // filename
    public String  mode;     // \">\", \"+<\"
    public String  charset;  // \"UTF-8\"
    public boolean binmode;
    public boolean output_autoflush;
    public PlObject tied;

    public static final int BUFFER_SIZE = 4096;
    public static final int BUFFER_THRESHOLD = BUFFER_SIZE - 256;
    public static HashSet<PlFileHandle> allOpenFiles = new HashSet<PlFileHandle>();

    public PlFileHandle() {
        this.readlineBuffer = new StringBuilder();
        this.printBuffer = new StringBuilder(PlFileHandle.BUFFER_SIZE);
        this.eof = true;
        this.is_argv = false;
        this.binmode = false;
        this.output_autoflush = false;
    }

    public PlFileHandle(String name) {
        this();     // call the base constructor
        if (name.equals(\"main::ARGV\")) {
            this.is_argv = true;
        }
        this.typeglob_name = name;
    }

    public boolean is_filehandle() {
        return true;
    }

    // tie \"handle\"
    public PlObject tie(PlArray args) {
        if (this.tied != null) {
            this.untie();
        }
        PlObject self = PerlOp.call(\"TIEHANDLE\", args, PlCx.VOID);
        this.tied = self;
        return self;
    }

    public PlObject untie() {
        if (this.tied != null) {
            PlObject tied = this.tied;
            PlObject untie = PerlOp.call(\"can\", new PlArray(tied, new PlString(\"UNTIE\")), PlCx.SCALAR);
            if (untie.to_boolean()) {
                untie.apply(PlCx.VOID, new PlArray(tied));
            };
            this.tied = null;
            return tied;
        }
        return this;
    }
    public PlObject tied() {
        if (this.tied != null) {
            return this.tied;
        }
        return PlCx.UNDEF;
    }
 
    public static void close_all_files() {
        // called at teardown - program finish, die() or exit()
        // Note: this is also called when the compiler finishes loading (the compiler is a Perl program)
        // System.out.println(\"PlFileHandle.close_all_files\");
        for ( PlFileHandle fh : allOpenFiles ) {
            try {
                fh.flush();     // not sure if we should close STDOUT and STDERR
            }
            catch(Exception e) {
                PlV.sset(\"main::!\", new PlStringLazyError(e));
            }
        }
    }
    public PlObject set_autoflush(PlObject o) {
        this.output_autoflush = o.to_boolean();
        if (this.output_autoflush) {
            try {
                this.flush();
            }
            catch(Exception e) {
                PlV.sset(\"main::!\", new PlStringLazyError(e));
            }
        }
        return o;
    }
    public void flush() throws IOException, UnsupportedEncodingException {
        // System.out.println(\"PlFileHandle.flush \" + typeglob_name);
        if (this.outputStream == null) {
            return;
        }
        if (this.binmode) {
            StringBuilder s = this.printBuffer;
            int ll = s.length();
            byte[] bytes = new byte[ll];
            for (int i2 = 0; i2 < ll; i2++) {
                bytes[i2] = (byte)(s.charAt(i2));
            }
            this.outputStream.write(bytes);
        }
        else {
            String s = this.printBuffer.toString();
            byte[] bytes = s.getBytes(this.charset);
            this.outputStream.write(bytes);
        }
        // this.printBuffer = new StringBuilder(PlFileHandle.BUFFER_SIZE);
        // this.outputStream.flush();   // no need to flush when using write()
        this.printBuffer.setLength(0);
    }
    public void close() throws IOException {
        this.readlineBuffer = new StringBuilder();
        this.eof = true;
        if (this.outputStream != null) {
            this.flush();
            this.outputStream.close();
        }
        if (this.reader != null) {
            this.reader.close();
        }
        PlFileHandle.allOpenFiles.remove(this);
    }
    public String toString() {
        if (this.typeglob_name == null) {
            return \"\";
        }
        if (this.typeglob_name.startsWith(\"main::\")) {
            return \"*\" + this.typeglob_name.substring(4);
        }
        return \"*\" + this.typeglob_name;
    }
    public PlObject setUndef() {
        // undef *{\$foo}
        // PlCORE.say( \"PlFileHandle.setUndef \" + typeglob_name);

        PlString name = new PlString(typeglob_name);

        try {
            // close filehandle if needed
            this.close();
        }
        catch(Exception e) {
            PlV.sset(\"main::!\", new PlStringLazyError(e));
        }

        PlStringConstant glob = PlStringConstant.getConstant(typeglob_name);
        glob.codeRef.set(PlCx.UNDEF);
        glob.scalarRef.set(PlCx.UNDEF);
        glob.arrayRef.set(new PlArrayRef());
        glob.hashRef.set(new PlHashRef());
        glob.fileRef.set(new PlFileHandle(typeglob_name));
        if (typeglob_name.endsWith(\"::\")) {
            // TODO - undefine inner symbol table
        }
        return PlCx.UNDEF; 
    }
    public PlObject hget(String i) {
        // *{ \$name }{CODE}->()
        // PlCORE.say( \"PlFileHandle.hget \" + i );

        if (i.equals(\"SCALAR\")) {
            return PlV.make_reference(PlV.sget(typeglob_name));
        }
        else if (i.equals(\"ARRAY\")) {
            return PlV.aget(typeglob_name);
        }
        else if (i.equals(\"HASH\")) {
            if (typeglob_name.endsWith(\"::\")) {
                // %{\"Module::\"}
                return new PlHashRef(PerlOp.getSymbolTable(typeglob_name));
            }
            return PlV.hget(typeglob_name);
        }
        else if (i.equals(\"CODE\")) {
            return PlV.cget(typeglob_name);
        }
        else if (i.equals(\"IO\")) {
            return this;    // close enough
        }
        else if (i.equals(\"GLOB\")) {
            return new PlGlobRef(this);
        }
        else if (i.equals(\"FORMAT\")) {
            // TODO
        }
        else if (i.equals(\"NAME\")) {
            int pos = typeglob_name.lastIndexOf(\"::\");
            if (pos != -1) {
                String name = typeglob_name.substring(pos+2);
                return new PlString(name);
            }
        }
        else if (i.equals(\"PACKAGE\")) {
            int pos = typeglob_name.lastIndexOf(\"::\");
            if (pos != -1) {
                String namespace = typeglob_name.substring(0, pos);
                return new PlString(namespace);
            }
        }
        return PlCx.UNDEF;
    }
    public PlObject hset(String s, PlObject v) {
        return PlCORE.die(\"Can't modify glob elem in scalar assignment\");
    }
    public PlObject hset(String s, PlLvalue v) {
        return PlCORE.die(\"Can't modify glob elem in scalar assignment\");
    }
    public PlObject hget_scalarref(String i) {
        return this.hget(i);
    }
    public PlObject scalar_deref_set(String namespace, PlObject v) {
        return PlV.sset(typeglob_name, v);
    }
}

"), ("
class PlLvalueSpecialVarAutoflush extends PlLvalue {
    // the \$| variable
    public PlObject set(PlObject o) {
        // System.out.println(\"Set autoflush \" + (o.to_boolean() ? \"1\" : \"0\"));
        PlV.STDOUT.set_autoflush(o);
        return super.set(o);
    }
    public PlObject set(PlScalarImmutable o) {
        return this.set((PlObject)o);
    }
    public PlObject set(PlLvalue o) {
        return this.set((PlObject)o.get());
    }
}

"), ("
class PlRegex extends PlReference {
    public Pattern p;
    public String  original_string;
    // public Matcher m;
    public boolean flag_xx;
    public static final String REF_str = new String(\"Regexp\");
    public static final PlStringConstant REF = new PlStringConstant(REF_str);

    public PlRegex(String p, int flags, boolean flag_xx) {
        this.flag_xx = flag_xx;
        this.p = Pattern.compile(PerlOp.regex_escape(p, flag_xx), flags);
    }
    public PlRegex(PlObject p, int flags, boolean flag_xx) {
        if (p.is_lvalue()) {
            p = p.get();
        }
        if (p.is_regex()) {
            this.p = ((PlRegex)p).p;    // reuse compiled regex; ignore any difference in flags
        }
        else {
            this.flag_xx = flag_xx;
            this.p = Pattern.compile(PerlOp.regex_escape(p.toString(), flag_xx), flags);
        }
    }
    public PlString ref() {
        if ( this.bless == null ) {
            return REF;
        }
        else {
            return this.bless.plClassName();
        }
    }
    public String ref_str() {
        if ( this.bless == null ) {
            return REF_str;
        }
        else {
            return this.bless.className();
        }
    }
    public boolean ref_boolean() {
        return true;
    }

    public PlObject reftype() {
        return REF;
    }
    public String toString() {
        if (original_string == null) {

            int flags = p.flags();
            StringBuilder sb = new StringBuilder();
            sb.append(\"(?\");

            if ((flags & Pattern.CASE_INSENSITIVE) != 0)
                sb.append(\"i\");
            if ((flags & Pattern.COMMENTS) != 0)
                sb.append(\"x\");
            if (flag_xx)
                sb.append(\"x\");
            if ((flags & Pattern.DOTALL) != 0)
                sb.append(\"s\");
            if ((flags & Pattern.MULTILINE) != 0)
                sb.append(\"m\");

            sb.append(\"-\");

            if ((flags & Pattern.CASE_INSENSITIVE) == 0)
                sb.append(\"i\");
            if ((flags & Pattern.COMMENTS) == 0)
                sb.append(\"x\");
            if ((flags & Pattern.DOTALL) == 0)
                sb.append(\"s\");
            if ((flags & Pattern.MULTILINE) == 0)
                sb.append(\"m\");

            sb.append(\":\");
            sb.append(p.toString());
            sb.append(\")\");
            original_string = sb.toString();
 
            // TODO - show flags
            // Pattern.CANON_EQ
            // Pattern.LITERAL
            // Pattern.UNICODE_CASE
            // Pattern.UNICODE_CHARACTER_CLASS
            // Pattern.UNIX_LINES
        }
        return this.original_string;
    }
    public boolean is_regex() {
        return true;
    }
}
class PlRegexResult extends PlScalarImmutable {
    public Matcher matcher;      // regex captures
    public String  regex_string; // last string used in a regex

    public boolean is_regex_result() {
        return true;
    }
}
class PlClosure extends PlReference implements Runnable {
    public PlObject[] env;       // new PlObject[]{ v1, v2, v3 }
    public PlObject prototype;   // '\$\$\$'
    public String pkg_name;      // 'main'
    public static final String REF_str = new String(\"CODE\");
    public static final PlStringConstant REF = new PlStringConstant(REF_str);
    public PlClosure currentSub;
    public boolean is_defined;
    // metadata for caller()
    public String  _javaClassName;
    public Integer _firstLineNumber;
    public Integer _lastLineNumber;

    public PlClosure(PlObject prototype, PlObject[] env, String pkg_name, boolean is_defined) {
        this.prototype = prototype;
        this.env = env;
        this.pkg_name = pkg_name;
        this.currentSub = this;
        this.is_defined = is_defined;
    }
    public PlClosure(PlObject prototype, PlObject[] env, String pkg_name, boolean is_defined, PlClosure currentSub) {
        // this is the constructor for do-BLOCK; currentSub points to the \"sub\" outside
        this.prototype = prototype;
        this.env = env;
        this.pkg_name = pkg_name;
        this.currentSub = currentSub;
        this.is_defined = is_defined;
    }

    public String javaClassName() {
        if (_javaClassName == null) {
            StackTraceElement firstStack = this.firstLine();
            if ( firstStack != null ) {
                _javaClassName = firstStack.getClassName();
            }
        }
        return _javaClassName;
    }

    public Integer firstLineNumber() {
        if (_firstLineNumber == null) {
            StackTraceElement firstStack = this.firstLine();
            if ( firstStack != null ) {
                _firstLineNumber = firstStack.getLineNumber();
            }
        }
        return _firstLineNumber;
    }

    public Integer lastLineNumber() {
        if (_lastLineNumber == null) {
            StackTraceElement lastStack = this.lastLine();
            if ( lastStack != null ) {
                _lastLineNumber = lastStack.getLineNumber();
            }
        }
        return _lastLineNumber;
    }

    public PlClosure getCurrentSub() {
        return this.currentSub;
    }

    // subclasses override perlFileName() and perlLineNumber()
    public String perlFileName() {
        return null;
    }
    public Integer perlLineNumber() {
        return null;
    }

    // subclasses override firstLine() and lastLine()
    // these methods are used by caller() to identify where the sub is implemented in the source code
    public StackTraceElement firstLine() {
        return null;
    }
    // Note: apply() overrides PlObject.apply(), which throws an error
    public PlObject apply(int want, PlArray List__) {
        PlCORE.die(\"it looks like you have a closure without a block\");
        return this;
    }
    public PlObject apply_do_block(int want, int return_context, PlArray List__) {
        PlCORE.die(\"it looks like you have a do-block without a block\");
        return this;
    }
    public StackTraceElement lastLine() {
        return null;
    }
    public void run() {
        // run as a thread
        this.apply(PlCx.VOID, new PlArray());
    }

    public PerlArgumentLookupResult castToClass(ArrayList<Class[]> params, int pos) {
        // want java.lang.Runnable
        for (Class[] cl : params) {
            if (cl[pos].equals( java.lang.Runnable.class )) {
                return new PerlArgumentLookupResult( this, cl[pos] );
            }
        }
        // try other things
        return this.get().castToClass(params, pos);
    }

    public PlString ref() {
        if ( this.bless == null ) {
            return REF;
        }
        else {
            return this.bless.plClassName();
        }
    }
    public String ref_str() {
        if ( this.bless == null ) {
            return REF_str;
        }
        else {
            return this.bless.className();
        }
    }
    public boolean ref_boolean() {
        return true;
    }

    public PlObject reftype() {
        return REF;
    }
    public boolean is_coderef() {
        return true;
    }
    public boolean is_undef() {
        return !is_defined;
    }
    public PlObject prototype() {
        return this.prototype;
    }
}
class PlLvalueRef extends PlReference {
    private PlObject o;
    public static final String REF_str = new String(\"SCALAR\");
    public static final PlStringConstant REF = new PlStringConstant(REF_str);
    public static final PlString REF_REF = new PlString(\"REF\");

    public PlString ref() {
        if ( this.bless == null ) {
            if ( this.o.is_ref() ) {
                return REF_REF;
            }
            return REF;
        }
        else {
            return this.bless.plClassName();
        }
    }
    public String ref_str() {
        if ( this.bless == null ) {
            if ( this.o.is_ref() ) {
                return REF_REF.toString();
            }
            return REF_str;
        }
        else {
            return this.bless.className();
        }
    }
    public boolean ref_boolean() {
        return true;
    }

    public PlInt refaddr() {
        // Scalar::Util::refaddr()
        int id = System.identityHashCode(this.o);
        return new PlInt(id);
    }
    public PlLvalueRef(PlLvalue o) {
        this.o = o;
    }
    public PlLvalueRef(PlObject o) {
        this.o = o;
    }
    public PlLvalueRef(String o) {
        this.o = new PlString(o);
    }
    public PlObject scalar_deref_lvalue(String namespace) {
        return this.o;
    }
    public PlObject scalar_deref(String namespace) {
        return this.o;
    }
    public PlObject scalar_deref_strict() {
        return this.o;
    }
    public PlObject scalar_deref_set(String namespace, PlObject v) {
        return this.o.set(v);
    }
    public boolean is_scalarref() {
        return true;
    }
}
class PlArrayRef extends PlReference {
    public static final String REF_str = new String(\"ARRAY\");
    public static final PlStringConstant REF = new PlStringConstant(REF_str);
    public PlArray ar;

    public PlArrayRef() {
        this.ar = new PlArray();
    }
    public PlArrayRef(PlArray o) {
        this.ar = o;
    }
    public PlArrayRef(PlObject o) {
        this.ar = (PlArray)o;
    }
    public PlInt refaddr() {
        // Scalar::Util::refaddr()
        int id = System.identityHashCode(this.ar);
        return new PlInt(id);
    }
    public PlObject set(PlArray o) {
        this.ar = o;
        return o;
    }
    public PlArray array_deref_lvalue() {
        return this.ar;
    }
    public PlArray array_deref(String namespace) {
        return this.ar;
    }
    public PlArray array_deref_strict() {
        return this.ar;
    }
    public PlObject array_deref_set(PlObject v) {
        this.ar.set(v);
        return v;
    }
    public boolean is_arrayref() {
        return true;
    }
    public PlString ref() {
        if ( this.bless == null ) {
            return REF;
        }
        else {
            return this.bless.plClassName();
        }
    }
    public String ref_str() {
        if ( this.bless == null ) {
            return REF_str;
        }
        else {
            return this.bless.className();
        }
    }
    public boolean ref_boolean() {
        return true;
    }

    public PlObject reftype() {
        return REF;
    }

    public PlObject aget(int i) {
        return this.ar.a.aget(i);
    }
    public PlObject aget_lvalue(int i) {
        return this.ar.aget_lvalue(i);
    }
    public PlObject aget_scalarref(int i) {
        return this.ar.aget_scalarref(i);
    }
    public PlObject aget_hashref(int i) {
        return this.ar.aget_hashref(i);
    }
    public PlObject aget_arrayref(int i) {
        return this.ar.aget_arrayref(i);
    }
    public PlObject aset(int i, PlObject v) {
        return this.ar.aset(i, v);
    }
 
    public PlObject aexists(PlObject i) {
        return this.ar.aexists(i);
    }
    public PlObject adelete(int want, PlObject i) {
        return this.ar.adelete(want, i);
    }
    public PlObject values() {
        return this.ar.values();
    }
    public PlObject keys() {
        return this.ar.keys();
    }
    public PlObject each() {
        return this.ar.each();
    }
}

class PlHashRef extends PlReference {
    public static final String REF_str = new String(\"HASH\");
    public static final PlStringConstant REF = new PlStringConstant(REF_str);
    public PlHash ha;

    public PlHashRef() {
        this.ha = new PlHash();
    }
    public PlHashRef(PlHash o) {
        this.ha = o;
    }
    public PlHashRef(PlObject o) {
        this.ha = (PlHash)o;
    }
    public PlInt refaddr() {
        // Scalar::Util::refaddr()
        int id = System.identityHashCode(this.ha);
        return new PlInt(id);
    }
    public boolean is_hashref() {
        return true;
    }
    public PlString ref() {
        if ( this.bless == null ) {
            return REF;
        }
        else {
            return this.bless.plClassName();
        }
    }
    public String ref_str() {
        if ( this.bless == null ) {
            return REF_str;
        }
        else {
            return this.bless.className();
        }
    }
    public boolean ref_boolean() {
        return true;
    }

    public PlObject reftype() {
        return REF;
    }

    public PlObject set(PlHash o) {
        this.ha = o;
        return o;
    }
    public PlHash hash_deref(String namespace) {
        return this.ha;
    }
    public PlHash hash_deref_strict() {
        return this.ha;
    }
    public PlObject hash_deref_set(PlObject v) {
        this.ha.set(PlCx.VOID, v);
        return v;
    }

    public PlObject hget(String i) {
        PlObject o = this.ha.h.get(i);
        if (o == null) {
            return PlCx.UNDEF;
        }
        return o;
    }

    public PlObject hget_lvalue(String i) {
        return this.ha.hget_lvalue(i);
    }
    public PlObject hget_lvalue_local(String i) {
        return this.ha.hget_lvalue_local(i);
    }

    public PlObject hget_scalarref(String i) {
        return this.ha.hget_scalarref(i);
    }

    public PlObject hget_arrayref(String i) {
        return this.ha.hget_arrayref(i);
    }

    public PlObject hget_hashref(String i) {
        return this.ha.hget_hashref(i);
    }

    public PlObject hset(String i, PlObject v) {
        return this.ha.hset(i, v);
    }
    public PlObject hset(String i, PlLvalue v) {
        return this.ha.hset(i, v.get());
    }
    public PlObject hset(int want, PlArray i, PlArray v) {
        return this.ha.hset(want, i, v);
    }
    public PlObject hset_alias(String i, PlObject v) {
        return this.ha.hset_alias(i, v);
    }
    public PlObject hexists(String i) {
        return this.ha.hexists(i);
    }
    public PlObject hexists(PlObject i) {
        return this.ha.hexists(i);
    }
    public PlObject hdelete(int want, PlObject a) {
        return this.ha.hdelete(want, a);
    }
    public PlObject hdelete(int want, PlArray a) {
        return this.ha.hdelete(want, a);
    }
    public PlObject hdelete(int want, PlString a) {
        return this.ha.hdelete(want, a);
    }
    public PlObject hdelete(int want, PlLvalue a) {
        return this.ha.hdelete(want, a);
    }
    public PlObject values() {
        return this.ha.values();
    }
    public PlObject keys() {
        return this.ha.keys();
    }
    public PlObject each() {
        return this.ha.each();
    }
}
class PlClass {
    public static HashMap<String, PlClass> classes = new HashMap<String, PlClass>();
    public String className;
    public PlString plClassName;
    public Boolean overload_flag;
    public Boolean overload_fallback_flag;
    public HashMap<String, PlObject> methodCache;

    protected PlClass(String s) {
        this.className = s;
        this.plClassName = new PlString(s);
        this.overload_flag = null;
        this.overload_fallback_flag = null;
        this.methodCache = new HashMap<String, PlObject>();
    }
    public static PlClass getInstance(PlObject s) {
        return PlClass.getInstance(s.toString());
    }
    public static PlClass getInstance(String s) {
        PlClass c = classes.get(s);
        if (c == null) {
            c = new PlClass(s);
            classes.put(s, c);
        }
        return c;
    }
    public String className() {
        return this.className;
    }
    public PlString plClassName() {
        return this.plClassName;
    }
    public boolean is_undef() {
        return this.className == null;
    }
    public Boolean is_overloaded() {
        if (this.overload_flag == null) {
            PlObject methodCode1 = this.method_lookup(\"((\", 0);
            PlObject methodCode2 = this.method_lookup(\"()\", 0);
            this.overload_flag = methodCode1.is_coderef() || methodCode2.is_coderef();
        }
        return this.overload_flag;
    }
    public Boolean is_overload_fallback() {
        if (this.overload_fallback_flag == null) {
            PlObject methodCode = this.method_lookup(\"()\", 0);
            this.overload_fallback_flag = methodCode.is_coderef();
        }
        return this.overload_fallback_flag;
    }

    public PlObject overload_lookup(String method, int level) {
        // method is like (*=
        PlObject methodCode;
        String methodName = className + \"::\" + method;
        methodCode = PlV.cget_no_autoload(methodName);
        if (methodCode.is_undef()) {
            // method not found
            // \"overload\" methods have no AUTOLOAD
            // lookup in \@ISA
          search:
            for (PlObject className : PlV.array_get(className + \"::ISA\")) {
                // prevent infinite loop
                if (level >= 100) {
                    PlCORE.die(\"Recursive inheritance detected in package '\" + className + \"'\");
                }
                methodCode = PlClass.getInstance(className).overload_lookup(method, level+1);
                if (!methodCode.is_undef()) {
                    return methodCode;
                }
            }
        }
        if (methodCode.is_undef()) {
            // overload does lookup in UNIVERSAL
            methodCode = PlV.cget_no_autoload(\"UNIVERSAL::\" + method);
        }
        // method found

        PlObject nameLookup = PlV.sget(methodName);
        if (!nameLookup.is_undef()) {
            // PlCORE.say(\"overload_lookup \" + methodName + \" scalar [\" + nameLookup.toString() + \"]\");
            return nameLookup;
        }

        return methodCode;
    }

    public PlObject method_lookup(String method, int level) {
        if (this.methodCache.containsKey(method)) {
            // retrieve from method cache
            // PlCORE.warn(\"match \" + method);
            return this.methodCache.get(method);
        }
        // PlCORE.warn(\"miss \" + method);

        PlObject methodCode;
        int pos = method.indexOf(\"::\");
        if (pos != -1) {
            // fully qualified method name
            if (method.startsWith(\"SUPER::\")) {
                PlCORE.die(\"not implemented: \" + method); 
            }
            return PlV.cget(method);
        }
        methodCode = PlV.cget_no_autoload(className + \"::\" + method);
        if (methodCode.is_undef()) {
            // method not found

            // lookup in AUTOLOAD
            methodCode = PlV.cget_no_autoload(className + \"::AUTOLOAD\");
            if (!methodCode.is_undef()) {
                if (method.charAt(0) == '('     // \"overload\" methods
                 || method.equals(\"import\")
                 || method.equals(\"unimport\")
                 || method.equals(\"isa\")
                 || method.equals(\"can\")
                ) {
                    // overload method - TODO
                }
                else {
                    PlV.sset(className + \"::AUTOLOAD\", new PlString(className + \"::\" + method));
                    // this.methodCache.put(method, methodCode);
                    return methodCode;
                }
            }

            // lookup in \@ISA
            for (PlObject className : PlV.array_get(className + \"::ISA\")) {
                // prevent infinite loop
                if (level >= 100) {
                    PlCORE.die(\"Recursive inheritance detected in package '\" + className + \"'\");
                }
                methodCode = PlClass.getInstance(className).method_lookup(method, level+1);
                if (!methodCode.is_undef()) {
                    // found
                    this.methodCache.put(method, methodCode);
                    return methodCode;
                }
            }

            // lookup in UNIVERSAL
            methodCode = PlV.cget_no_autoload(\"UNIVERSAL::\" + method);
        }
        this.methodCache.put(method, methodCode);
        return methodCode;
    }
    public PlObject isa(String s, int level) {
        if (className.equals(s)) {
            return PlCx.INT1;
        }

        // lookup in \@ISA
        for (PlObject isa_item : PlV.array_get(className + \"::ISA\")) {
            String className = isa_item.toString();
            // prevent infinite loop
            if (level >= 100) {
                PlCORE.die(\"Recursive inheritance detected in package '\" + className.toString() + \"'\");
            }
            PlObject is = PlClass.getInstance(className).isa(s, level+1);
            if (is.to_boolean()) {
                return is;
            }
        }

        // lookup in UNIVERSAL
        if (s.equals(\"UNIVERSAL\")) {
            return PlCx.INT1;
        }
        return PlCx.UNDEF;
    }
"), ("    public static PlObject overload_to_string(PlObject o) {
        PlClass bless = o.blessed_class();
        if ( bless != null && bless.is_overloaded() ) {
            // PlCORE.say(\"PlReference toString() \" + bless.className);
            for (String ovl : new String[] { PlCx.OVERLOAD_STRING, PlCx.OVERLOAD_NUM, PlCx.OVERLOAD_BOOL }) {
                PlObject methodCode = bless.overload_lookup(ovl, 0);
                if (!methodCode.is_undef()) {
                    return PerlOp.call(methodCode, new PlArray(o), PlCx.SCALAR);
                }
                if (!bless.is_overload_fallback()) {
                    break;
                }
            }

            // nomethod
            PlObject methodCode = bless.overload_lookup(PlCx.OVERLOAD_NOMETHOD, 0);
            if (!methodCode.is_undef()) {
                return PerlOp.call(methodCode, new PlArray( o, PlCx.UNDEF, PlCx.UNDEF, new PlString(PlCx.OVERLOAD_STRING) ), PlCx.SCALAR);
            }
        }

        return o.refstring();
    }
    public static PlObject overload_to_number(PlObject o) {
        PlClass bless = o.blessed_class();
        if ( bless != null && bless.is_overloaded() ) {
            for (String ovl : new String[] { PlCx.OVERLOAD_NUM, PlCx.OVERLOAD_STRING, PlCx.OVERLOAD_BOOL }) {
                PlObject methodCode = bless.overload_lookup(ovl, 0);
                if (!methodCode.is_undef()) {
                    return PerlOp.call(methodCode, new PlArray(o), PlCx.SCALAR);
                }
                if (!bless.is_overload_fallback()) {
                    break;
                }
            }

            // nomethod
            PlObject methodCode = bless.overload_lookup(PlCx.OVERLOAD_NOMETHOD, 0);
            if (!methodCode.is_undef()) {
                return PerlOp.call(methodCode, new PlArray( o, PlCx.UNDEF, PlCx.UNDEF, new PlString(PlCx.OVERLOAD_STRING) ), PlCx.SCALAR);
            }
        }

        return o.refaddr();
    }
    public static PlObject overload_to_boolean(PlObject o) {
        PlClass bless = o.blessed_class();
        if ( bless != null && bless.is_overloaded() ) {
            for (String ovl : new String[] { PlCx.OVERLOAD_BOOL, PlCx.OVERLOAD_NUM, PlCx.OVERLOAD_STRING }) {
                PlObject methodCode = bless.overload_lookup(ovl, 0);
                if (!methodCode.is_undef()) {
                    return PerlOp.call(methodCode, new PlArray(o), PlCx.SCALAR);
                }
                if (!bless.is_overload_fallback()) {
                    break;
                }
            }

            // nomethod
            PlObject methodCode = bless.overload_lookup(PlCx.OVERLOAD_NOMETHOD, 0);
            if (!methodCode.is_undef()) {
                return PerlOp.call(methodCode, new PlArray( o, PlCx.UNDEF, PlCx.UNDEF, new PlString(PlCx.OVERLOAD_STRING) ), PlCx.SCALAR);
            }
        }

        return PlCx.TRUE;
    }
"), ((map {
            my $perl = $_;
            my $native;
            exists($number_binop{$perl}) && ($native = $number_binop{$perl}->{"op"});
            $perl eq "num_cmp" && ($native = "<=>");
            $perl eq "pow" && ($native = "**");
            $perl eq "atan2" && ($native = "atan2");
            $perl eq "mod" && ($native = "%");
            $perl eq "int_shr" && ($native = ">>");
            "    public static PlObject overload_" . $perl . "(PlObject o, PlObject other, PlObject swap) {
        PlClass bless = o.blessed_class();
        if ( bless != null && bless.is_overloaded() ) {
            PlObject methodCode = bless.overload_lookup(\"(" . $native . "\", 0);
            if (!methodCode.is_undef()) {
                return PerlOp.call(methodCode, new PlArray(o, other, swap), PlCx.SCALAR);
            }
            if (bless.is_overload_fallback()) {
                o = PlClass.overload_to_number(o);
            }
            else {
                PlCORE.die(\"Operation " . $native . ": no method found\");
            }
        }
        else {
            o = o.refaddr();
        }
        if (swap.to_boolean()) {
            return other." . $perl . "(o);
        }
        return o." . $perl . "(other);
    }
"
        } sort {;
            $a cmp $b
        } ("num_cmp", "pow", "atan2", "mod", keys(%number_binop)))), ((map {
            my $perl = $_;
            my $native = $perl;
            $perl eq "_incr" && ($native = "++");
            $perl eq "_decr" && ($native = "--");
            "    public static PlObject overload_" . $perl . "(PlObject o) {
        PlClass bless = o.blessed_class();
        if ( bless != null && bless.is_overloaded() ) {
            PlObject methodCode = bless.overload_lookup(\"(" . $native . "\", 0);
            PlObject copyConstructorCode = bless.overload_lookup(\"(=\", 0);
            if (!methodCode.is_undef()) {

                if (!copyConstructorCode.is_undef()) {
                    o = PerlOp.call(copyConstructorCode, new PlArray(o), PlCx.SCALAR);
                }
                else if (o.is_scalarref()) {
                    // mutator: copy the reference
                    PlObject v = o.scalar_deref(\"main\");
                    if (v.is_lvalue()) {
                        v = new PlLvalue(v.get());
                    }
                    o = new PlLvalueRef(v);
                    o.bless( bless.className() );
                }

                return PerlOp.call(methodCode, new PlArray(o), PlCx.SCALAR);
            }
            // if (bless.is_overload_fallback()) {
            PlObject v = PlClass.overload_to_number(o)." . $perl . "();
            if (o.is_scalarref()) {
                // auto generated mutator: copy the reference
                PlLvalueRef ret = new PlLvalueRef(v);
                ret.bless( bless.className() );
                return ret;
            }
            // TODO - call the 'Copy constructor'
            return v;
        }
        return o.refaddr()." . $perl . "();
    }
"
        } sort {;
            $a cmp $b
        } ("_decr", "_incr"))), ((map {
            my $perl = $_;
            my $native = $perl;
            $perl eq "op_int" && ($native = "int");
            $perl eq "complement" && ($native = "~");
            "    public static PlObject overload_" . $perl . "(PlObject o) {
        PlClass bless = o.blessed_class();
        // PlCORE.say(\"overload_" . $perl . "\");
        if ( bless != null && bless.is_overloaded() ) {
            PlObject methodCode = bless.overload_lookup(\"(" . $native . "\", 0);
            if (!methodCode.is_undef()) {
                // PlCORE.say(\"overload_" . $perl . " hit \");
                return PerlOp.call(methodCode, new PlArray(o), PlCx.SCALAR);
            }
" . ($perl eq "neg" ? "
            // neg falls back to (0-v)
            methodCode = bless.overload_lookup(\"(-\", 0);
            if (!methodCode.is_undef()) {
                // PlCORE.say(\"overload_" . $perl . " fallback (- \");
                return PerlOp.call(methodCode, new PlArray(o, PlCx.INT0, PlCx.TRUE), PlCx.SCALAR);
            }
" : ()) . ($perl eq "abs" ? "
            // abs falls back to (v < 0 ? 0-v : v)
            methodCode = bless.overload_lookup(\"(<\", 0);
            if (!methodCode.is_undef()) {
                // PlCORE.say(\"overload_" . $perl . " fallback (< \");
                int cmp = PerlOp.call(methodCode, new PlArray(o, PlCx.INT0, PlCx.FALSE), PlCx.SCALAR).to_int();
                if (cmp > 0) {
                    return o.neg();
                }
                return o;
            }

            methodCode = bless.overload_lookup(\"(<=>\", 0);
            if (!methodCode.is_undef()) {
                // PlCORE.say(\"overload_" . $perl . " fallback (<=> \");
                int cmp = PerlOp.call(methodCode, new PlArray(o, PlCx.INT0, PlCx.FALSE), PlCx.SCALAR).to_int();
                if (cmp >= 0) {
                    return o;
                }
                return o.neg();
            }
" : ()) . ("
            if (bless.is_overload_fallback()) {
                // PlCORE.say(\"overload_" . $perl . " plain fallback \");
                return PlClass.overload_to_number(o)." . $perl . "();
            }
            // PlCORE.say(\"overload_" . $perl . " fall through \");
            PlCORE.die(\"Operation " . $native . ": no method found\");
        }
        return o.refaddr()." . $perl . "();
    }
")
        } sort {;
            $a cmp $b
        } (@number_unary))), ((map {
            my $perl = $_;
            my $native;
            exists($string_binop{$perl}) && ($native = $string_binop{$perl}->{"str_op"});
            $perl eq "str_cmp" && ($native = "cmp");
            $perl eq "string_replicate" && ($native = "x");
            $perl eq "smartmatch" && ($native = "~~");
            "    public static PlObject overload_" . $perl . "(PlObject o, PlObject other, PlObject swap) {
        PlClass bless = o.blessed_class();
        if ( bless != null && bless.is_overloaded() ) {
            PlObject methodCode = bless.overload_lookup(\"(" . $native . "\", 0);
            if (!methodCode.is_undef()) {
                return PerlOp.call(methodCode, new PlArray(o, other, swap), PlCx.SCALAR);
            }
            if (bless.is_overload_fallback()) {
                o = PlClass.overload_to_string(o);
            }
            else {
                o = o.refstring();
            }
        }
        else {
            o = o.refstring();
        }
        if (swap.to_boolean()) {
            return other." . $perl . "(o);
        }
        return o." . $perl . "(other);
    }
"
        } sort {;
            $a cmp $b
        } ("str_cmp", "string_replicate", "smartmatch", keys(%string_binop)))), ((map {
            my $perl = $_;
            my $native;
            exists($self_assign_number_binop{$perl}) && ($native = $self_assign_number_binop{$perl}->{"op"});
            $perl eq "string_replicate" && ($native = "x=");
            "    public static PlObject overload__self_" . $perl . "(PlObject o, PlObject other, PlObject swap) {
        PlClass bless = o.blessed_class();
        // PlCORE.say(\"in self_assign " . $native . " \");
        if ( bless != null && bless.is_overloaded() ) {
            PlObject methodCode = bless.overload_lookup(\"(" . $native . "\", 0);
            PlObject copyConstructorCode = bless.overload_lookup(\"(=\", 0);
            if (!methodCode.is_undef()) {
                // PlCORE.say(\"self_assign (" . $native . " \" + other.toString());

                if (!copyConstructorCode.is_undef()) {
                    o = PerlOp.call(copyConstructorCode, new PlArray(o), PlCx.SCALAR);
                }
                else if (o.is_scalarref()) {
                    // mutator: copy the reference
                    PlObject v = o.scalar_deref(\"main\");
                    if (v.is_lvalue()) {
                        v = new PlLvalue(v.get());
                    }
                    o = new PlLvalueRef(v);
                    o.bless( bless.className() );
                }

                return PerlOp.call(methodCode, new PlArray(o, other, swap), PlCx.SCALAR);
            }
            // TODO - overload_self_assign_" . $perl . "
            //if (bless.is_overload_fallback()) {
                // PlCORE.say(\"self_assign generated (" . $native . " \" + other.toString());

                PlObject v;
                if (swap.to_boolean()) {
                    v = other." . $perl . "(PlClass.overload_to_number(o));
                }
                else {
                    v = PlClass.overload_to_number(o)." . $perl . "(other);
                }
                if (o.is_scalarref()) {
                    // auto generated mutator: copy the reference
                    PlLvalueRef ret = new PlLvalueRef(v);
                    ret.bless( bless.className() );
                    return ret;
                }
                // TODO - call the 'Copy constructor'
                return v;

            //}
            //else {
            //    o = o.refstring();
            //}
        }
        else {
            o = o.refstring();
        }
        if (swap.to_boolean()) {
            return other." . $perl . "(o);
        }
        return o." . $perl . "(other);
    }
"
        } sort {;
            $a cmp $b
        } ("string_replicate", keys(%self_assign_number_binop)))), ("}
class PlLazyIndex extends PlLazyLvalue {
    private PlArray la;    // \@la
    private int i;         // \$la[\$i]

    public PlLazyIndex(PlArray la, int i) {
        this.la = la;
        this.i  = i;
    }

    // internal lazy api
    public PlLvalue create_scalar() {
        if (llv == null) {
            llv = la.create_scalar(i);
        }
        return llv;
    }

}

class PlLvalueSubstring extends PlLazyLvalue {
    private PlObject lv;
    private String start;
    private String end;
    private String replacement;

    public PlLvalueSubstring(PlObject lv, int offset, int length) {
        this.lv = lv;
        this.replacement = lv.get().substr(offset, length).toString();

        String s = lv.toString();
        int ofs = offset;
        int len = length;
        if (ofs < 0) {
            ofs = s.length() + ofs;
        }

        if (len < 0) {
            len = s.length() + len;
        }
        else {
            len = ofs + len;
        }

        if (len >= s.length()) {
            len = s.length();
        }
        if (ofs < 0) {
            ofs = 0;
        }

        PlObject ret = new PlString(s.substring(ofs, len));
        this.start = \"\";
        this.end = \"\";
        
        if (ofs > 0) {
            this.start = s.substring(0, ofs);
        }
        if (len < s.length()) {
            this.end = s.substring(len);
        }
    }

    // internal lazy api
    public PlLvalue create_scalar() {
        return (PlLvalue)this.lv;
    }

    public PlScalarImmutable get() {
        return new PlString( replacement );
    }

    public PlObject set(PlObject o) {
        this.replacement = o.toString();
        lv.set( new PlString( start + replacement + end ) );
        return this;
    }

    public PlObject pre_decr() {
        // --\$x
        PlObject o = this.get()._decr();
        return this.set(o);
    }
    public PlObject post_decr() {
        // \$x--
        PlObject o = this.get();
        this.set(o._decr());
        return o;
    }
    public PlObject pre_incr() {
        // ++\$x
        PlObject o = this.get()._incr();
        return this.set(o);
    }
    public PlObject post_incr() {
        // \$x++
        PlObject o = this.get();
        this.set(o._incr());
        return o;
    }
}
class PlLazyTiedLookup extends PlLazyLvalue {
    private PlHash la;    // %la
    private String i;     // \$la{\$i}

    public PlLazyTiedLookup(PlHash la, String i) {
        this.la = la;
        this.i  = i;
    }

    // internal lazy api
    public PlLvalue create_scalar() {
        if (llv == null) {
            llv = la.create_scalar(i);
        }
        return llv;
    }

    public PlScalarImmutable get() {
        return (PlScalarImmutable)la.hget(i);
    }

    public PlObject set(PlObject o) {
        la.hset(i, o);
        return this;
    }

    public PlObject pre_decr() {
        // --\$x
        PlObject o = this.get()._decr();
        return this.set(o);
    }
    public PlObject post_decr() {
        // \$x--
        PlObject o = this.get();
        this.set(o._decr());
        return o;
    }
    public PlObject pre_incr() {
        // ++\$x
        PlObject o = this.get()._incr();
        return this.set(o);
    }
    public PlObject post_incr() {
        // \$x++
        PlObject o = this.get();
        this.set(o._incr());
        return o;
    }
}
class PlLazyLookup extends PlLazyLvalue {
    private PlHash la;    // %la
    private String i;     // \$la{\$i}

    public PlLazyLookup(PlHash la, String i) {
        this.la = la;
        this.i  = i;
    }

    // internal lazy api
    public PlLvalue create_scalar() {
        if (llv == null) {
            llv = la.create_scalar(i);
        }
        return llv;
    }
}
class PlLazyScalarref extends PlLazyLvalue {
    private PlLvalue lv;    // \$lv

    public PlLazyScalarref(PlLvalue lv) {
        this.lv = lv;
    }

    // internal lazy api
    public PlLvalue create_scalar() {
        if (this.llv == null) {
            PlLvalue s = new PlLvalue();
            lv.create_scalar().set(new PlLvalueRef(s));
            this.llv = s;
        }
        return this.llv;
    }
}

class PlLazyLvalue extends PlLvalue {
    public  PlLvalue llv;   // \$\$lv

    public PlLazyLvalue() {
    }

    public PlLvalue create_scalar() {
        return (PlLvalue)PlCORE.die(\"internal error: called PlLazyLvalue.create_scalar()\");
    }

    public PlScalarImmutable get() {
        if (llv == null) {
            return PlCx.UNDEF;
        }
        return llv.get();
    }

    // Note: several versions of set()
    public PlObject set(PlObject o) {
        if (llv == null) {
            create_scalar();
        }
        return llv.set(o);
    }
    public PlObject set(PlScalarImmutable o) {
        if (llv == null) {
            create_scalar();
        }
        return llv.set(o);
    }
    public PlObject set(PlLvalue o) {
        if (llv == null) {
            create_scalar();
        }
        return llv.set(o);
    }
"), ((map {
            my $perl = $_;
            "    public PlObject " . $perl . "(PlObject s) {
        return this.get()." . $perl . "(s);
    }
    public PlObject " . $perl . "2(PlObject s) {
        return s." . $perl . "(this.get());
    }
"
        } sort {;
            $a cmp $b
        } ("num_cmp", "mod", keys(%number_binop)))), ((map {
            (my $op, my $type) = @{$_};
            "    public " . $type . " " . $op . "() {
        return this.get()." . $op . "();
    }
"
        } map([$_, "PlObject"], (@number_unary, "blessed", "refaddr", "reftype", "to_num")), map([$_, "boolean"], (@boolean_unary, "is_integer_range")), ["toString", "String"], ["to_int", "int"], ["to_long", "long"], ["to_double", "double"], ["to_boolean", "boolean"], ["blessed_class", "PlClass"], ["ref", "PlString"], ["ref_str", "String"], ["ref_boolean", "boolean"], (map {
            my $class = $java_classes{$_};
            $class->{"import"} || $class->{"extends"} || $class->{"implements"} ? [$class->{"perl_to_java"}, $class->{"java_type"}] : ()
        } grep {;
            $java_classes{$_}->{"perl_to_java"}
        } sort {;
            $a cmp $b
        } keys(%java_classes)))), ("
}
class PlLvalue extends PlScalarObject {
    public PlScalarImmutable o;
    public Integer pos;
    public boolean regex_zero_length_flag;
    public PlObject tied;

    // Note: several versions of PlLvalue()
    public PlLvalue() {
        this.o = PlCx.UNDEF;
    }
    public PlLvalue(long o) {
        this.o = new PlInt(o);
    }
    public PlLvalue(PlObject o) {
        this.o = (PlScalarImmutable)o;
    }
    public PlLvalue(PlScalarImmutable o) {
        this.o = o;
    }
    public PlLvalue(PlLvalue o) {
        this.o = o.get();
    }
    public PlLvalue(PlArray o) {
        // \$a = \@x
        this.o = o.scalar();
    }
    public PlLvalue(PlHash o) {
        // \$a = %x
        this.o = o.scalar();
    }

    public PerlArgumentLookupResult castToClass(ArrayList<Class[]> params, int pos) {
        // want PlLvalue
        for (Class[] cl : params) {
            if (cl[pos].equals( this.getClass() )) {
                return new PerlArgumentLookupResult( this, cl[pos] );
            }
        }
        // try other things
        return this.get().castToClass(params, pos);
    }

    public Iterator<PlObject> iterator() {
        return new PlLvalueIterator(this); 
    }

    // tie scalar
    public PlObject tie(PlArray args) {
        if (this.o.is_filehandle()) {
            return this.o.tie(args);
        }

        if (this.tied != null) {
            this.untie();
        }
        PlObject self = PerlOp.call(\"TIESCALAR\", args, PlCx.VOID);
        this.tied = self;
        return self;
    }

    public PlObject untie() {
        if (this.o.is_filehandle()) {
            return ((PlFileHandle)this.o).untie();
        }

        if (this.tied != null) {
            PlObject tied = this.tied;
            PlObject untie = PerlOp.call(\"can\", new PlArray(tied, new PlString(\"UNTIE\")), PlCx.SCALAR);
            if (untie.to_boolean()) {
                untie.apply(PlCx.VOID, new PlArray(tied));
            };
            this.tied = null;
            return tied;
        }
        return this;
    }
    public PlObject tied() {
        if (this.o.is_filehandle()) {
            return this.o.tied();
        }

        if (this.tied != null) {
            return this.tied;
        }
        return PlCx.UNDEF;
    }
 
    // internal lazy api
    public PlLvalue create_scalar() {
        if (this.o.is_undef()) {
            PlLvalue llv = new PlLvalue();
            this.set(new PlLvalueRef(llv));
            return llv;
        }
        else if (this.o.is_scalarref()) {
            return (PlLvalue)this.o.scalar_deref(\"main\");
        }
        return (PlLvalue)PlCORE.die(\"Not a SCALAR reference\");
    }

    public PlObject pos() {
        // TODO - optimize: we are adding \"pos\" (Integer) to all PlLvalue objects
        if (this.pos == null) {
            return PlCx.UNDEF;
        }
        return new PlInt(this.pos);
    }
    public PlObject set_pos(PlObject value) {
        this.regex_zero_length_flag = false;
        if (value.is_undef()) {
            this.pos = null;
        }
        else {
            this.pos = value.to_int();
        }
        return value;
    }

    public PlScalarImmutable get() {
        if (this.tied != null) {
            PlScalarImmutable v = PerlOp.call(\"FETCH\", new PlArray(tied), PlCx.VOID).scalar();
            this.o = v;
            return v;
        }
        return this.o;
    }
    public PlObject get_scalarref() {
        PlScalarImmutable o = this.get();
        if (o.is_undef()) {
            PlLvalueRef ar = new PlLvalueRef(new PlLvalue());
            this.set(ar);
            return ar;
        }
        else if (o.is_scalarref()) {
            return o;
        }
        // Modification of a read-only value attempted
        return o;
    }
    public PlObject get_arrayref() {
        PlScalarImmutable o = this.get();
        if (o.is_undef()) {
            PlArrayRef ar = new PlArrayRef();
            this.set(ar);
            return ar;
        }
        else if (o.is_arrayref()) {
            return o;
        }
        return PlCORE.die(\"Not an ARRAY reference\");
    }
    public PlObject get_hashref() {
        PlScalarImmutable o = this.get();
        if (o.is_undef()) {
            PlHashRef hr = new PlHashRef();
            this.set(hr);
            return hr;
        }
        else if (o.is_hashref()) {
            return o;
        }
        return PlCORE.die(\"Not a HASH reference\");
    }
    public PlObject aget(int i) {
        PlScalarImmutable o = this.get();
        if (o.is_undef()) {
            o = new PlArrayRef();
            this.set(o);
        }
        return o.aget(i);
    }

    public PlObject aget_scalarref(int i) {
        PlScalarImmutable o = this.get();
        if (o.is_undef()) {
            o = new PlArrayRef();
            this.set(o);
        }
        return o.aget_scalarref(i);
    }
    public PlObject aget_arrayref(int i) {
        PlScalarImmutable o = this.get();
        if (o.is_undef()) {
            o = new PlArrayRef();
            this.set(o);
        }
        return o.aget_arrayref(i);
    }
    public PlObject aget_lvalue(int pos) {
        PlScalarImmutable o = this.get();
        if (o.is_undef()) {
            o = new PlArrayRef();
            this.set(o);
        }
        return o.aget_lvalue(pos);
    }
    public PlObject aget_hashref(int i) {
        PlScalarImmutable o = this.get();
        if (o.is_undef()) {
            o = new PlArrayRef();
            this.set(o);
        }
        return o.aget_hashref(i);
    }

    public PlObject aset(int i, PlObject v) {
        PlScalarImmutable o = this.get();
        if (o.is_undef()) {
            o = new PlArrayRef();
            this.set(o);
        }
        return o.aset(i, v);
    }
    public PlObject hget(String i) {
        PlScalarImmutable o = this.get();
        if (o.is_undef()) {
            o = new PlHashRef();
            this.set(o);
        }
        return o.hget(i);
    }
    public PlObject hget_lvalue(String i) {
        PlScalarImmutable o = this.get();
        if (o.is_undef()) {
            o = new PlHashRef();
            this.set(o);
        }
        return o.hget_lvalue(i);
    }

    public PlObject hget_scalarref(String i) {
        PlScalarImmutable o = this.get();
        if (o.is_undef()) {
            o = new PlHashRef();
            this.set(o);
        }
        return o.hget_scalarref(i);
    }
    public PlObject hget_arrayref(String i) {
        PlScalarImmutable o = this.get();
        if (o.is_undef()) {
            o = new PlHashRef();
            this.set(o);
        }
        return o.hget_arrayref(i);
    }
    public PlObject hget_hashref(String i) {
        PlScalarImmutable o = this.get();
        if (o.is_undef()) {
            o = new PlHashRef();
            this.set(o);
        }
        return o.hget_hashref(i);
    }

    public PlObject hset(String s, PlObject v) {
        PlScalarImmutable o = this.get();
        if (o.is_undef()) {
            o = new PlHashRef();
            this.set(o);
        }
        return o.hset(s, v);
    }
    public PlObject hset(String s, PlLvalue v) {
        PlScalarImmutable o = this.get();
        if (o.is_undef()) {
            o = new PlHashRef();
            this.set(o);
        }
        return o.hset(s, v.get());
    }

    public PlObject scalar_deref(String namespace) {
        PlScalarImmutable o = this.get();
        if (o.is_undef()) {
            return new PlLazyScalarref(this);
        }
        return o.scalar_deref(namespace);
    }
    public PlObject scalar_deref_strict() {
        PlScalarImmutable o = this.get();
        return o.scalar_deref_strict();
    }
    public PlObject scalar_deref_lvalue(String namespace) {
        PlScalarImmutable o = this.get();
        if (o.is_undef()) {
            PlLvalue lv = new PlLvalue();
            this.set(new PlLvalueRef(lv));
            return lv;
        }
        return o.scalar_deref_lvalue(namespace);
    }
    public PlObject scalar_deref_set(String namespace, PlObject v) {
        PlScalarImmutable o = this.get();
        if (o.is_undef()) {
            PlLvalueRef ar = new PlLvalueRef(new PlLvalue());
            this.set(ar);
        }
        return o.scalar_deref_set(namespace, v);
    }

    public PlArray array_deref(String namespace) {
        // \@\$x doesn't autovivify
        PlScalarImmutable o = this.get();
        if (o.is_undef()) {
            return new PlArray();
        }
        else if (o.is_arrayref()) {
            return (PlArray)(o.array_deref(namespace));
        }
        return o.array_deref(namespace);
    }
    public PlArray array_deref_strict() {
        // \@\$x doesn't autovivify
        PlScalarImmutable o = this.get();
        return (PlArray)(o.array_deref_strict());
    }
    public PlArray array_deref_lvalue() {
        PlScalarImmutable o = this.get();
        if (o.is_undef()) {
            PlArrayRef ar = new PlArrayRef();
            this.set(ar);
            return (PlArray)(ar.array_deref_lvalue());
        }
        else if (o.is_arrayref()) {
            return (PlArray)(o.array_deref_lvalue());
        }
        return o.array_deref_strict();
    }
    public PlObject array_deref_set(PlObject v) {
        // \@\$x = ...
        PlScalarImmutable o = this.get();
        if (o.is_undef()) {
            o = new PlArrayRef();
            this.set(o);
            return o.array_deref_set(v);
        }
        else if (o.is_arrayref()) {
            return o.array_deref_set(v);
        }
        return o.array_deref_set(v);
    }

    public PlObject hash_deref(String namespace) {
        // %\$x doesn't autovivify
        PlScalarImmutable o = this.get();
        if (o.is_undef()) {
            return new PlHash();
        }
        else if (o.is_hashref()) {
            return o.hash_deref(namespace);
        }
        return o.hash_deref(namespace);
    }
    public PlHash hash_deref_strict() {
        // %\$x doesn't autovivify
        PlScalarImmutable o = this.get();
        return o.hash_deref_strict();
    }
    public PlObject hash_deref_set(PlObject v) {
        // %\$x = ...
        PlScalarImmutable o = this.get();
        if (o.is_undef()) {
            o = new PlHashRef();
            this.set(o);
            return o.hash_deref_set(v);
        }
        else if (o.is_hashref()) {
            return o.hash_deref_set(v);
        }
        return o.hash_deref_set(v);
    }

    // Note: several versions of set()
    public PlObject set(PlObject o) {
        if (o == null) {
            o = PlCx.UNDEF;
        }
        if (o.is_lvalue()) {
            o = o.get();
        }
        if (this.tied != null) {
            PerlOp.call(\"STORE\", new PlArray(tied, o), PlCx.VOID);
            return this;
        }
        this.o = (PlScalarImmutable)o;
        return this;
    }
    public PlObject set(PlScalarImmutable o) {
        if (this.tied != null) {
            PerlOp.call(\"STORE\", new PlArray(tied, o), PlCx.VOID);
            return this;
        }
        this.o = o;
        return this;
    }
    public PlObject set(PlLvalue o) {
        if (this.tied != null) {
            PerlOp.call(\"STORE\", new PlArray(tied, o), PlCx.VOID);
            return this;
        }
        this.o = o.get();
        return this;
    }
    public PlObject set(PlArray o) {
        // \$a = \@x
        return this.set(o.scalar());
    }
    public PlObject set(PlHash o) {
        // \$a = %x
        return this.set(o.scalar());
    }
    public PlObject set(Object o) {
        // \$a = new Object()
        return this.set(PlJavaObject.fromObject(o));
    }
    public PlObject set(String s) {
        if (s == null) {
            this.set(PlCx.UNDEF);
            return this;
        }
        this.set(new PlString(s));
        return this;
    }
    public PlObject set(boolean s) {
        this.set(new PlBool(s));
        return this;
    }
    public PlObject set(double s) {
        this.set(new PlDouble(s));
        return this;
    }
    public PlObject set(long s) {
        this.set(new PlInt(s));
        return this;
    }

    public PlScalarImmutable length() {
        return this.get().length();
    }
    public PlObject apply(int want, PlArray List__) {
        return this.get().apply(want, List__);
    }
    public PlObject hexists(String a) {
        // exists \$v->{\$a}
        return this.get().hexists(a);
    }
    public PlObject hexists(PlObject a) {
        // exists \$v->{\$a}
        return this.get().hexists(a);
    }
    public PlObject aexists(PlObject a) {
        // exists \$v->[\$a]
        return this.get().aexists(a);
    }
    public PlObject hdelete(int want, PlObject a) {
        // delete \$v->{\$a}
        return this.get().hdelete(want, a);
    }
    public PlObject adelete(int want, PlObject a) {
        // delete \$v->[\$a]
        return this.get().adelete(want, a);
    }

    public PlObject vecSet(PlObject pOffset, PlObject pBits, PlObject pValue) {
        // vec(\$i,  0, 32) = 0x5065726C
        String vv  = this.toString();
        int offset = pOffset.to_int();
        if (offset < 0) {
            return PlCORE.die(\"Negative offset to vec in lvalue context: \" + offset);
        }
        int bits   = pBits.to_int();
        long value = pValue.to_long();
        StringBuilder sb = new StringBuilder(vv);
        if (bits == 1) {
            int byteOfs = offset / 8;
            int bitOfs  = offset - 8 * byteOfs;
            value = (value & 0b0001) << bitOfs;
            long mask = 0b0001 << bitOfs;
            if (byteOfs < sb.length()) {
                value = (sb.charAt(byteOfs) & ~mask) | value;
            }
            // fallback to 8bit
            offset = byteOfs;
            bits = 8;
        }
        if (bits == 2) {
            int byteOfs = offset / 4;
            int bitOfs  = 2 * (offset - 4 * byteOfs);
            value = (value & 0b0011) << bitOfs;
            long mask = 0b0011 << bitOfs;
            if (byteOfs < sb.length()) {
                value = (sb.charAt(byteOfs) & ~mask) | value;
            }
            // fallback to 8bit
            offset = byteOfs;
            bits = 8;
        }
        if (bits == 4) {
            int byteOfs = offset / 2;
            int bitOfs  = 4 * (offset - 2 * byteOfs);
            value = (value & 0b1111) << bitOfs;
            long mask = 0b1111 << bitOfs;
            if (byteOfs < sb.length()) {
                value = (sb.charAt(byteOfs) & ~mask) | value;
            }
            // fallback to 8bit
            offset = byteOfs;
            bits = 8;
        }
        if (bits == 8) {
            if (offset >= sb.length()) {
                sb.setLength(offset + 1);
            }
            sb.setCharAt(offset, (char)(value & 0xFF));
            return this.set(new PlString(sb.toString()));
        }
        if (bits == 16) {
            if ((offset + 1) >= sb.length()) {
                sb.setLength(offset + 2);
            }
            sb.setCharAt(offset,     (char)((value >> 8) & 0xFF));
            sb.setCharAt(offset + 1, (char)(value & 0xFF));
            return this.set(new PlString(sb.toString()));
        }
        if (bits == 32) {
            if ((offset + 3) >= sb.length()) {
                sb.setLength(offset + 4);
            }
            sb.setCharAt(offset,     (char)((value >> 24) & 0xFF));
            sb.setCharAt(offset + 1, (char)((value >> 16) & 0xFF));
            sb.setCharAt(offset + 2, (char)((value >>  8) & 0xFF));
            sb.setCharAt(offset + 3, (char)(value & 0xFF));
            return this.set(new PlString(sb.toString()));
        }
        return PlCORE.die(\"Illegal number of bits in vec: \" + bits);
    }

    public boolean is_lvalue() {
        return true;
    }
    public Object toJava() {
        PlScalarImmutable res = this.get();
        if ( res.is_JavaObject() ) {
            return res.toJava();
        }
        return res;
    }
 
    public PlObject pre_decr() {
        // --\$x
        PlScalarImmutable res = this.get();
        return this.set((PlScalarImmutable)res._decr());
    }
    public PlObject post_decr() {
        // \$x--
        PlScalarImmutable res = this.get();
        this.set((PlScalarImmutable)res._decr());
        return res;
    }
    public PlObject pre_incr() {
        // ++\$x
        PlScalarImmutable res = this.get();
        return this.set((PlScalarImmutable)res._incr());
    }
    public PlObject post_incr() {
        // \$x++
        PlScalarImmutable res = this.get();
        this.set((PlScalarImmutable)res._incr());
        return res;
    }
    public PlObject bless(String className) {
        return this.get().bless(className);
    }

    public PlObject pow(PlObject arg)    { return this.get().pow(arg); }
    public PlObject atan2(PlObject arg)  { return this.get().atan2(arg); }

    public PlScalarImmutable scalar() {
        return this.get();
    }
    public PlObject clone() throws CloneNotSupportedException {
        return this.get().clone();
    }

    public PlObject self_assign_or(PlObject s) {
        return (this.to_boolean() ? this : this.set(s));
    }
    public PlObject self_assign_and(PlObject s) {
        return (this.to_boolean() ? this.set(s) : this);
    }
"), ((map {
            my $perl = $_;
            "    public PlObject " . $perl . "(PlObject s) {
        if (this.tied != null) {
            PlScalarImmutable v = PerlOp.call(\"FETCH\", new PlArray(tied), PlCx.VOID).scalar();
            this.o = v;
        }
        return this.o." . $perl . "(s);
    }
    public PlObject " . $perl . "2(PlObject s) {
        if (this.tied != null) {
            PlScalarImmutable v = PerlOp.call(\"FETCH\", new PlArray(tied), PlCx.VOID).scalar();
            this.o = v;
        }
        return s." . $perl . "(this.o);
    }
"
        } sort {;
            $a cmp $b
        } ("num_cmp", "mod", keys(%number_binop)))), ((map {
            my $perl = $_;
            "    public PlObject self_assign_" . $perl . "(PlObject s) {
        return this.set(this.get()._self_" . $perl . "(s));
    }
"
        } sort {;
            $a cmp $b
        } ("string_replicate", keys(%self_assign_number_binop)))), ((map {
            my $perl = $_;
            "    public PlObject self_assign_" . $perl . "(PlObject s) {
        return PlCORE.die(\"not implemented\");
    }
"
        } sort {;
            $a cmp $b
        } ("str_and", "str_or", "str_xor"))), ((map {
            (my $op, my $type) = @{$_};
            "    public " . $type . " " . $op . "() {
        if (this.tied != null) {
            PlScalarImmutable v = PerlOp.call(\"FETCH\", new PlArray(tied), PlCx.VOID).scalar();
            this.o = v;
        }
        return this.o." . $op . "();
    }
"
        } map([$_, "PlObject"], (@number_unary, "blessed", "refaddr", "reftype", "to_num")), map([$_, "boolean"], (@boolean_unary, "is_integer_range")), ["toString", "String"], ["to_int", "int"], ["to_long", "long"], ["to_double", "double"], ["to_boolean", "boolean"], ["blessed_class", "PlClass"], ["ref", "PlString"], ["ref_str", "String"], ["ref_boolean", "boolean"], (map {
            my $class = $java_classes{$_};
            $class->{"import"} || $class->{"extends"} || $class->{"implements"} ? [$class->{"perl_to_java"}, $class->{"java_type"}] : ()
        } grep {;
            $java_classes{$_}->{"perl_to_java"}
        } sort {;
            $a cmp $b
        } keys(%java_classes)))), ("
}

"), ("
class PlROvalue extends PlLvalue {

    // Note: several versions of PlROvalue()
    public PlROvalue() {
        this.o = PlCx.UNDEF;
    }
    public PlROvalue(PlObject o) {
        this.o = (PlScalarImmutable)o;
    }
    public PlROvalue(PlScalarImmutable o) {
        this.o = o;
    }
    public PlROvalue(PlLvalue o) {
        this.o = o.get();
    }
    public PlROvalue(PlArray o) {
        // \$a = \@x
        this.o = o.scalar();
    }
    public PlROvalue(PlHash o) {
        // \$a = %x
        this.o = o.scalar();
    }

    public PlObject set(Object o) {
        PlCORE.die(\"Modification of a read-only value attempted\");
        return this;
    }
    public PlObject set(PlScalarImmutable o) {
        return PlCORE.die(\"Modification of a read-only value attempted\");
    }
    public PlObject set(PlLvalue o) {
        return PlCORE.die(\"Modification of a read-only value attempted\");
    }

    public PlObject pre_decr() {
        return PlCORE.die(\"Modification of a read-only value attempted\");
    }
    public PlObject post_decr() {
        return PlCORE.die(\"Modification of a read-only value attempted\");
    }
    public PlObject pre_incr() {
        return PlCORE.die(\"Modification of a read-only value attempted\");
    }
    public PlObject post_incr() {
        return PlCORE.die(\"Modification of a read-only value attempted\");
    }

}
class PlSlice extends PlArray {
    public PlSlice( PlArrayList a ) {
        this.each_iterator = 0;
        this.a = a;
    }

    public boolean is_slice() {
        return true;
    }
}

class PlTieArrayIterator implements Iterator<PlObject> {
    public PlObject tied;
    private int key;

    public PlTieArrayIterator(PlObject tied) {
        this.tied = tied;
    }
    public PlObject next() {
        return PerlOp.call(\"FETCH\", new PlArray(this.tied, new PlInt(this.key)), PlCx.SCALAR);
    }
    public boolean hasNext() {
        return this.key < PerlOp.call(\"FETCHSIZE\", new PlArray(this.tied), PlCx.SCALAR).to_int();
    }
}
class PlTieArrayList extends PlArrayList {
    public PlObject tied;
    public PlArrayList old_var;

    public PlTieArrayList() {
    }
    // add(PlObject)
    // add(pos, PlObject)
    // get(pos)
    // remove(pos)
    // set(pos, PlObject)
    // size()
    // clear()
    // iterator()

    public boolean add(PlObject v) {
        PerlOp.call(\"PUSH\", new PlArray(this.tied, v), PlCx.SCALAR);
        return true;
    }
    public void add(int i, PlObject v) {
        if (i == 0) {
            PerlOp.call(\"UNSHIFT\", new PlArray(tied, v), PlCx.SCALAR);
        }
        else {
            PerlOp.call(\"PUSH\", new PlArray(tied, v), PlCx.SCALAR);
        }
    }
    public PlScalarImmutable get(int i) {
        return PerlOp.call(\"FETCH\", new PlArray(tied, new PlInt(i)), PlCx.SCALAR).scalar();
    }
    public PlObject remove(int i) {
        if (i == 0) {
            return PerlOp.call(\"SHIFT\", new PlArray(tied), PlCx.SCALAR);
        }
        return PerlOp.call(\"POP\", new PlArray(tied), PlCx.SCALAR);
    }
    public PlObject set(int i, PlObject v) {
        return PerlOp.call(\"STORE\", new PlArray(tied, new PlInt(i), v), PlCx.SCALAR);
    }
    public int size() {
        return PerlOp.call(\"FETCHSIZE\", new PlArray(tied), PlCx.SCALAR).to_int();
    }
    public void clear() {
        PerlOp.call(\"STORESIZE\", new PlArray(tied, PlCx.INT0), PlCx.SCALAR);
    }
    public Iterator<PlObject> iterator() {
        return new PlTieArrayIterator(this.tied);
    }

    // Perl API
    // add == PUSH
    // add(0, v) == UNSHIFT

    public PlObject aexists(PlObject i) {
        return PerlOp.call(\"EXISTS\", new PlArray(tied, i), PlCx.SCALAR);
    }
    public PlObject adelete(int want, PlObject i) {
        return PerlOp.call(\"DELETE\", new PlArray(tied, i), want);
    }

    public PlObject set_end_of_array_index(int i) {
        return PerlOp.call(\"STORESIZE\", new PlArray(tied), PlCx.SCALAR);
    }
    public PlObject aset(int i, PlObject v) {
        this.set(i, v);
        return v;
    }
    public PlObject aget(int i) {
        return this.get(i);
    }
    public PlObject shift() {
        return PerlOp.call(\"SHIFT\", new PlArray(tied), PlCx.SCALAR);
    }
    public PlObject pop() {
        return PerlOp.call(\"POP\", new PlArray(tied), PlCx.SCALAR);
    }

    public PlScalarImmutable scalar() {
        return PerlOp.call(\"SCALAR\", new PlArray(this.tied), PlCx.SCALAR).scalar();
    }
    public boolean is_tiedArray() {
        return true;
    }
    public PlObject tied() {
        return this.tied;
    }
} // PlTieArrayList
class PlArrayList extends ArrayList<PlObject> implements Iterable<PlObject> {
    public PlArrayList() {
    }
    // add(PlObject)
    // add(pos, PlObject)
    // get(pos)
    // remove(pos)
    // set(pos, PlObject)
    // size()
    // clear()
    // iterator()

    // Perl API

    public PlObject aexists(PlObject i) {
        int pos  = i.to_int();
        if (pos < 0) {
            pos = this.size() + pos;
        }
        if (pos < 0 || pos >= this.size()) {
            return PlCx.FALSE;
        }
        return PlCx.TRUE;
    }
    public PlObject adelete(int want, PlObject i) {
        int pos  = i.to_int();
        if (pos < 0) {
            pos = this.size() + pos;
        }
        if ((pos+1) == this.size()) {
            return this.pop();
        }
        if (pos < 0 || pos >= this.size()) {
            return PlCx.FALSE;
        }
        PlObject res = this.aget(pos);
        this.aset(pos, PlCx.UNDEF);
        return res;
    }

    public PlObject set_end_of_array_index(int i) {
        int size = i + 1;
        while (this.size() < size) {
            this.add(PlCx.UNDEF);
        }
        if (size < this.size() && this.size() > 0) {
            this.removeRange(size, this.size());
        }
        return new PlInt(this.size());
    }
    public PlObject aset(int i, PlObject v) {
        int size = this.size();
        int pos  = i;
        if (pos < 0) {
            pos = size + pos;
        }
        if (size <= pos) {
            while (size < pos) {
                this.add( PlCx.UNDEF );
                size++;
            }
            this.add(v.scalar());
            return v;
        }
        PlObject old = this.get(pos);
        if (old.is_lvalue()) {
            old.set(v.scalar());
        }
        else {
            this.set(pos, v.scalar());
        }
        return v;
    }
    public PlObject aget(int i) {
        int pos  = i;
        if (pos < 0) {
            pos = this.size() + pos;
        }
        if (pos < 0 || pos >= this.size()) {
            return PlCx.UNDEF;
        }
        return this.get(pos);
    }
    public PlObject shift() {
        int size = this.size();
        if (size > 0) {
            return this.remove(0);
        }
        else {
            return PlCx.UNDEF;
        }
    }
    public PlObject pop() {
        int size = this.size() - 1;
        if (size >= 0) {
            return this.remove(size);
        }
        else {
            return PlCx.UNDEF;
        }
    }

    public PlScalarImmutable scalar() {
        return new PlInt(this.hashCode());
    }
    public boolean is_tiedArray() {
        return false;
    }
    public PlObject tied() {
        return PlCx.UNDEF;
    }
}
class PlArrayLvalueIterator implements Iterator<PlObject> {
    private final PlArray ar;
    private final PlArrayList a;
    private int pos;
    public PlArrayLvalueIterator(PlArray ar) {
        this.ar = ar;
        this.a = ar.a;
        this.pos = 0;
    }
    public PlObject next() {
        PlObject o = this.a.get(pos);
        if (o == null) {
            return new PlLazyIndex(this.ar, pos++);
        }
        if (o.is_lvalue()) {
            pos++;
            return o;
        }
        PlLvalue la = new PlLvalue(o);
        this.a.set(pos++, la);
        return la;
    }
    public boolean hasNext() {
        return pos < this.a.size();
    }
}
class PlArray extends PlObject implements Iterable<PlObject> {
    public PlArrayList a;
    public int each_iterator;

    public Iterator<PlObject> iterator() {
        return new PlArrayLvalueIterator(this); 
    }

    public PlArray( PlArrayList a ) {
        this.each_iterator = 0;
        this.a = a;
    }
    public PlArray() {
        this.each_iterator = 0;
        this.a = new PlArrayList();
    }
    public PlArray(PlObject... args) {
        PlArrayList aa = new PlArrayList();
        for (PlObject s : args) {
            if (s.is_hash()) {
                // \@x = %x;
                s = s.to_array();
            }
            if (s.is_array()) {
                // \@x = ( \@x, \@y );
                for (int i = 0; i < s.to_long(); i++) {
                    PlObject v = s.aget(i);
                    if (v.is_lvalue()) {
                        v = v.get();
                    }
                    aa.add(v);
                }
            }
            else if (s.is_lvalue()) {
                aa.add(s.get());
            }
            else {
                aa.add(s);
            }
        }
        this.each_iterator = 0;
        this.a = aa;
    }

    // TODO - this is part of a possible optimization to: split(\"\", \$str)
    // public PlArray(char... args) {
    //     PlArrayList aa = new PlArrayList();
    //     for (char s : args) {
    //         aa.add(new PlString(s));
    //     }
    //     this.each_iterator = 0;
    //     this.a = aa;
    // }

    // tie hash
    public PlObject tie(PlArray args) {
        if (this.a.is_tiedArray()) {
            this.untie();
        }
        PlTieArrayList v = new PlTieArrayList();
        PlObject self = PerlOp.call(\"TIEARRAY\", args, PlCx.VOID);
        v.tied = self;
        v.old_var = this.a;
        this.a = v;
        return self;
    }

    public PlObject untie() {
        if (this.a.is_tiedArray()) {
            PlObject tied = this.a.tied();
            PlObject untie = PerlOp.call(\"can\", new PlArray(tied, new PlString(\"UNTIE\")), PlCx.SCALAR);
            if (untie.to_boolean()) {
                untie.apply(PlCx.VOID, new PlArray(tied));
            };
            this.a = ((PlTieArrayList)a).old_var;
            return tied;
        }
        return this;
    }
    public PlObject tied() {
        return a.tied();
    }

    // internal lazy api
    public PlLvalue create_scalar(int i) {
        int size = this.a.size();
        int pos  = i;
        if (pos < 0) {
            return (PlLvalue)PlCORE.die(\"internal error: negative index on PlArray.create_scalar()\");
        }
        if (size <= pos) {
            while (size < pos) {
                this.a.add( PlCx.UNDEF );
                size++;
            }
            PlLvalue v = new PlLvalue();
            this.a.add(v);
            return v;
        }
        PlObject old = this.a.get(pos);
        if (old.is_lvalue()) {
            return (PlLvalue)old;
        }
        if (old.is_undef()) {
            PlLvalue v = new PlLvalue();
            this.a.set(pos, v);
            return v;
        }
        return (PlLvalue)PlCORE.die(\"Not a SCALAR reference\");
    }

    public static PlArray construct_list_of_aliases(PlScalarImmutable s) {
        PlArrayList aa = new PlArrayList();
        aa.add(new PlROvalue(s));  // store lvalue as read-only
        return new PlArray(aa);
    }
    public static PlArray construct_list_of_aliases(PlScalarImmutable s1, PlScalarImmutable s2) {
        PlArrayList aa = new PlArrayList();
        aa.add(new PlROvalue(s1));  // store lvalue as read-only
        aa.add(new PlROvalue(s2));  // store lvalue as read-only
        return new PlArray(aa);
    }
    public static PlArray construct_list_of_aliases(PlScalarImmutable... args) {
        PlArrayList aa = new PlArrayList();
        for (PlObject s : args) {
            aa.add(new PlROvalue(s));  // store \"read only\"
        }
        return new PlArray(aa);
    }

    public static PlArray construct_list_of_aliases(PlLvalue s) {
        PlArrayList aa = new PlArrayList();
        aa.add(s);  // store lvalue as-is
        return new PlArray(aa);
    }
    public static PlArray construct_list_of_aliases(PlLvalue s1, PlLvalue s2) {
        PlArrayList aa = new PlArrayList();
        aa.add(s1);  // store lvalue as-is
        aa.add(s2);  // store lvalue as-is
        return new PlArray(aa);
    }

    public static PlArray construct_list_of_aliases(PlArray s) {
        PlArrayList aa = new PlArrayList();
        int ll = s.to_int();
        for (int i = 0; i < ll; i++) {
            aa.add(s.aget_lvalue(i));
        }
        return new PlArray(aa);
    }
    public static PlArray construct_list_of_aliases(PlObject s) {
        PlArrayList aa = new PlArrayList();
        if (s.is_lvalue()) {
            aa.add(s);  // store lvalue as-is
        }
        else if (s.is_hash()) {
            // ( %x );
            s = ((PlHash)s).to_list_of_aliases();
            for (int i = 0; i < s.to_long(); i++) {
                aa.add(s.aget_lvalue(i));
            }
        }
        else if (s.is_array()) {
            // ( \@x, \@y );
            int ll = s.to_int();
            for (int i = 0; i < ll; i++) {
                aa.add(s.aget_lvalue(i));
            }
        }
        else {
            aa.add(new PlROvalue(s));  // store \"read only\"
        }
        return new PlArray(aa);
    }
    public static PlArray construct_list_of_aliases(PlObject... args) {
        PlArrayList aa = new PlArrayList();
        for (PlObject s : args) {
            if (s.is_lvalue()) {
                aa.add(s);  // store lvalue as-is
            }
            else if (s.is_hash()) {
                // ( %x );
                s = ((PlHash)s).to_list_of_aliases();
                for (int i = 0; i < s.to_long(); i++) {
                    aa.add(s.aget_lvalue(i));
                }
            }
            else if (s.is_array()) {
                // ( \@x, \@y );
                int ll = s.to_int();
                for (int i = 0; i < ll; i++) {
                    aa.add(s.aget_lvalue(i));
                }
            }
            else {
                aa.add(new PlROvalue(s));  // store \"read only\"
            }
        }
        return new PlArray(aa);
    }
    public static PlArray construct_list_of_aliases(Object... args) {
        PlArrayList aa = new PlArrayList();
        for (Object s1 : args) {
            PlObject s = PlJavaObject.fromObject(s1);
            if (s.is_lvalue()) {
                aa.add(s);  // store lvalue as-is
            }
            else if (s.is_hash()) {
                // ( %x );
                s = ((PlHash)s).to_list_of_aliases();
                for (int i = 0; i < s.to_long(); i++) {
                    aa.add(s.aget_lvalue(i));
                }
            }
            else if (s.is_array()) {
                // ( \@x, \@y );
                int ll = s.to_int();
                for (int i = 0; i < ll; i++) {
                    aa.add(s.aget_lvalue(i));
                }
            }
            else {
                aa.add(new PlROvalue(s));  // store \"read only\"
            }
        }
        return new PlArray(aa);
    }

    public static PlArray construct_list_of_references(PlObject... args) {
        PlArray aa = PlArray.construct_list_of_aliases(args);
        PlArray result = new PlArray();
        for (PlObject s : aa) {
            result.push_void(new PlLvalueRef(s));
        }
        return result;
    }

    public static void static_list_set(PlObject src, PlLvalue... args) {
        int count = 0;
        for (PlLvalue s : args) {
            s.set(src.aget(count++));
        }
    }
    public static void static_list_set(PlObject src_list, PlObject... args) {
        PlArray src = new PlArray(src_list);
        for (PlObject s : args) {
            if (s.is_hash()) {
                // ( %x );
                ((PlHash)s).set(PlCx.VOID, src);
                src = new PlArray();
            }
            else if (s.is_slice()) {
                // ( \@x[3,4] ); - \"slice\" is not \"slurpy\"
                int s_size = s.to_int();
                for (int i = 0; i < s_size; i++) {
                    s.aset(i, src.shift());
                }
            }
            else if (s.is_array()) {
                // ( \@x ); - \"array\" is \"slurpy\"
                s.set(src);
                src = new PlArray();
            }
            else if (s.is_lvalue()) {
                PlObject o = src.shift();
                s.set(o);
            }
            else if (s.is_undef()) {
                src.shift();   // skip
            }
            else {
                PlCORE.die(\"Can't modify constant item in list assignment\");
            }
        }
    }

    public static PlObject static_list_set(int want, PlObject src, PlLvalue... args) {
        int count = 0;
        for (PlLvalue s : args) {
            s.set(src.aget(count++));
        }
        if (want == PlCx.VOID) {
            return PlCx.UNDEF;
        }
        if (want == PlCx.LIST) {
            return PlArray.construct_list_of_aliases(args);
        }
        return src.scalar();
    }
    public static PlObject static_list_set(int want, PlObject src_list, PlObject... args) {
        PlArray src = new PlArray(src_list);
        for (PlObject s : args) {
            if (s.is_hash()) {
                // ( %x );
                ((PlHash)s).set(PlCx.VOID, src);
                src = new PlArray();
            }
            else if (s.is_slice()) {
                // ( \@x[3,4] ); - \"slice\" is not \"slurpy\"
                int s_size = s.to_int();
                for (int i = 0; i < s_size; i++) {
                    s.aset(i, src.shift());
                }
            }
            else if (s.is_array()) {
                // ( \@x ); - \"array\" is \"slurpy\"
                s.set(src);
                src = new PlArray();
            }
            else if (s.is_lvalue()) {
                PlObject o = src.shift();
                s.set(o);
            }
            else if (s.is_undef()) {
                src.shift();   // skip
            }
            else {
                PlCORE.die(\"Can't modify constant item in list assignment\");
            }
        }
        if (want == PlCx.VOID) {
            return PlCx.UNDEF;
        }
        if (want == PlCx.LIST) {
            return PlArray.construct_list_of_aliases(args);
        }
        return src_list.scalar();
    }
    public PlObject list_set(int want, PlArray s) {
        // \@x[3,4] = ( \@x, \@y );
        for (int i = 0; i < this.to_long(); i++) {
            this.aset(i, s.aget(i));
        }
        this.each_iterator = 0;
        if (want == PlCx.LIST) {
            return this;
        }
        return this.pop();
    }

    public PlObject set(PlObject s) {
        this.a.clear();
        PlObject tmp;
        if (s.is_hash()) {
            // \@x = %x;
            s = s.to_array();
        }
        if (s.is_array()) {
            // \@x = ( \@x, \@y );
            for (int i = 0; i < s.to_long(); i++) {
                tmp = s.aget(i);
                if (tmp.is_lvalue()) {
                    this.a.add(tmp.get());
                }
                else {
                    this.a.add(tmp);
                }
            }
        }
        else {
            this.a.add(s);
        }
        this.each_iterator = 0;
        return this;
    }

    public PlObject set(Map<String, String> env) {
        this.a.clear();
        for (String envName : env.keySet()) {
            this.a.add(new PlString(envName));
            this.a.add(new PlString(env.get(envName)));
        }
        this.each_iterator = 0;
        return this;
    }
    public PlArray(Map<String, String> strings) {
        PlArray arr = new PlArray();
        arr.set(strings);
        this.each_iterator = arr.each_iterator;
        this.a = arr.a;
    }

"), ((map {
            my $native = $_;
            my $perl = $native_to_perl{$native};
            $native && $perl ? "    public PlObject set(" . $native . "[] stuffs) {
        this.a.clear();
        // \@x = " . $native . "[] native;
        for(" . $native . " i : stuffs){
            this.a.add(new " . $perl . "(i));
        }
        this.each_iterator = 0;
        return this;
    }
    public PlArray(" . $native . "[] stuffs) {
        PlArray aa = new PlArray();
        aa.set(stuffs);
        this.each_iterator = aa.each_iterator;
        this.a = aa.a;
    }
" : ()
        } sort {;
            $a cmp $b
        } keys(%native_to_perl))), ("    public PlObject aget(int i) {
        return this.a.aget(i);
    }
    public PlObject aget_lvalue(int pos) {
        int size = this.a.size();
        if (pos < 0) {
            pos = size + pos;
        }
        if (size <= pos) {
            return new PlLazyIndex(this, pos);
        }
        PlObject o = this.a.get(pos);
        if (o == null) {
            return new PlLazyIndex(this, pos);
        }
        if (o.is_lvalue()) {
            return o;
        }
        PlLvalue a = new PlLvalue(o);
        this.a.set(pos, a);
        return a;
    }
    public PlObject aget_lvalue_local(int i) {
        PlObject o = this.a.get(i);
        if (o == null) {
            this.a.set(i, PlCx.UNDEF);
        }
        return PerlOp.push_local(this, i);
    }

    public PlObject aget_list_of_aliases(int want, PlArray a) {
        // \@a[LIST]
        PlArrayList aa = new PlArrayList();
        for (PlObject i : a) {
            aa.add( this.aget_lvalue(i.to_int()) );
        }
        PlSlice result = new PlSlice(aa);
        if (want == PlCx.LIST) {
            return result;
        }
        return result.pop();
    }
    public PlObject aget_hash_list_of_aliases(int want, PlArray a) {
        // %a[LIST]
        PlArrayList aa = new PlArrayList();
        for (PlObject i : a) {
            aa.add( i );
            aa.add( this.aget_lvalue(i.to_int()) );
        }
        PlSlice result = new PlSlice(aa);
        if (want == PlCx.LIST) {
            return result;
        }
        return result.pop();
    }

    public PlObject get_scalar(PlObject s) {
        // \$\$x
        int i = s.to_int();
        PlObject o = this.a.aget(i);
        if (o.is_undef()) {
            PlLvalue a = new PlLvalue();
            this.a.aset(i, new PlLvalueRef(a));
            return a;
        }
        else if (o.is_scalarref()) {
            return o.get();
        }
        // Modification of a read-only value attempted
        // return PlCORE.die(\"Not an SCALAR reference\");
        return o;
    }
    public PlObject aget_scalarref(int i) {
        PlObject o = this.a.aget(i);
        if (o.is_undef()) {
            return new PlLvalueRef(new PlLazyScalarref(new PlLazyIndex(this, i)));
        }
        return o;
    }

    public PlObject aget_arrayref(int i) {
        PlObject o = this.a.aget(i);
        if (o.is_undef()) {
            PlArrayRef ar = new PlArrayRef();
            this.a.aset(i, ar);
            return ar;
        }
        return o;
    }

    public PlObject aget_hashref(int i) {
        PlObject o = this.a.aget(i);
        if (o.is_undef()) {
            PlHashRef hr = new PlHashRef();
            this.a.aset(i, hr);
            return hr;
        }
        return o;
    }

    public PlObject get_hash(int i) {
        PlObject o = this.a.aget(i);
        if (o.is_undef()) {
            PlHashRef hr = new PlHashRef();
            this.a.aset(i, hr);
            return hr;
        }
        else if (o.is_hashref()) {
            return o;
        }
        return PlCORE.die(\"Not a HASH reference\");
    }

    // Note: multiple versions of set()
    public PlObject aset(int i, PlObject v) {
        return this.a.aset(i, v);
    }
    public PlObject aset(int i, PlLvalue v) {
        return this.a.aset(i, v.get());
    }

    public PlObject push(PlObject... args) {
        for (int i = 0; i < args.length; i++) {
            this.push_void(args[i]);
        }
        return new PlInt(this.a.size());
    }
    public void push_void(PlObject... args) {
        for (int i = 0; i < args.length; i++) {
            this.push_void(args[i]);
        }
    }

    public PlObject unshift(PlObject... args) {
        for (int i = args.length-1; i >= 0; i--) {
            this.unshift(args[i]);
        }
        return new PlInt(this.a.size());
    }
    public PlObject aset(int s, Object o) {
        return this.aset(s, PlJavaObject.fromObject(o));
    }
    public PlObject push(Object o) {
        return this.push(PlJavaObject.fromObject(o));
    }
    public void push_void(Object o) {
        this.push_void(PlJavaObject.fromObject(o));
    }
    public PlObject unshift(Object o) {
        return this.unshift(PlJavaObject.fromObject(o));
    }

"), ((map {
            my $native = $_;
            my $perl = $native_to_perl{$native};
            $native && $perl ? "    public PlObject aset(int i, " . $native . " s) {
        return this.aset(i, new " . $perl . "(s));
    }
    public PlObject push(" . $native . " s) {
        return this.push(new " . $perl . "(s));
    }
    public void push_void(" . $native . " s) {
        this.push_void(new " . $perl . "(s));
    }
    public PlObject unshift(" . $native . " s) {
        return this.unshift(new " . $perl . "(s));
    }
" : ()
        } sort {;
            $a cmp $b
        } keys(%native_to_perl))), ("    public PlObject aset_alias(int i, PlLvalue lvalue) {
        return this.a.set(i, lvalue);
    }

    // Note: multiple versions of push()
    public PlObject push(PlObject v) {
        if (v.is_array()) {
            return this.push( (PlArray)v );
        }
        this.a.add(v.scalar());
        return new PlInt(this.a.size());
    }
    public void push_void(PlObject v) {
        if (v.is_array()) {
            this.push_void( (PlArray)v );
            return;
        }
        this.a.add(v.scalar());
    }

    public PlObject push(PlLvalue v) {
        this.a.add(v.get());
        return new PlInt(this.a.size());
    }
    public void push_void(PlLvalue v) {
        this.a.add(v.get());
    }
    public PlObject push(PlArray args) {
        int size = args.a.size();
        for (int i = 0; i < size; i++) {
            PlObject s = args.aget(i);
            if (s.is_hash()) {
                // \@x = %x;
                s = s.to_array();
            }
            if (s.is_array()) {
                this.push_void(s);
            }
            else {
                this.a.add(s);
            }
        }
        return new PlInt(this.a.size());
    }
    public void push_void(PlArray args) {
        int size = args.a.size();
        for (int i = 0; i < size; i++) {
            PlObject s = args.aget(i);
            if (s.is_hash()) {
                // \@x = %x;
                s = s.to_array();
            }
            if (s.is_array()) {
                this.push_void(s);
            }
            else {
                this.a.add(s);
            }
        }
    }

    // Note: multiple versions of unshift()
    public PlObject unshift(PlObject v) {
        if (v.is_array()) {
            return this.unshift( (PlArray)v );
        }
        this.a.add(0, v.scalar());
        return new PlInt(this.a.size());
    }
    public PlObject unshift(PlLvalue v) {
        this.a.add(0, v.get());
        return new PlInt(this.a.size());
    }
    public PlObject unshift(PlArray args) {
        args = new PlArray(args);   // allow \"unshift \@x, \@x\" - TODO: optimize
        int size = args.a.size();
        for (int i = size - 1; i >= 0; i--) {
            PlObject s = args.aget(i);
            if (s.is_hash()) {
                // \@x = %x;
                s = s.to_array();
            }
            if (s.is_array()) {
                this.unshift(s);
            }
            else {
                this.a.add(0, s);
            }
        }
        return new PlInt(this.a.size());
    }

    public PlObject pop() {
        return this.a.pop();
    }
    public PlObject shift() {
        return this.a.shift();
    }
    public PlObject aexists(PlObject i) {
        return this.a.aexists(i);
    }
    public PlObject adelete(int want, PlObject i) {
        return this.a.adelete(want, i);
    }
    public PlObject values() {
        // return a copy
        return new PlArray(this);
    }
    public PlObject keys() {
        PlArray aa = new PlArray();
        int size = this.to_int();
        for (int i = 0; i < size; i++) {
            aa.push_void(new PlInt(i));
        }
        return aa;
    }
    public PlObject each() {
        PlArray aa = new PlArray();
        int size = this.to_int();
        if (this.each_iterator < size) {
            aa.push_void(new PlInt(this.each_iterator));
            aa.push_void(this.a.aget(this.each_iterator));
            this.each_iterator++;
        }
        else {
            // return empty list
            this.each_iterator = 0;
        }
        return aa;
    }
    public String toString() {
        StringBuilder sb = new StringBuilder();
        int size = this.to_int();
        for (int i = 0; i < size; i++) {
            String item = this.a.aget(i).toString();
            sb.append(item);
        }
        return sb.toString();
    }
    public long to_long() {
        return this.a.size();
    }
    public int to_int() {
        return this.a.size();
    }
    public PlScalarImmutable length_of_array() {
        return new PlInt(this.a.size());
    }
    public boolean length_of_array_boolean() {
        return ( this.a.size() > 0 );
    }
    public int length_of_array_int() {
        return this.a.size();
    }
    public PlObject end_of_array_index() {
        return new PlInt(this.a.size() - 1);
    }
    public PlObject set_end_of_array_index(PlObject o) {
        return this.a.set_end_of_array_index(o.to_int());
    }
    public double to_double() {
        return 0.0 + this.to_long();
    }
    public boolean to_boolean() {
        return (this.a.size() > 0);
    }
    public PlObject to_num() {
        return new PlInt(this.a.size());
    }
    public boolean is_array() {
        return true;
    }
    public PlScalarImmutable scalar() {
        return new PlInt(this.a.size());
    }
}


class PlTieHashIterator implements Iterator<Map.Entry<String, PlObject>> {
    public PlObject tied;
    private PlObject key;

    public PlTieHashIterator(PlObject tied) {
        this.tied = tied;
    }
    public Map.Entry<String, PlObject> next() {
        return new AbstractMap.SimpleEntry<String, PlObject>(
                    this.key.toString(),
                    PerlOp.call(\"FETCH\", new PlArray(this.tied, this.key), PlCx.SCALAR)
               );
    }
    public boolean hasNext() {
        if (this.key == null) {
            this.key = PerlOp.call(\"FIRSTKEY\", new PlArray(this.tied), PlCx.SCALAR);
        }
        else {
            this.key = PerlOp.call(\"NEXTKEY\", new PlArray(this.tied), PlCx.SCALAR);
        }
        return !this.key.is_undef();
    }
}
class PlTieHashMap extends PlHashMap {
    public PlObject tied;
    public PlHashMap old_var;

    public PlTieHashMap() {
    }
    // get(String)
    // put(String, PlObject)
    // containsKey(String)
    // remove(String)
    // clear()
    // entrySet().iterator() == iterator()

    public PlScalarImmutable get(Object i) {
        return PerlOp.call(\"FETCH\", new PlArray(this.tied, new PlString((String)i)), PlCx.SCALAR).scalar();
    }
    public PlObject put(String i, PlObject v) {
        return PerlOp.call(\"STORE\", new PlArray(this.tied, new PlString(i), v), PlCx.SCALAR);
    }
    public boolean containsKey(Object i) {
        return PerlOp.call(\"EXISTS\", new PlArray(this.tied, new PlString((String)i)), PlCx.SCALAR).to_boolean();
    }
    public PlObject remove(Object i) {
        return PerlOp.call(\"DELETE\", new PlArray(this.tied, new PlString((String)i)), PlCx.SCALAR);
    }
    public void clear() {
        PerlOp.call(\"CLEAR\", new PlArray(this.tied), PlCx.SCALAR);
    }
    public Iterator<Map.Entry<String, PlObject>> iterator() {
        return new PlTieHashIterator(this.tied);
    }
    public PlScalarImmutable scalar() {
        return PerlOp.call(\"SCALAR\", new PlArray(this.tied), PlCx.SCALAR).scalar();
    }
    public boolean is_tiedHash() {
        return true;
    }
    public PlObject tied() {
        return this.tied;
    }

} // PlTieHashMap

class PlHashIterator {
    public Iterator<Map.Entry<String, PlObject>> iterator;

    public PlHashIterator() {
    }
    public void reset() {
        iterator = null;
    }
}
class PlHashMap extends HashMap<String, PlObject> implements Iterable<Map.Entry<String, PlObject>> {
    public PlHashMap() {
    }
    // get(String)
    // put(String, PlObject)
    // containsKey(String)
    // remove(String)
    // clear()
    // entrySet().iterator() == iterator()

    public Iterator<Map.Entry<String, PlObject>> iterator() {
        return this.entrySet().iterator();
    }
    public PlScalarImmutable scalar() {
        return new PlInt(this.hashCode());
    }
    public boolean is_tiedHash() {
        return false;
    }
    public PlObject tied() {
        return PlCx.UNDEF;
    }
}
class PlHashLvalueIterator implements Iterator<PlObject> {
    private final PlHash hr;
    private final PlHashMap h;
    private Iterator<Map.Entry<String, PlObject>> each_iterator;
    private boolean is_key;
    private Map.Entry<String, PlObject> entry;
    private String key;

    public PlHashLvalueIterator(PlHash hr) {
        this.hr = hr;
        this.h = hr.h;
        this.each_iterator = this.h.iterator();
        this.is_key = true;
    }
    public PlObject next() {
        if (is_key) {
            is_key = false;
            this.entry = this.each_iterator.next();
            this.key   = entry.getKey();
            return new PlLvalue(new PlString(this.key));
        }
        is_key = true;
        PlObject o = this.entry.getValue();
        if (o == null) {
            return new PlLazyLookup(this.hr, this.key);
        }
        if (o.is_lvalue()) {
            return o;
        }
        PlLvalue lh = new PlLvalue(o);
        this.h.put(this.key, lh);
        return lh;
    }
    public boolean hasNext() {
        if (is_key) {
            return this.each_iterator.hasNext();
        }
        return true;
    }
}
class PlHash extends PlObject implements Iterable<PlObject> {
    public PlHashMap h;
    public PlHashIterator each_iterator;

    public Iterator<PlObject> iterator() {
        return new PlHashLvalueIterator(this); 
    }

    public PlHash() {
        this.each_iterator = new PlHashIterator();
        this.h = new PlHashMap();
        this.each_iterator.reset();
    }
    public PlHash(PlObject... args) {
        this.each_iterator = new PlHashIterator();
        this.h = new PlHashMap();
        int args_size = args.length;
        for (int i = 0; i < args_size; i++) {
            PlObject s = args[i];
            if (s.is_hash()) {
                // \@x = %x;
                s = s.to_array();
            }
            if (s.is_array()) {
                // %x = ( \@x, \@y );
                int array_size = s.to_int();
                for (int j = 0; j < array_size; j++) {
                    String key = s.aget(j).toString();
                    j++;
                    PlObject value;
                    if ( j >= array_size ) {
                        // TODO - emit warning about odd number of arguments
                        value = PlCx.UNDEF;
                    }
                    else {
                        value = s.aget(j);
                    }
                    this.hset(key, value);
                }
            }
            else {
                i++;
                PlObject value;
                if ( i >= args_size ) {
                    // TODO - emit warning about odd number of arguments
                    value = PlCx.UNDEF;
                }
                else {
                    value = args[i];
                }
                this.hset(s.toString(), value);
            }
        }
        this.each_iterator.reset();
    }


    // tie hash
    public PlObject tie(PlArray args) {
        if (this.h.is_tiedHash()) {
            this.untie();
        }
        PlTieHashMap v = new PlTieHashMap();
        PlObject self = PerlOp.call(\"TIEHASH\", args, PlCx.VOID);
        v.tied = self;
        v.old_var = this.h;
        this.h = v;
        return self;
    }

    public PlObject untie() {
        if (this.h.is_tiedHash()) {
            PlObject tied = this.h.tied();
            PlObject untie = PerlOp.call(\"can\", new PlArray(tied, new PlString(\"UNTIE\")), PlCx.SCALAR);
            if (untie.to_boolean()) {
                untie.apply(PlCx.VOID, new PlArray(tied));
            };
            this.h = ((PlTieHashMap)h).old_var;
            return tied;
        }
        return this;
    }
    public PlObject tied() {
        return h.tied();
    }


    // internal lazy api
    public PlLvalue create_scalar(String i) {
        PlObject o = this.h.get(i);
        if (o == null) {
            PlLvalue a = new PlLvalue();
            this.h.put(i, a);
            return a;
        }
        if (o.is_lvalue()) {
            return (PlLvalue)o;
        }
        if (o.is_undef()) {
            PlLvalue a = new PlLvalue();
            this.h.put(i, a);
            return a;
        }
        return (PlLvalue)PlCORE.die(\"Not a SCALAR reference\");
    }

    public PlObject set(int want, PlObject s) {
        this.h.clear();
        if (s.is_hash()) {
            // \@x = %x;
            s = s.to_array();
        }
        if (s.is_array()) {
            // %x = ( \@x, \@y );
            int array_size = s.to_int();
            for (int j = 0; j < array_size; j++) {
                String key = s.aget(j).toString();
                j++;
                PlObject value;
                if ( j >= array_size ) {
                    // odd number of arguments
                    if (array_size == 1 && s.aget(0).is_ref()) {
                        PlCORE.warn(PlCx.VOID, new PlArray(new PlString(\"Reference found where even-sized list expected\")));
                    }
                    else {
                        PlCORE.warn(PlCx.VOID, new PlArray(new PlString(\"Odd number of elements in hash assignment\")));
                    }
                    value = PlCx.UNDEF;
                }
                else {
                    value = s.aget(j);
                }
                this.hset(key, value);
            }
        }
        else {
            // TODO - emit warning about odd number of arguments
            PlCORE.warn(PlCx.VOID, new PlArray(new PlString(\"Odd number of elements in hash assignment\")));
            this.hset(s.toString(), PlCx.UNDEF);
        }
        this.each_iterator.reset();
        if (want == PlCx.LIST) {
            return this.to_list_of_aliases();
        }
        return s.scalar();
    }

    public PlObject to_array() {
        PlArray aa = new PlArray();
        for (Map.Entry<String, PlObject> entry : this.h) {
            String key = entry.getKey();
            PlObject value = entry.getValue();
            aa.push_void(new PlString(key));
            aa.push_void(value);
        }
        return aa;
    }

    public PlArray to_list_of_aliases() {
        PlArrayList aa = new PlArrayList();
        for (Map.Entry<String, PlObject> entry : this.h) {
            String key = entry.getKey();
            aa.add(new PlString(key));
            PlObject value = this.hget_lvalue(key);
            aa.add(value);
        }
        PlSlice result = new PlSlice(aa);
        return result;
    }

    public PlObject hget(String i) {
        PlObject o = this.h.get(i);
        if (o == null) {
            return PlCx.UNDEF;
        }
        return o;
    }
    public PlObject hget_list_of_aliases(int want, PlArray a) {
        // \@a{LIST}
        PlArrayList aa = new PlArrayList();
        for (int i = 0; i < a.to_int(); i++) {
            String key = a.aget(i).toString();
            PlObject value = this.hget_lvalue(key);
            aa.add(value);
        }
        PlSlice result = new PlSlice(aa);
        if (want == PlCx.LIST) {
            return result;
        }
        return result.pop();
    }
    public PlObject hget_hash_list_of_aliases(int want, PlArray a) {
        // %a{LIST}
        PlArrayList aa = new PlArrayList();
        for (int i = 0; i < a.to_int(); i++) {
            String key = a.aget(i).toString();
            aa.add(new PlString(key));
            PlObject value = this.hget_lvalue(key);
            aa.add(value);
        }
        PlArray result = new PlArray(aa);
        if (want == PlCx.LIST) {
            return result;
        }
        return result.pop();
    }

    public PlObject hget_lvalue(String i) {
        PlObject o = this.h.get(i);
        if (o == null) {
            return new PlLazyLookup(this, i);
        }
        else if (o.is_lvalue()) {
            return o;
        }

        if (this.h.is_tiedHash()) {
            return new PlLazyTiedLookup(this, i);
        }

        PlLvalue a = new PlLvalue(o);
        this.h.put(i, a);
        return a;
    }
    public PlObject hget_lvalue_local(String i) {
        PlObject o = this.h.get(i);
        if (o == null) {
            this.h.put(i, PlCx.UNDEF);
        }

        if (this.h.is_tiedHash()) {
            PerlOp.push_local(this, i);
            return new PlLazyTiedLookup(this, i);
        }

        return PerlOp.push_local(this, i);
    }

    public PlObject get_scalar(PlObject arg) {
        // \$\$x
        String s = arg.toString();
        PlObject o = this.h.get(s);
        if (o == null || o.is_undef()) {
            PlLvalue a = new PlLvalue();
            this.hset(s, new PlLvalueRef(a));
            return a;
        }
        else if (o.is_scalarref()) {
            return o.get();
        }
        // Modification of a read-only value attempted
        // return PlCORE.die(\"Not an SCALAR reference\");
        return o;
    }

    public PlObject hget_scalarref(String i) {
        PlObject o = this.h.get(i);
        if (o == null || o.is_undef()) {
            return new PlLvalueRef(new PlLazyScalarref(new PlLazyLookup(this, i)));
        }
        else if (o.is_scalarref()) {
            return o;
        }
        // Modification of a read-only value attempted
        return o;
    }

    public PlObject hget_arrayref(String i) {
        PlObject o = this.h.get(i);
        if (o == null || o.is_undef()) {
            PlArrayRef ar = new PlArrayRef();
            this.hset(i, ar);
            return ar;
        }
        else if (o.is_arrayref()) {
            return o;
        }
        return PlCORE.die(\"Not an ARRAY reference\");
    }

    public PlObject hget_hashref(String i) {
        PlObject o = this.h.get(i);
        if (o == null || o.is_undef()) {
            PlHashRef hr = new PlHashRef();
            this.hset(i, hr);
            return hr;
        }
        else if (o.is_hashref()) {
            return o;
        }
        return PlCORE.die(\"Not a HASH reference\");
    }

    // Note: multiple versions of set()
    public PlObject hset(String key, PlObject v) {
        PlObject value = v.scalar();
        PlObject o = this.h.get(key);
        if (o != null && o.is_lvalue()) {
            o.set(value);
        }
        else {
            this.h.put(key, value);
        }
        return v;
    }
    public PlObject hset(String key, PlLvalue v) {
        PlObject value = v.get();
        PlObject o = this.h.get(key);
        if (o != null && o.is_lvalue()) {
            o.set(value);
        }
        else {
            this.h.put(key, value);
        }
        return v;
    }
    public PlObject hset(int want, PlArray s, PlArray v) {
        PlArray aa = new PlArray();

        for (int i = 0; i < v.to_int(); i++){
            aa.push_void(this.hset(v.aget(i).toString(), s.aget(i)));
        };
        if (want == PlCx.LIST) {
            return aa;
        }
        return aa.pop();
    }
    public PlObject hset_alias(String s, PlObject lvalue) {
        return this.h.put(s, lvalue);
    }
    public PlObject hexists(String i) {
        return this.h.containsKey(i) ? PlCx.TRUE : PlCx.FALSE;
    }
    public PlObject hexists(PlObject i) {
        return this.h.containsKey(i.toString()) ? PlCx.TRUE : PlCx.FALSE;
    }
    public PlObject hdelete(int want, PlObject i) {
        PlObject r = this.h.remove(i.toString());
        if (r == null) {
            return PlCx.UNDEF;
        }
        return r;
    }
    public PlObject hdelete(int want, PlArray a) {
        PlArray aa = new PlArray();

        for (int i = 0; i < a.to_int(); i++) {
            PlObject r = this.hdelete(want, a.aget(i));
            aa.push_void(r);
        }
        if (want == PlCx.LIST) {
            return aa;
        }
        return aa.pop();
    }
    public PlObject hdelete(int want, PlString a) {
        PlArray aa = new PlArray();
        aa.push_void(a);
        return this.hdelete(want, aa);
    }
    public PlObject hdelete(int want, PlLvalue a) {
        PlArray aa = new PlArray();
        aa.push_void(a);
        return this.hdelete(want, aa);
    }
    public PlObject values() {
        PlArray aa = new PlArray();
        for (Map.Entry<String, PlObject> entry : this.h) {
            PlObject value = entry.getValue();
            aa.push_void(value);
        }
        return aa;
    }
    public PlObject keys() {
        PlArray aa = new PlArray();
        for (Map.Entry<String, PlObject> entry : this.h) {
            String key = entry.getKey();
            aa.push_void(new PlString(key));
        }
        return aa;
    }
    public PlObject each() {
        PlArray aa = new PlArray();
        if (this.each_iterator.iterator == null) {
            this.each_iterator.iterator = this.h.iterator();
        }
        if (this.each_iterator.iterator.hasNext()) {
            Map.Entry<String, PlObject> entry = this.each_iterator.iterator.next();
            String key = entry.getKey();
            aa.push_void(new PlString(key));
            PlObject value = entry.getValue();
            aa.push_void(value);
        }
        else {
            // return empty list
            this.each_iterator.reset();
        }
        return aa;
    }
    public PlObject hset(String s, Object o) {
        return this.hset(s, PlJavaObject.fromObject(o));
    }
"), ((map {
            my $native = $_;
            my $perl = $native_to_perl{$native};
            $native && $perl ? "    public PlObject hset(String s, " . $native . " v) {
        return this.hset(s, new " . $perl . "(v));
    }
" : ()
        } sort {;
            $a cmp $b
        } keys(%native_to_perl))), ("
    public String toString() {
        // TODO
        return \"\" + this.hashCode();
    }
    public int to_int() {
        // TODO
        return this.hashCode();
    }
    public long to_long() {
        // TODO
        return this.hashCode();
    }
    public double to_double() {
        return 0.0 + this.to_long();
    }
    public boolean to_boolean() {
        for (Map.Entry<String, PlObject> entry : this.h) {
            return true;
        }
        return false;
    }
    public PlObject to_num() {
        return this.scalar();
    }
    public boolean is_hash() {
        return true;
    }
    public PlScalarImmutable scalar() {
        return this.h.scalar();
    }
}
class PlUndef extends PlScalarImmutable {
    public PlUndef() {
    }
    public PlObject apply(int want, PlArray List__) {
        // \$a->()
        PlCORE.die(\"Can't use an undefined value as a subroutine reference\");
        return this;
    }
    public PlScalarImmutable length() {
        return PlCx.UNDEF;
    }
    public int to_int() {
        return 0;
    }
    public long to_long() {
        return 0;
    }
    public double to_double() {
        return 0.0;
    }
    public String toString() {
        return \"\";
    }
    public boolean to_boolean() {
        return false;
    }
    public PlObject to_num() {
        return PlCx.INT0;
    }
    public boolean is_undef() {
        return true;
    }

    public PlObject scalar_deref_strict() {
        return PlCORE.die(\"Can't use an undefined value as a SCALAR reference\");
    }
    public PlArray array_deref_strict() {
        return (PlArray)PlCORE.die(\"Can't use an undefined value as an ARRAY reference\");
    }
    public PlHash hash_deref_strict() {
        return (PlHash)PlCORE.die(\"Can't use an undefined value as a HASH reference\");
    }

}
class PlBool extends PlScalarImmutable {
    private final boolean i;
    public PlBool(boolean i) {
        this.i = i;
    }

    public PerlArgumentLookupResult castToClass(ArrayList<Class[]> params, int pos) {
        // want boolean
        for (Class[] cl : params) {
            if (cl[pos].equals( java.lang.Boolean.TYPE )) {
                return new PerlArgumentLookupResult( this.to_boolean(), cl[pos] );
            }
        }
        // try other things
        return super.castToClass(params, pos);
    }

    public int to_int() {
        if (this.i) {
            return 1;
        }
        else {
            return 0;
        }
    }
    public long to_long() {
        if (this.i) {
            return 1;
        }
        else {
            return 0;
        }
    }
    public double to_double() {
        if (this.i) {
            return 1.0;
        }
        else {
            return 0.0;
        }
    }
    public String toString() {
        if (this.i) {
            return \"1\";
        }
        else {
            return \"\";
        }
    }
    public boolean to_boolean() {
        return this.i;
    }
    public PlObject to_num() {
        if (i) {
            return PlCx.INT1;
        }
        else {
            return PlCx.INT0;
        }
    }
    public boolean is_bool() {
        return true;
    }
    public PlObject _decr() {
        // --\$x
        if (i) {
            return PlCx.INT0;
        }
        else {
            return PlCx.MIN1;
        }
    }
    public PlObject _incr() {
        // ++\$x
        if (i) {
            return PlCx.INT2;
        }
        else {
            return PlCx.INT1;
        }
    }
    public PlObject neg() {
        if (i) {
            return PlCx.MIN1;
        }
        else {
            return PlCx.INT0;
        }
    }
    public PlObject apply(int want, PlArray List__) {
        if (i) {
            // RT #63790:  calling PL_sv_yes as a sub is special-cased to silently
            // return (so Foo->import() silently fails if import() doesn't exist),
            return PerlOp.context(want);
        }
        else {
            return PlCORE.die(\"Undefined subroutine\");
        }
    }
}
class PlInt extends PlScalarImmutable {
    private final long i;
    public PlInt(long i) {
        this.i = i;
    }
    public PlInt(int i) {
        this.i = (long)i;
    }

    public PerlArgumentLookupResult castToClass(ArrayList<Class[]> params, int pos) {
        // TODO - byte - short - int - long - float - double

        // want long
        for (Class[] cl : params) {
            if (cl[pos].equals( java.lang.Long.TYPE )) {
                return new PerlArgumentLookupResult( this.to_long(), cl[pos] );
            }
        }
        // want int
        for (Class[] cl : params) {
            if (cl[pos].equals( java.lang.Integer.TYPE )) {
                return new PerlArgumentLookupResult( this.to_int(), cl[pos] );
            }
        }
        // want float
        for (Class[] cl : params) {
            if (cl[pos].equals( java.lang.Float.TYPE )) {
                return new PerlArgumentLookupResult( this.to_float(), cl[pos] );
            }
        }
        // want double
        for (Class[] cl : params) {
            if (cl[pos].equals( java.lang.Double.TYPE )) {
                return new PerlArgumentLookupResult( this.to_double(), cl[pos] );
            }
        }
        // try other things
        return super.castToClass(params, pos);
    }

    public int to_int() {
        return (int)this.i;
    }
    public long to_long() {
        return this.i;
    }
    public double to_double() {
        return (double)(this.i);
    }
    public String toString() {
        return \"\" + this.i;
    }
    public boolean to_boolean() {
        return this.i != 0;
    }
    public PlObject to_num() {
        return this;
    }
    public PlObject mod(PlObject o) {
        return PerlOp.mod(this, o);
    }
    public boolean is_int() {
        return true;
    }
    public boolean is_integer_range() {
        return true;
    }
    public PlObject _decr() {
        // --\$x
        return new PlInt(i-1);
    }
    public PlObject _incr() {
        // ++\$x
        return new PlInt(i+1);
    }
    public PlObject neg() {
        return new PlInt(-i);
    }
    public PlObject mul2(PlObject s) {
        long v = s.to_long();
        // 3037000000 is sqrt(Long.MAX_VALUE)
        if (i > 3037000000L || i < -3037000000L || v > 3037000000L || v < -3037000000L) {
            return new PlDouble(this.to_double()).mul2(s);
        }
        return new PlInt(v * i);
    }
}
class PlDouble extends PlScalarImmutable {
    private final double i;
    public PlDouble(double i) {
        this.i = i;
    }

    public PerlArgumentLookupResult castToClass(ArrayList<Class[]> params, int pos) {
        // TODO - byte - short - int - long - float - double

        // want double
        for (Class[] cl : params) {
            if (cl[pos].equals( java.lang.Double.TYPE )) {
                return new PerlArgumentLookupResult( this.to_double(), cl[pos] );
            }
        }
        // want float
        for (Class[] cl : params) {
            if (cl[pos].equals( java.lang.Float.TYPE )) {
                return new PerlArgumentLookupResult( this.to_float(), cl[pos] );
            }
        }
        // want long
        for (Class[] cl : params) {
            if (cl[pos].equals( java.lang.Long.TYPE )) {
                return new PerlArgumentLookupResult( this.to_long(), cl[pos] );
            }
        }
        // want int
        for (Class[] cl : params) {
            if (cl[pos].equals( java.lang.Integer.TYPE )) {
                return new PerlArgumentLookupResult( this.to_int(), cl[pos] );
            }
        }
        // try other things
        return super.castToClass(params, pos);
    }

    public int to_int() {
        return (int)(this.i);
    }
    public long to_long() {
        return (long)(this.i);
    }
    public double to_double() {
        return this.i;
    }
    public String toString() {
        if (Double.isNaN(this.i)) {
            return \"NaN\";
        }
        if (Double.isInfinite(this.i)) {
            return this.i > 0 ? \"Inf\" : \"-Inf\";
        }
        double v = this.i;
        String s;
        if (   v < 0.0001 && v > -0.0001
            || v < -1E14
            || v >  1E14 )
        {
            // use scientific notation
            s = String.format(\"%20.20e\", v);
            s = s.replaceAll(\"\\\\.?0*e\", \"e\");
            if (s.equals(\"0e+00\") || s.equals(\"-0e+00\")) {
                s = \"0\";
            }
        }
        else {
            s = String.format(\"%20.20f\", v);
            s = s.replaceAll(\"\\\\.?0*\$\", \"\");
        }
        return s;
    }
    public boolean to_boolean() {
        return this.i != 0.0;
    }
    public PlObject to_num() {
        return this;
    }
    public PlObject _decr() {
        // --\$x
        return new PlDouble(i-1);
    }
    public PlObject _incr() {
        // ++\$x
        return new PlDouble(i+1);
    }
    public PlObject neg() {
        return new PlDouble(-i);
    }
    public PlObject abs() {
        return new PlDouble(i < 0.0 ? -i : i);
    }
    public PlObject num_cmp(PlObject b) {
        if (Double.isNaN(this.i)) {
            return PlCx.UNDEF;
        }
        double bb = b.to_double();
        if (Double.isNaN(bb)) {
            return PlCx.UNDEF;
        }
        int c = ((Double)this.i).compareTo(bb);
        return (c == 0 ? PlCx.INT0 : c < 0 ? PlCx.MIN1 : PlCx.INT1);
    }
    public PlObject num_cmp2(PlObject b) {
        if (Double.isNaN(this.i)) {
            return PlCx.UNDEF;
        }
        double bb = b.to_double();
        if (Double.isNaN(bb)) {
            return PlCx.UNDEF;
        }
        int c = ((Double)bb).compareTo(this.i);
        return (c == 0 ? PlCx.INT0 : c < 0 ? PlCx.MIN1 : PlCx.INT1);
    }
"), ((map {
            my $perl = $_;
            my $native = $number_binop{$perl}->{"op"};
            my $returns = $number_binop{$perl}->{"num_returns"};
            if ($returns eq "PlInt") {;
                "    public PlObject " . $perl . "(PlObject s) {
        // num - int, num - num
        return new " . $returns . "( this.to_long() " . $native . " s.to_long() );
    }
    public PlObject " . $perl . "2(PlObject s) {
        // int - num
        return new " . $returns . "( s.to_long() " . $native . " this.to_long() );
    }
"
            }
            else {;
                "    public PlObject " . $perl . "(PlObject s) {
        // num - int, num - num
        return new " . $returns . "( this.i " . $native . " s.to_double() );
    }
    public PlObject " . $perl . "2(PlObject s) {
        // int - num
        return new " . $returns . "( s.to_double() " . $native . " this.i );
    }
"
            }
        } sort {;
            $a cmp $b
        } keys(%number_binop))), ("    public PlObject mod(PlObject o) {
        return PerlOp.mod(this, o);
    }
    public boolean is_num() {
        return true;
    }
    public boolean is_integer_range() {
        return !Double.isNaN(i) && i <= Long.MAX_VALUE && i >= Long.MIN_VALUE;
    }
}
class PlStringLazyError extends PlString {
    private Exception e;

    public PlStringLazyError(Exception e) {
        this.e = e;
    }
    public String toString() {
        if (this.s == null) {
            this.s = e.getClass().getCanonicalName() + \": \" + e.getMessage() + \"\\n\" + java.util.Arrays.toString(e.getStackTrace());
        }
        return this.s;
    }
    public boolean to_boolean() {
        return true;
    }
}
class PlStringConstant extends PlString {
    public static HashMap<String, PlStringConstant> constants = new HashMap<String, PlStringConstant>();

    // inherited: String s
    private PlClass cls;
    public PlLvalue codeRef;   // CODE
    public PlLvalue scalarRef; // SCALAR
    public PlLvalue arrayRef;  // ARRAY
    public PlLvalue hashRef;   // HASH
    public PlLvalue fileRef;   // IO

    public PlStringConstant(String s) {
        super(s);
        this.codeRef = new PlLvalue();
        this.scalarRef = new PlLvalue();
        this.arrayRef = new PlLvalue(new PlArrayRef());
        this.hashRef = new PlLvalue(new PlHashRef());
        this.fileRef = new PlLvalue(new PlFileHandle(s));
    }

    public static PlStringConstant getConstant(String s) {
        PlStringConstant v = constants.get(s);
        if (v == null) {
            v = new PlStringConstant(s);
            constants.put(s, v);
        }
        return v;
    }

    public PlClass blessed_class() {
        if (cls == null) {
            cls = PlClass.getInstance(s);
        }
        return cls;
    }
    public PlObject apply(int want, PlArray List__) {
        if (this.codeRef.is_undef()) {
            String name = this.s;
            int pos = name.lastIndexOf(\"::\");
            if (pos != -1) {
                String namespace = name.substring(0, pos);
                PlLvalue autoload = PlV.cget_no_autoload(namespace + \"::AUTOLOAD\");
                if ( autoload.is_coderef() ) {
                    PlV.sset(namespace + \"::AUTOLOAD\", new PlString(name));
                    return autoload.apply(want, List__);
                }
            }
            return PlCORE.die(\"Undefined subroutine &\" + name + \" called\");
        }
        return this.codeRef.apply(want, List__);
    }
}
class PlString extends PlScalarImmutable {
    public java.lang.String s;
    private PlObject numericValue;

    public PlString() {
    }
    public PlString(String s) {
        // if (s == null) {
        //     s = \"\";
        // }
        this.s = s;
    }
    public PlString(char s) {
        this.s = \"\" + s;
    }
    public PlObject scalar_deref_lvalue(String namespace) {
        return this.scalar_deref(namespace);
    }
    public PlObject scalar_deref(String namespace) {
        if (s.length() == 1) {
            if (this._looks_like_non_negative_integer()) {
                return PerlOp.regex_var(this.to_int());
            }
            if (s.equals(\"&\") || s.equals(\"`\") || s.equals(\"'\")) {
                return PerlOp.regex_var(s);
            }
            if (s.equals(\"\$\")) {
                return PerlOp.getPID();
            }

            // special variables like \$_ \$\\
"), ((map {
            my $java_name = $Perlito5::Java::special_scalar{$_};
            my $perl_name = $_;
            $perl_name eq "\\" && ($perl_name = "\\\\");
            "
            if (s.equals(\"" . $perl_name . "\")) {
                return PlV." . $java_name . ";
            }
"
        } sort {;
            $a cmp $b
        } keys(%Perlito5::Java::special_scalar))), ("
        }
        if (s.indexOf(\"::\") == -1) {
            return PlV.sget( namespace + \"::\" + s );
        }

        // special variables like \$_ \$\\
"), ((map {
            my $java_name = $Perlito5::Java::special_scalar{$_};
            my $perl_name = $_;
            $perl_name eq "\\" && ($perl_name = "\\\\");
            "
        if (s.equals(\"main::" . $perl_name . "\")) {
            return PlV." . $java_name . ";
        }
"
        } sort {;
            $a cmp $b
        } keys(%Perlito5::Java::special_scalar))), ("
        return PlV.sget(s);
    }
    public PlObject scalar_deref_strict() {
        return PlCORE.die(\"Can't use string (\\\"\" + this.s + \"\\\") as a SCALAR ref while \\\"strict refs\\\" in use\");
    }
    public PlObject scalar_deref_set(String namespace, PlObject v) {
        if (s.length() == 1) {

            // special variables like \$_ \$\\
"), ((map {
            my $java_name = $Perlito5::Java::special_scalar{$_};
            my $perl_name = $_;
            $perl_name eq "\\" && ($perl_name = "\\\\");
            "
            if (s.equals(\"" . $perl_name . "\")) {
                return PlV." . $java_name . ".set(v);
            }
"
        } sort {;
            $a cmp $b
        } keys(%Perlito5::Java::special_scalar))), ("
        }
        if (s.indexOf(\"::\") == -1) {
            return PlV.sset( namespace + \"::\" + s, v );
        }

        // special variables like \$_ \$\\
"), ((map {
            my $java_name = $Perlito5::Java::special_scalar{$_};
            my $perl_name = $_;
            $perl_name eq "\\" && ($perl_name = "\\\\");
            "
        if (s.equals(\"main::" . $perl_name . "\")) {
            return PlV." . $java_name . ".set(v);
        }
"
        } sort {;
            $a cmp $b
        } keys(%Perlito5::Java::special_scalar))), ("
        return PlV.sset(s, v);
    }
    public PlArray array_deref_lvalue() {
        // TODO - concatenate current namespace if needed
        return PlV.array_get(s);
    }
    public PlArray array_deref_strict() {
        PlCORE.die(\"Can't use string (\\\"\" + this.s + \"\\\") as an ARRAY ref while \\\"strict refs\\\" in use\");
        return PlV.array_get(s);
    }
    public PlArray array_deref(String namespace) {
        if (s.indexOf(\"::\") == -1) {
            return PlV.array_get( namespace + \"::\" + s );
        }
        return PlV.array_get(s);
    }
    public PlObject array_deref_set(PlObject v) {
        // TODO - concatenate current namespace if needed
        return PlV.aset(s, v);
    }
    public PlObject hget(String i) {
        return this.hash_deref(\"\").hget(i);
    }
    public PlObject hash_deref(String namespace) {
        int pos = s.lastIndexOf(\"::\");
        if (pos == -1) {
            return PlV.hash_get( namespace + \"::\" + s );
        }
        else if (pos == s.length() - 2) {
            // %{\"Module::\"}
            return PerlOp.getSymbolTable(this.s);
        }
        return PlV.hash_get(s);
    }
    public PlHash hash_deref_strict() {
        PlCORE.die(\"Can't use string (\\\"\" + this.s + \"\\\") as a HASH ref while \\\"strict refs\\\" in use\");
        return PlV.hash_get(s);
    }
    public PlObject hash_deref_set(PlObject v) {
        // TODO - concatenate current namespace if needed
        return PlV.hash_set(s, v);
    }
    public PlObject hdelete(int want, PlObject a) {
        // TODO - concatenate current namespace if needed
        int pos = s.lastIndexOf(\"::\");
        // if (pos == -1) {
        //     s = namespace + \"::\" + s;
        // }
        if (pos == s.length() - 2) {
            // %{\"Module::\"}
            return PerlOp.deleteSymbolTable(this.s, a);
        }
        return PlV.hash_get(s).hdelete(want, a);
    }
    public PlClass blessed_class() {
        return PlClass.getInstance(s);
    }

    public PlObject parse() {
        if (numericValue == null) {
            numericValue = this._parse();
        }
        return numericValue;
    }
    private boolean _looks_like_non_negative_integer() {
        final int length = s.length();
        for (int offset = 0; offset < length; ) {
            final int c = s.codePointAt(offset);
            switch (c) {
                case '0': case '1': case '2': case '3': case '4':
                case '5': case '6': case '7': case '8': case '9':
                    break;
                default:
                    return false;
            }
        }
        return true;
    }
    private PlObject _parse_exp(int length, int signal, int offset, int next) {
        // 123.45E^^^
        int offset_orig = next;
        int offset3 = next;
        if (offset3 >= length) {
            return new PlDouble(Double.parseDouble(this.s.substring(0, offset_orig - 1)));
        }
        final int sig = s.codePointAt(offset3);
        if (sig == '+' || sig == '-') {
            offset3++;
            if (offset3 >= length) {
                return new PlDouble(Double.parseDouble(this.s.substring(0, offset_orig - 1)));
            }
        }
        final int num = s.codePointAt(offset3);
        if (num < '0' || num > '9') {
            // illegal exp
            return new PlDouble(Double.parseDouble(this.s.substring(0, offset_orig - 1)));
        }
        for ( ; offset3 < length; ) {
            final int c3 = s.codePointAt(offset3);
            switch (c3) {
                case '0': case '1': case '2': case '3': case '4':
                case '5': case '6': case '7': case '8': case '9':
                    break;
                default:    // invalid
                    return new PlDouble(Double.parseDouble(this.s.substring(0, offset3)));
            }
            offset3++;
        }
        return new PlDouble(Double.parseDouble(this.s.substring(0, offset3)));
    }
    private PlObject _parse_dot(int length, int signal, int offset, int next) {
        // 123.^^^
        int offset3 = next;
        for ( ; offset3 < length; ) {
            final int c3 = s.codePointAt(offset3);
            switch (c3) {
                case '0': case '1': case '2': case '3': case '4':
                case '5': case '6': case '7': case '8': case '9':
                    break;
                case 'E': case 'e':
                    // start exponential part
                    return _parse_exp(length, signal, offset, offset3+1);
                default:    // invalid
                    try {
                        return new PlDouble(Double.parseDouble(this.s.substring(0, offset3)));
                    }
                    catch (NumberFormatException e) {
                        // string is \".\"
                        return PlCx.INT0;   // string is \".\"
                    }
            }
            offset3++;
        }
        if (offset3 == 1) {
            return PlCx.INT0;   // string is \".\"
        }
        return new PlDouble(Double.parseDouble(this.s.substring(0, offset3)));
    }
    private PlObject _parse() {
        final int length = s.length();
        int signal = 0;
        for (int offset = 0; offset < length; ) {
            final int c = s.codePointAt(offset);
            switch (c) {
                case 'i': case 'I':
                            if (length > 2 && this.s.substring(offset, offset+3).equalsIgnoreCase(\"inf\")) {
                                if (signal < 0) {
                                    return new PlDouble(Double.NEGATIVE_INFINITY);
                                }
                                else {
                                    return new PlDouble(Double.POSITIVE_INFINITY);
                                }
                            }
                            return PlCx.INT0;
                case 'n': case 'N':
                            if (length > 2 && this.s.substring(offset, offset+3).equalsIgnoreCase(\"nan\")) {
                                return new PlDouble(Double.NaN);
                            }
                            return PlCx.INT0;
                case '.':   // starts with dot
                            if (signal != 0) {
                                signal = 1;
                            }
                            return _parse_dot(length, signal, offset, offset+1);
                case '0': case '1': case '2': case '3': case '4':
                case '5': case '6': case '7': case '8': case '9':
                            // starts with number
                            if (signal == 0) {
                                signal = 1;
                            }
                            int offset2 = offset+1;
                            for ( ; offset2 < length; ) {
                                final int c2 = s.codePointAt(offset2);
                                switch (c2) {
                                    case '0': case '1': case '2': case '3': case '4':
                                    case '5': case '6': case '7': case '8': case '9':
                                        // more numbers
                                        break;
                                    case '.':
                                        // start decimal part
                                        return _parse_dot(length, signal, offset, offset2+1);
                                    case 'E': case 'e':
                                        // start exponential part
                                        return _parse_exp(length, signal, offset, offset2+1);
                                    default:
                                        // return integer
                                        try {
                                            if (signal < 0) {
                                                return new PlInt(-Long.parseLong(this.s.substring(offset, offset2)));
                                            }
                                            else {
                                                return new PlInt(Long.parseLong(this.s.substring(offset, offset2)));
                                            }
                                        }
                                        catch (NumberFormatException e) {
                                            return new PlDouble(Double.parseDouble(this.s.substring(offset, offset2)));
                                        }
                                }
                                offset2++;
                            }
                            // integer
                            try {
                                if (signal < 0) {
                                    return new PlInt(-Long.parseLong(this.s.substring(offset, offset2)));
                                }
                                else {
                                    return new PlInt(Long.parseLong(this.s.substring(offset, offset2)));
                                }
                            }
                            catch (NumberFormatException e) {
                                return new PlDouble(Double.parseDouble(this.s.substring(offset, offset2)));
                            }
                case '+':   // starts with +
                            if (signal != 0) {
                                // invalid
                                return PlCx.INT0;
                            }
                            signal = 1;
                            break;
                case '-':   // starts with -
                            if (signal != 0) {
                                // invalid
                                return PlCx.INT0;
                            }
                            signal = -1;
                            break;
                case ' ': case '\\t': case '\\n': case '\\r':
                            // starts with space
                            if (signal != 0) {
                                // invalid
                                return PlCx.INT0;
                            }
                            break;
                default:    // invalid
                            return PlCx.INT0;
            }
            offset++;
        }
        return PlCx.INT0;
    }
    public int to_int() {
        return this.parse().to_int();
    }
    public long to_long() {
        return this.parse().to_long();
    }
    public double to_double() {
        return this.parse().to_double();
    }
    public String toString() {
        return this.s;
    }
    public boolean to_boolean() {
        return !( this.s.equals(\"\") || this.s.equals(\"0\") );
    }
    public PlObject to_num() {
        return this.parse();
    }
    public char to_char() {
        if (this.s.length() == 0) {
            return '\\u0000';
        }
        return this.s.charAt(0);
    }
    public boolean is_string() {
        return true;
    }
    public boolean boolean_str_le(String b) {
        return this.s.compareTo(b) <= 0;
    }
    public int int_length() {
        return this.s.length();
    }
    public PlScalarImmutable length() {
        return new PlInt(this.s.length());
    }
    public PlObject _decr() {
        // --\$x
        return this.add(PlCx.MIN1);
    }

    // \$x++ when \$x is PlString
    private static final String _string_increment(String s) {
        if (s.length() < 2) {
            final int c = s.codePointAt(0);
            if ((c >= '0' && c <= '8') || (c >= 'A' && c <= 'Y') || (c >= 'a' && c <= 'y')) {
                return \"\" + (char)(c + 1);
            }
            if (c == '9') {
                return \"10\";
            }
            if (c == 'Z') {
                return \"AA\";
            }
            if (c == 'z') {
                return \"aa\";
            }
            return \"1\";
        }
        String c = _string_increment(s.substring(s.length()-1, s.length()));
        if (c.length() == 1) {
            // AAAC => AAAD
            return s.substring(0, s.length()-1) + c;
        }
        // AAAZ => AABA
        return _string_increment(s.substring(0, s.length()-1)) + c.substring(c.length()-1, c.length());
    }
    public PlObject _incr() {
        // ++\$x
        final int length = s.length();
        if (length == 0) {
            return PlCx.INT1;
        }
        int c = this.s.codePointAt(0);
        switch (c) {
            case ' ': case '\\t': case '\\n': case '\\r':
            case '+': case '-': case '.':
            case '0': case '1': case '2': case '3': case '4':
            case '5': case '6': case '7': case '8': case '9':
                return this.add(PlCx.INT1);
        }
        c = s.codePointAt(length - 1);
        if ((c >= '0' && c <= '8') || (c >= 'A' && c <= 'Y') || (c >= 'a' && c <= 'y')) {
            return new PlString(s.substring(0, length-1) + (char)(c + 1));
        }
        return new PlString(_string_increment(this.s));
    }
    public PlObject neg() {
        final int length = s.length();
        if (length == 0) {
            return PlCx.INT0;
        }
        final int c = this.s.codePointAt(0);
        switch (c) {
            case '+': case '-':
                if (c == '+') {
                    return new PlString( '-' + s.substring(1) );
                }
                if (c == '-') {
                    return new PlString( '+' + s.substring(1) );
                }
            case '.':
            case ' ': case '\\t': case '\\n': case '\\r':
            case '0': case '1': case '2': case '3': case '4':
            case '5': case '6': case '7': case '8': case '9':
                return this.parse().neg();
        }
        if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {
            return new PlString( '-' + s );
        }
        return PlCx.INT0;
    }
    public PlObject abs() {
        return this.parse().abs();
    }
    public PlObject num_cmp(PlObject b) {
        return this.parse().num_cmp(b);
    }
    public PlObject num_cmp2(PlObject b) {
        return b.num_cmp(this.parse());
    }
    public boolean is_integer_range() {
        return this.parse().is_integer_range();
    }
"), ((map {
            my $perl = $_;
            my $native = $number_binop{$perl}->{"op"};
            my $returns = $number_binop{$perl}->{"returns"};
            my $num_returns = $number_binop{$perl}->{"num_returns"};
            if ($returns eq "PlDouble") {;
                "    public PlObject " . $perl . "(PlObject b) {
        // 'num' - int, 'num' - num
        return this.parse()." . $perl . "(b);
    }
    public PlObject " . $perl . "2(PlObject b) {
        // int - 'num'
        return b." . $perl . "(this.parse());
    }
"
            }
            else {;
                "    public PlObject " . $perl . "(PlObject b) {
        // 'num' - int, 'num' - num
        return this.parse()." . $perl . "(b);
    }
    public PlObject " . $perl . "2(PlObject b) {
        // int - 'num'
        return b." . $perl . "(this.parse());
    }
"
            }
        } sort {;
            $a cmp $b
        } keys(%number_binop))), ("}
"), ("class PlJavaObject extends PlReference {
    private Object stuff;

    static PlObject fromObject(Object o) {
        // Runtime casting
        if (o == null) {
            return PlCx.UNDEF;
        }
        if (o instanceof PlObject) {
            // this is already a Perl object
            return (PlObject)o;
        }
        if (o instanceof Number) {
            if (o instanceof Byte) {
                return new PlInt((Byte)o);
            }
            if (o instanceof Short) {
                return new PlInt((Short)o);
            }
            if (o instanceof Integer) {
                return new PlInt((Integer)o);
            }
            if (o instanceof Long) {
                return new PlInt((Long)o);
            }
            if (o instanceof Float) {
                return new PlDouble((Float)o);
            }
            if (o instanceof Double) {
                return new PlDouble((Double)o);
            }
            // TODO - there are more Number types
        }
        if (o instanceof Character) {
            return new PlString((Character)o);
        }
        if (o instanceof String) {
            return new PlString((String)o);
        }
        if (o instanceof Boolean) {
            return new PlBool((Boolean)o);
        }
        // TODO - more castings from %java_classes
        return new PlJavaObject(o);
    }

    public PerlArgumentLookupResult castToClass(ArrayList<Class[]> params, int pos) {
        // want same Java class
        // System.out.println(\"PerlArgumentLookupResult castToClass from \" + this.ref_str());
        for (Class[] cl : params) {
            // System.out.println(\"  compare to \" + cl[pos]);
            if (cl[pos].equals( this.stuff.getClass() )) {
                // System.out.println(\"   match\");
                return new PerlArgumentLookupResult( this.stuff, cl[pos] );
            }
            // try again with Class.cast()
            try {
                cl[pos].cast( this.stuff );
                // cast returns ok
                // System.out.println(\"   can cast()\");
                return new PerlArgumentLookupResult( this.stuff, cl[pos] );
            }
            catch (ClassCastException e) {
                // System.out.println(\"   cannot cast()\");
            }
        }
        // try other things
        return super.castToClass(params, pos);
    }

    public PlJavaObject(Object stuff) {
        this.stuff = stuff;
    }
    public Object toJava() {
        return this.stuff;
    }
    public PlString ref() {
        return new PlString(stuff.getClass().getCanonicalName());
    }
    public String ref_str() {
        return stuff.getClass().getCanonicalName();
    }
    public boolean ref_boolean() {
        return true;
    }

    public PlObject reftype() {
        // Scalar::Util::reftype()
        return ref();
    }
    public String toString() {
        if (stuff == null) {
            return \"\";
        }
        return this.stuff.toString();
    }
    public boolean to_boolean() {
        if (stuff == null) {
            return false;
        }
        return true;
    }
    public boolean is_JavaObject() {
        return true;
    }
    public boolean is_undef() {
        return stuff == null;
    }
    public PlObject clone() throws CloneNotSupportedException {
        // TODO - test if implements 'Cloneable' and call stuff.clone() if possible
        return this;
    }
}
"), ("// end Perl-Java runtime
"))
    }
    1
}
{
    package main;
    package Perlito5::Java::Lib;
    sub Perlito5::Java::Lib::init {;
        @Perlito5::Grammar::Use::Perlito_internal_lib_directory = ("Perlito5X/Java", "Perlito5X", '')
    }
    1
}
{
    package main;
    package Perlito5;
    my $_V5_COMPILER_NAME = Perlito5::Compiler::compiler_name();
    my $_V5_COMPILER_VERSION = $Perlito5::VERSION;
    my $source = '';
    my $backend = ${^O};
    my $compile_only = 0;
    my $execute = 1;
    my $verbose = 0;
    my $expand_use = 1;
    my $boilerplate = 1;
    my $bootstrapping = 0;
    my $wrapper_begin = '';
    my $wrapper_end = '';
    my $wrapper_priority = 0;
    my @Use;
    my $i_switch = 0;
    my $i_switch_extension = '';
    my @e_switch;
    $Perlito5::BOOTSTRAP_JAVA_EVAL = 0;
    $Perlito5::JAVA_EVAL = 0;
    $Perlito5::FILE_NAME = '';
    if ($verbose) {
        warn("// Perlito5 compiler");
        warn("// ARGV: " . join(${"\""}, @ARGV))
    }
    my $help_message = "
perlito5 [switches] [programfile]
  switches:
    -c              check syntax only (runs BEGIN and CHECK blocks)
    -e program      one line of program (omit programfile)
    -E program      like -e, but enables all optional features
    -h --help
    -Idirectory     specify \@INC/include directory (several -I's allowed)
    -[mM][-]module  execute \"use/no module...\" before executing program
    -n              assume \"while (<>) { ... }\" loop around program
    -p              assume loop like -n but print line also, like sed
    -V --version
    -v
    --verbose
    -Ctarget        target backend: js, perl5, perl6, java
    -Cast-perl5     emits a dump of the abstract syntax tree as a Perl dump
    -Cast-json      emits a dump of the abstract syntax tree in JSON format
    --expand_use --noexpand_use
                    expand 'use' statements at compile time
    --boilerplate --noboilerplate
                    emits or not boilerplate code
    --bootstrapping set this when compiling the compiler,
                    otherwise the new subroutine definitions will overwrite the current compiler
    --java_eval     enable Java eval, using perlito5-lib.jar
    --nojava_eval   disable Java eval, creates a standalone file that doesn't depend on perlito5-lib.jar
    -J DEBUG=1      set Java backend options
                        DEBUG=1     dump the Java source code in eval-string
    -JS DEBUG=1     set JavaScript backend options
                        DEBUG=1     dump the JavaScript source code in eval-string
";
    my $copyright_message = (("This is Perlito5 " . $_V5_COMPILER_VERSION . ", an implementation of the Perl language.

The Perl language is Copyright 1987-2017, Larry Wall
The Perlito5 implementation is Copyright 2011-2017 by Flavio Soibelmann Glock and others.

Perl may be copied only under the terms of either the Artistic License or the
GNU General Public License, which may be found in the Perl 5 source kit.

Complete documentation for Perl, including FAQ lists, should be found on
this system using \"man perl\" or \"perldoc perl\".  If you have access to the
Internet, point your browser at http://www.perl.org/, the Perl Home Page.
"));
    sub Perlito5::chomp_switch {
        my $s = substr($ARGV[0], 2);
        if ($s) {;
            $ARGV[0] = "-" . $s
        }
        else {;
            shift(@ARGV)
        }
    }
    sub Perlito5::get_text_from_switch {
        my $s = substr($ARGV[0], 2);
        if (!$s) {
            shift(@ARGV);
            $s = $ARGV[0]
        }
        if ($s) {
            my $c = substr($s, 0, 1);
            if ($c eq "\"" || $c eq "'") {;
                if (substr($s, -1, 1) eq $c) {;
                    $s = substr($s, 1, -1)
                }
            }
        }
        return $s
    }
    my $use_warnings = '';
    my @user_inc;
    push(@Use, "no strict");
    ARG_LOOP:
    while (@ARGV && substr($ARGV[0], 0, 1) eq "-") {
        if ($ARGV[0] eq "--verbose") {
            $verbose = 1;
            shift(@ARGV)
        }
        elsif (substr($ARGV[0], 0, 3) eq "-JS") {
            $ARGV[0] = "-J" . substr($ARGV[0], 3);
            my $java_opt = Perlito5::get_text_from_switch();
            (my $key, my $value) = split("=", $java_opt, 2);
            if (!defined($value)) {;
                $value = 1
            }
            ${"Perlito5::JavaScript::" . $key} = $value;
            shift(@ARGV)
        }
        elsif (substr($ARGV[0], 0, 2) eq "-J") {
            my $java_opt = Perlito5::get_text_from_switch();
            (my $key, my $value) = split("=", $java_opt, 2);
            if (!defined($value)) {;
                $value = 1
            }
            ${"Perlito5::Java::" . $key} = $value;
            shift(@ARGV)
        }
        elsif (substr($ARGV[0], 0, 2) eq "-I") {
            my $lib = Perlito5::get_text_from_switch();
            push(@user_inc, $lib);
            shift(@ARGV)
        }
        elsif (substr($ARGV[0], 0, 2) eq "-e" || substr($ARGV[0], 0, 2) eq "-E") {
            my $source = Perlito5::get_text_from_switch();
            push(@e_switch, $source);
            $Perlito5::FILE_NAME = "-e";
            if ($verbose) {;
                warn("// source from command line: " . $source)
            }
            shift(@ARGV)
        }
        elsif (substr($ARGV[0], 0, 2) eq "-c") {
            $compile_only = 1;
            $execute = 0;
            $backend = "perl5";
            Perlito5::chomp_switch()
        }
        elsif (substr($ARGV[0], 0, 2) eq "-C") {
            $backend = Perlito5::get_text_from_switch();
            $execute = 0;
            shift(@ARGV)
        }
        elsif (substr($ARGV[0], 0, 2) eq "-i") {
            $i_switch = 1;
            $ARGV[0] ne "-i" && ($i_switch_extension = Perlito5::get_text_from_switch());
            die("switch -i " . $i_switch_extension . " not yet implemented.
");
            shift(@ARGV)
        }
        elsif ($ARGV[0] eq "-MO=Deparse") {
            $backend = "perl5";
            $execute = 0;
            $expand_use = 0;
            shift(@ARGV)
        }
        elsif (uc(substr($ARGV[0], 0, 2)) eq "-M") {
            my $s = $ARGV[0];
            my $import = '';
            if (substr($s, 1, 1) eq "m") {;
                $import = "()"
            }
            $s = substr($s, 2);
            my $use = "use";
            if (substr($s, 0, 1) eq "-") {
                $use = "no";
                $s = substr($s, 1)
            }
            if (index($s, "=") > -1) {
                ($s, $import) = split("=", $s);
                $import = "split(/,/,q{" . $import . "})"
            }
            push(@Use, $use . " " . $s . " " . $import);
            shift(@ARGV)
        }
        elsif (substr($ARGV[0], 0, 2) eq "-w") {
            $use_warnings = "w";
            Perlito5::chomp_switch()
        }
        elsif (substr($ARGV[0], 0, 2) eq "-W") {
            $use_warnings = "W";
            Perlito5::chomp_switch()
        }
        elsif (substr($ARGV[0], 0, 2) eq "-X") {
            $use_warnings = '';
            Perlito5::chomp_switch()
        }
        elsif (substr($ARGV[0], 0, 2) eq "-n") {
            if ($wrapper_priority < 1) {
                $wrapper_begin = " LINE: while (<>) { ";
                $wrapper_end = " } ";
                $wrapper_priority = 1
            }
            Perlito5::chomp_switch()
        }
        elsif (substr($ARGV[0], 0, 2) eq "-p") {
            if ($wrapper_priority < 2) {
                $wrapper_begin = " LINE: while (<>) { ";
                $wrapper_end = " } continue { " . " print or die \"-p destination: \$!\\n\"; " . " } ";
                $wrapper_priority = 2
            }
            Perlito5::chomp_switch()
        }
        elsif ($ARGV[0] eq "-V") {
            $backend = '';
            say($_V5_COMPILER_NAME, " ", $_V5_COMPILER_VERSION);
            if ($ENV{"PERL5LIB"}) {
                say("  %ENV:");
                say("    PERL5LIB=\"" . $ENV{"PERL5LIB"} . "\"")
            }
            say("  \@INC:");
            say("    " . $_)
                for @INC;
            shift(@ARGV)
        }
        elsif ($ARGV[0] eq "-v" || $ARGV[0] eq "--version") {
            $backend = '';
            say($copyright_message);
            shift(@ARGV)
        }
        elsif ($ARGV[0] eq "-h" || $ARGV[0] eq "--help" || !@ARGV) {
            $backend = '';
            say($_V5_COMPILER_NAME, " ", $_V5_COMPILER_VERSION, $help_message);
            shift(@ARGV)
        }
        elsif ($ARGV[0] eq "--expand_use") {
            $expand_use = 1;
            shift(@ARGV)
        }
        elsif ($ARGV[0] eq "--noexpand_use") {
            $expand_use = 0;
            shift(@ARGV)
        }
        elsif ($ARGV[0] eq "--boilerplate") {
            $boilerplate = 1;
            shift(@ARGV)
        }
        elsif ($ARGV[0] eq "--noboilerplate") {
            $boilerplate = 0;
            shift(@ARGV)
        }
        elsif ($ARGV[0] eq "--bootstrapping") {
            $bootstrapping = 1;
            shift(@ARGV)
        }
        elsif ($ARGV[0] eq "--bootstrap_java_eval") {
            $Perlito5::BOOTSTRAP_JAVA_EVAL = 1;
            shift(@ARGV)
        }
        elsif ($ARGV[0] eq "--java_eval") {
            $Perlito5::JAVA_EVAL = 1;
            shift(@ARGV)
        }
        elsif ($ARGV[0] eq "--nojava_eval") {
            $Perlito5::JAVA_EVAL = 0;
            shift(@ARGV)
        }
        elsif ($ARGV[0] eq "-") {
            shift(@ARGV);
            last(ARG_LOOP)
        }
        else {;
            die("Unrecognized switch: " . $ARGV[0] . "  (-h will show valid options).
")
        }
    }
    unshift(@INC, @user_inc);
    if (!$expand_use) {;
        $Perlito5::EMIT_USE = 1
    }
    if ($backend) {
        local $Perlito5::LINE_NUMBER = 1;
        if (@e_switch) {;
            $source = join("
", @e_switch)
        }
        else {
            $Perlito5::FILE_NAME = $ARGV[0];
            if ($verbose) {;
                warn("// source from file: ", $ARGV[0])
            }
            my $source_filename = shift(@ARGV);
            if ($source_filename eq '') {
                local $/ = undef;
                $source = <STDIN>
            }
            else {;
                $source = Perlito5::Grammar::Use::slurp_source_file($source_filename) or die("Cannot read " . $source_filename . ": " . ${"!"} . "
")
            }
        }
        $0 = $Perlito5::FILE_NAME;
        if ($verbose) {
            warn("// backend: ", $backend);
            warn("now parsing")
        }
        $Perlito5::PKG_NAME = "main";
        $Perlito5::PROTO = {};
        Perlito5::set_global_phase("BEGIN");
        if ($source =~ m/^#![^\n]+-(w|W)/) {;
            $use_warnings = $1
        }
        $source = "
# line 1
" . $source;
        if ($wrapper_begin) {;
            $source = " " . $wrapper_begin . ";
                    " . $source . ";
                    " . $wrapper_end . "
                  "
        }
        if ($verbose) {;
            warn("// source [[[ " . $source . " ]]]
")
        }
        Perlito5::Java::init();
        $backend eq "java" && Perlito5::Java::Lib::init();
        ($backend eq "js" || ${^O} eq "node.js") && Perlito5::JavaScript2::Lib::init();
        $backend eq "java" && ($Perlito5::CODE_TOO_LARGE = 1);
        $Perlito5::EXPAND_USE = 1;
        $bootstrapping && ($Perlito5::EXPAND_USE = 0);
        if ($execute) {
            local ${"\@"};
            my $init = join("; ", @Use);
            my $warnings = '';
            $use_warnings && ($warnings = "use warnings");
            eval("
            " . $warnings . ";
            Perlito5::set_global_phase(\"CHECK\");
            \$_->() for \@Perlito5::CHECK_BLOCK;
            package main;
            " . $init . ";
            Perlito5::set_global_phase(\"INIT\");
            eval {
                \$_->() for \@Perlito5::INIT_BLOCK;
                1;
            }
            or die \"\$\@
INIT failed--call queue aborted.
\";
            Perlito5::set_global_phase(\"RUN\");
            " . $source . ";
            \$\@ = undef
        ");
            my $error = ${"\@"};
            $error && warn($error);
            Perlito5::set_global_phase("END");
            $_->()
                for @Perlito5::END_BLOCK;
            if ($error) {;
                exit(255)
            }
        }
        else {;
            eval {
                %INC = ();
                @Perlito5::COMP_UNIT = ();
                $use_warnings && ($source = "use warnings;
" . $source);
                my $m;
                my $ok;
                eval {
                    $m = Perlito5::Grammar::exp_stmts($source, 0);
                    $ok = 1
                };
                if (!$ok || $m->{"to"} < length($source)) {
                    my $error = ${"\@"} || ($m->{"to"} < length($source) && "Syntax Error near " . ($m->{"to"})) || "Unknown error";
                    warn($error);
                    exit(255)
                }
                else {
                    if ($expand_use) {
                        my $ok;
                        eval {
                            push(@Perlito5::COMP_UNIT, Perlito5::AST::CompUnit::->new("name", "main", "body", Perlito5::Match::flat($m)));
                            $ok = 1
                        };
                        if (!$ok) {
                            my $error = ${"\@"} || "Unknown error loading a module";
                            warn($error);
                            exit(255)
                        }
                    }
                    else {;
                        push(@Perlito5::COMP_UNIT, Perlito5::AST::CompUnit::->new("name", "main", "body", Perlito5::Match::flat($m)))
                    }
                    for $_ (0 .. $#Perlito5::COMP_UNIT) {;
                        $Perlito5::COMP_UNIT[$_] = $Perlito5::COMP_UNIT[$_]->emit_begin_scratchpad()
                    }
                    {
                        local ${^GLOBAL_PHASE};
                        Perlito5::set_global_phase("CHECK");
                        $_->()
                            for @Perlito5::CHECK_BLOCK
                    }
                    if (!$bootstrapping) {
                        ${^H} = 0;
                        %{^H} = ();
                        my @units;
                        push(@units, Perlito5::AST::Block::->new("stmts", Perlito5::CompileTime::Dumper::emit_globals_after_BEGIN($Perlito5::GLOBAL)));
                        if (@Perlito5::INIT_BLOCK || keys(%Perlito5::DATA_SECTION)) {
                            $s = "{ ";
                            if (keys(%Perlito5::DATA_SECTION)) {;
                                for my $pkg (keys(%Perlito5::DATA_SECTION)) {
                                    $s .= "open " . $pkg . "::DATA, '<', \\\$Perlito5::DATA_SECTION{" . $pkg . "}{data}; ";
                                    $s .= "seek(" . $pkg . "::DATA, \$Perlito5::DATA_SECTION{" . $pkg . "}{pos}, 0); "
                                }
                            }
                            $s .= "local \$\@; " . "local \${^GLOBAL_PHASE}; " . "eval { \${^GLOBAL_PHASE} = \"INIT\" }; " . "eval { " . "\$_->() for \@Perlito5::INIT_BLOCK; " . "1; " . "} " . "or die \"\$\@\\nINIT failed--call queue aborted.\\n\"; " . "} ";
                            my $m = Perlito5::Grammar::exp_stmts($s, 0);
                            push(@units, @{Perlito5::Match::flat($m)})
                        }
                        unshift(@Perlito5::COMP_UNIT, @units)
                    }
                    my $comp_units = [@Perlito5::COMP_UNIT];
                    if ($compile_only) {;
                        say($Perlito5::FILE_NAME . " syntax OK")
                    }
                    elsif ($backend eq "perl5") {
                        if ($expand_use) {;
                            print(Perlito5::Perl5::Runtime::->emit_perl5())
                        }
                        else {;
                            $Perlito5::EMIT_USE = 1
                        }
                        my @data = Perlito5::AST::CompUnit::emit_perl5_program($comp_units);
                        my $out = [];
                        Perlito5::Perl5::PrettyPrinter::pretty_print(\@data, 0, $out);
                        print(join('', @{$out}), ";1
")
                    }
                    elsif ($backend eq "perl6") {
                        if ($boilerplate) {;
                            say("use v6;")
                        }
                        if (!$boilerplate) {;
                            if (ref($comp_units) eq "ARRAY" && (@{$comp_units} == 1) && ref($comp_units->[0]) eq "Perlito5::AST::CompUnit") {;
                                $comp_units = $comp_units->[0]->{"body"}
                            }
                        }
                        my @data = Perlito5::AST::CompUnit::emit_perl6_program($comp_units);
                        my $out = [];
                        Perlito5::Perl6::PrettyPrinter::pretty_print(\@data, 0, $out);
                        print(join('', @{$out}));
                        $boilerplate && print("
")
                    }
                    elsif ($backend eq "js") {;
                        print(Perlito5::AST::CompUnit::emit_javascript2_program($comp_units, "expand_use", $expand_use))
                    }
                    elsif ($backend eq "java") {;
                        print(Perlito5::AST::CompUnit::emit_java_program($comp_units, "expand_use", $expand_use))
                    }
                    elsif ($backend eq "ast-perl5" || $backend eq "ast") {;
                        say(Perlito5::Dumper::ast_dumper($comp_units))
                    }
                    elsif ($backend eq "ast-json") {;
                        say(Perlito5::JSON::ast_dumper($comp_units))
                    }
                    elsif ($backend eq "ast-pretty") {
                        eval("use Data::Printer {colored=>1,class=>{expand=>\"all\",show_methods=>\"none\"}};p(\$comp_units);1");
                        print(${"\@"})
                    }
                    elsif ($backend eq "_comp") {;
                        say(Perlito5::Dumper::ast_dumper(\@Perlito5::BASE_SCOPE))
                    }
                    else {;
                        die("don't know what to do with backend '" . $backend . "'")
                    }
                }
                ${"\@"} = undef
            }
        }
        if (${"\@"}) {
            my $error = ${"\@"};
            warn($error);
            exit(255)
        }
    }
}
;1
