# Do not edit this file - Generated by Perlito5 9.0

package Perlito5::IO;

sub slurp {
    my $source_filename = shift;
    open FILE, $source_filename
      or die "Cannot read $source_filename\n";
    local $/ = undef;
    $source = <FILE>;
    close FILE;
    return $source;
}

use v5.10;
package main;
undef();
package Perlito;
package main;
undef();
package Perlito5::Match;
sub Perlito5::Match::flat {
    ((my  $self) = $_[0]);
    (defined($self->{'capture'}) ? $self->{'capture'} : substr($self->{'str'}, $self->{'from'}, (($self->{'to'} - $self->{'from'}))))
};
1;

;

# use Perlito5::Match
;
package main;
undef();
package Rul;
sub Rul::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Rul::constant {
    ((my  $str) = shift());
    ((my  $len) = length($str));
    if (($str eq chr(92))) {
        ($str = chr(92) . chr(92))
    };
    if (($str eq chr(39))) {
        ($str = chr(92) . chr(39))
    };
    if ($len) {
        ('( ' . chr(39) . $str . chr(39) . ' eq substr( $str, $MATCH->{to}, ' . $len . ') ' . '&& ( $MATCH->{to} = ' . $len . ' + $MATCH->{to} )' . ')')
    }
    else {
        return ('1')
    }
};
package Rul::Quantifier;
sub Rul::Quantifier::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Rul::Quantifier::term {
    $_[0]->{    'term'}
};
sub Rul::Quantifier::quant {
    $_[0]->{    'quant'}
};
sub Rul::Quantifier::greedy {
    $_[0]->{    'greedy'}
};
sub Rul::Quantifier::emit_perl5 {
    ((my  $self) = $_[0]);
    if ((($self->{'quant'} eq '') && ($self->{'greedy'} eq ''))) {
        return ($self->{'term'}->emit_perl5())
    };
    if ((($self->{'quant'} eq '+') && ($self->{'greedy'} eq ''))) {
        $self->{'term'}->set_captures_to_array();
        return (('(do { ' . 'my $last_match_null = 0; ' . 'my $m = $MATCH; ' . 'my $to = $MATCH->{to}; ' . 'my $count = 0; ' . 'while (' . $self->{'term'}->emit_perl5() . ' && ($last_match_null < 2)) ' . '{ ' . 'if ($to == $MATCH->{to}) { ' . '$last_match_null = $last_match_null + 1; ' . '} ' . 'else { ' . '$last_match_null = 0; ' . '}; ' . '$m = $MATCH; ' . '$to = $MATCH->{to}; ' . '$count = $count + 1; ' . '}; ' . '$MATCH = $m; ' . '$MATCH->{to} = $to; ' . '$count > 0; ' . '})'))
    };
    if ((($self->{'quant'} eq '*') && ($self->{'greedy'} eq ''))) {
        $self->{'term'}->set_captures_to_array();
        return (('(do { ' . 'my $last_match_null = 0; ' . 'my $m = $MATCH; ' . 'my $to = $MATCH->{to}; ' . 'while (' . $self->{'term'}->emit_perl5() . ' && ($last_match_null < 2)) ' . '{ ' . 'if ($to == $MATCH->{to}) { ' . '$last_match_null = $last_match_null + 1; ' . '} ' . 'else { ' . '$last_match_null = 0; ' . '}; ' . '$m = $MATCH; ' . '$to = $MATCH->{to}; ' . '}; ' . '$MATCH = $m; ' . '$MATCH->{to} = $to; ' . '1 ' . '})'))
    };
    if ((($self->{'quant'} eq '?') && ($self->{'greedy'} eq ''))) {
        $self->{'term'}->set_captures_to_array();
        return (('(do { ' . 'my $m = $MATCH; ' . 'if (!(do {' . $self->{'term'}->emit_perl5() . '})) ' . '{ ' . '$MATCH = $m; ' . '}; ' . '1 ' . '})'))
    };
    warn('Rul::Quantifier:  not implemented');
    $self->{'term'}->emit_perl5()
};
sub Rul::Quantifier::set_captures_to_array {
    ((my  $self) = $_[0]);
    $self->{'term'}->set_captures_to_array()
};
package Rul::Or;
sub Rul::Or::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Rul::Or::or_list {
    $_[0]->{    'or_list'}
};
sub Rul::Or::emit_perl5 {
    ((my  $self) = $_[0]);
    ('(do { ' . 'my $pos1 = $MATCH->{to}; (do { ' . join('}) || (do { $MATCH->{to} = $pos1; ', map($_->emit_perl5(), @{$self->{'or_list'}})) . '}) })')
};
sub Rul::Or::set_captures_to_array {
    ((my  $self) = $_[0]);
    map($_->set_captures_to_array(), @{$self->{'or_list'}})
};
package Rul::Concat;
sub Rul::Concat::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Rul::Concat::concat {
    $_[0]->{    'concat'}
};
sub Rul::Concat::emit_perl5 {
    ((my  $self) = $_[0]);
    ('(' . join(' && ', map($_->emit_perl5(), @{$self->{'concat'}})) . ')')
};
sub Rul::Concat::set_captures_to_array {
    ((my  $self) = $_[0]);
    map($_->set_captures_to_array(), @{$self->{'concat'}})
};
package Rul::Perlito5::AST::Subrule;
sub Rul::Perlito5::AST::Subrule::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Rul::Perlito5::AST::Subrule::metasyntax {
    $_[0]->{    'metasyntax'}
};
sub Rul::Perlito5::AST::Subrule::captures {
    $_[0]->{    'captures'}
};
sub Rul::Perlito5::AST::Subrule::emit_perl5 {
    ((my  $self) = $_[0]);
    ((my  $s) = $self->{'metasyntax'});
    ($s =~ s!\.!->!g);
    ((my  $meth) = (((1 + index($self->{'metasyntax'}, '.'))) ? $s : (('$grammar->' . $self->{'metasyntax'}))));
    (my  $code);
    if (($self->{'captures'} == 1)) {
        ($code = ('if ($m2) { $MATCH->{to} = $m2->{to}; $MATCH->{' . chr(39) . $self->{'metasyntax'} . chr(39) . '} = $m2; 1 } else { 0 }; '))
    }
    else {
        if (($self->{'captures'} > 1)) {
            ($code = ('if ($m2) { ' . '$MATCH->{to} = $m2->{to}; ' . 'if (exists $MATCH->{' . chr(39) . $self->{'metasyntax'} . chr(39) . '}) { ' . 'push @{ $MATCH->{' . chr(39) . $self->{'metasyntax'} . chr(39) . '} }, $m2; ' . '} ' . 'else { ' . '$MATCH->{' . chr(39) . $self->{'metasyntax'} . chr(39) . '} = [ $m2 ]; ' . '}; ' . '1 ' . '} else { 0 }; '))
        }
        else {
            ($code = 'if ($m2) { $MATCH->{to} = $m2->{to}; 1 } else { 0 }; ')
        }
    };
    ('(do { ' . 'my $m2 = ' . $meth . '($str, $MATCH->{to}); ' . $code . '})')
};
sub Rul::Perlito5::AST::Subrule::set_captures_to_array {
    ((my  $self) = $_[0]);
    if (($self->{'captures'} > 0)) {
        ($self->{'captures'} = ($self->{'captures'} + 1))
    }
};
package Rul::Constant;
sub Rul::Constant::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Rul::Constant::constant {
    $_[0]->{    'constant'}
};
sub Rul::Constant::emit_perl5 {
    ((my  $self) = $_[0]);
    ((my  $str) = $self->{'constant'});
    Rul::constant($str)
};
sub Rul::Constant::set_captures_to_array {
    ((my  $self) = $_[0])
};
package Rul::Perlito5::AST::Dot;
sub Rul::Perlito5::AST::Dot::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Rul::Perlito5::AST::Dot::emit_perl5 {
    ((my  $self) = $_[0]);
    ('( ' . chr(39) . chr(39) . ' ne substr( $str, $MATCH->{to}, 1 ) ' . '&& ($MATCH->{to} = 1 + $MATCH->{to})' . ')')
};
sub Rul::Perlito5::AST::Dot::set_captures_to_array {
    ((my  $self) = $_[0])
};
package Rul::SpecialChar;
sub Rul::SpecialChar::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Rul::SpecialChar::char {
    $_[0]->{    'char'}
};
sub Rul::SpecialChar::emit_perl5 {
    ((my  $self) = $_[0]);
    ((my  $char) = $self->{'char'});
    if (($char eq 'n')) {
        return (Rul::Perlito5::AST::Subrule->new('metasyntax', 'is_newline', 'captures', 0)->emit_perl5())
    };
    if (($char eq 'N')) {
        return (Rul::Perlito5::AST::Subrule->new('metasyntax', 'not_newline', 'captures', 0)->emit_perl5())
    };
    if (($char eq 'd')) {
        return (Rul::Perlito5::AST::Subrule->new('metasyntax', 'digit', 'captures', 0)->emit_perl5())
    };
    if (($char eq 's')) {
        return (Rul::Perlito5::AST::Subrule->new('metasyntax', 'space', 'captures', 0)->emit_perl5())
    };
    if (($char eq 't')) {
        return (Rul::constant(chr(9)))
    };
    return (Rul::constant($char))
};
sub Rul::SpecialChar::set_captures_to_array {
    ((my  $self) = $_[0])
};
package Rul::Block;
sub Rul::Block::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Rul::Block::closure {
    $_[0]->{    'closure'}
};
sub Rul::Block::emit_perl5 {
    ((my  $self) = $_[0]);
    ('(do { ' . $self->{'closure'} . '; 1 })')
};
sub Rul::Block::set_captures_to_array {
    ((my  $self) = $_[0])
};
package Rul::Before;
sub Rul::Before::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Rul::Before::rule_exp {
    $_[0]->{    'rule_exp'}
};
sub Rul::Before::emit_perl5 {
    ((my  $self) = $_[0]);
    ('(do { ' . 'my $tmp = $MATCH; ' . '$MATCH = { ' . chr(39) . 'str' . chr(39) . ' => $str, ' . chr(39) . 'from' . chr(39) . ' => $tmp->{to}, ' . chr(39) . 'to' . chr(39) . ' => $tmp->{to} }; ' . 'my $res = ' . $self->{'rule_exp'}->emit_perl5() . '; ' . '$MATCH = $res ? $tmp : 0; ' . '})')
};
sub Rul::Before::set_captures_to_array {
    ((my  $self) = $_[0])
};
package Rul::NotBefore;
sub Rul::NotBefore::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Rul::NotBefore::rule_exp {
    $_[0]->{    'rule_exp'}
};
sub Rul::NotBefore::emit_perl5 {
    ((my  $self) = $_[0]);
    ('(do { ' . 'my $tmp = $MATCH; ' . '$MATCH = { ' . chr(39) . 'str' . chr(39) . ' => $str, ' . chr(39) . 'from' . chr(39) . ' => $tmp->{to}, ' . chr(39) . 'to' . chr(39) . ' => $tmp->{to} }; ' . 'my $res = ' . $self->{'rule_exp'}->emit_perl5() . '; ' . '$MATCH = $res ? 0 : $tmp; ' . '})')
};
sub Rul::NotBefore::set_captures_to_array {
    ((my  $self) = $_[0])
};
1;

;

# use Perlito5::Emitter::Token
;
package main;
package Perlito5::Precedence;
sub Perlito5::Precedence::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
((my  $Operator) = {});
((my  $Precedence) = {});
((my  $Assoc) = {});
sub Perlito5::Precedence::is_assoc_type {
    ((my  $assoc_type) = shift());
    ((my  $op_name) = shift());
    return ($Assoc->{$assoc_type}->{$op_name})
};
sub Perlito5::Precedence::is_fixity_type {
    ((my  $fixity_type) = shift());
    ((my  $op_name) = shift());
    return ($Operator->{$fixity_type}->{$op_name})
};
sub Perlito5::Precedence::is_term {
    ((my  $token) = shift());
    (((($token->[0] eq 'term')) || (($token->[0] eq 'postfix_or_term'))) || (($token->[0] eq 'postfix')))
};
sub Perlito5::Precedence::is_num {
    (($_[0] ge '0') && ($_[0] le '9'))
};
sub Perlito5::Precedence::is_ident_middle {
    ((my  $c) = shift());
    ((((($c ge 'a') && ($c le 'z'))) || ((($c ge '0') && ($c le '9')))) || (($c eq '_')))
};
((my  @Parsed_op_chars) = (2, 1));
((my  %Parsed_op) = ('?', sub {
    Perlito5::Expression->term_ternary($_[0], $_[1])
}, '(', sub {
    Perlito5::Expression->term_paren($_[0], $_[1])
}, '[', sub {
    Perlito5::Expression->term_square($_[0], $_[1])
}, '{', sub {
    Perlito5::Expression->term_curly($_[0], $_[1])
}, '->', sub {
    Perlito5::Expression->term_arrow($_[0], $_[1])
}));
((my  @Term_chars) = (7, 6, 5, 4, 3, 2, 1));
((my  %Term) = ('.', sub {
    Perlito5::Expression->term_digit($_[0], $_[1])
}, '0', sub {
    Perlito5::Expression->term_digit($_[0], $_[1])
}, '1', sub {
    Perlito5::Expression->term_digit($_[0], $_[1])
}, '2', sub {
    Perlito5::Expression->term_digit($_[0], $_[1])
}, '3', sub {
    Perlito5::Expression->term_digit($_[0], $_[1])
}, '4', sub {
    Perlito5::Expression->term_digit($_[0], $_[1])
}, '5', sub {
    Perlito5::Expression->term_digit($_[0], $_[1])
}, '6', sub {
    Perlito5::Expression->term_digit($_[0], $_[1])
}, '7', sub {
    Perlito5::Expression->term_digit($_[0], $_[1])
}, '8', sub {
    Perlito5::Expression->term_digit($_[0], $_[1])
}, '9', sub {
    Perlito5::Expression->term_digit($_[0], $_[1])
}, 'my', sub {
    Perlito5::Expression->term_declarator($_[0], $_[1])
}, 'do', sub {
    Perlito5::Expression->term_do($_[0], $_[1])
}, 'our', sub {
    Perlito5::Expression->term_declarator($_[0], $_[1])
}, 'sub', sub {
    Perlito5::Expression->term_anon_sub($_[0], $_[1])
}, 'map', sub {
    Perlito5::Expression->term_map_or_sort($_[0], $_[1])
}, 'eval', sub {
    Perlito5::Expression->term_eval($_[0], $_[1])
}, 'sort', sub {
    Perlito5::Expression->term_map_or_sort($_[0], $_[1])
}, 'grep', sub {
    Perlito5::Expression->term_map_or_sort($_[0], $_[1])
}, 'state', sub {
    Perlito5::Expression->term_declarator($_[0], $_[1])
}, 'local', sub {
    Perlito5::Expression->term_declarator($_[0], $_[1])
}, 'return', sub {
    Perlito5::Expression->term_return($_[0], $_[1])
}, 'package', sub {
    Perlito5::Expression->term_package($_[0], $_[1])
}));
sub Perlito5::Precedence::add_term {
    ((my  $name) = shift());
    ((my  $param) = shift());
    ($Term{$name} = $param)
};
(my  $End_token);
(my  $End_token_chars);
(my  %Op);
((my  @Op_chars) = (3, 2, 1));
sub Perlito5::Precedence::op_parse {
    ((my  $self) = shift());
    ((my  $str) = shift());
    ((my  $pos) = shift());
    ((my  $last_is_term) = shift());
    for my $len (@{$End_token_chars}) {
        ((my  $term) = substr($str, $pos, $len));
        if (exists($End_token->{$term})) {
            ((my  $c1) = substr($str, (($pos + length($term)) - 1), 1));
            ((my  $c2) = substr($str, ($pos + length($term)), 1));
            if (!(((is_ident_middle($c1) && is_ident_middle($c2))))) {
                return ({'str', $str, 'from', $pos, 'to', $pos, 'capture', ['end', $term]})
            }
        }
    };
    if (!($last_is_term)) {
        for my $len (@Term_chars) {
            ((my  $term) = substr($str, $pos, $len));
            if (exists($Term{$term})) {
                ((my  $c1) = substr($str, (($pos + length($term)) - 1), 1));
                ((my  $c2) = substr($str, ($pos + length($term)), 1));
                if (((is_num($c1) || !(is_ident_middle($c1))) || !(is_ident_middle($c2)))) {
                    ((my  $m) = $Term{$term}->($str, $pos));
                    if ($m) {
                        return ($m)
                    }
                }
            }
        }
    };
    for my $len (@Parsed_op_chars) {
        ((my  $op) = substr($str, $pos, $len));
        if (exists($Parsed_op{$op})) {
            ((my  $m) = $Parsed_op{$op}->($str, $pos));
            if ($m) {
                return ($m)
            }
        }
    };
    for my $len (@Op_chars) {
        ((my  $op) = substr($str, $pos, $len));
        if (exists($Op{$op})) {
            ((my  $c1) = substr($str, (($pos + length($op)) - 1), 1));
            ((my  $c2) = substr($str, ($pos + length($op)), 1));
            if ((!(((is_ident_middle($c1) && is_ident_middle($c2)))) && !(((($c1 eq '&') && ($c2 eq '&')))))) {
                if (((exists($Operator->{'infix'}->{$op}) && !(exists($Operator->{'prefix'}->{$op}))) && !($last_is_term))) {

                }
                else {
                    return ({'str', $str, 'from', $pos, 'to', ($pos + $len), 'capture', ['op', $op]})
                }
            }
        }
    };
    return (Perlito5::Grammar::Bareword->term_bareword($str, $pos))
};
sub Perlito5::Precedence::add_op {
    ((my  $fixity) = shift());
    ((my  $name) = shift());
    ((my  $precedence) = shift());
    ((my  $param) = shift());
    if (!((defined($param)))) {
        ($param = {})
    };
    ((my  $assoc) = ($param->{'assoc'} || 'left'));
    ($Operator->{$fixity}->{$name} = 1);
    ($Precedence->{$name} = $precedence);
    ($Assoc->{$assoc}->{$name} = 1);
    ($Op{$name} = 1)
};
((my  $prec) = 100);
add_op('postfix', '.( )', $prec);
add_op('postfix', '.[ ]', $prec);
add_op('postfix', '.{ }', $prec);
add_op('postfix', '( )', $prec);
add_op('postfix', '[ ]', $prec);
add_op('postfix', 'funcall', $prec);
add_op('postfix', 'funcall_no_params', $prec);
add_op('postfix', 'methcall', $prec);
add_op('postfix', 'methcall_no_params', $prec);
add_op('postfix', 'block', $prec);
add_op('postfix', 'hash', $prec);
($prec = ($prec - 1));
add_op('prefix', '++', $prec);
add_op('prefix', '--', $prec);
add_op('postfix', '++', $prec);
add_op('postfix', '--', $prec);
($prec = ($prec - 1));
add_op('infix', '**', $prec, {'assoc', 'right'});
($prec = ($prec - 1));
add_op('prefix', chr(92), $prec);
add_op('prefix', '+', $prec);
add_op('prefix', '-', $prec);
add_op('prefix', '~', $prec);
add_op('prefix', '!', $prec);
($prec = ($prec - 1));
add_op('infix', '=~', $prec);
add_op('infix', '!~', $prec);
($prec = ($prec - 1));
add_op('infix', '*', $prec);
add_op('infix', '/', $prec);
add_op('infix', '%', $prec);
add_op('infix', 'x', $prec);
($prec = ($prec - 1));
add_op('infix', '+', $prec);
add_op('infix', '-', $prec);
add_op('infix', '.', $prec, {'assoc', 'list'});
($prec = ($prec - 1));
add_op('infix', '<<', $prec);
add_op('infix', '>>', $prec);
($prec = ($prec - 1));
for (('-r', '-w', '-x', '-o', '-R', '-W', '-X', '-O', '-e', '-z', '-s', '-f', '-d', '-l', '-p', '-S', '-b', '-c', '-t', '-u', '-g', '-k', '-T', '-B', '-M', '-A', '-C')) {
    add_op('prefix', $_, $prec)
};
($prec = ($prec - 1));
add_op('infix', 'lt', $prec, {'assoc', 'chain'});
add_op('infix', 'le', $prec, {'assoc', 'chain'});
add_op('infix', 'gt', $prec, {'assoc', 'chain'});
add_op('infix', 'ge', $prec, {'assoc', 'chain'});
add_op('infix', '<=', $prec, {'assoc', 'chain'});
add_op('infix', '>=', $prec, {'assoc', 'chain'});
add_op('infix', '<', $prec, {'assoc', 'chain'});
add_op('infix', '>', $prec, {'assoc', 'chain'});
($prec = ($prec - 1));
add_op('infix', '<=>', $prec);
add_op('infix', 'cmp', $prec);
add_op('infix', '==', $prec, {'assoc', 'chain'});
add_op('infix', '!=', $prec, {'assoc', 'chain'});
add_op('infix', 'ne', $prec, {'assoc', 'chain'});
add_op('infix', 'eq', $prec, {'assoc', 'chain'});
($prec = ($prec - 1));
add_op('infix', '&', $prec);
($prec = ($prec - 1));
add_op('infix', '|', $prec);
add_op('infix', '^', $prec);
($prec = ($prec - 1));
add_op('infix', '..', $prec);
add_op('infix', '...', $prec);
add_op('infix', '~~', $prec, {'assoc', 'chain'});
($prec = ($prec - 1));
add_op('infix', '&&', $prec);
($prec = ($prec - 1));
add_op('infix', '||', $prec);
add_op('infix', '//', $prec);
($prec = ($prec - 1));
add_op('ternary', '? :', $prec, {'assoc', 'right'});
($prec = ($prec - 1));
add_op('infix', '=', $prec, {'assoc', 'right'});
add_op('infix', '**=', $prec, {'assoc', 'right'});
add_op('infix', '+=', $prec, {'assoc', 'right'});
add_op('infix', '-=', $prec, {'assoc', 'right'});
add_op('infix', '*=', $prec, {'assoc', 'right'});
add_op('infix', '/=', $prec, {'assoc', 'right'});
add_op('infix', 'x=', $prec, {'assoc', 'right'});
add_op('infix', '|=', $prec, {'assoc', 'right'});
add_op('infix', '&=', $prec, {'assoc', 'right'});
add_op('infix', '.=', $prec, {'assoc', 'right'});
add_op('infix', '<<=', $prec, {'assoc', 'right'});
add_op('infix', '>>=', $prec, {'assoc', 'right'});
add_op('infix', '%=', $prec, {'assoc', 'right'});
add_op('infix', '||=', $prec, {'assoc', 'right'});
add_op('infix', '&&=', $prec, {'assoc', 'right'});
add_op('infix', '^=', $prec, {'assoc', 'right'});
add_op('infix', '//=', $prec, {'assoc', 'right'});
($prec = ($prec - 1));
add_op('infix', '=>', $prec);
($prec = ($prec - 1));
add_op('list', ',', $prec, {'assoc', 'list'});
($prec = ($prec - 1));
add_op('prefix', 'not', $prec);
($prec = ($prec - 1));
add_op('infix', 'and', $prec);
($prec = ($prec - 1));
add_op('infix', 'or', $prec);
add_op('infix', 'xor', $prec);
($prec = ($prec - 1));
add_op('infix', '*start*', $prec);
sub Perlito5::Precedence::precedence_parse {
    ((my  $self) = shift());
    ((my  $get_token) = $self->{'get_token'});
    ((my  $reduce) = $self->{'reduce'});
    ((my  $last_end_token) = $End_token);
    ((my  $last_end_token_chars) = $End_token_chars);
    ($End_token = $self->{'end_token'});
    ($End_token_chars = $self->{'end_token_chars'});
    ((my  $op_stack) = []);
    ((my  $num_stack) = []);
    ((my  $last) = ['op', '*start*']);
    ((my  $last_is_term) = 0);
    ((my  $token) = $get_token->($last_is_term));
    if (($token->[0] eq 'space')) {
        ($token = $get_token->($last_is_term))
    };
    for ( ; ((defined($token)) && (($token->[0] ne 'end'))); do {{

}} ) {
        ((my  $token_is_term) = is_term($token));
        if (((($token->[1] eq ',')) && (((($last->[1] eq '*start*')) || (($last->[1] eq ',')))))) {
            push(@{$num_stack}, ['term', undef()] )
        };
        if (($Operator->{'prefix'}->{$token->[1]} && (((($last->[1] eq '*start*')) || !($last_is_term))))) {
            ($token->[0] = 'prefix');
            unshift(@{$op_stack}, $token)
        }
        else {
            if ((($Operator->{'postfix'})->{$token->[1]} && $last_is_term)) {
                ((my  $pr) = $Precedence->{$token->[1]});
                for ( ; (scalar(@{$op_stack}) && (($pr <= $Precedence->{($op_stack->[0])->[1]}))); do {{

}} ) {
                    $reduce->($op_stack, $num_stack)
                };
                if (($token->[0] ne 'postfix_or_term')) {
                    ($token->[0] = 'postfix')
                };
                unshift(@{$op_stack}, $token);
                ($token_is_term = 1)
            }
            else {
                if ($token_is_term) {
                    if ($last_is_term) {
                        say('#      last:  ', Perlito5::Dumper::Dumper($last));
                        say('#      token: ', Perlito5::Dumper::Dumper($token));
                        die('Value tokens must be separated by an operator')
                    };
                    ($token->[0] = 'term');
                    push(@{$num_stack}, $token )
                }
                else {
                    if ($Precedence->{$token->[1]}) {
                        ((my  $pr) = $Precedence->{$token->[1]});
                        if ($Assoc->{'right'}->{$token->[1]}) {
                            for ( ; (scalar(@{$op_stack}) && (($pr < $Precedence->{($op_stack->[0])->[1]}))); do {{

}} ) {
                                $reduce->($op_stack, $num_stack)
                            }
                        }
                        else {
                            for ( ; (scalar(@{$op_stack}) && (($pr <= $Precedence->{($op_stack->[0])->[1]}))); do {{

}} ) {
                                $reduce->($op_stack, $num_stack)
                            }
                        };
                        if ($Operator->{'ternary'}->{$token->[1]}) {
                            ($token->[0] = 'ternary')
                        }
                        else {
                            ($token->[0] = 'infix')
                        };
                        unshift(@{$op_stack}, $token)
                    }
                    else {
                        die('Unknown token: ' . chr(39), $token->[1], chr(39))
                    }
                }
            }
        };
        ($last = $token);
        ($last_is_term = $token_is_term);
        ($token = $get_token->($last_is_term));
        if (($token->[0] eq 'space')) {
            ($token = $get_token->($last_is_term))
        }
    };
    if ((defined($token) && (($token->[0] ne 'end')))) {
        die('Unexpected end token: ', $token)
    };
    for ( ; scalar(@{$op_stack}); do {{

}} ) {
        $reduce->($op_stack, $num_stack)
    };
    ($End_token = $last_end_token);
    ($End_token_chars = $last_end_token_chars);
    return ($num_stack)
};
1;

;
package main;
package Perlito5::Grammar::Bareword;
sub Perlito5::Grammar::Bareword::term_bareword {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $p) = $pos);
    ((my  $m_namespace) = Perlito5::Grammar->optional_namespace_before_ident($str, $p));
    ($p = $m_namespace->{'to'});
    ((my  $m_name) = Perlito5::Grammar->ident($str, $p));
    if ($m_name) {

    }
    else {
        return ($m_name)
    };
    ($p = $m_name->{'to'});
    ((my  $name) = Perlito5::Match::flat($m_name));
    ((my  $namespace) = Perlito5::Match::flat($m_namespace));
    ((my  $full_name) = $name);
    if ($namespace) {
        ($full_name = ($namespace . '::' . $name))
    };
    ((my  $m) = Perlito5::Grammar::Space->ws($str, $p));
    if ($m) {
        ($p = $m->{'to'})
    };
    if ((substr($str, $p, 2) eq '=>')) {
        ($m_name->{'capture'} = ['term', Perlito5::AST::Apply->new('code', $name, 'namespace', $namespace, 'arguments', [], 'bareword', 1)]);
        ($m_name->{'to'} = $p);
        return ($m_name)
    };
    if ((substr($str, $p, 2) eq '->')) {
        ($m_name->{'capture'} = ['term', Perlito5::AST::Proto->new('name', $full_name)]);
        ($m_name->{'to'} = $p);
        return ($m_name)
    };
    ((my  $effective_name) = ((($namespace || $Perlito5::PKG_NAME)) . '::' . $name));
    (my  $sig);
    if (exists($Perlito5::PROTO->{$effective_name})) {
        ($sig = $Perlito5::PROTO->{$effective_name})
    }
    else {
        if ((((!($namespace) || ($namespace eq 'CORE'))) && exists($Perlito5::CORE_PROTO->{('CORE::' . $name)}))) {
            ($effective_name = ('CORE::' . $name));
            ($sig = $Perlito5::CORE_PROTO->{$effective_name})
        }
        else {
            ($sig = undef())
        }
    };
    ((my  $has_paren) = 0);
    if (defined($sig)) {
        if ((substr($sig, 0, 1) eq ';')) {
            if ((substr($str, $p, 2) eq '//')) {
                ($m_name->{'capture'} = ['term', Perlito5::AST::Apply->new('code', $name, 'namespace', $namespace, 'arguments', [], 'bareword', 1)]);
                ($m_name->{'to'} = $p);
                return ($m_name)
            }
        };
        if (($sig eq '')) {
            if ((substr($str, $p, 1) eq '(')) {
                ($p)++;
                ($has_paren = 1);
                ((my  $m) = Perlito5::Grammar::Space->ws($str, $p));
                if ($m) {
                    ($p = $m->{'to'})
                };
                if ((substr($str, $p, 1) ne ')')) {
                    die('syntax error near ', substr($str, $pos, 10))
                };
                ($p)++
            };
            ($m_name->{'capture'} = ['term', Perlito5::AST::Apply->new('code', $name, 'namespace', $namespace, 'arguments', [], 'bareword', (($has_paren == 0)))]);
            ($m_name->{'to'} = $p);
            return ($m_name)
        };
        if (((($sig eq '_') || ($sig eq '$')) || ($sig eq ';$'))) {
            (my  $m);
            (my  $arg);
            if ((substr($str, $p, 1) eq '(')) {
                ($m = Perlito5::Expression->term_paren($str, $p));
                if (!($m)) {
                    return ($m)
                };
                ($p = $m->{'to'});
                ($has_paren = 1);
                ($arg = $m->{'capture'}->[2]);
                ($arg = Perlito5::Expression::expand_list($arg));
                ((my  $v) = shift(@{$arg}));
                if (@{$arg}) {
                    die(('Too many arguments for ' . $name))
                };
                ($arg = $v)
            }
            else {
                ($m = Perlito5::Expression->argument_parse($str, $p));
                ($arg = $m->{'capture'});
                if (($arg eq '*undef*')) {
                    ($arg = undef())
                }
                else {
                    if (((ref($arg) eq 'Perlito5::AST::Apply') && ($arg->{'code'} eq 'circumfix:<( )>'))) {
                        ((my  $v) = shift(@{$arg->{'arguments'}}));
                        if (@{$arg->{'arguments'}}) {
                            die(('Too many arguments for ' . $name))
                        };
                        ($arg = $v)
                    }
                }
            };
            (my  @args);
            if (defined($arg)) {
                push(@args, $arg );
                ($has_paren = 1)
            }
            else {
                if (($sig eq '$')) {
                    die(('Not enough arguments for ' . $name))
                };
                if (($sig eq '_')) {
                    push(@args, Perlito5::AST::Var->new('namespace', '', 'name', '_', 'sigil', '$') )
                }
            };
            ($m->{'capture'} = ['term', Perlito5::AST::Apply->new('code', $name, 'namespace', $namespace, 'arguments', \@args, 'bareword', (($has_paren == 0)))]);
            return ($m)
        };
        if (($sig eq '*')) {

        }
    };
    if ((substr($str, $p, 1) eq '(')) {
        ($m = Perlito5::Expression->term_paren($str, $p));
        if (!($m)) {
            return ($m)
        };
        ((my  $arg) = $m->{'capture'}->[2]);
        ($arg = Perlito5::Expression::expand_list($arg));
        ($m->{'capture'} = ['term', Perlito5::AST::Apply->new('code', $name, 'namespace', $namespace, 'arguments', $arg)]);
        return ($m)
    };
    ((my  $m_list) = Perlito5::Expression->list_parse($str, $p));
    ((my  $list) = $m_list->{'capture'});
    if (($list ne '*undef*')) {
        ($m_name->{'capture'} = ['postfix_or_term', 'funcall', $namespace, $name, $list]);
        ($m_name->{'to'} = $m_list->{'to'});
        return ($m_name)
    };
    ($m_name->{'capture'} = ['postfix_or_term', 'funcall_no_params', $namespace, $name]);
    return ($m_name)
};
1;

;
package main;
package Perlito5::Expression;

# use Perlito5::Precedence
;

# use Perlito5::Grammar::Bareword
;
sub Perlito5::Expression::expand_list {
    ((my  $param_list) = shift());
    if (((ref($param_list) eq 'Perlito5::AST::Apply') && ($param_list->code() eq 'list:<,>'))) {
        ((my  $args) = []);
        for my $v (@{$param_list->arguments()}) {
            if (defined($v)) {
                push(@{$args}, $v )
            }
        };
        return ($args)
    }
    else {
        if (($param_list eq '*undef*')) {
            return ([])
        }
        else {
            return ([$param_list])
        }
    }
};
sub Perlito5::Expression::block_or_hash {
    ((my  $o) = shift());
    if (defined($o->sig())) {
        return ($o)
    };
    ((my  $stmts) = $o->stmts());
    if ((!((defined($stmts))) || (scalar(@{$stmts}) == 0))) {
        return (Perlito5::AST::Apply->new('code', 'circumfix:<{ }>', 'namespace', '', 'arguments', []))
    };
    if ((scalar(@{$stmts}) != 1)) {
        return ($o)
    };
    ((my  $stmt) = $stmts->[0]);
    if ((ref($stmt) eq 'Perlito5::AST::Var')) {
        return (Perlito5::AST::Apply->new('code', 'circumfix:<{ }>', 'namespace', '', 'arguments', [$stmt]))
    };
    if ((ref($stmt) ne 'Perlito5::AST::Apply')) {
        return ($o)
    };
    if (($stmt->code() eq 'infix:<=>>')) {
        return (Perlito5::AST::Apply->new('code', 'circumfix:<{ }>', 'namespace', '', 'arguments', [$stmt]))
    };
    if (($stmt->code() ne 'list:<,>')) {
        return ($o)
    };
    for my $item (@{$stmt->arguments()}) {
        if (((ref($item) eq 'Perlito5::AST::Apply') && ($item->code() eq 'infix:<=>>'))) {
            return (Perlito5::AST::Apply->new('code', 'circumfix:<{ }>', 'namespace', '', 'arguments', expand_list($stmt)))
        }
    };
    return ($o)
};
sub Perlito5::Expression::pop_term {
    ((my  $num_stack) = shift());
    ((my  $v) = pop(@{$num_stack}));
    if ((ref($v) eq 'ARRAY')) {
        if (($v->[1] eq 'methcall_no_params')) {
            ($v = Perlito5::AST::Call->new('invocant', undef(), 'method', $v->[2], 'arguments', []));
            return ($v)
        };
        if (($v->[1] eq 'funcall_no_params')) {
            ($v = Perlito5::AST::Apply->new('code', $v->[3], 'namespace', $v->[2], 'arguments', [], 'bareword', 1));
            return ($v)
        };
        if (($v->[1] eq 'methcall')) {
            ((my  $param_list) = expand_list(($v->[3])));
            ($v = Perlito5::AST::Call->new('invocant', undef(), 'method', $v->[2], 'arguments', $param_list));
            return ($v)
        };
        if (($v->[1] eq 'funcall')) {
            ((my  $param_list) = expand_list(($v->[4])));
            ($v = Perlito5::AST::Apply->new('code', $v->[3], 'arguments', $param_list, 'namespace', $v->[2]));
            return ($v)
        };
        if (($v->[1] eq '( )')) {
            ((my  $param_list) = expand_list($v->[2]));
            ($v = Perlito5::AST::Apply->new('code', 'circumfix:<( )>', 'arguments', $param_list, 'namespace', ''));
            return ($v)
        };
        if (($v->[1] eq '[ ]')) {
            ((my  $param_list) = expand_list($v->[2]));
            ($v = Perlito5::AST::Apply->new('code', 'circumfix:<[ ]>', 'arguments', $param_list, 'namespace', ''));
            return ($v)
        };
        if (($v->[1] eq 'block')) {
            ($v = Perlito5::AST::Lit::Block->new('stmts', $v->[2], 'sig', $v->[3]));
            ($v = block_or_hash($v));
            return ($v)
        };
        if (($v->[1] eq '.( )')) {
            ($v = Perlito5::AST::Call->new('invocant', undef(), 'method', 'postcircumfix:<( )>', 'arguments', $v->[2]));
            return ($v)
        };
        if (($v->[1] eq '.[ ]')) {
            ($v = Perlito5::AST::Index->new('obj', undef(), 'index_exp', $v->[2]));
            return ($v)
        };
        if (($v->[1] eq '.{ }')) {
            ($v = Perlito5::AST::Lookup->new('obj', undef(), 'index_exp', $v->[2]));
            return ($v)
        };
        if (((ref($v->[1]) eq 'ARRAY') && (scalar($v->[1]) == 2))) {
            ($v = Perlito5::AST::Apply->new('code', 'pair', 'arguments', $v->[1], 'namespace', ''));
            return ($v)
        };
        return ($v->[1])
    };
    return ($v)
};
sub Perlito5::Expression::reduce_postfix {
    ((my  $op) = shift());
    ((my  $value) = shift());
    ((my  $v) = $op);
    if (($v->[1] eq 'methcall_no_params')) {
        ($v = Perlito5::AST::Call->new('invocant', $value, 'method', $v->[2], 'arguments', []));
        return ($v)
    };
    if (($v->[1] eq 'funcall_no_params')) {
        die('unexpected function call')
    };
    if (($v->[1] eq 'methcall')) {
        ((my  $param_list) = expand_list($v->[3]));
        ($v = Perlito5::AST::Call->new('invocant', $value, 'method', $v->[2], 'arguments', $param_list));
        return ($v)
    };
    if (($v->[1] eq 'funcall')) {
        die('unexpected function call')
    };
    if (($v->[1] eq '( )')) {
        ((my  $param_list) = expand_list($v->[2]));
        if (((ref($value) eq 'Perlito5::AST::Apply') && !((defined($value->arguments()))))) {
            ($value->{'arguments'} = $param_list);
            return ($value)
        };
        if (((ref($value) eq 'Perlito5::AST::Call') && !((defined($value->arguments()))))) {
            ($value->{'arguments'} = $param_list);
            return ($value)
        };
        ($v = Perlito5::AST::Call->new('invocant', $value, 'method', 'postcircumfix:<( )>', 'arguments', $param_list));
        return ($v)
    };
    if (($v->[1] eq '[ ]')) {
        ($v = Perlito5::AST::Index->new('obj', $value, 'index_exp', $v->[2]));
        return ($v)
    };
    if (($v->[1] eq 'block')) {
        ($v = Perlito5::AST::Lookup->new('obj', $value, 'index_exp', ($v->[2])->[0]));
        return ($v)
    };
    if (($v->[1] eq '.( )')) {
        ((my  $param_list) = expand_list($v->[2]));
        ($v = Perlito5::AST::Call->new('invocant', $value, 'method', 'postcircumfix:<( )>', 'arguments', $param_list));
        return ($v)
    };
    if (($v->[1] eq '.[ ]')) {
        ($v = Perlito5::AST::Call->new('invocant', $value, 'method', 'postcircumfix:<[ ]>', 'arguments', $v->[2]));
        return ($v)
    };
    if (($v->[1] eq '.{ }')) {
        ($v = Perlito5::AST::Call->new('invocant', $value, 'method', 'postcircumfix:<{ }>', 'arguments', $v->[2]));
        return ($v)
    };
    push(@{$op}, $value );
    return ($op)
};
((my  $reduce_to_ast) = sub {
    ((my  $op_stack) = shift());
    ((my  $num_stack) = shift());
    ((my  $last_op) = shift(@{$op_stack}));
    if (($last_op->[0] eq 'prefix')) {
        push(@{$num_stack}, Perlito5::AST::Apply->new('namespace', '', 'code', ('prefix:<' . $last_op->[1] . '>'), 'arguments', [pop_term($num_stack)]) )
    }
    else {
        if (($last_op->[0] eq 'postfix')) {
            push(@{$num_stack}, Perlito5::AST::Apply->new('namespace', '', 'code', ('postfix:<' . $last_op->[1] . '>'), 'arguments', [pop_term($num_stack)]) )
        }
        else {
            if (($last_op->[0] eq 'postfix_or_term')) {
                push(@{$num_stack}, reduce_postfix($last_op, pop_term($num_stack)) )
            }
            else {
                if (Perlito5::Precedence::is_assoc_type('list', $last_op->[1])) {
                    (my  $arg);
                    if ((scalar(@{$num_stack}) < 2)) {
                        ((my  $v2) = pop_term($num_stack));
                        if (((ref($v2) eq 'Perlito5::AST::Apply') && ($v2->code() eq (('list:<' . $last_op->[1] . '>'))))) {
                            push(@{$num_stack}, Perlito5::AST::Apply->new('namespace', $v2->namespace(), 'code', $v2->code(), 'arguments', [@{$v2->arguments()}, undef()]) )
                        }
                        else {
                            push(@{$num_stack}, Perlito5::AST::Apply->new('namespace', '', 'code', ('list:<' . $last_op->[1] . '>'), 'arguments', [$v2, undef()]) )
                        };
                        return ()
                    }
                    else {
                        ((my  $v2) = pop_term($num_stack));
                        ($arg = [pop_term($num_stack), $v2])
                    };
                    if ((((ref($arg->[0]) eq 'Perlito5::AST::Apply') && ($last_op->[0] eq 'infix')) && (($arg->[0]->code() eq ('list:<' . $last_op->[1] . '>'))))) {
                        push(@{$num_stack}, Perlito5::AST::Apply->new('namespace', '', 'code', ($arg->[0])->code(), 'arguments', [@{($arg->[0])->arguments()}, $arg->[1]]) );
                        return ()
                    };
                    push(@{$num_stack}, Perlito5::AST::Apply->new('namespace', '', 'code', ('list:<' . $last_op->[1] . '>'), 'arguments', $arg) )
                }
                else {
                    if (Perlito5::Precedence::is_assoc_type('chain', $last_op->[1])) {
                        if ((scalar(@{$num_stack}) < 2)) {
                            die(('Missing value after operator ' . $last_op->[1]))
                        };
                        ((my  $v2) = pop_term($num_stack));
                        ((my  $arg) = [pop_term($num_stack), $v2]);
                        push(@{$num_stack}, Perlito5::AST::Apply->new('namespace', '', 'code', ('infix:<' . $last_op->[1] . '>'), 'arguments', $arg) )
                    }
                    else {
                        if (($last_op->[0] eq 'ternary')) {
                            if ((scalar(@{$num_stack}) < 2)) {
                                die('Missing value after ternary operator')
                            };
                            ((my  $v2) = pop_term($num_stack));
                            push(@{$num_stack}, Perlito5::AST::Apply->new('namespace', '', 'code', ('ternary:<' . $last_op->[1] . '>'), 'arguments', [pop_term($num_stack), $last_op->[2], $v2]) )
                        }
                        else {
                            if ((scalar(@{$num_stack}) < 2)) {
                                die(('missing value after operator ' . chr(39) . $last_op->[1] . chr(39)))
                            };
                            ((my  $v2) = pop_term($num_stack));
                            push(@{$num_stack}, Perlito5::AST::Apply->new('namespace', '', 'code', ('infix:<' . $last_op->[1] . '>'), 'arguments', [pop_term($num_stack), $v2]) )
                        }
                    }
                }
            }
        }
    }
});
sub Perlito5::Expression::term_arrow {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((((('->' eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((((((do {
    (((((('(' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->paren_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'paren_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((')' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = ['postfix_or_term', '.( )', Perlito5::Match::flat($MATCH->{'paren_parse'})]);
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((((('[' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->square_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'square_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((']' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = ['postfix_or_term', '.[ ]', Perlito5::Match::flat($MATCH->{'square_parse'})]);
    1
}))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((((('{' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->curly_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'curly_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = ['postfix_or_term', '.{ }', Perlito5::Match::flat($MATCH->{'curly_parse'})]);
    1
}))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((((('$' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = Perlito5::Grammar->ident($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.ident'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((((('(' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->paren_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'paren_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((')' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = ['postfix_or_term', 'methcall', Perlito5::AST::Var->new('sigil', '$', 'namespace', '', 'name', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.ident'})), Perlito5::Match::flat($MATCH->{'paren_parse'})]);
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((do {
    ($MATCH->{'capture'} = ['postfix_or_term', 'methcall_no_params', Perlito5::AST::Var->new('sigil', '$', 'namespace', '', 'name', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.ident'}))]);
    1
})))
})))
}))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((do {
    ((my  $m2) = Perlito5::Grammar->full_ident($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.full_ident'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((((('(' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->paren_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'paren_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((')' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = ['postfix_or_term', 'methcall', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.full_ident'}), Perlito5::Match::flat($MATCH->{'paren_parse'})]);
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((do {
    ($MATCH->{'capture'} = ['postfix_or_term', 'methcall_no_params', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.full_ident'})]);
    1
})))
})))
}))))
})))
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Expression::term_digit {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((do {
    ((my  $m2) = Perlito5::Grammar->val_num($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.val_num'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.val_num'})]);
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((do {
    ((my  $m2) = Perlito5::Grammar->val_int($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.val_int'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.val_int'})]);
    1
}))))
})))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Expression::term_ternary {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((('?' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->ternary5_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'ternary5_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((':' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = ['op', '? :', Perlito5::Match::flat($MATCH->{'ternary5_parse'})]);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Expression::term_paren {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((('(' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->paren_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'paren_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((')' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = ['postfix_or_term', '( )', Perlito5::Match::flat($MATCH->{'paren_parse'})]);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Expression::term_square {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((('[' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->square_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'square_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((']' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = ['postfix_or_term', '[ ]', Perlito5::Match::flat($MATCH->{'square_parse'})]);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Expression::term_curly {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((((('{' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m) = $MATCH);
    if (!(((do {
    ((my  $m2) = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})))) {
        ($MATCH = $m)
    };
    1
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->exp_stmts($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.exp_stmts'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m) = $MATCH);
    if (!(((do {
    ((my  $m2) = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})))) {
        ($MATCH = $m)
    };
    1
}))) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = ['postfix_or_term', 'block', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.exp_stmts'})]);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Expression::declarator {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((((do {
    (('my' eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('state' eq substr($str, $MATCH->{'to'}, 5)) && (($MATCH->{'to'} = (5 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('our' eq substr($str, $MATCH->{'to'}, 3)) && (($MATCH->{'to'} = (3 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('local' eq substr($str, $MATCH->{'to'}, 5)) && (($MATCH->{'to'} = (5 + $MATCH->{'to'}))))))
})))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Expression::term_declarator {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((((do {
    ((my  $m2) = $grammar->declarator($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'declarator'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->opt_type($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.opt_type'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->var_ident($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.var_ident'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $decl) = Perlito5::Match::flat($MATCH->{'declarator'}));
    ((my  $type) = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.opt_type'}));
    ((my  $var) = $MATCH->{'Perlito5::Grammar.var_ident'}->{'capture'});
    if (($decl eq 'local')) {
        ($MATCH = Perlito5::Grammar::String->double_quoted_var_with_subscript($MATCH->{'Perlito5::Grammar.var_ident'}));
        ($var = $MATCH->{'capture'})
    };
    ($MATCH->{'capture'} = ['term', Perlito5::AST::Decl->new('decl', $decl, 'type', $type, 'var', $var)]);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Expression::term_return {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((('return' eq substr($str, $MATCH->{'to'}, 6)) && (($MATCH->{'to'} = (6 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->list_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'list_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $args) = Perlito5::Match::flat($MATCH->{'list_parse'}));
    ($MATCH->{'capture'} = ['term', Perlito5::AST::Apply->new('code', 'return', 'arguments', (($args eq '*undef*') ? [] : [$args]), 'namespace', '')]);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Expression::term_anon_sub {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((('sub' eq substr($str, $MATCH->{'to'}, 3)) && (($MATCH->{'to'} = (3 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->anon_sub_def($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.anon_sub_def'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.anon_sub_def'})]);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Expression::term_do {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((((((('do' eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}});
    ((my  $res) = ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (('{' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
}))
})));
    ($MATCH = ($res ? $tmp : 0))
}))) && ((do {
    ((my  $m2) = $grammar->statement_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'statement_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::AST::Do->new('block', Perlito5::Match::flat($MATCH->{'statement_parse'}))]);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Expression::term_package {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((('package' eq substr($str, $MATCH->{'to'}, 7)) && (($MATCH->{'to'} = (7 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->full_ident($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.full_ident'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $name) = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.full_ident'}));
    ($Perlito5::PKG_NAME = $name);
    ($MATCH->{'capture'} = ['term', Perlito5::AST::Apply->new('code', 'package', 'arguments', [], 'namespace', $name)]);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Expression::term_eval {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((((((('eval' eq substr($str, $MATCH->{'to'}, 4)) && (($MATCH->{'to'} = (4 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}});
    ((my  $res) = ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (('{' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
}))
})));
    ($MATCH = ($res ? $tmp : 0))
}))) && ((do {
    ((my  $m2) = $grammar->term_curly($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'term_curly'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::AST::Apply->new('code', 'eval', 'arguments', [Perlito5::AST::Do->new('block', Perlito5::AST::Lit::Block->new('stmts', Perlito5::Match::flat($MATCH->{'term_curly'})->[2]))], 'namespace', '')]);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Expression::map_or_sort {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((((do {
    (('map' eq substr($str, $MATCH->{'to'}, 3)) && (($MATCH->{'to'} = (3 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('sort' eq substr($str, $MATCH->{'to'}, 4)) && (($MATCH->{'to'} = (4 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('grep' eq substr($str, $MATCH->{'to'}, 4)) && (($MATCH->{'to'} = (4 + $MATCH->{'to'}))))))
})))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Expression::term_map_or_sort {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((((do {
    ((my  $m2) = $grammar->map_or_sort($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'map_or_sort'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}});
    ((my  $res) = ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (('{' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
}))
})));
    ($MATCH = ($res ? $tmp : 0))
}))) && ((do {
    ((my  $m2) = $grammar->term_curly($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'term_curly'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->list_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'list_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::AST::Apply->new('code', Perlito5::Match::flat($MATCH->{'map_or_sort'}), 'arguments', [Perlito5::AST::Lit::Block->new('stmts', $MATCH->{'term_curly'}->{'capture'}->[2]), @{expand_list($MATCH->{'list_parse'}->{'capture'})}], 'namespace', '')]);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
((my  $Argument_end_token) = {':', 1, ']', 1, ')', 1, '}', 1, ';', 1, ',', 1, '<', 1, '>', 1, '=', 1, '|', 1, '^', 1, '?', 1, 'or', 1, 'if', 1, '=>', 1, 'lt', 1, 'le', 1, 'gt', 1, 'ge', 1, '<=', 1, '>=', 1, '==', 1, '!=', 1, 'ne', 1, 'eq', 1, '..', 1, '~~', 1, '&&', 1, '||', 1, '+=', 1, '-=', 1, '*=', 1, '/=', 1, 'x=', 1, '|=', 1, '&=', 1, '.=', 1, '^=', 1, '%=', 1, '//', 1, 'for', 1, 'and', 1, 'xor', 1, '...', 1, '<=>', 1, 'cmp', 1, '<<=', 1, '>>=', 1, '||=', 1, '&&=', 1, '//=', 1, '**=', 1, 'when', 1, 'while', 1, 'unless', 1, 'foreach', 1});
((my  $Argument_end_token_chars) = [7, 6, 5, 4, 3, 2, 1]);
((my  $List_end_token) = {':', 1, ']', 1, ')', 1, '}', 1, ';', 1, 'or', 1, 'if', 1, 'for', 1, 'and', 1, 'xor', 1, 'else', 1, 'when', 1, 'while', 1, 'elsif', 1, 'unless', 1, 'foreach', 1});
((my  $List_end_token_chars) = [7, 6, 5, 4, 3, 2, 1]);
((my  $Expr_end_token) = {']', 1, ')', 1, '}', 1, ';', 1, 'if', 1, 'for', 1, 'else', 1, 'when', 1, 'while', 1, 'elsif', 1, 'unless', 1, 'foreach', 1});
((my  $Expr_end_token_chars) = [7, 6, 5, 4, 3, 2, 1]);
sub Perlito5::Expression::op_parse_spc {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $last_is_term) = $_[3]);
    ((my  $m) = Perlito5::Precedence->op_parse($str, $pos, $last_is_term));
    if (!($m)) {
        return ($m)
    };
    ((my  $spc) = Perlito5::Grammar::Space->ws($str, $m->{'to'}));
    if ($spc) {
        ($m->{'to'} = $spc->{'to'})
    };
    return ($m)
};
sub Perlito5::Expression::argument_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    (my  $expr);
    ((my  $last_pos) = $pos);
    ((my  $is_first_token) = 1);
    ((my  $lexer_stack) = []);
    ((my  $last_token_was_space) = 1);
    ((my  $get_token) = sub {
    ((my  $last_is_term) = $_[0]);
    (my  $v);
    if (scalar(@{$lexer_stack})) {
        ($v = pop(@{$lexer_stack}));
        if ((($is_first_token && (($v->[0] eq 'op'))) && !((Perlito5::Precedence::is_fixity_type('prefix', $v->[1]))))) {
            ($v->[0] = 'end')
        }
    }
    else {
        ((my  $m) = Perlito5::Expression->op_parse_spc($str, $last_pos, $last_is_term));
        if (!($m)) {
            return (['end', '*end*'])
        };
        ($v = $m->{'capture'});
        if ((($is_first_token && (($v->[0] eq 'op'))) && !((Perlito5::Precedence::is_fixity_type('prefix', $v->[1]))))) {
            ($v->[0] = 'end')
        };
        if (($v->[0] ne 'end')) {
            ($last_pos = $m->{'to'})
        }
    };
    ($last_token_was_space = (($v->[0] eq 'space')));
    ($is_first_token = 0);
    return ($v)
});
    ((my  $prec) = Perlito5::Precedence->new('get_token', $get_token, 'reduce', $reduce_to_ast, 'end_token', $Argument_end_token, 'end_token_chars', $Argument_end_token_chars));
    ((my  $res) = $prec->precedence_parse());
    if ((scalar(@{$res}) == 0)) {
        return ({'str', $str, 'from', $pos, 'to', $last_pos, 'capture', '*undef*'})
    };
    ((my  $result) = pop_term($res));
    return ({'str', $str, 'from', $pos, 'to', $last_pos, 'capture', $result})
};
sub Perlito5::Expression::list_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    (my  $expr);
    ((my  $last_pos) = $pos);
    ((my  $is_first_token) = 1);
    ((my  $lexer_stack) = []);
    ((my  $last_token_was_space) = 1);
    ((my  $get_token) = sub {
    ((my  $last_is_term) = $_[0]);
    (my  $v);
    if (scalar(@{$lexer_stack})) {
        ($v = pop(@{$lexer_stack}));
        if ((($is_first_token && (($v->[0] eq 'op'))) && !((Perlito5::Precedence::is_fixity_type('prefix', $v->[1]))))) {
            ($v->[0] = 'end')
        }
    }
    else {
        ((my  $m) = Perlito5::Expression->op_parse_spc($str, $last_pos, $last_is_term));
        if (!($m)) {
            return (['end', '*end*'])
        };
        ($v = $m->{'capture'});
        if ((($is_first_token && (($v->[0] eq 'op'))) && !((Perlito5::Precedence::is_fixity_type('prefix', $v->[1]))))) {
            ($v->[0] = 'end')
        };
        if (($v->[0] ne 'end')) {
            ($last_pos = $m->{'to'})
        }
    };
    ($last_token_was_space = (($v->[0] eq 'space')));
    ($is_first_token = 0);
    return ($v)
});
    ((my  $prec) = Perlito5::Precedence->new('get_token', $get_token, 'reduce', $reduce_to_ast, 'end_token', $List_end_token, 'end_token_chars', $List_end_token_chars));
    ((my  $res) = $prec->precedence_parse());
    if ((scalar(@{$res}) == 0)) {
        return ({'str', $str, 'from', $pos, 'to', $last_pos, 'capture', '*undef*'})
    };
    ((my  $result) = pop_term($res));
    return ({'str', $str, 'from', $pos, 'to', $last_pos, 'capture', $result})
};
sub Perlito5::Expression::circumfix_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $delimiter) = $_[3]);
    (my  $expr);
    ((my  $last_pos) = $pos);
    ((my  $get_token) = sub {
    ((my  $last_is_term) = $_[0]);
    ((my  $m) = Perlito5::Expression->op_parse_spc($str, $last_pos, $last_is_term));
    if (!($m)) {
        die('Expected closing delimiter: ', $delimiter, ' near ', $last_pos)
    };
    ((my  $v) = $m->{'capture'});
    if (($v->[0] ne 'end')) {
        ($last_pos = $m->{'to'})
    };
    return ($v)
});
    (my  %delim_token);
    ($delim_token{$delimiter} = 1);
    ((my  $prec) = Perlito5::Precedence->new('get_token', $get_token, 'reduce', $reduce_to_ast, 'end_token', \%delim_token, 'end_token_chars', [length($delimiter)]));
    ((my  $res) = $prec->precedence_parse());
    ($res = pop_term($res));
    if (!((defined($res)))) {
        ($res = '*undef*')
    };
    return ({'str', $str, 'from', $pos, 'to', $last_pos, 'capture', $res})
};
sub Perlito5::Expression::ternary5_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    return ($self->circumfix_parse($str, $pos, ':'))
};
sub Perlito5::Expression::curly_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    return ($self->circumfix_parse($str, $pos, '}'))
};
sub Perlito5::Expression::square_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    return ($self->circumfix_parse($str, $pos, ']'))
};
sub Perlito5::Expression::paren_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    return ($self->circumfix_parse($str, $pos, ')'))
};
sub Perlito5::Expression::exp_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    (my  $expr);
    ((my  $last_pos) = $pos);
    ((my  $lexer_stack) = []);
    ((my  $get_token) = sub {
    ((my  $last_is_term) = $_[0]);
    (my  $v);
    if (scalar(@{$lexer_stack})) {
        ($v = pop(@{$lexer_stack}))
    }
    else {
        ((my  $m) = Perlito5::Expression->op_parse_spc($str, $last_pos, $last_is_term));
        if (!($m)) {
            return (['end', '*end*'])
        };
        ($v = $m->{'capture'});
        if (($v->[0] ne 'end')) {
            ($last_pos = $m->{'to'})
        }
    };
    return ($v)
});
    ((my  $prec) = Perlito5::Precedence->new('get_token', $get_token, 'reduce', $reduce_to_ast, 'end_token', $Expr_end_token, 'end_token_chars', $Expr_end_token_chars));
    ((my  $res) = $prec->precedence_parse());
    if ((scalar(@{$res}) == 0)) {
        return (0)
    };
    ((my  $result) = pop_term($res));
    return ({'str', $str, 'from', $pos, 'to', $last_pos, 'capture', $result})
};
((my  @Statement_chars) = (9, 8, 7, 6, 5, 4, 3, 2, 1));
((my  %Statement) = ('if', sub {
    Perlito5::Grammar->if($_[0], $_[1])
}, 'unless', sub {
    Perlito5::Grammar->unless($_[0], $_[1])
}, 'when', sub {
    Perlito5::Grammar->when($_[0], $_[1])
}, 'for', sub {
    Perlito5::Grammar->for($_[0], $_[1])
}, 'while', sub {
    Perlito5::Grammar->while($_[0], $_[1])
}, 'when', sub {
    Perlito5::Grammar->when($_[0], $_[1])
}));
sub Perlito5::Expression::add_statement {
    ((my  $name) = shift());
    ((my  $param) = shift());
    ($Statement{$name} = $param)
};
sub Perlito5::Expression::exp_stmt {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    for my $len (@Statement_chars) {
        ((my  $term) = substr($str, $pos, $len));
        if (exists($Statement{$term})) {
            ((my  $m) = $Statement{$term}->($str, $pos));
            if ($m) {
                return ($m)
            }
        }
    };
    return (0)
};
((my  @Modifier_chars) = (7, 6, 5, 4, 3, 2));
((my  %Modifier) = ('if', 1, 'unless', 1, 'when', 1, 'for', 1, 'foreach', 1, 'while', 1, 'when', 1));
sub Perlito5::Expression::statement_modifier {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $expression) = $_[3]);
    for my $len (@Modifier_chars) {
        ((my  $term) = substr($str, $pos, $len));
        if (exists($Modifier{$term})) {
            ((my  $m) = $self->modifier($str, ($pos + $len), $term, $expression));
            if ($m) {
                return ($m)
            }
        }
    };
    return (0)
};
sub Perlito5::Expression::modifier {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $modifier) = $_[3]);
    ((my  $expression) = $_[4]);
    ((my  $modifier_exp) = $self->exp_parse($str, $pos));
    if (!($modifier_exp)) {
        die('Expected expression after ' . chr(39), Perlito5::Match::flat($modifier), chr(39))
    };
    if (($modifier eq 'if')) {
        return ({'str', $str, 'from', $pos, 'to', $modifier_exp->{'to'}, 'capture', Perlito5::AST::If->new('cond', Perlito5::Match::flat($modifier_exp), 'body', Perlito5::AST::Lit::Block->new('stmts', [$expression]), 'otherwise', Perlito5::AST::Lit::Block->new('stmts', []))})
    };
    if (($modifier eq 'unless')) {
        return ({'str', $str, 'from', $pos, 'to', $modifier_exp->{'to'}, 'capture', Perlito5::AST::If->new('cond', Perlito5::Match::flat($modifier_exp), 'body', Perlito5::AST::Lit::Block->new('stmts', []), 'otherwise', Perlito5::AST::Lit::Block->new('stmts', [$expression]))})
    };
    if (($modifier eq 'when')) {
        return ({'str', $str, 'from', $pos, 'to', $modifier_exp->{'to'}, 'capture', Perlito5::AST::When->new('cond', Perlito5::Match::flat($modifier_exp), 'body', Perlito5::AST::Lit::Block->new('stmts', [$expression]))})
    };
    if (($modifier eq 'while')) {
        return ({'str', $str, 'from', $pos, 'to', $modifier_exp->{'to'}, 'capture', Perlito5::AST::While->new('cond', Perlito5::Match::flat($modifier_exp), 'body', Perlito5::AST::Lit::Block->new('stmts', [$expression]), 'continue', Perlito5::AST::Lit::Block->new('stmts', []))})
    };
    if ((($modifier eq 'for') || ($modifier eq 'foreach'))) {
        return ({'str', $str, 'from', $pos, 'to', $modifier_exp->{'to'}, 'capture', Perlito5::AST::For->new('cond', Perlito5::Match::flat($modifier_exp), 'body', Perlito5::AST::Lit::Block->new('stmts', [$expression]), 'continue', Perlito5::AST::Lit::Block->new('stmts', []))})
    };
    die(('Unexpected statement modifier ' . chr(39) . $modifier . chr(39)))
};
sub Perlito5::Expression::delimited_statement {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((do {
    ((my  $m) = $MATCH);
    if (!(((do {
    ((my  $m2) = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})))) {
        ($MATCH = $m)
    };
    1
})) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    ((((';' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m) = $MATCH);
    if (!(((do {
    ((my  $m2) = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})))) {
        ($MATCH = $m)
    };
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((((do {
    ((my  $m2) = $grammar->statement_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'statement_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m) = $MATCH);
    if (!(((do {
    ((';' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})))) {
        ($MATCH = $m)
    };
    1
}))) && ((do {
    ((my  $m) = $MATCH);
    if (!(((do {
    ((my  $m2) = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})))) {
        ($MATCH = $m)
    };
    1
}))) && ((do {
    ($MATCH->{'capture'} = $MATCH->{'statement_parse'}->{'capture'});
    1
}))))
})))
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Expression::statement_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $res) = $self->exp_stmt($str, $pos));
    if ($res) {
        return ($res)
    };
    ($res = $self->exp_parse($str, $pos));
    if (!($res)) {
        return ()
    };
    if ((((substr($str, $res->{'to'}, 1) eq ':') && $res->{'capture'}->isa('Perlito5::AST::Apply')) && $res->{'capture'}->{'bareword'})) {
        ((my  $label) = $res->{'capture'}->{'code'});
        ((my  $ws) = Perlito5::Grammar::Space->opt_ws($str, ($res->{'to'} + 1)));
        ((my  $stmt) = $self->statement_parse($str, $ws->{'to'}));
        if ($stmt) {
            ($stmt->{'capture'}->{'label'} = $label);
            return ($stmt)
        };
        ($res->{'to'} = $ws->{'to'});
        ($res->{'capture'} = Perlito5::AST::Apply->new('arguments', [], 'code', 'undef', 'namespace', '', 'label', $label));
        return ($res)
    };
    ((my  $modifier) = $self->statement_modifier($str, $res->{'to'}, Perlito5::Match::flat($res)));
    ((my  $p) = ($modifier ? $modifier->{'to'} : $res->{'to'}));
    ((my  $terminator) = substr($str, $p, 1));
    if (((($terminator ne ';') && ($terminator ne '}')) && ($terminator ne ''))) {
        die('Number or Bareword found where operator expected')
    };
    if (!($modifier)) {
        return ($res)
    };
    return ($modifier)
};
1;

;

# use Perlito5::Expression
;
package main;
package Perlito5::Grammar;
sub Perlito5::Grammar::unless {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((((((((((((('u' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((('n' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((('l' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((('e' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((('s' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((('s' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Expression->term_paren($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Expression.term_paren'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Expression->term_curly($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Expression.term_curly'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((((((((((((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && ((('e' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((('l' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((('s' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((('e' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((('{' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->exp_stmts($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.exp_stmts'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $body) = Perlito5::Match::flat($MATCH->{'Perlito5::Expression.term_curly'})->[2]);
    if (!(defined($body))) {
        die('Missing code block in ' . chr(39) . 'if' . chr(39))
    };
    ($MATCH->{'capture'} = Perlito5::AST::If->new('cond', Perlito5::Match::flat($MATCH->{'Perlito5::Expression.term_paren'})->[2], 'body', Perlito5::AST::Lit::Block->new('stmts', (Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.exp_stmts'}) || [])), 'otherwise', Perlito5::AST::Lit::Block->new('stmts', $body)));
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((do {
    ((my  $body) = Perlito5::Match::flat($MATCH->{'Perlito5::Expression.term_curly'})->[2]);
    if (!(defined($body))) {
        die('Missing code block in ' . chr(39) . 'unless' . chr(39))
    };
    ($MATCH->{'capture'} = Perlito5::AST::If->new('cond', Perlito5::Match::flat($MATCH->{'Perlito5::Expression.term_paren'})->[2], 'body', Perlito5::AST::Lit::Block->new('stmts', []), 'otherwise', Perlito5::AST::Lit::Block->new('stmts', $body)));
    1
})))
})))
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::if {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((((((((('i' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((('f' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Expression->term_paren($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Expression.term_paren'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Expression->term_curly($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Expression.term_curly'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((((do {
    (((((((((((((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && ((('e' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((('l' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((('s' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((('e' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((('{' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->exp_stmts($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.exp_stmts'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $body) = Perlito5::Match::flat($MATCH->{'Perlito5::Expression.term_curly'})->[2]);
    if (!(defined($body))) {
        die('Missing code block in ' . chr(39) . 'if' . chr(39))
    };
    ($MATCH->{'capture'} = Perlito5::AST::If->new('cond', Perlito5::Match::flat($MATCH->{'Perlito5::Expression.term_paren'})->[2], 'body', Perlito5::AST::Lit::Block->new('stmts', $body), 'otherwise', Perlito5::AST::Lit::Block->new('stmts', (Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.exp_stmts'}) || []))));
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((((((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && ((('e' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((('l' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((('s' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $m2) = $grammar->if($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'if'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $body) = Perlito5::Match::flat($MATCH->{'Perlito5::Expression.term_curly'})->[2]);
    if (!(defined($body))) {
        die('Missing code block in ' . chr(39) . 'if' . chr(39))
    };
    ($MATCH->{'capture'} = Perlito5::AST::If->new('cond', Perlito5::Match::flat($MATCH->{'Perlito5::Expression.term_paren'})->[2], 'body', Perlito5::AST::Lit::Block->new('stmts', $body), 'otherwise', Perlito5::AST::Lit::Block->new('stmts', [Perlito5::Match::flat($MATCH->{'if'})])));
    1
}))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((do {
    ((my  $body) = Perlito5::Match::flat($MATCH->{'Perlito5::Expression.term_curly'})->[2]);
    if (!(defined($body))) {
        die('Missing code block in ' . chr(39) . 'if' . chr(39))
    };
    ($MATCH->{'capture'} = Perlito5::AST::If->new('cond', Perlito5::Match::flat($MATCH->{'Perlito5::Expression.term_paren'})->[2], 'body', Perlito5::AST::Lit::Block->new('stmts', $body), 'otherwise', Perlito5::AST::Lit::Block->new('stmts', [])));
    1
})))
})))
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::when {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((((((((((('w' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((('h' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((('e' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((('n' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Expression->term_paren($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Expression.term_paren'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Expression->term_curly($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Expression.term_curly'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $body) = Perlito5::Match::flat($MATCH->{'Perlito5::Expression.term_curly'})->[2]);
    if (!(defined($body))) {
        die('Missing code block in ' . chr(39) . 'when' . chr(39))
    };
    ($MATCH->{'capture'} = Perlito5::AST::When->new('cond', Perlito5::Match::flat($MATCH->{'Perlito5::Expression.term_paren'})->[2], 'body', Perlito5::AST::Lit::Block->new('stmts', $body)));
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::for {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((((((('f' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((('o' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((('r' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $m) = $MATCH);
    if (!(((do {
    (('each' eq substr($str, $MATCH->{'to'}, 4)) && (($MATCH->{'to'} = (4 + $MATCH->{'to'}))))
})))) {
        ($MATCH = $m)
    };
    1
}))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((((((((((((((((((do {
    ((my  $m2) = $grammar->ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && ((('m' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((('y' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->var_ident($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.var_ident'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((('(' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $m2) = Perlito5::Expression->paren_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Expression.paren_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((')' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((('{' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->exp_stmts($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.exp_stmts'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->opt_continue_block($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'opt_continue_block'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = Perlito5::AST::For->new('cond', Perlito5::Match::flat($MATCH->{'Perlito5::Expression.paren_parse'}), 'topic', undef(), 'body', Perlito5::AST::Lit::Block->new('stmts', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.exp_stmts'}), 'sig', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.var_ident'})), 'continue', $MATCH->{'opt_continue_block'}->{'capture'}));
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((((((((((((((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && ((('(' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $m2) = Perlito5::Expression->exp_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Expression.exp_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((((((';' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ($MATCH->{'c_style_for'} = 1);
    1
}))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((((do {
    ((my  $m2) = Perlito5::Grammar->exp($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.exp'} = $m2);
        1
    }
    else {
        0
    }
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ()
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})))
})))
}))) && (((';' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((((do {
    ((my  $m2) = Perlito5::Grammar->exp2($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.exp2'} = $m2);
        1
    }
    else {
        0
    }
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ()
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})))
})))
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (1)
})))
}))) && (((')' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((('{' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->exp_stmts2($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.exp_stmts2'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->opt_continue_block($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'opt_continue_block'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    (my  $header);
    if ($MATCH->{'c_style_for'}) {
        ($header = [$MATCH->{'Perlito5::Expression.exp_parse'}->{'capture'}, $MATCH->{'Perlito5::Grammar.exp'}->{'capture'}, $MATCH->{'Perlito5::Grammar.exp2'}->{'capture'}])
    }
    else {
        ($header = $MATCH->{'Perlito5::Expression.exp_parse'}->{'capture'})
    };
    ($MATCH->{'capture'} = Perlito5::AST::For->new('cond', $header, 'topic', undef(), 'body', Perlito5::AST::Lit::Block->new('stmts', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.exp_stmts2'}), 'sig', undef()), 'continue', $MATCH->{'opt_continue_block'}->{'capture'}));
    1
}))))
})))
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::while {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((((((((((((((((('w' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((('h' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((('i' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((('l' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((('e' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((('(' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $m2) = Perlito5::Expression->paren_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Expression.paren_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((')' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((('{' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->exp_stmts($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.exp_stmts'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->opt_continue_block($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'opt_continue_block'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = Perlito5::AST::While->new('cond', Perlito5::Match::flat($MATCH->{'Perlito5::Expression.paren_parse'}), 'body', Perlito5::AST::Lit::Block->new('stmts', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.exp_stmts'}), 'sig', undef()), 'continue', $MATCH->{'opt_continue_block'}->{'capture'}));
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::opt_continue_block {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((((((((('continue' eq substr($str, $MATCH->{'to'}, 8)) && (($MATCH->{'to'} = (8 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((('{' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->exp_stmts($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.exp_stmts'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = Perlito5::AST::Lit::Block->new('stmts', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.exp_stmts'}), 'sig', undef()));
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((do {
    ($MATCH->{'capture'} = Perlito5::AST::Lit::Block->new('stmts', [], 'sig', undef()));
    1
})))
})))
}))));
    ($tmp ? $MATCH : 0)
};

;

# use Perlito5::Grammar::Control
;
package main;
package Perlito5::Grammar::Regex;

# use Perlito5::Precedence
;
sub Perlito5::Grammar::Regex::token {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((((do {
    ((my  $m2) = Perlito5::Grammar->ident($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.ident'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((('{' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $m2) = Perlito5::Grammar::Regex->rule($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar::Regex.rule'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $source) = (Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.ident'}) . '{ ' . 'my $grammar = $_[0]; ' . 'my $str     = $_[1]; ' . 'my $pos     = $_[2]; ' . 'my $MATCH = { str => $str, from => $pos, to => $pos }; ' . 'my $tmp = ( ' . Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Regex.rule'})->emit_perl5() . '); ' . '$tmp ? $MATCH : 0; ' . '}'));
    ((my  $ast) = Perlito5::Grammar::Block->named_sub_def($source, 0));
    ($MATCH->{'capture'} = Perlito5::Match::flat($ast));
;
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Regex::term_token {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((('token' eq substr($str, $MATCH->{'to'}, 5)) && (($MATCH->{'to'} = (5 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->token($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'token'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'token'})]);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
Perlito5::Precedence::add_term('token', sub {
    Perlito5::Grammar::Regex->term_token($_[0], $_[1])
});
sub Perlito5::Grammar::Regex::any {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (('' ne substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Regex::literal {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((my  $last_match_null) = 0);
    ((my  $m) = $MATCH);
    ((my  $to) = $MATCH->{'to'});
    for ( ; (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    ((((chr(92) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((('' ne substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}});
    ((my  $res) = ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((chr(39) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
}))
})));
    ($MATCH = ($res ? 0 : $tmp))
})) && ((('' ne substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))))
})))
})) && (($last_match_null < 2))); do {{

}} ) {
        if (($to == $MATCH->{'to'})) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($m = $MATCH);
        ($to = $MATCH->{'to'})
    };
    ($MATCH = $m);
    ($MATCH->{'to'} = $to);
    1
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Regex::metasyntax_exp {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((my  $last_match_null) = 0);
    ((my  $m) = $MATCH);
    ((my  $to) = $MATCH->{'to'});
    ((my  $count) = 0);
    for ( ; (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((((((do {
    ((((chr(92) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((('' ne substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((((chr(39) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->literal($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && (((chr(39) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((('{' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->string_code($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((('<' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->metasyntax_exp($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((('>' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}});
    ((my  $res) = ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (('>' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
}))
})));
    ($MATCH = ($res ? 0 : $tmp))
})) && ((('' ne substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))))
})))
})) && (($last_match_null < 2))); do {{

}} ) {
        if (($to == $MATCH->{'to'})) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($m = $MATCH);
        ($to = $MATCH->{'to'});
        ($count = ($count + 1))
    };
    ($MATCH = $m);
    ($MATCH->{'to'} = $to);
    ($count > 0)
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Regex::string_code {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((my  $last_match_null) = 0);
    ((my  $m) = $MATCH);
    ((my  $to) = $MATCH->{'to'});
    ((my  $count) = 0);
    for ( ; (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((((do {
    ((((chr(92) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((('' ne substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((((chr(39) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->literal($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && (((chr(39) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((('{' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->string_code($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}});
    ((my  $res) = ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (('}' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
}))
})));
    ($MATCH = ($res ? 0 : $tmp))
})) && ((('' ne substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))))
})))
})) && (($last_match_null < 2))); do {{

}} ) {
        if (($to == $MATCH->{'to'})) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($m = $MATCH);
        ($to = $MATCH->{'to'});
        ($count = ($count + 1))
    };
    ($MATCH = $m);
    ($MATCH->{'to'} = $to);
    ($count > 0)
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Regex::parsed_code {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((do {
    ((my  $m2) = $grammar->string_code($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{'capture'} = Perlito5::Match::flat($MATCH));
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Regex::rule_terms {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((((((((do {
    ((((((('<before' eq substr($str, $MATCH->{'to'}, 7)) && (($MATCH->{'to'} = (7 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->rule($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'rule'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((('>' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = Rul::Before->new('rule_exp', Perlito5::Match::flat($MATCH->{'rule'})));
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((((('<!before' eq substr($str, $MATCH->{'to'}, 8)) && (($MATCH->{'to'} = (8 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->rule($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'rule'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((('>' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = Rul::NotBefore->new('rule_exp', Perlito5::Match::flat($MATCH->{'rule'})));
    1
}))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((((chr(39) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->literal($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'literal'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((chr(39) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = Rul::Constant->new('constant', Perlito5::Match::flat($MATCH->{'literal'})));
    1
}))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((('<' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((((('.' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->metasyntax_exp($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'metasyntax_exp'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((('>' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = Rul::Perlito5::AST::Subrule->new('metasyntax', Perlito5::Match::flat($MATCH->{'metasyntax_exp'}), 'captures', 0));
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((do {
    ((my  $m2) = $grammar->metasyntax_exp($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'metasyntax_exp'} = $m2);
        1
    }
    else {
        0
    }
})) && ((('>' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = Rul::Perlito5::AST::Subrule->new('metasyntax', Perlito5::Match::flat($MATCH->{'metasyntax_exp'}), 'captures', 1));
    1
}))))
})))
}))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((((('{' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->parsed_code($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'parsed_code'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((('}' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = Rul::Block->new('closure', Perlito5::Match::flat($MATCH->{'parsed_code'})));
    1
}))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((chr(92) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((((do {
    ((((((('c' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((('[' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $m2) = Perlito5::Grammar->digits($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.digits'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((']' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = Rul::Constant->new('constant', chr(Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.digits'}))));
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((('c' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = Perlito5::Grammar->digits($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.digits'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = Rul::Constant->new('constant', chr(Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.digits'}))));
    1
}))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((do {
    ((my  $m2) = $grammar->any($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'any'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{'capture'} = Rul::SpecialChar->new('char', Perlito5::Match::flat($MATCH->{'any'})));
    1
}))))
})))
}))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((('.' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ($MATCH->{'capture'} = Rul::Perlito5::AST::Dot->new());
    1
}))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((((('[' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->rule($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'rule'} = $m2);
        1
    }
    else {
        0
    }
}))) && (((']' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'rule'}));
    1
}))))
})))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Regex::rule_term {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((do {
    ((my  $m2) = $grammar->rule_terms($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'rule_terms'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'rule_terms'}));
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}});
    ((my  $res) = ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((((((((((((do {
    ((']' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('}' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((')' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('>' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((':' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('?' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('+' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('*' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('|' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('&' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('/' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
})))
})));
    ($MATCH = ($res ? 0 : $tmp))
})) && ((do {
    ((my  $m2) = $grammar->any($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'any'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = Rul::Constant->new('constant', Perlito5::Match::flat($MATCH->{'any'})));
    1
}))))
})))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Regex::quant_exp {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((((do {
    (('?' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('*' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('+' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
})))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Regex::greedy_exp {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((((do {
    (('?' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('+' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (1)
})))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Regex::quantifier {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((do {
    ((my  $m2) = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar::Space.opt_ws'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = $grammar->rule_term($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'rule_term'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar::Space.opt_ws'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((((do {
    ((my  $m2) = $grammar->quant_exp($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'quant_exp'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = $grammar->greedy_exp($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'greedy_exp'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar::Space.opt_ws'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = Rul::Quantifier->new('term', Perlito5::Match::flat($MATCH->{'rule_term'}), 'quant', Perlito5::Match::flat($MATCH->{'quant_exp'}), 'greedy', Perlito5::Match::flat($MATCH->{'greedy_exp'})));
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((do {
    ($MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'rule_term'}));
    1
})))
})))
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Regex::concat_list {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((do {
    ((my  $m2) = $grammar->quantifier($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'quantifier'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((do {
    ((my  $m2) = $grammar->concat_list($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'concat_list'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{'capture'} = [Perlito5::Match::flat($MATCH->{'quantifier'}), @{Perlito5::Match::flat($MATCH->{'concat_list'})}]);
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((do {
    ($MATCH->{'capture'} = [Perlito5::Match::flat($MATCH->{'quantifier'})]);
    1
})))
})))
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((do {
    ($MATCH->{'capture'} = []);
    1
})))
})))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Regex::concat_exp {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((do {
    ((my  $m2) = $grammar->concat_list($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'concat_list'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{'capture'} = Rul::Concat->new('concat', Perlito5::Match::flat($MATCH->{'concat_list'})));
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Regex::or_list_exp {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((do {
    ((my  $m2) = $grammar->concat_exp($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'concat_exp'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    ((((('|' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->or_list_exp($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'or_list_exp'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = [Perlito5::Match::flat($MATCH->{'concat_exp'}), @{Perlito5::Match::flat($MATCH->{'or_list_exp'})}]);
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((do {
    ($MATCH->{'capture'} = [Perlito5::Match::flat($MATCH->{'concat_exp'})]);
    1
})))
})))
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((do {
    ($MATCH->{'capture'} = []);
    1
})))
})))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Regex::rule {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((do {
    ((my  $m) = $MATCH);
    if (!(((do {
    ((my  $m2) = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})))) {
        ($MATCH = $m)
    };
    1
})) && ((('|' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (1)
})))
})) && ((do {
    ((my  $m2) = $grammar->or_list_exp($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'or_list_exp'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = Rul::Or->new('or_list', Perlito5::Match::flat($MATCH->{'or_list_exp'})));
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};

;

# use Perlito5::Grammar::Regex
;
package main;
undef();
package Perlito5::Grammar::String;

# use Perlito5::Precedence
;
Perlito5::Precedence::add_term(chr(39), sub {
    Perlito5::Grammar::String->term_q_quote($_[0], $_[1])
});
Perlito5::Precedence::add_term('"', sub {
    Perlito5::Grammar::String->term_qq_quote($_[0], $_[1])
});
Perlito5::Precedence::add_term('/', sub {
    Perlito5::Grammar::String->term_m_quote($_[0], $_[1])
});
Perlito5::Precedence::add_term('<', sub {
    Perlito5::Grammar::String->term_glob($_[0], $_[1])
});
Perlito5::Precedence::add_term('<<', sub {
    Perlito5::Grammar::String->here_doc_wanted($_[0], $_[1])
});
Perlito5::Precedence::add_term('`', sub {
    Perlito5::Grammar::String->term_qx($_[0], $_[1])
});
Perlito5::Precedence::add_term('m', sub {
    Perlito5::Grammar::String->term_m_quote($_[0], $_[1])
});
Perlito5::Precedence::add_term('q', sub {
    Perlito5::Grammar::String->term_q_quote($_[0], $_[1])
});
Perlito5::Precedence::add_term('qq', sub {
    Perlito5::Grammar::String->term_qq_quote($_[0], $_[1])
});
Perlito5::Precedence::add_term('qw', sub {
    Perlito5::Grammar::String->term_qw_quote($_[0], $_[1])
});
Perlito5::Precedence::add_term('qx', sub {
    Perlito5::Grammar::String->term_qx($_[0], $_[1])
});
Perlito5::Precedence::add_term('qr', sub {
    Perlito5::Grammar::String->term_qr_quote($_[0], $_[1])
});
Perlito5::Precedence::add_term('s', sub {
    Perlito5::Grammar::String->term_s_quote($_[0], $_[1])
});
Perlito5::Precedence::add_term('tr', sub {
    Perlito5::Grammar::String->term_tr_quote($_[0], $_[1])
});
Perlito5::Precedence::add_term('y', sub {
    Perlito5::Grammar::String->term_tr_quote($_[0], $_[1])
});
sub Perlito5::Grammar::String::term_q_quote {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((('q' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (('#' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((do {
    ((my  $m2) = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}});
    ((my  $res) = ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((my  $m2) = Perlito5::Grammar->word($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))
})));
    ($MATCH = ($res ? 0 : $tmp))
}))) && ((('' ne substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))))
})))
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((chr(39) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
})))
})) && ((do {
    ((my  $m2) = $grammar->q_quote_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'q_quote_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'q_quote_parse'})]);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::String::term_qq_quote {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((('qq' eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'}))))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (('#' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((do {
    ((my  $m2) = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}});
    ((my  $res) = ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((my  $m2) = Perlito5::Grammar->word($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))
})));
    ($MATCH = ($res ? 0 : $tmp))
}))) && ((('' ne substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))))
})))
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('"' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
})))
})) && ((do {
    ((my  $m2) = $grammar->qq_quote_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'qq_quote_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'qq_quote_parse'})]);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::String::term_qw_quote {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((('qw' eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'}))))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (('#' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((do {
    ((my  $m2) = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}});
    ((my  $res) = ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((my  $m2) = Perlito5::Grammar->word($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))
})));
    ($MATCH = ($res ? 0 : $tmp))
}))) && ((('' ne substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))))
})))
}))) && ((do {
    ((my  $m2) = $grammar->qw_quote_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'qw_quote_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'qw_quote_parse'})]);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::String::term_m_quote {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((('m' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (('#' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((do {
    ((my  $m2) = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}});
    ((my  $res) = ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((my  $m2) = Perlito5::Grammar->word($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))
})));
    ($MATCH = ($res ? 0 : $tmp))
}))) && ((('' ne substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))))
})))
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('/' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
})))
})) && ((do {
    ((my  $m2) = $grammar->m_quote_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'m_quote_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'m_quote_parse'})]);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::String::term_s_quote {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((('s' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (('#' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((do {
    ((my  $m2) = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}});
    ((my  $res) = ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((my  $m2) = Perlito5::Grammar->word($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))
})));
    ($MATCH = ($res ? 0 : $tmp))
}))) && ((('' ne substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))))
})))
}))) && ((do {
    ((my  $m2) = $grammar->s_quote_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'s_quote_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'s_quote_parse'})]);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::String::term_qx {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((('qx' eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'}))))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (('#' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((do {
    ((my  $m2) = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}});
    ((my  $res) = ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((my  $m2) = Perlito5::Grammar->word($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))
})));
    ($MATCH = ($res ? 0 : $tmp))
}))) && ((('' ne substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))))
})))
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('`' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
})))
})) && ((do {
    ((my  $m2) = $grammar->qx_quote_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'qx_quote_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'qx_quote_parse'})]);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::String::term_glob {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((((('<' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->glob_quote_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'glob_quote_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'glob_quote_parse'})]);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::String::term_tr_quote {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (('tr' eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('y' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
})))
})) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (('#' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((do {
    ((my  $m2) = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}});
    ((my  $res) = ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((my  $m2) = Perlito5::Grammar->word($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))
})));
    ($MATCH = ($res ? 0 : $tmp))
}))) && ((('' ne substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))))
})))
}))) && ((do {
    ((my  $m2) = $grammar->tr_quote_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'tr_quote_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'tr_quote_parse'})]);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::String::term_qr_quote {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((('qr' eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'}))))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (('#' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((do {
    ((my  $m2) = Perlito5::Grammar::Space->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}});
    ((my  $res) = ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((my  $m2) = Perlito5::Grammar->word($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))
})));
    ($MATCH = ($res ? 0 : $tmp))
}))) && ((('' ne substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))))
})))
}))) && ((do {
    ((my  $m2) = $grammar->qr_quote_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'qr_quote_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'qr_quote_parse'})]);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
((my  %pair) = ('{', '}', '(', ')', '[', ']', '<', '>'));
((my  %escape_sequence) = ('a', '7', 'b', '8', 'e', '27', 'f', '12', 'n', '10', 'r', '13', 't', '9'));
((my  %hex) = map(+(($_, 1)), ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F')));
((my  %octal) = map(+(($_, 1)), ('0', '1', '2', '3', '4', '5', '6', '7')));
sub Perlito5::Grammar::String::q_quote_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $delimiter) = substr($str, ($pos - 1), 1));
    ((my  $open_delimiter) = $delimiter);
    if (exists($pair{$delimiter})) {
        ($delimiter = $pair{$delimiter})
    };
    return ($self->string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 0))
};
sub Perlito5::Grammar::String::qq_quote_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $delimiter) = substr($str, ($pos - 1), 1));
    ((my  $open_delimiter) = $delimiter);
    if (exists($pair{$delimiter})) {
        ($delimiter = $pair{$delimiter})
    };
    return ($self->string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 1))
};
sub Perlito5::Grammar::String::qw_quote_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $delimiter) = substr($str, ($pos - 1), 1));
    ((my  $open_delimiter) = $delimiter);
    if (exists($pair{$delimiter})) {
        ($delimiter = $pair{$delimiter})
    };
    ((my  $m) = $self->string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 0));
    if ($m) {
        ($m->{'capture'} = Perlito5::AST::Apply->new('code', 'list:<,>', 'arguments', [map(Perlito5::AST::Val::Buf->new('buf', $_), split(' ', Perlito5::Match::flat($m)->{'buf'}))], 'namespace', ''))
    };
    return ($m)
};
sub Perlito5::Grammar::String::m_quote_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $delimiter) = substr($str, ($pos - 1), 1));
    ((my  $open_delimiter) = $delimiter);
    ((my  $closing_delimiter) = $delimiter);
    if (exists($pair{$delimiter})) {
        ($closing_delimiter = $pair{$delimiter})
    };
    ((my  $part1) = $self->string_interpolation_parse($str, $pos, $open_delimiter, $closing_delimiter, 2));
    if ($part1) {

    }
    else {
        return ($part1)
    };
    ((my  $str_regex) = $part1->{'capture'});
    ((my  $p) = $part1->{'to'});
    ((my  $modifiers) = '');
    ((my  $m) = Perlito5::Grammar->ident($str, $p));
    if ($m) {
        ($modifiers = Perlito5::Match::flat($m));
        ($part1->{'to'} = $m->{'to'})
    };
    ($part1->{'capture'} = Perlito5::AST::Apply->new('code', 'p5:m', 'arguments', [$str_regex, $modifiers], 'namespace', ''));
    return ($part1)
};
sub Perlito5::Grammar::String::s_quote_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $delimiter) = substr($str, ($pos - 1), 1));
    ((my  $open_delimiter) = $delimiter);
    ((my  $closing_delimiter) = $delimiter);
    if (exists($pair{$delimiter})) {
        ($closing_delimiter = $pair{$delimiter})
    };
    ((my  $part1) = $self->string_interpolation_parse($str, $pos, $open_delimiter, $closing_delimiter, 1));
    if ($part1) {

    }
    else {
        return ($part1)
    };
    ((my  $str_regex) = Perlito5::AST::Val::Buf->new('buf', substr($str, $pos, (($part1->{'to'} - $pos) - 1))));
    (my  $part2);
    (my  $m);
    ((my  $p) = $part1->{'to'});
    if (exists($pair{$delimiter})) {
        ($m = Perlito5::Grammar::Space->opt_ws($str, $p));
        ($p = $m->{'to'});
        ($delimiter = substr($str, $p, 1));
        ((my  $open_delimiter) = $delimiter);
        ($p)++;
        ($closing_delimiter = $delimiter);
        if (exists($pair{$delimiter})) {
            ($closing_delimiter = $pair{$delimiter})
        };
        ($part2 = $self->string_interpolation_parse($str, $p, $open_delimiter, $closing_delimiter, 1));
        if ($part2) {

        }
        else {
            return ($part2)
        }
    }
    else {
        ($part2 = $self->string_interpolation_parse($str, $p, $open_delimiter, $closing_delimiter, 1));
        if ($part2) {

        }
        else {
            return ($part2)
        }
    };
    ($p = $part2->{'to'});
    ((my  $modifiers) = '');
    ($m = Perlito5::Grammar->ident($str, $p));
    if ($m) {
        ($modifiers = Perlito5::Match::flat($m));
        ($part2->{'to'} = $m->{'to'})
    };
    ($part2->{'capture'} = Perlito5::AST::Apply->new('code', 'p5:s', 'arguments', [$str_regex, Perlito5::Match::flat($part2), $modifiers], 'namespace', ''));
    return ($part2)
};
sub Perlito5::Grammar::String::qr_quote_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $delimiter) = substr($str, ($pos - 1), 1));
    ((my  $open_delimiter) = $delimiter);
    ((my  $closing_delimiter) = $delimiter);
    if (exists($pair{$delimiter})) {
        ($closing_delimiter = $pair{$delimiter})
    };
    ((my  $part1) = $self->string_interpolation_parse($str, $pos, $open_delimiter, $closing_delimiter, 2));
    if ($part1) {

    }
    else {
        return ($part1)
    };
    ((my  $str_regex) = $part1->{'capture'});
    ((my  $p) = $part1->{'to'});
    ((my  $modifiers) = '');
    ((my  $m) = Perlito5::Grammar->ident($str, $p));
    if ($m) {
        ($modifiers = Perlito5::Match::flat($m));
        ($part1->{'to'} = $m->{'to'})
    };
    ($part1->{'capture'} = Perlito5::AST::Apply->new('code', 'p5:qr', 'arguments', [$str_regex, $modifiers], 'namespace', ''));
    return ($part1)
};
sub Perlito5::Grammar::String::qx_quote_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $delimiter) = substr($str, ($pos - 1), 1));
    ((my  $open_delimiter) = $delimiter);
    if (exists($pair{$delimiter})) {
        ($delimiter = $pair{$delimiter})
    };
    ((my  $m) = $self->string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 0));
    if ($m) {
        ($m->{'capture'} = Perlito5::AST::Apply->new('code', 'qx', 'arguments', [Perlito5::Match::flat($m)], 'namespace', ''))
    };
    return ($m)
};
sub Perlito5::Grammar::String::glob_quote_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $delimiter) = substr($str, ($pos - 1), 1));
    ((my  $open_delimiter) = $delimiter);
    if (exists($pair{$delimiter})) {
        ($delimiter = $pair{$delimiter})
    };
    ((my  $m) = $self->string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 0));
    if ($m) {
        ($m->{'capture'} = Perlito5::AST::Apply->new('code', 'glob', 'arguments', [Perlito5::Match::flat($m)], 'namespace', ''))
    };
    return ($m)
};
sub Perlito5::Grammar::String::tr_quote_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $delimiter) = substr($str, ($pos - 1), 1));
    ((my  $open_delimiter) = $delimiter);
    ((my  $closing_delimiter) = $delimiter);
    if (exists($pair{$delimiter})) {
        ($closing_delimiter = $pair{$delimiter})
    };
    ((my  $part1) = $self->string_interpolation_parse($str, $pos, $open_delimiter, $closing_delimiter, 1));
    if ($part1) {

    }
    else {
        return ($part1)
    };
    ((my  $str_regex) = Perlito5::AST::Val::Buf->new('buf', substr($str, $pos, (($part1->{'to'} - $pos) - 1))));
    (my  $part2);
    (my  $m);
    ((my  $p) = $part1->{'to'});
    if (exists($pair{$delimiter})) {
        ($m = Perlito5::Grammar::Space->opt_ws($str, $p));
        ($p = $m->{'to'});
        ($delimiter = substr($str, $p, 1));
        ((my  $open_delimiter) = $delimiter);
        ($p)++;
        ($closing_delimiter = $delimiter);
        if (exists($pair{$delimiter})) {
            ($closing_delimiter = $pair{$delimiter})
        };
        ($part2 = $self->string_interpolation_parse($str, $p, $open_delimiter, $closing_delimiter, 1));
        if ($part2) {

        }
        else {
            return ($part2)
        }
    }
    else {
        ($part2 = $self->string_interpolation_parse($str, $p, $open_delimiter, $closing_delimiter, 1));
        if ($part2) {

        }
        else {
            return ($part2)
        }
    };
    ($p = $part2->{'to'});
    ((my  $modifiers) = '');
    ($m = Perlito5::Grammar->ident($str, $p));
    if ($m) {
        ($modifiers = Perlito5::Match::flat($m));
        ($part2->{'to'} = $m->{'to'})
    };
    ($part2->{'capture'} = Perlito5::AST::Apply->new('code', 'p5:tr', 'arguments', [$str_regex, Perlito5::Match::flat($part2), $modifiers], 'namespace', ''));
    return ($part2)
};
sub Perlito5::Grammar::String::string_interpolation_parse {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $open_delimiter) = $_[3]);
    ((my  $delimiter) = $_[4]);
    ((my  $interpolate) = $_[5]);
    ((my  $p) = $pos);
    ((my  $balanced) = ($open_delimiter && exists($pair{$open_delimiter})));
    (my  @args);
    ((my  $buf) = '');
    for ( ; (($p < length($str)) && (substr($str, $p, length($delimiter)) ne $delimiter)); do {{

}} ) {
        ((my  $c) = substr($str, $p, 1));
        ((my  $c2) = substr($str, ($p + 1), 1));
        (my  $m);
        ((my  $more) = '');
        if ((($balanced && ($c eq chr(92))) && ((($c2 eq $open_delimiter) || ($c2 eq $delimiter))))) {
            ($p)++;
            ($c = $c2)
        }
        else {
            if (($balanced && ($c eq $open_delimiter))) {
                ($buf = ($buf . $c));
                ($p)++;
                ($m = $self->string_interpolation_parse($str, $p, $open_delimiter, $delimiter, $interpolate));
                ($more = $delimiter)
            }
            else {
                if (($interpolate && ((($c eq '$') || ($c eq '@'))))) {
                    ($m = Perlito5::Grammar::String->double_quoted_var($str, $p, $delimiter, $interpolate))
                }
                else {
                    if (($c eq chr(92))) {
                        if (($interpolate == 2)) {
                            ($m = {'str', $str, 'from', $p, 'to', ($p + 2), 'capture', Perlito5::AST::Val::Buf->new('buf', substr($str, $p, 2))})
                        }
                        else {
                            if (($interpolate == 1)) {
                                ($m = Perlito5::Grammar::String->double_quoted_unescape($str, $p))
                            }
                            else {
                                ($m = (($c2 eq chr(92)) ? {'str', $str, 'from', $p, 'to', ($p + 2), 'capture', Perlito5::AST::Val::Buf->new('buf', chr(92))} : (($c2 eq chr(39)) ? {'str', $str, 'from', $p, 'to', ($p + 2), 'capture', Perlito5::AST::Val::Buf->new('buf', chr(39))} : 0)))
                            }
                        }
                    }
                }
            }
        };
        if ($m) {
            ((my  $obj) = Perlito5::Match::flat($m));
            if ((ref($obj) eq 'Perlito5::AST::Val::Buf')) {
                ($buf = ($buf . $obj->{'buf'}));
                ($obj = undef())
            };
            if ($obj) {
                if (length($buf)) {
                    push(@args, Perlito5::AST::Val::Buf->new('buf', $buf) );
                    ($buf = '')
                };
                push(@args, $obj )
            };
            ($p = $m->{'to'});
            ($buf = ($buf . $more))
        }
        else {
            ($p)++;
            if ((($c eq chr(10)) || ($c eq chr(13)))) {
                ((my  $m) = $self->here_doc($str, $p));
                if (($p != $m->{'to'})) {
                    ($p = $m->{'to'})
                }
                else {
                    ($buf = ($buf . $c))
                }
            }
            else {
                ($buf = ($buf . $c))
            }
        }
    };
    if (length($buf)) {
        push(@args, Perlito5::AST::Val::Buf->new('buf', $buf) )
    };
    if ((substr($str, $p, length($delimiter)) ne $delimiter)) {
        die(('Can' . chr(39) . 't find string terminator ' . chr(39) . $delimiter . chr(39) . ' anywhere before EOF'))
    };
    ($p = ($p + length($delimiter)));
    (my  $ast);
    if (!(@args)) {
        ($ast = Perlito5::AST::Val::Buf->new('buf', ''))
    }
    else {
        if ((@args == 1)) {
            ($ast = $args[0])
        }
        else {
            ($ast = Perlito5::AST::Apply->new('namespace', '', 'code', 'list:<.>', 'arguments', \@args))
        }
    };
    return ({'str', $str, 'from', $pos, 'to', $p, 'capture', $ast})
};
(my  @Here_doc);
sub Perlito5::Grammar::String::here_doc_wanted {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    (my  $delimiter);
    ((my  $type) = 'double_quote');
    ((my  $p) = $pos);
    if ((substr($str, $p, 2) eq '<<')) {
        ($p = ($p + 2));
        ((my  $quote) = substr($str, $p, 1));
        if ((($quote eq chr(39)) || ($quote eq '"'))) {
            ($p = ($p + 1));
            ((my  $m) = $self->string_interpolation_parse($str, $p, $quote, $quote, 0));
            if ($m) {
                ($p = $m->{'to'});
                ($delimiter = Perlito5::Match::flat($m)->{'buf'});
                ($type = (($quote eq chr(39)) ? 'single_quote' : 'double_quote'))
            }
        }
        else {
            if (($quote eq chr(92))) {
                ($p = ($p + 1))
            };
            ((my  $m) = Perlito5::Grammar->ident($str, $p));
            if ($m) {
                ($p = $m->{'to'});
                ($delimiter = Perlito5::Match::flat($m));
                ($type = (($quote eq chr(92)) ? 'single_quote' : 'double_quote'))
            }
            else {
                die('Use of bare << to mean <<"" is deprecated')
            }
        }
    };
    if (!(defined($delimiter))) {
        return (0)
    };
    ((my  $placeholder) = Perlito5::AST::Apply->new('code', 'list:<.>', 'namespace', '', 'arguments', [Perlito5::AST::Apply->new('code', 'list:<.>', 'namespace', '', 'arguments', [])]));
    push(@Here_doc, [$type, $placeholder->{'arguments'}->[0]->{'arguments'}, $delimiter] );
    return ({'str', $str, 'from', $pos, 'to', $p, 'capture', ['term', $placeholder]})
};
sub Perlito5::Grammar::String::newline {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    ((((chr(10) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m) = $MATCH);
    if (!(((do {
    ((chr(13) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})))) {
        ($MATCH = $m)
    };
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((chr(13) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m) = $MATCH);
    if (!(((do {
    ((chr(10) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})))) {
        ($MATCH = $m)
    };
    1
}))))
})))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::String::here_doc {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    if (!(@Here_doc)) {
        return ({'str', $str, 'from', $pos, 'to', $pos})
    };
    ((my  $p) = $pos);
    ((my  $here) = shift(@Here_doc));
    ((my  $type) = $here->[0]);
    ((my  $result) = $here->[1]);
    ((my  $delimiter) = $here->[2]);
    if (($type eq 'single_quote')) {
        for ( ; ($p < length($str)); do {{

}} ) {
            if ((substr($str, $p, length($delimiter)) eq $delimiter)) {
                push(@{$result}, Perlito5::AST::Val::Buf->new('buf', substr($str, $pos, ($p - $pos))) );
                ($p = ($p + length($delimiter)));
                ((my  $m) = $self->newline($str, $p));
                if ((($p >= length($str)) || $m)) {
                    if ($m) {
                        ($p = $m->{'to'})
                    };
                    return ({'str', $str, 'from', $pos, 'to', ($p - 1)})
                }
            };
            for ( ; (($p < length($str)) && (((substr($str, $p, 1) ne chr(10)) && (substr($str, $p, 1) ne chr(13))))); do {{

}} ) {
                ($p)++
            };
            for ( ; (($p < length($str)) && (((substr($str, $p, 1) eq chr(10)) || (substr($str, $p, 1) eq chr(13))))); do {{

}} ) {
                ($p)++
            }
        }
    }
    else {
        (my  $m);
        if ((substr($str, $p, length($delimiter)) eq $delimiter)) {
            ($p = ($p + length($delimiter)));
            ($m = $self->newline($str, $p));
            if ((($p >= length($str)) || $m)) {
                push(@{$result}, Perlito5::AST::Val::Buf->new('buf', '') );
                if ($m) {
                    ($p = $m->{'to'})
                };
                return ({'str', $str, 'from', $pos, 'to', $p})
            }
        };
        ($m = $self->string_interpolation_parse($str, $pos, '', (chr(10) . $delimiter . chr(10)), 1));
        if ($m) {
            push(@{$result}, Perlito5::Match::flat($m) );
            push(@{$result}, Perlito5::AST::Val::Buf->new('buf', chr(10)) );
            ($m->{'to'} = ($m->{'to'} - 1));
            return ($m)
        }
    };
    die(('Can' . chr(39) . 't find string terminator "' . $delimiter . '" anywhere before EOF'))
};
sub Perlito5::Grammar::String::double_quoted_unescape {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $c2) = substr($str, ($pos + 1), 1));
    (my  $m);
    if (exists($escape_sequence{$c2})) {
        ($m = {'str', $str, 'from', $pos, 'to', ($pos + 2), 'capture', Perlito5::AST::Val::Buf->new('buf', chr($escape_sequence{$c2}))})
    }
    else {
        if (($c2 eq 'c')) {
            ((my  $c3) = ((ord(substr($str, ($pos + 2), 1)) - ord('A')) + 1));
            if (($c3 < 0)) {
                ($c3 = (128 + $c3))
            };
            ($m = {'str', $str, 'from', $pos, 'to', ($pos + 3), 'capture', Perlito5::AST::Val::Buf->new('buf', chr($c3))})
        }
        else {
            if (($c2 eq 'x')) {
                if ((substr($str, ($pos + 2), 1) eq '{')) {
                    ((my  $p) = ($pos + 3));
                    for ( ; (($p < length($str)) && (substr($str, $p, 1) ne '}')); do {{

}} ) {
                        ($p)++
                    };
                    ((my  $tmp) = oct(('0x' . substr($str, ($pos + 3), ($p - $pos)))));
                    ($m = {'str', $str, 'from', $pos, 'to', ($p + 1), 'capture', Perlito5::AST::Apply->new('arguments', [Perlito5::AST::Val::Int->new('int', $tmp)], 'code', 'chr')})
                }
                else {
                    ((my  $p) = ($pos + 2));
                    if ($hex{uc(substr($str, $p, 1))}) {
                        ($p)++
                    };
                    if ($hex{uc(substr($str, $p, 1))}) {
                        ($p)++
                    };
                    ((my  $tmp) = oct(('0x' . substr($str, ($pos + 2), ($p - $pos)))));
                    ($m = {'str', $str, 'from', $pos, 'to', $p, 'capture', Perlito5::AST::Apply->new('arguments', [Perlito5::AST::Val::Int->new('int', $tmp)], 'code', 'chr')})
                }
            }
            else {
                if (exists($octal{$c2})) {
                    ((my  $p) = ($pos + 2));
                    if ($octal{substr($str, $p, 1)}) {
                        ($p)++
                    };
                    if ($octal{substr($str, $p, 1)}) {
                        ($p)++
                    };
                    ((my  $tmp) = oct(substr($str, ($pos + 1), ($p - $pos))));
                    ($m = {'str', $str, 'from', $pos, 'to', $p, 'capture', Perlito5::AST::Apply->new('arguments', [Perlito5::AST::Val::Int->new('int', $tmp)], 'code', 'chr')})
                }
                else {
                    ($m = {'str', $str, 'from', $pos, 'to', ($pos + 2), 'capture', Perlito5::AST::Val::Buf->new('buf', $c2)})
                }
            }
        }
    };
    return ($m)
};
sub Perlito5::Grammar::String::double_quoted_var_with_subscript {
    ((my  $self) = $_[0]);
    ((my  $m_var) = $_[1]);
    ((my  $interpolate) = $_[2]);
    ((my  $str) = $m_var->{'str'});
    ((my  $pos) = $m_var->{'to'});
    ((my  $p) = $pos);
    (my  $m_index);
    if ((substr($str, $p, 1) eq '[')) {
        if (($interpolate == 2)) {
            ((my  $m) = ((Perlito5::Expression->term_digit($str, ($p + 1)) || (((substr($str, ($p + 1), 1) eq '-') && Perlito5::Expression->term_digit($str, ($p + 2))))) || Perlito5::Grammar::Sigil->term_sigil($str, ($p + 1))));
            if ($m) {

            }
            else {
                return ($m_var)
            };
            if ((substr($str, $m->{'to'}, 1) eq ']')) {

            }
            else {
                return ($m_var)
            }
        };
        ($p)++;
        ($m_index = Perlito5::Expression->list_parse($str, $p));
        if ($m_index) {
            ((my  $exp) = $m_index->{'capture'});
            ($p = $m_index->{'to'});
            if ((($exp ne '*undef*') && (substr($str, $p, 1) eq ']'))) {
                ($p)++;
                ($m_index->{'capture'} = Perlito5::AST::Index->new('obj', $m_var->{'capture'}, 'index_exp', $exp));
                ($m_index->{'to'} = $p);
                return ($self->double_quoted_var_with_subscript($m_index, $interpolate))
            }
        }
    };
    ($m_index = Perlito5::Expression->term_curly($str, $pos));
    if ($m_index) {
        ($m_index->{'capture'} = Perlito5::AST::Lookup->new('obj', $m_var->{'capture'}, 'index_exp', Perlito5::Match::flat($m_index)->[2]->[0]));
        return ($self->double_quoted_var_with_subscript($m_index, $interpolate))
    };
    return ($m_var)
};
sub Perlito5::Grammar::String::double_quoted_var {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $delimiter) = $_[3]);
    ((my  $interpolate) = $_[4]);
    ((my  $c) = substr($str, $pos, 1));
    if ((($c eq '$') && (substr($str, ($pos + 1), 1) eq '{'))) {
        ((my  $m) = Perlito5::Grammar::Sigil->term_sigil($str, $pos));
        if ($m) {

        }
        else {
            return ($m)
        };
        ((my  $var) = Perlito5::Match::flat($m)->[1]);
        ($m->{'capture'} = $var);
        return ($m)
    }
    else {
        if ((($c eq '$') && (substr($str, ($pos + 1), length($delimiter)) ne $delimiter))) {
            ((my  $m) = Perlito5::Grammar::Sigil->term_sigil($str, $pos));
            if ($m) {

            }
            else {
                return ($m)
            };
            ($m->{'capture'} = $m->{'capture'}->[1]);
            return ($self->double_quoted_var_with_subscript($m, $interpolate))
        }
        else {
            if ((($c eq '@') && (substr($str, ($pos + 1), length($delimiter)) ne $delimiter))) {
                ((my  $m) = Perlito5::Grammar::Sigil->term_sigil($str, $pos));
                if ($m) {

                }
                else {
                    return ($m)
                };
                ($m->{'capture'} = $m->{'capture'}->[1]);
                ($m = $self->double_quoted_var_with_subscript($m, $interpolate));
                ($m->{'capture'} = Perlito5::AST::Apply->new('code', 'join', 'arguments', [Perlito5::AST::Val::Buf->new('buf', ' '), $m->{'capture'}], 'namespace', ''));
                return ($m)
            }
        }
    };
    return (0)
};
1;

;
package main;
undef();
package Perlito5::Grammar::Sigil;

# use Perlito5::Precedence
;
Perlito5::Precedence::add_term('$', sub {
    Perlito5::Grammar::Sigil->term_sigil($_[0], $_[1])
});
Perlito5::Precedence::add_term('@', sub {
    Perlito5::Grammar::Sigil->term_sigil($_[0], $_[1])
});
Perlito5::Precedence::add_term('%', sub {
    Perlito5::Grammar::Sigil->term_sigil($_[0], $_[1])
});
Perlito5::Precedence::add_term('&', sub {
    Perlito5::Grammar::Sigil->term_sigil($_[0], $_[1])
});
Perlito5::Precedence::add_term('*', sub {
    Perlito5::Grammar::Sigil->term_sigil($_[0], $_[1])
});
((my  %special_var) = ('$_', '', '$&', '', '$`', '', '$' . chr(39), '', '$+', '', '@+', '', '%+', '', '$.', '', '$/', '', '$|', '', '$,', '', '$' . chr(92), '', '$"', '', '$;', '', '$%', '', '$=', '', '$-', '', '@-', '', '%-', '', '$~', '', '$^', '', '$:', '', '$?', '', '$!', '', '%!', '', '$@', '', '$$', '', '$<', '', '$>', '', '$(', '', '$)', '', '$[', '', '$]', 'main', '@_', '', '*_', '', '*&', '', '*`', '', '*' . chr(39), '', '*+', '', '*.', '', '*/', '', '*|', '', '*,', '', '*' . chr(92), '', '*"', '', '*;', '', '*%', '', '*=', '', '*-', '', '*~', '', '*^', '', '*:', '', '*?', '', '*!', '', '*@', '', '*$', '', '*<', '', '*>', '', '*(', '', '*)', '', '*[', '', '*]', '', '*_', '', '**', '', '*#', '', '$#+', '', '$#-', '', '$#_', ''));
sub Perlito5::Grammar::Sigil::term_special_var {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $len) = 0);
    ((my  $s) = substr($str, $pos, 3));
    if (($s eq '$#[')) {
        ($len = 2)
    }
    else {
        if (exists($special_var{$s})) {
            ($len = 3)
        }
        else {
            ($s = substr($str, $pos, 2));
            if (exists($special_var{$s})) {
                ($len = 2)
            }
        }
    };
    if ($len) {
        ((my  $c0) = substr($str, (($pos + $len) - 1), 1));
        ((my  $c1) = substr($str, ($pos + $len), 1));
        if (((((((($c0 eq '$') || ($c0 eq '@')) || ($c0 eq '%')) || ($c0 eq '*')) || ($c0 eq '&'))) && ((((((((($c1 eq '$') || ($c1 eq '@')) || ($c1 eq '%')) || ($c1 eq '*')) || ($c1 eq '&')) || ((($c1 ge 'a') && ($c1 le 'z')))) || ((($c1 ge 'A') && ($c1 le 'Z')))) || ((($c1 ge '0') && ($c1 le '9'))))))) {

        }
        else {
            return ({'str', $str, 'from', $pos, 'to', ($pos + $len), 'capture', ['term', Perlito5::AST::Var->new('sigil', substr($s, 0, ($len - 1)), 'namespace', $special_var{$s}, 'name', substr($s, ($len - 1), 1))]})
        }
    };
    return (0)
};
((my  %sigil) = ('$', 1, '%', 1, '@', 1, '&', 1, '*', 1));
sub Perlito5::Grammar::Sigil::term_sigil {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $c1) = substr($str, $pos, 1));
    if (exists($sigil{$c1})) {

    }
    else {
        return ()
    };
    ((my  $p) = ($pos + 1));
    ((my  $sigil) = $c1);
    if ((substr($str, $pos, 2) eq '$#')) {
        ($sigil = '$#');
        ($p)++
    };
    ((my  $m) = Perlito5::Grammar::Space->opt_ws($str, $p));
    ($p = $m->{'to'});
    ($c1 = substr($str, $p, 1));
    ((my  $q) = ($p + 1));
    if (($c1 eq '{')) {
        ((my  $p) = $q);
        ($m = Perlito5::Grammar::Space->opt_ws($str, $p));
        ($p = $m->{'to'});
        ($m = Perlito5::Grammar->optional_namespace_before_ident($str, $p));
        if ($m) {
            ((my  $n) = Perlito5::Grammar->var_name($str, $m->{'to'}));
            if ($n) {
                ((my  $spc) = Perlito5::Grammar::Space->opt_ws($str, $n->{'to'}));
                ($m->{'capture'} = Perlito5::AST::Var->new('sigil', $sigil, 'namespace', Perlito5::Match::flat($m), 'name', Perlito5::Match::flat($n)));
                ($m->{'to'} = $spc->{'to'});
                ($m = Perlito5::Grammar::String->double_quoted_var_with_subscript($m));
                ($m->{'capture'} = ['term', $m->{'capture'}]);
                ($spc = Perlito5::Grammar::Space->opt_ws($str, $m->{'to'}));
                ((my  $p) = $spc->{'to'});
                if ((substr($str, $p, 1) eq '}')) {
                    ($m->{'to'} = ($p + 1));
                    return ($m)
                }
            }
        };
        if ((substr($str, $p, 1) eq '^')) {
            ($m = Perlito5::Grammar->var_name($str, ($p + 1)));
            if ($m) {
                ((my  $p) = $m->{'to'});
                if ((substr($str, $p, 1) eq '}')) {
                    ($m->{'to'} = ($m->{'to'} + 1));
                    ($m->{'capture'} = ['term', Perlito5::AST::Var->new('sigil', $sigil, 'namespace', 'main', 'name', ('^' . Perlito5::Match::flat($m)))]);
                    return ($m)
                }
            }
        };
        ($m = Perlito5::Expression->curly_parse($str, $p));
        if ($m) {
            ((my  $p) = $m->{'to'});
            if ((substr($str, $p, 1) eq '}')) {
                ($m->{'to'} = ($m->{'to'} + 1));
                ($m->{'capture'} = ['term', Perlito5::AST::Apply->new('arguments', [$m->{'capture'}], 'code', ('prefix:<' . $sigil . '>'), 'namespace', '')]);
                return ($m)
            }
        }
    };
    if (($c1 eq '^')) {
        ((my  $p) = $q);
        ($m = Perlito5::Grammar->word($str, $p));
        if ($m) {
            ($m->{'capture'} = ['term', Perlito5::AST::Var->new('sigil', $sigil, 'namespace', 'main', 'name', ('^' . Perlito5::Match::flat($m)))]);
            return ($m)
        }
    };
    if (($c1 eq '$')) {
        ($m = $self->term_sigil($str, $p));
        if ($m) {
            ($m->{'capture'} = ['term', Perlito5::AST::Apply->new('arguments', [$m->{'capture'}->[1]], 'code', ('prefix:<' . $sigil . '>'), 'namespace', '')]);
            return ($m)
        }
    };
    ($m = Perlito5::Grammar->optional_namespace_before_ident($str, $p));
    if ($m) {
        ((my  $n) = Perlito5::Grammar->var_name($str, $m->{'to'}));
        if ($n) {
            ($n->{'capture'} = ['term', Perlito5::AST::Var->new('sigil', $sigil, 'namespace', Perlito5::Match::flat($m), 'name', Perlito5::Match::flat($n))]);
            return ($n)
        }
    };
    return ($self->term_special_var($str, $pos))
};
1;

;
package main;
package Perlito5::Grammar::Use;

# use Perlito5::Precedence
;

# use Perlito5::Grammar
;
Perlito5::Precedence::add_term('no', sub {
    Perlito5::Grammar::Use->term_use($_[0], $_[1])
});
Perlito5::Precedence::add_term('use', sub {
    Perlito5::Grammar::Use->term_use($_[0], $_[1])
});
((my  %Perlito_internal_module) = ('strict', 'Perlito5::strict', 'warnings', 'Perlito5::warnings', 'utf8', 'Perlito5::utf8', 'bytes', 'Perlito5::bytes', 'encoding', 'Perlito5::encoding'));
sub Perlito5::Grammar::Use::use_decl {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (('use' eq substr($str, $MATCH->{'to'}, 3)) && (($MATCH->{'to'} = (3 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('no' eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'}))))))
})))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Use::term_use {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((((do {
    ((my  $m2) = $grammar->use_decl($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'use_decl'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((do {
    ((my  $m2) = Perlito5::Grammar->val_version($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.val_version'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{'capture'} = ['term', Perlito5::AST::Apply->new('code', 'undef', 'namespace', '', 'arguments', [])]);
;
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((((do {
    ((my  $m2) = Perlito5::Grammar->full_ident($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.full_ident'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m) = $MATCH);
    if (!(((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((('-' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = Perlito5::Grammar->ident($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        if (exists($MATCH->{'Perlito5::Grammar.ident'})) {
            push(@{$MATCH->{'Perlito5::Grammar.ident'}}, $m2 )
        }
        else {
            ($MATCH->{'Perlito5::Grammar.ident'} = [$m2])
        };
        1
    }
    else {
        0
    }
})))
}))
})))) {
        ($MATCH = $m)
    };
    1
}))) && ((do {
    ((my  $m2) = Perlito5::Expression->list_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Expression.list_parse'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $list) = Perlito5::Match::flat($MATCH->{'Perlito5::Expression.list_parse'}));
    if (($list eq '*undef*')) {
        ($list = undef())
    }
    else {
        ((my  $m) = $MATCH->{'Perlito5::Expression.list_parse'});
        ((my  $list_code) = substr($str, $m->{'from'}, ($m->{'to'} - $m->{'from'})));
        ((my  @list) = (do { my $m = Perlito5::Grammar->exp_stmts(    $list_code, 0);my $source; $source .= (defined $_ ? $_->emit_perl5(0, "scalar") : "") . ";\n" for @{ Perlito5::Match::flat($m) }; eval $source;}));
        ($list = \@list)
    };
    ((my  $ast) = Perlito5::AST::Use->new('code', Perlito5::Match::flat($MATCH->{'use_decl'}), 'mod', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.full_ident'}), 'arguments', $list));
    parse_time_eval($ast);
    ($MATCH->{'capture'} = ['term', $ast]);
;
    1
}))))
})))
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Use::parse_time_eval {
    ((my  $self) = shift());
    ((my  $module_name) = $self->mod());
    ((my  $use_or_not) = $self->code());
    ((my  $arguments) = $self->{'arguments'});
    ((my  $skip_import) = (defined($arguments) && (@{$arguments} == 0)));
    if (defined($arguments)) {

    }
    else {
        ($arguments = [])
    };
    if (($module_name eq 'feature')) {

    }
    else {
        if ($Perlito5::EXPAND_USE) {
            if (exists($Perlito_internal_module{$module_name})) {
                ($module_name = $Perlito_internal_module{$module_name})
            };
            ((my  $filename) = modulename_to_filename($module_name));
Perlito5::Grammar::Use::require($filename);
            if (!($skip_import)) {
                if (($use_or_not eq 'use')) {
                    if (defined(&{($module_name . '::import')})) {
                        unshift(@{$Perlito5::CALLER}, [$Perlito5::PKG_NAME]);
                        $module_name->import(@{$arguments});
                        shift(@{$Perlito5::CALLER})
                    }
                }
                else {
                    if (($use_or_not eq 'no')) {
                        if (defined(&{($module_name . '::unimport')})) {
                            unshift(@{$Perlito5::CALLER}, [$Perlito5::PKG_NAME]);
                            $module_name->unimport(@{$arguments});
                            shift(@{$Perlito5::CALLER})
                        }
                    }
                }
            }
        }
    }
};
sub Perlito5::Grammar::Use::emit_time_eval {
    ((my  $self) = shift());
    if (($self->mod() eq 'strict')) {
        if (($self->code() eq 'use')) {
            Perlito5::strict->import()
        }
        else {
            if (($self->code() eq 'no')) {
                Perlito5::strict->unimport()
            }
        }
    }
};
sub Perlito5::Grammar::Use::modulename_to_filename {
    ((my  $s) = shift());
    ($s =~ s!::!/!g);
    return (($s . '.pm'))
};
sub Perlito5::Grammar::Use::filename_lookup {
    ((my  $filename) = shift());
    if (exists($INC{$filename})) {
        if ($INC{$filename}) {
            return ('done')
        };
        die('Compilation failed in require')
    };
    for my $prefix ((@INC, '.')) {
        ((my  $realfilename) = ($prefix . '/' . $filename));
        if (-f($realfilename)) {
            ($INC{$filename} = $realfilename);
            return ('todo')
        }
    };
    die(('Can' . chr(39) . 't locate ' . $filename . ' in @INC ' . '(@INC contains ' . join(' ', @INC) . ').'))
};
sub Perlito5::Grammar::Use::expand_use {
    ((my  $comp_units) = shift());
    ((my  $stmt) = shift());
    ((my  $module_name) = $stmt->mod());
    if (((($module_name eq 'strict') || ($module_name eq 'warnings')) || ($module_name eq 'feature'))) {
        return ()
    };
    if (exists($Perlito_internal_module{$module_name})) {
        ($module_name = $Perlito_internal_module{$module_name})
    };
    ((my  $filename) = modulename_to_filename($module_name));
    if ((filename_lookup($filename) eq 'done')) {
        return ()
    };
    ((my  $realfilename) = $INC{$filename});
    ((my  $source) = Perlito5::IO::slurp($realfilename));
    ((my  $m) = Perlito5::Grammar->exp_stmts($source, 0));
    if (($m->{'to'} != length($source))) {
        die('Syntax Error near ', $m->{'to'})
    };
    push(@{$comp_units}, @{add_comp_unit([Perlito5::AST::CompUnit->new('name', 'main', 'body', Perlito5::Match::flat($m))])} )
};
sub Perlito5::Grammar::Use::add_comp_unit {
    ((my  $parse) = shift());
    ((my  $comp_units) = []);
    for my $comp_unit (@{$parse}) {
        if (defined($comp_unit)) {
            if ($comp_unit->isa('Perlito5::AST::Use')) {
                expand_use($comp_units, $comp_unit)
            }
            else {
                if ($comp_unit->isa('Perlito5::AST::CompUnit')) {
                    for my $stmt (@{$comp_unit->body()}) {
                        if ($stmt->isa('Perlito5::AST::Use')) {
                            expand_use($comp_units, $stmt)
                        }
                    }
                }
            };
            push(@{$comp_units}, $comp_unit )
        }
    };
    return ($comp_units)
};
sub Perlito5::Grammar::Use::require {
    ((my  $filename) = shift());
    ((my  $is_bareword) = shift());
    if ($is_bareword) {
        ($filename = modulename_to_filename($filename))
    };
    if ((filename_lookup($filename) eq 'done')) {
        return ()
    };
    ($result = (do { my $m = Perlito5::Grammar->exp_stmts(    Perlito5::IO::slurp($INC{$filename}), 0);my $source; $source .= (defined $_ ? $_->emit_perl5(0, "scalar") : "") . ";\n" for @{ Perlito5::Match::flat($m) }; eval $source;}));
    if (${'@'}) {
        ($INC{$filename} = undef());
        die(${'@'})
    }
    else {
        if (!($result)) {
            delete($INC{$filename});
            if (${'@'}) {
                warn(${'@'})
            };
            die(($filename . ' did not return true value'))
        }
        else {
            return ($result)
        }
    }
};
1;

;
package main;
package Perlito5::Grammar::Block;

# use Perlito5::Expression
;
((our  %Named_block) = ('BEGIN', 1, 'UNITCHECK', 1, 'CHECK', 1, 'INIT', 1, 'END', 1));
Perlito5::Expression::add_statement('{', sub {
    Perlito5::Grammar::Block->term_block($_[0], $_[1])
});
Perlito5::Expression::add_statement('sub', sub {
    Perlito5::Grammar::Block->named_sub($_[0], $_[1])
});
for (keys(%Named_block)) {
    Perlito5::Expression::add_statement($_, sub {
    Perlito5::Grammar::Block->term_block($_[0], $_[1])
})
};
sub Perlito5::Grammar::Block::term_block {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $p) = $pos);
    (my  $block_name);
    ((my  $m_name) = Perlito5::Grammar->ident($str, $p));
    if ($m_name) {
        ($p = $m_name->{'to'});
        ($block_name = Perlito5::Match::flat($m_name))
    };
    ((my  $ws) = Perlito5::Grammar::Space->ws($str, $p));
    if ($ws) {
        ($p = $ws->{'to'})
    };
    if ((substr($str, $p, 1) eq '{')) {
        ((my  $m) = Perlito5::Expression->term_curly($str, $p));
        if ($m) {
            ((my  $block_start) = $p);
            ($p = $m->{'to'});
            ($ws = Perlito5::Grammar::Space->ws($str, $p));
            if ($ws) {
                ($p = $ws->{'to'})
            };
            ((my  $continue) = Perlito5::AST::Lit::Block->new('stmts', []));
            ((my  $has_continue) = 0);
            if ((!($block_name) && (substr($str, $p, 8) eq 'continue'))) {
                ($p = ($p + 8));
                ($ws = Perlito5::Grammar::Space->ws($str, $p));
                if ($ws) {
                    ($p = $ws->{'to'})
                };
                ((my  $cont) = Perlito5::Expression->term_curly($str, $p));
                if ($cont) {

                }
                else {
                    die('syntax error')
                };
                warn('continue!');
                ($continue->{'stmts'} = $cont->{'capture'}->[2]);
                ($has_continue = 1);
                ($m->{'to'} = $cont->{'to'})
            };
            ((my  $v) = Perlito5::Match::flat($m));
            ($v = Perlito5::AST::Lit::Block->new('stmts', $v->[2], 'sig', $v->[3]));
            if (($has_continue || $block_name)) {

            }
            else {
                ($v = Perlito5::Expression::block_or_hash($v))
            };
            if ((ref($v) eq 'Perlito5::AST::Lit::Block')) {
                if (($block_name eq 'BEGIN')) {
                    (do { my $m = Perlito5::Grammar->exp_stmts(                        substr($str, $block_start, ($m->{'to'} - $block_start)), 0);my $source; $source .= (defined $_ ? $_->emit_perl5(0, "scalar") : "") . ";\n" for @{ Perlito5::Match::flat($m) }; eval $source;});
                    ($m->{'capture'} = Perlito5::AST::Apply->new('code', 'undef', 'namespace', '', 'arguments', []))
                }
                else {
                    ($v->{'name'} = $block_name);
                    ($m->{'capture'} = $v);
                    ($m->{'capture'}->{'continue'} = $continue)
                };
                return ($m)
            }
        }
    };
    return (0)
};
sub Perlito5::Grammar::Block::named_sub_def {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((((((((do {
    ((my  $m2) = Perlito5::Grammar->optional_namespace_before_ident($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.optional_namespace_before_ident'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = Perlito5::Grammar->ident($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.ident'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->prototype($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.prototype'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((('{' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $m2) = Perlito5::Grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->exp_stmts($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Grammar.exp_stmts'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = Perlito5::Grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (('}' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((do {
    die('Syntax Error in sub ' . chr(39), Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.ident'}), chr(39));
    1
})))
})))
}))) && ((do {
    ((my  $name) = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.ident'}));
    ((my  $sig) = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.prototype'}));
    if (($sig eq '*undef*')) {
        ($sig = undef())
    };
    ((my  $namespace) = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.optional_namespace_before_ident'}));
    if ($name) {
        if ($namespace) {

        }
        else {
            ($namespace = $Perlito5::PKG_NAME)
        };
        ((my  $full_name) = ($namespace . '::' . $name));
        if (exists($Perlito5::PROTO->{$full_name})) {
            warn(('Subroutine ' . $full_name . ' redefined'))
        };
        ($Perlito5::PROTO->{$full_name} = $sig)
    };
    ($MATCH->{'capture'} = Perlito5::AST::Sub->new('name', $name, 'namespace', $namespace, 'sig', $sig, 'block', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar.exp_stmts'})));
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Block::named_sub {
    ((my  $self) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    if ((substr($str, $pos, 3) eq 'sub')) {

    }
    else {
        return ()
    };
    ((my  $ws) = Perlito5::Grammar::Space->ws($str, ($pos + 3)));
    if ($ws) {

    }
    else {
        return ()
    };
    ($p = $ws->{'to'});
    ((my  $m_name) = Perlito5::Grammar->ident($str, $p));
    if ($m_name) {

    }
    else {
        return ()
    };
    ((my  $block_name) = Perlito5::Match::flat($m_name));
    if (exists($Named_block{$block_name})) {
        return (Perlito5::Grammar::Block->term_block($str, $p))
    };
    return (Perlito5::Grammar::Block->named_sub_def($str, $p))
};
1;

;
package main;
package Perlito5::Grammar::Space;

# use Perlito5::Precedence
;
((my  %space) = ('#', sub {
    ((my  $m) = Perlito5::Grammar::Space->to_eol($_[0], $_[1]));
    $m->{    'to'}
}, chr(9), sub {
    $_[1]
}, chr(10), sub {
    ((my  $str) = $_[0]);
    ((my  $pos) = $_[1]);
    if ((substr($str, $pos, 1) eq chr(13))) {
        ($pos)++
    };
    ((my  $m) = Perlito5::Grammar::Space->start_of_line($_[0], $pos));
    $m->{    'to'}
}, chr(12), sub {
    $_[1]
}, chr(13), sub {
    ((my  $str) = $_[0]);
    ((my  $pos) = $_[1]);
    if ((substr($str, $pos, 1) eq chr(10))) {
        ($pos)++
    };
    ((my  $m) = Perlito5::Grammar::Space->start_of_line($_[0], $pos));
    $m->{    'to'}
}, chr(32), sub {
    $_[1]
}));
sub Perlito5::Grammar::Space::term_space {
    ((my  $str) = $_[0]);
    ((my  $pos) = $_[1]);
    ((my  $p) = $pos);
    for ( ; exists($space{substr($str, $p, 1)}); do {{

}} ) {
        ($p = $space{substr($str, $p, 1)}->($str, ($p + 1)))
    };
    if (((substr($str, $p, 7) eq '__END__') || (substr($str, $p, 8) eq '__DATA__'))) {
        return ({'str', $str, 'from', $pos, 'to', length($str)})
    };
    return ({'str', $str, 'from', $pos, 'to', $p, 'capture', ['space', ' ']})
};
sub Perlito5::Grammar::Space::term_end {
    return ({'str', $_[0], 'from', $_[1], 'to', length($_[0]), 'capture', ['space', ' ']})
};
Perlito5::Precedence::add_term('#', \&term_space);
Perlito5::Precedence::add_term(chr(9), \&term_space);
Perlito5::Precedence::add_term(chr(10), \&term_space);
Perlito5::Precedence::add_term(chr(12), \&term_space);
Perlito5::Precedence::add_term(chr(13), \&term_space);
Perlito5::Precedence::add_term(chr(32), \&term_space);
Perlito5::Precedence::add_term('__END__', \&term_end);
Perlito5::Precedence::add_term('__DATA__', \&term_end);
sub Perlito5::Grammar::Space::to_eol {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((my  $last_match_null) = 0);
    ((my  $m) = $MATCH);
    ((my  $to) = $MATCH->{'to'});
    for ( ; (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}});
    ((my  $res) = ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    ((chr(10) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((chr(13) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
})))
}))
})));
    ($MATCH = ($res ? 0 : $tmp))
})) && ((('' ne substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))
})) && (($last_match_null < 2))); do {{

}} ) {
        if (($to == $MATCH->{'to'})) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($m = $MATCH);
        ($to = $MATCH->{'to'})
    };
    ($MATCH = $m);
    ($MATCH->{'to'} = $to);
    1
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Space::pod_pod_begin {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    ((((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    ((chr(10) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((chr(13) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
})))
})) && ((('=cut' eq substr($str, $MATCH->{'to'}, 4)) && (($MATCH->{'to'} = (4 + $MATCH->{'to'})))))) && ((do {
    ((my  $m2) = $grammar->to_eol($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((('' ne substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->to_eol($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->pod_pod_begin($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))))
})))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Space::pod_begin {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    ((((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    ((chr(10) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((chr(13) eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
})))
})) && ((('=end' eq substr($str, $MATCH->{'to'}, 4)) && (($MATCH->{'to'} = (4 + $MATCH->{'to'})))))) && ((do {
    ((my  $m2) = $grammar->to_eol($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((('' ne substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->to_eol($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->pod_begin($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))))
})))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Space::start_of_line {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((do {
    ((my  $m2) = Perlito5::Grammar::String->here_doc($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((('=' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((((do {
    (((('pod' eq substr($str, $MATCH->{'to'}, 3)) && (($MATCH->{'to'} = (3 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->pod_pod_begin($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((('head1' eq substr($str, $MATCH->{'to'}, 5)) && (($MATCH->{'to'} = (5 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->pod_pod_begin($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((('begin' eq substr($str, $MATCH->{'to'}, 5)) && (($MATCH->{'to'} = (5 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->pod_begin($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((('for' eq substr($str, $MATCH->{'to'}, 3)) && (($MATCH->{'to'} = (3 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->pod_begin($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))))
})))
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (1)
})))
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::Space::ws {
    ((my  $self) = shift());
    ((my  $str) = shift());
    ((my  $pos) = shift());
    ((my  $p) = $pos);
    for ( ; exists($space{substr($str, $p, 1)}); do {{

}} ) {
        ($p = $space{substr($str, $p, 1)}->($str, ($p + 1)))
    };
    if (((substr($str, $p, 7) eq '__END__') || (substr($str, $p, 8) eq '__DATA__'))) {
        return ({'str', $str, 'from', $pos, 'to', length($str)})
    };
    if (($p == $pos)) {
        return (0)
    };
    return ({'str', $str, 'from', $pos, 'to', $p})
};
sub Perlito5::Grammar::Space::opt_ws {
    ((my  $self) = shift());
    ((my  $str) = shift());
    ((my  $pos) = shift());
    ((my  $p) = $pos);
    for ( ; exists($space{substr($str, $p, 1)}); do {{

}} ) {
        ($p = $space{substr($str, $p, 1)}->($str, ($p + 1)))
    };
    if (((substr($str, $p, 7) eq '__END__') || (substr($str, $p, 8) eq '__DATA__'))) {
        return ({'str', $str, 'from', $pos, 'to', length($str)})
    };
    return ({'str', $str, 'from', $pos, 'to', $p})
};
1;

;
package main;
package Perlito5::Grammar;

# use Perlito5::Expression
;

# use Perlito5::Grammar::Control
;

# use Perlito5::Grammar::String
;

# use Perlito5::Grammar::Sigil
;

# use Perlito5::Grammar::Use
;

# use Perlito5::Grammar::Block
;

# use Perlito5::Grammar::Space
;
sub Perlito5::Grammar::word {
    ((substr($_[1], $_[2], 1) =~ m!\w!) ? {'str', $_[1], 'from', $_[2], 'to', ($_[2] + 1)} : 0)
};
sub Perlito5::Grammar::digit {
    ((substr($_[1], $_[2], 1) =~ m!\d!) ? {'str', $_[1], 'from', $_[2], 'to', ($_[2] + 1)} : 0)
};
sub Perlito5::Grammar::ident {
    if (((substr($_[1], $_[2], 1) !~ m!\w!) || (substr($_[1], $_[2], 1) =~ m!\d!))) {
        return ()
    };
    ((my  $m) = {'str', $_[1], 'from', $_[2], 'to', ($_[2] + 1)});
    for ( ; (substr($_[1], $m->{'to'}, 1) =~ m!\w!); do {{

}} ) {
        ($m->{'to'})++
    };
    $m
};
sub Perlito5::Grammar::full_ident {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((do {
    ((my  $m2) = $grammar->ident($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $m) = $MATCH);
    ((my  $to) = $MATCH->{'to'});
    for ( ; (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((('::' eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->ident($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})))
}))
})) && (($last_match_null < 2))); do {{

}} ) {
        if (($to == $MATCH->{'to'})) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($m = $MATCH);
        ($to = $MATCH->{'to'})
    };
    ($MATCH = $m);
    ($MATCH->{'to'} = $to);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::namespace_before_ident {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((((do {
    ((my  $m2) = $grammar->ident($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}});
    ((my  $res) = ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (('::' eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'}))))
}))
})));
    ($MATCH = ($res ? $tmp : 0))
}))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $m) = $MATCH);
    ((my  $to) = $MATCH->{'to'});
    for ( ; (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((((('::' eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->ident($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}});
    ((my  $res) = ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (('::' eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'}))))
}))
})));
    ($MATCH = ($res ? $tmp : 0))
})))
}))
})) && (($last_match_null < 2))); do {{

}} ) {
        if (($to == $MATCH->{'to'})) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($m = $MATCH);
        ($to = $MATCH->{'to'})
    };
    ($MATCH = $m);
    ($MATCH->{'to'} = $to);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::optional_namespace_before_ident {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((((do {
    ((((do {
    ((my  $m2) = $grammar->namespace_before_ident($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'namespace_before_ident'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $m) = $MATCH);
    ((my  $to) = $MATCH->{'to'});
    for ( ; (((('::' eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'}))))) && (($last_match_null < 2))); do {{

}} ) {
        if (($to == $MATCH->{'to'})) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($m = $MATCH);
        ($to = $MATCH->{'to'})
    };
    ($MATCH = $m);
    ($MATCH->{'to'} = $to);
    1
}))) && ((do {
    ($MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'namespace_before_ident'}));
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((('::' eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'}))))) && ((do {
    ($MATCH->{'capture'} = 'main');
    1
}))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((1 && ((do {
    ($MATCH->{'capture'} = '');
    1
}))))
})))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::ws {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((my  $m2) = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::opt_ws {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((my  $m) = $MATCH);
    if (!(((do {
    ((my  $m2) = Perlito5::Grammar::Space->ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})))) {
        ($MATCH = $m)
    };
    1
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::exp_stmts2 {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((do {
    ((my  $m2) = $grammar->exp_stmts($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'exp_stmts'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'exp_stmts'}));
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::exp {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((do {
    ((my  $m2) = Perlito5::Expression->exp_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Expression.exp_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Expression.exp_parse'}));
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::exp2 {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((do {
    ((my  $m2) = Perlito5::Expression->exp_parse($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'Perlito5::Expression.exp_parse'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ($MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'Perlito5::Expression.exp_parse'}));
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::opt_type {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    ((((do {
    ((my  $m) = $MATCH);
    if (!(((do {
    (('::' eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'}))))
})))) {
        ($MATCH = $m)
    };
    1
})) && ((do {
    ((my  $m2) = $grammar->full_ident($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'full_ident'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = Perlito5::Match::flat($MATCH->{'full_ident'}));
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((1 && ((do {
    ($MATCH->{'capture'} = '');
    1
}))))
})))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::var_sigil {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((((((do {
    (('$' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('%' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('@' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('&' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('*' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
})))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::var_name {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    ((my  $m2) = $grammar->full_ident($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'full_ident'} = $m2);
        1
    }
    else {
        0
    }
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'digit'} = $m2);
        1
    }
    else {
        0
    }
})))
})))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::var_ident {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((do {
    ((my  $m2) = $grammar->var_sigil($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'var_sigil'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = $grammar->optional_namespace_before_ident($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'optional_namespace_before_ident'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->var_name($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'var_name'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ($MATCH->{'capture'} = Perlito5::AST::Var->new('sigil', Perlito5::Match::flat($MATCH->{'var_sigil'}), 'namespace', Perlito5::Match::flat($MATCH->{'optional_namespace_before_ident'}), 'name', Perlito5::Match::flat($MATCH->{'var_name'})));
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::exponent {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (('e' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('E' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
})))
})) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((((do {
    (('+' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('-' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (1)
})))
}))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $m) = $MATCH);
    ((my  $to) = $MATCH->{'to'});
    ((my  $count) = 0);
    for ( ; (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (('_' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})))
})))
})) && (($last_match_null < 2))); do {{

}} ) {
        if (($to == $MATCH->{'to'})) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($m = $MATCH);
        ($to = $MATCH->{'to'});
        ($count = ($count + 1))
    };
    ($MATCH = $m);
    ($MATCH->{'to'} = $to);
    ($count > 0)
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::val_num {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((((('.' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $m) = $MATCH);
    ((my  $to) = $MATCH->{'to'});
    for ( ; (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (('_' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})))
})))
})) && (($last_match_null < 2))); do {{

}} ) {
        if (($to == $MATCH->{'to'})) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($m = $MATCH);
        ($to = $MATCH->{'to'})
    };
    ($MATCH = $m);
    ($MATCH->{'to'} = $to);
    1
}))) && ((do {
    ((my  $m) = $MATCH);
    if (!(((do {
    ((my  $m2) = $grammar->exponent($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})))) {
        ($MATCH = $m)
    };
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $m) = $MATCH);
    ((my  $to) = $MATCH->{'to'});
    for ( ; (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (('_' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})))
})))
})) && (($last_match_null < 2))); do {{

}} ) {
        if (($to == $MATCH->{'to'})) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($m = $MATCH);
        ($to = $MATCH->{'to'})
    };
    ($MATCH = $m);
    ($MATCH->{'to'} = $to);
    1
}))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    ((my  $m2) = $grammar->exponent($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((((('.' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $tmp) = $MATCH);
    ($MATCH = {'str', $str, 'from', $tmp->{'to'}, 'to', $tmp->{'to'}});
    ((my  $res) = ((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (('.' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
}))
})));
    ($MATCH = ($res ? 0 : $tmp))
}))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $m) = $MATCH);
    ((my  $to) = $MATCH->{'to'});
    for ( ; (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (('_' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})))
})))
})) && (($last_match_null < 2))); do {{

}} ) {
        if (($to == $MATCH->{'to'})) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($m = $MATCH);
        ($to = $MATCH->{'to'})
    };
    ($MATCH = $m);
    ($MATCH->{'to'} = $to);
    1
}))) && ((do {
    ((my  $m) = $MATCH);
    if (!(((do {
    ((my  $m2) = $grammar->exponent($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})))) {
        ($MATCH = $m)
    };
    1
}))))
})))
}))))
})))
})) && ((do {
    ((my  $s) = Perlito5::Match::flat($MATCH));
    ($s =~ s!_!!g);
    ($MATCH->{'capture'} = Perlito5::AST::Val::Num->new('num', $s));
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::digits {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((my  $last_match_null) = 0);
    ((my  $m) = $MATCH);
    ((my  $to) = $MATCH->{'to'});
    ((my  $count) = 0);
    for ( ; (((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))); do {{

}} ) {
        if (($to == $MATCH->{'to'})) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($m = $MATCH);
        ($to = $MATCH->{'to'});
        ($count = ($count + 1))
    };
    ($MATCH = $m);
    ($MATCH->{'to'} = $to);
    ($count > 0)
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::val_int {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((((do {
    ((((('0' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (('x' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('X' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
})))
}))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $m) = $MATCH);
    ((my  $to) = $MATCH->{'to'});
    ((my  $count) = 0);
    for ( ; (((do {
    ((my  $m2) = $grammar->word($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))); do {{

}} ) {
        if (($to == $MATCH->{'to'})) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($m = $MATCH);
        ($to = $MATCH->{'to'});
        ($count = ($count + 1))
    };
    ($MATCH = $m);
    ($MATCH->{'to'} = $to);
    ($count > 0)
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((('0' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (('b' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('B' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
})))
}))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $m) = $MATCH);
    ((my  $to) = $MATCH->{'to'});
    ((my  $count) = 0);
    for ( ; (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((((do {
    (('_' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('0' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('1' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
})))
})) && (($last_match_null < 2))); do {{

}} ) {
        if (($to == $MATCH->{'to'})) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($m = $MATCH);
        ($to = $MATCH->{'to'});
        ($count = ($count + 1))
    };
    ($MATCH = $m);
    ($MATCH->{'to'} = $to);
    ($count > 0)
}))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((('0' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $m) = $MATCH);
    ((my  $to) = $MATCH->{'to'});
    ((my  $count) = 0);
    for ( ; (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (('_' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})))
})))
})) && (($last_match_null < 2))); do {{

}} ) {
        if (($to == $MATCH->{'to'})) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($m = $MATCH);
        ($to = $MATCH->{'to'});
        ($count = ($count + 1))
    };
    ($MATCH = $m);
    ($MATCH->{'to'} = $to);
    ($count > 0)
}))))
})))
})) && ((do {
    ($MATCH->{'capture'} = Perlito5::AST::Val::Int->new('int', oct(lc(Perlito5::Match::flat($MATCH)))));
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $m) = $MATCH);
    ((my  $to) = $MATCH->{'to'});
    for ( ; (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (('_' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((do {
    ((my  $m2) = $grammar->digit($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})))
})))
})) && (($last_match_null < 2))); do {{

}} ) {
        if (($to == $MATCH->{'to'})) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($m = $MATCH);
        ($to = $MATCH->{'to'})
    };
    ($MATCH = $m);
    ($MATCH->{'to'} = $to);
    1
}))) && ((do {
    ((my  $s) = Perlito5::Match::flat($MATCH));
    ($s =~ s!_!!g);
    ($MATCH->{'capture'} = Perlito5::AST::Val::Int->new('int', $s));
    1
}))))
})))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::val_version {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((((do {
    ((my  $m) = $MATCH);
    if (!(((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (('v' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
}))
})))) {
        ($MATCH = $m)
    };
    1
})) && ((do {
    ((my  $m2) = $grammar->digits($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m) = $MATCH);
    if (!(((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((((('.' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->digits($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m) = $MATCH);
    if (!(((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((('.' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))) && ((do {
    ((my  $m2) = $grammar->digits($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})))
}))
})))) {
        ($MATCH = $m)
    };
    1
})))
}))
})))) {
        ($MATCH = $m)
    };
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
(my  @PKG);
sub Perlito5::Grammar::exp_stmts {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((((do {
    push(@PKG, $Perlito5::PKG_NAME );
    1
})) && ((do {
    ((my  $last_match_null) = 0);
    ((my  $m) = $MATCH);
    ((my  $to) = $MATCH->{'to'});
    for ( ; (((do {
    ((my  $m2) = Perlito5::Expression->delimited_statement($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        if (exists($MATCH->{'Perlito5::Expression.delimited_statement'})) {
            push(@{$MATCH->{'Perlito5::Expression.delimited_statement'}}, $m2 )
        }
        else {
            ($MATCH->{'Perlito5::Expression.delimited_statement'} = [$m2])
        };
        1
    }
    else {
        0
    }
})) && (($last_match_null < 2))); do {{

}} ) {
        if (($to == $MATCH->{'to'})) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($m = $MATCH);
        ($to = $MATCH->{'to'})
    };
    ($MATCH = $m);
    ($MATCH->{'to'} = $to);
    1
}))) && ((do {
    ($Perlito5::PKG_NAME = pop(@PKG));
    ($MATCH->{'capture'} = [map($_->{'capture'}, @{$MATCH->{'Perlito5::Expression.delimited_statement'}})]);
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::args_sig {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    ((my  $last_match_null) = 0);
    ((my  $m) = $MATCH);
    ((my  $to) = $MATCH->{'to'});
    for ( ; (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((((((((((do {
    ((';' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((chr(92) eq substr($str, $MATCH->{'to'}, 2)) && (($MATCH->{'to'} = (2 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('[' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    ((((']' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('*' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('+' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('@' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('%' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('$' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
}))) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((('&' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))))
})))
})) && (($last_match_null < 2))); do {{

}} ) {
        if (($to == $MATCH->{'to'})) {
            ($last_match_null = ($last_match_null + 1))
        }
        else {
            ($last_match_null = 0)
        };
        ($m = $MATCH);
        ($to = $MATCH->{'to'})
    };
    ($MATCH = $m);
    ($MATCH->{'to'} = $to);
    1
}))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::prototype {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    ((((((((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
})) && ((('(' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->args_sig($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'args_sig'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && (((')' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ($MATCH->{'capture'} = ('' . Perlito5::Match::flat($MATCH->{'args_sig'})));
    1
})))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((do {
    ($MATCH->{'capture'} = '*undef*');
    1
})))
})))
}))));
    ($tmp ? $MATCH : 0)
};
sub Perlito5::Grammar::anon_sub_def {
    ((my  $grammar) = $_[0]);
    ((my  $str) = $_[1]);
    ((my  $pos) = $_[2]);
    ((my  $MATCH) = {'str', $str, 'from', $pos, 'to', $pos});
    ((my  $tmp) = (((do {
    ((my  $pos1) = $MATCH->{'to'});
    ((do {
    (((((((((do {
    ((my  $m2) = $grammar->prototype($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'prototype'} = $m2);
        1
    }
    else {
        0
    }
})) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((('{' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'})))))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->exp_stmts($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        ($MATCH->{'exp_stmts'} = $m2);
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $m2) = $grammar->opt_ws($str, $MATCH->{'to'}));
    if ($m2) {
        ($MATCH->{'to'} = $m2->{'to'});
        1
    }
    else {
        0
    }
}))) && ((do {
    ((my  $pos1) = $MATCH->{'to'});
    (((do {
    (('}' eq substr($str, $MATCH->{'to'}, 1)) && (($MATCH->{'to'} = (1 + $MATCH->{'to'}))))
})) || ((do {
    ($MATCH->{'to'} = $pos1);
    (((do {
    die('Syntax Error in anon sub');
    1
})))
})))
}))) && ((do {
    ((my  $sig) = Perlito5::Match::flat($MATCH->{'prototype'}));
    if (($sig eq '*undef*')) {
        ($sig = undef())
    };
    ($MATCH->{'capture'} = Perlito5::AST::Sub->new('name', undef(), 'namespace', undef(), 'sig', $sig, 'block', Perlito5::Match::flat($MATCH->{'exp_stmts'})));
    1
})))
}))
}))));
    ($tmp ? $MATCH : 0)
};

;

# use Perlito5::Grammar
;
package main;
undef();
package Perlito5::AST::CompUnit;
sub Perlito5::AST::CompUnit::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Perlito5::AST::CompUnit::name {
    $_[0]->{    'name'}
};
sub Perlito5::AST::CompUnit::body {
    $_[0]->{    'body'}
};
package Perlito5::AST::Val::Int;
sub Perlito5::AST::Val::Int::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Perlito5::AST::Val::Int::int {
    $_[0]->{    'int'}
};
package Perlito5::AST::Val::Num;
sub Perlito5::AST::Val::Num::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Perlito5::AST::Val::Num::num {
    $_[0]->{    'num'}
};
package Perlito5::AST::Val::Buf;
sub Perlito5::AST::Val::Buf::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Perlito5::AST::Val::Buf::buf {
    $_[0]->{    'buf'}
};
package Perlito5::AST::Lit::Block;
sub Perlito5::AST::Lit::Block::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Perlito5::AST::Lit::Block::sig {
    $_[0]->{    'sig'}
};
sub Perlito5::AST::Lit::Block::stmts {
    $_[0]->{    'stmts'}
};
package Perlito5::AST::Index;
sub Perlito5::AST::Index::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Perlito5::AST::Index::obj {
    $_[0]->{    'obj'}
};
sub Perlito5::AST::Index::index_exp {
    $_[0]->{    'index_exp'}
};
package Perlito5::AST::Lookup;
sub Perlito5::AST::Lookup::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Perlito5::AST::Lookup::obj {
    $_[0]->{    'obj'}
};
sub Perlito5::AST::Lookup::index_exp {
    $_[0]->{    'index_exp'}
};
sub Perlito5::AST::Lookup::autoquote {
    ((my  $self) = shift());
    ((my  $index) = shift());
    if (($index->isa('Perlito5::AST::Apply') && $index->{'bareword'})) {
        return (Perlito5::AST::Val::Buf->new('buf', ((($index->{'namespace'} ? ($index->{'namespace'} . '::') : '')) . $index->{'code'})))
    };
    $index
};
package Perlito5::AST::Var;
sub Perlito5::AST::Var::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Perlito5::AST::Var::sigil {
    $_[0]->{    'sigil'}
};
sub Perlito5::AST::Var::namespace {
    $_[0]->{    'namespace'}
};
sub Perlito5::AST::Var::name {
    $_[0]->{    'name'}
};
sub Perlito5::AST::Var::plain_name {
    ((my  $self) = shift());
    if ($self->namespace()) {
        return (($self->namespace() . '::' . $self->name()))
    };
    return ($self->name())
};
package Perlito5::AST::Proto;
sub Perlito5::AST::Proto::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Perlito5::AST::Proto::name {
    $_[0]->{    'name'}
};
package Perlito5::AST::Call;
sub Perlito5::AST::Call::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Perlito5::AST::Call::invocant {
    $_[0]->{    'invocant'}
};
sub Perlito5::AST::Call::method {
    $_[0]->{    'method'}
};
sub Perlito5::AST::Call::arguments {
    $_[0]->{    'arguments'}
};
package Perlito5::AST::Apply;
sub Perlito5::AST::Apply::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Perlito5::AST::Apply::code {
    $_[0]->{    'code'}
};
sub Perlito5::AST::Apply::arguments {
    $_[0]->{    'arguments'}
};
sub Perlito5::AST::Apply::namespace {
    $_[0]->{    'namespace'}
};
package Perlito5::AST::If;
sub Perlito5::AST::If::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Perlito5::AST::If::cond {
    $_[0]->{    'cond'}
};
sub Perlito5::AST::If::body {
    $_[0]->{    'body'}
};
sub Perlito5::AST::If::otherwise {
    $_[0]->{    'otherwise'}
};
package Perlito5::AST::When;
sub Perlito5::AST::When::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Perlito5::AST::When::cond {
    $_[0]->{    'cond'}
};
sub Perlito5::AST::When::body {
    $_[0]->{    'body'}
};
package Perlito5::AST::While;
sub Perlito5::AST::While::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Perlito5::AST::While::init {
    $_[0]->{    'init'}
};
sub Perlito5::AST::While::cond {
    $_[0]->{    'cond'}
};
sub Perlito5::AST::While::continue {
    $_[0]->{    'continue'}
};
sub Perlito5::AST::While::body {
    $_[0]->{    'body'}
};
package Perlito5::AST::For;
sub Perlito5::AST::For::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Perlito5::AST::For::cond {
    $_[0]->{    'cond'}
};
sub Perlito5::AST::For::continue {
    $_[0]->{    'continue'}
};
sub Perlito5::AST::For::body {
    $_[0]->{    'body'}
};
package Perlito5::AST::Decl;
sub Perlito5::AST::Decl::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Perlito5::AST::Decl::decl {
    $_[0]->{    'decl'}
};
sub Perlito5::AST::Decl::type {
    $_[0]->{    'type'}
};
sub Perlito5::AST::Decl::var {
    $_[0]->{    'var'}
};
package Perlito5::AST::Sig;
sub Perlito5::AST::Sig::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Perlito5::AST::Sig::positional {
    $_[0]->{    'positional'}
};
package Perlito5::AST::Sub;
sub Perlito5::AST::Sub::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Perlito5::AST::Sub::name {
    $_[0]->{    'name'}
};
sub Perlito5::AST::Sub::sig {
    $_[0]->{    'sig'}
};
sub Perlito5::AST::Sub::block {
    $_[0]->{    'block'}
};
package Perlito5::AST::Do;
sub Perlito5::AST::Do::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Perlito5::AST::Do::block {
    $_[0]->{    'block'}
};
package Perlito5::AST::Use;
sub Perlito5::AST::Use::new {
    ((my  $class) = shift());
    bless({@_}, $class)
};
sub Perlito5::AST::Use::mod {
    $_[0]->{    'mod'}
};
sub Perlito5::AST::Use::code {
    $_[0]->{    'code'}
};

;
package main;
package Perlito5::Dumper;
sub Perlito5::Dumper::Dumper {
    ((my  $obj) = $_[0]);
    ((my  $level) = ($_[1] || 0));
    if (!(defined($obj))) {
        return ('undef')
    };
    ((my  $ref) = ref($obj));
    ((my  $tab) = join("", '    ' x $level));
    ((my  $tab1) = ($tab . '    '));
    if (($ref eq 'ARRAY')) {
        return (('[' . chr(10) . join('', map(($tab1 . Dumper($_, ($level + 1)) . ',' . chr(10)), @{$obj})) . $tab . ']'))
    }
    else {
        if (($ref eq 'HASH')) {
            return (('{' . chr(10) . join('', map(($tab1 . (chr(39) . $_ . chr(39) . ' => ') . Dumper($obj->{$_}, ($level + 1)) . ',' . chr(10)), sort(keys(%{$obj})))) . $tab . '}'))
        }
        else {
            if ($ref) {
                return (('bless({' . chr(10) . join('', map(($tab1 . (chr(39) . $_ . chr(39) . ' => ') . Dumper($obj->{$_}, ($level + 1)) . ',' . chr(10)), sort(keys(%{$obj})))) . $tab . ('}, ' . chr(39) . $ref . chr(39) . ')')))
            }
        }
    };
    return ((chr(39) . $obj . chr(39)))
};
1;

;
package main;
undef();

# use Perlito5::AST
;

# use Perlito5::Dumper
;
package Perlito5::Javascript2;
do {{
    ((my  $label_count) = 100);
    (my  %label);
    sub Perlito5::Javascript2::pkg {
        ('p5pkg["' . $Perlito5::PKG_NAME . '"]')
    };
    sub Perlito5::Javascript2::pkg_new_var {
        ($label{$Perlito5::PKG_NAME} = ('p5' . ($label_count)++))
    };
    sub Perlito5::Javascript2::get_label {
        ($label_count)++
    };
    sub Perlito5::Javascript2::tab {
        ((my  $level) = shift());
join("", chr(9) x $level)
    };
    ((our  %op_prefix_js_str) = ('prefix:<-A>', 'p5atime', 'prefix:<-C>', 'p5ctime', 'prefix:<-M>', 'p5mtime', 'prefix:<-d>', 'p5is_directory', 'prefix:<-e>', 'p5file_exists', 'prefix:<-f>', 'p5is_file', 'prefix:<-s>', 'p5size'));
    ((our  %op_infix_js_str) = ('infix:<eq>', ' == ', 'infix:<ne>', ' != ', 'infix:<le>', ' <= ', 'infix:<ge>', ' >= '));
    ((our  %op_infix_js_num) = ('infix:<==>', ' == ', 'infix:<!=>', ' != ', 'infix:<+>', ' + ', 'infix:<->', ' - ', 'infix:<*>', ' * ', 'infix:</>', ' / ', 'infix:<%>', ' % ', 'infix:<>>', ' > ', 'infix:<<>', ' < ', 'infix:<>=>', ' >= ', 'infix:<<=>', ' <= ', 'infix:<&>', ' & ', 'infix:<|>', ' | ', 'infix:<^>', ' ^ ', 'infix:<>>>', ' >>> ', 'infix:<<<>', ' << '));
    ((our  %op_to_bool) = map(+(($_, 1)), ('prefix:<!>', 'infix:<!=>', 'infix:<==>', 'infix:<<=>', 'infix:<>=>', 'infix:<>>', 'infix:<<>', 'infix:<eq>', 'infix:<ne>', 'infix:<ge>', 'infix:<le>', 'prefix:<not>', 'exists', 'defined')));
    ((our  %op_to_str) = map(+(($_, 1)), ('substr', 'join', 'list:<.>', 'chr')));
    ((our  %op_to_num) = map(+(($_, 1)), ('length', 'index', 'ord', 'oct', 'infix:<->', 'infix:<+>', 'infix:<*>', 'infix:</>', 'infix:<%>', 'infix:<**>')));
    ((my  %safe_char) = (' ', 1, '!', 1, '"', 1, '#', 1, '$', 1, '%', 1, '&', 1, '(', 1, ')', 1, '*', 1, '+', 1, ',', 1, '-', 1, '.', 1, '/', 1, ':', 1, ';', 1, '<', 1, '=', 1, '>', 1, '?', 1, '@', 1, '[', 1, ']', 1, '^', 1, '_', 1, '`', 1, '{', 1, '|', 1, '}', 1, '~', 1));
    sub Perlito5::Javascript2::escape_string {
        ((my  $s) = shift());
        (my  @out);
        ((my  $tmp) = '');
        if (($s eq '')) {
            return (chr(39) . chr(39))
        };
        for my $i ((0 .. (length($s) - 1))) {
            ((my  $c) = substr($s, $i, 1));
            if ((((((($c ge 'a') && ($c le 'z'))) || ((($c ge 'A') && ($c le 'Z')))) || ((($c ge '0') && ($c le '9')))) || exists($safe_char{$c}))) {
                ($tmp = ($tmp . $c))
            }
            else {
                if (($tmp ne '')) {
                    push(@out, (chr(39) . $tmp . chr(39)) )
                };
                push(@out, ('String.fromCharCode(' . ord($c) . ')') );
                ($tmp = '')
            }
        };
        if (($tmp ne '')) {
            push(@out, (chr(39) . $tmp . chr(39)) )
        };
        return (join(' + ', @out))
    };
    sub Perlito5::Javascript2::to_str {
        ((my  $cond) = shift());
        ((my  $level) = shift());
        ((my  $wantarray) = 'scalar');
        if (((($cond->isa('Perlito5::AST::Apply') && ($cond->code() eq 'circumfix:<( )>')) && $cond->{'arguments'}) && @{$cond->{'arguments'}})) {
            return (to_str($cond->{'arguments'}->[0], $level))
        };
        if ((($cond->isa('Perlito5::AST::Val::Buf')) || (($cond->isa('Perlito5::AST::Apply') && exists($op_to_str{$cond->code()}))))) {
            return ($cond->emit_javascript2($level, $wantarray))
        }
        else {
            return (('p5str(' . $cond->emit_javascript2($level, $wantarray) . ')'))
        }
    };
    sub Perlito5::Javascript2::to_num {
        ((my  $cond) = shift());
        ((my  $level) = shift());
        ((my  $wantarray) = 'scalar');
        if ((($cond->isa('Perlito5::AST::Val::Int') || $cond->isa('Perlito5::AST::Val::Num')) || (($cond->isa('Perlito5::AST::Apply') && exists($op_to_num{$cond->code()}))))) {
            return ($cond->emit_javascript2($level, $wantarray))
        }
        else {
            return (('p5num(' . $cond->emit_javascript2($level, $wantarray) . ')'))
        }
    };
    sub Perlito5::Javascript2::to_bool {
        ((my  $cond) = shift());
        ((my  $level) = shift());
        ((my  $wantarray) = 'scalar');
        if (((($cond->isa('Perlito5::AST::Apply') && ($cond->code() eq 'circumfix:<( )>')) && $cond->{'arguments'}) && @{$cond->{'arguments'}})) {
            return (to_bool($cond->{'arguments'}->[0], $level))
        };
        if (($cond->isa('Perlito5::AST::Apply') && ((($cond->code() eq 'infix:<&&>') || ($cond->code() eq 'infix:<and>'))))) {
            return (('(' . to_bool($cond->{'arguments'}->[0], $level) . ' && ' . to_bool($cond->{'arguments'}->[1], $level) . ')'))
        };
        if (($cond->isa('Perlito5::AST::Apply') && ((($cond->code() eq 'infix:<||>') || ($cond->code() eq 'infix:<or>'))))) {
            return (('(' . to_bool($cond->{'arguments'}->[0], $level) . ' || ' . to_bool($cond->{'arguments'}->[1], $level) . ')'))
        };
        if (((($cond->isa('Perlito5::AST::Val::Int')) || ($cond->isa('Perlito5::AST::Val::Num'))) || (($cond->isa('Perlito5::AST::Apply') && exists($op_to_bool{$cond->code()}))))) {
            return ($cond->emit_javascript2($level, $wantarray))
        }
        else {
            return (('p5bool(' . $cond->emit_javascript2($level, $wantarray) . ')'))
        }
    };
    sub Perlito5::Javascript2::is_scalar {
        (((((!($_[0]->isa('Perlito5::AST::Val::Int')) && !($_[0]->isa('Perlito5::AST::Val::Num'))) && !($_[0]->isa('Perlito5::AST::Val::Buf'))) && !($_[0]->isa('Perlito5::AST::Sub'))) && !((($_[0]->isa('Perlito5::AST::Var') && ($_[0]->{'sigil'} eq '$'))))) && !((($_[0]->isa('Perlito5::AST::Apply') && ((((exists($op_to_str{$_[0]->{'code'}}) || exists($op_to_num{$_[0]->{'code'}})) || exists($op_to_bool{$_[0]->{'code'}})) || ($_[0]->{'code'} eq 'prefix:<' . chr(92) . '>')))))))
    };
    sub Perlito5::Javascript2::to_list {
        ((my  $items) = to_list_preprocess($_[0]));
        ((my  $level) = $_[1]);
        ((my  $literal_type) = ($_[2] || 'array'));
        ((my  $wantarray) = 'list');
        ((my  $interpolate) = 0);
        for (@{$items}) {
            if (is_scalar($_)) {
                ($interpolate = 1)
            }
        };
        if (($literal_type eq 'hash')) {
            if (!($interpolate)) {
                (my  @out);
                ((my  $printable) = 1);
                ((my  @in) = @{$items});
                for ( ; @in; do {{

}} ) {
                    ((my  $k) = shift(@in));
                    ((my  $v) = shift(@in));
                    ($k = $k->emit_javascript2($level, 0));
                    if (($k =~ m![ \[]!)) {
                        ($printable = 0)
                    };
                    ($v = ($v ? $v->emit_javascript2($level, 0) : 'null'));
                    push(@out, ($k . ' : ' . $v) )
                };
                if ($printable) {
                    return (('{' . join(', ', @out) . '}'))
                }
            };
            return (('p5a_to_h(' . to_list($items, $level, 'array') . ')'))
        };
        ($interpolate ? (('p5list_to_a(' . join(', ', map($_->emit_javascript2($level, $wantarray), @{$items})) . ')')) : (('[' . join(', ', map($_->emit_javascript2($level, $wantarray), @{$items})) . ']')))
    };
    sub Perlito5::Javascript2::to_list_preprocess {
        (my  @items);
        for my $item (@{$_[0]}) {
            if (($item->isa('Perlito5::AST::Apply') && (((($item->code() eq 'circumfix:<( )>') || ($item->code() eq 'list:<,>')) || ($item->code() eq 'infix:<=>>'))))) {
                if (($item->isa('Perlito5::AST::Apply') && ($item->code() eq 'infix:<=>>'))) {
                    ($item->{'arguments'}->[0] = Perlito5::AST::Lookup->autoquote($item->{'arguments'}->[0]))
                };
                for my $arg (@{to_list_preprocess($item->arguments())}) {
                    push(@items, $arg )
                }
            }
            else {
                push(@items, $item )
            }
        };
        return (\@items)
    };
    sub Perlito5::Javascript2::to_scalar {
        ((my  $items) = to_scalar_preprocess($_[0]));
        ((my  $level) = $_[1]);
        ((my  $wantarray) = 'scalar');
        (@{$items} ? ('(' . join(', ', map($_->emit_javascript2($level, $wantarray), @{$items})) . ')') : 'null')
    };
    sub Perlito5::Javascript2::to_scalar_preprocess {
        (my  @items);
        for my $item (@{$_[0]}) {
            if (($item->isa('Perlito5::AST::Apply') && ((($item->code() eq 'list:<,>') || ($item->code() eq 'infix:<=>>'))))) {
                if (($item->isa('Perlito5::AST::Apply') && ($item->code() eq 'infix:<=>>'))) {
                    ($item->{'arguments'}->[0] = Perlito5::AST::Lookup->autoquote($item->{'arguments'}->[0]))
                };
                for my $arg (@{to_scalar_preprocess($item->arguments())}) {
                    push(@items, $arg )
                }
            }
            else {
                push(@items, $item )
            }
        };
        return (\@items)
    };
    sub Perlito5::Javascript2::to_runtime_context {
        ((my  $items) = to_scalar_preprocess($_[0]));
        ((my  $level) = $_[1]);
        ((my  $wantarray) = 'runtime');
        if (((@{$items} == 1) && is_scalar($items->[0]))) {
            return ($items->[0]->emit_javascript2($level, $wantarray))
        };
        ('p5context(' . '[' . join(', ', map($_->emit_javascript2($level, $wantarray), @{$items})) . ']' . ', p5want)')
    };
    sub Perlito5::Javascript2::emit_javascript2_autovivify {
        ((my  $obj) = shift());
        ((my  $level) = shift());
        ((my  $type) = shift());
        ('(' . $obj->emit_javascript2($level) . ' || (' . $obj->emit_javascript2($level) . ' = ' . ((($type eq 'array') ? 'new p5ArrayRef([])' : (($type eq 'hash') ? 'new p5HashRef({})' : 'new p5ScalarRef(null)'))) . ')' . ')')
    };
    sub Perlito5::Javascript2::emit_function_javascript2 {
        ((my  $level) = shift());
        ((my  $wantarray) = shift());
        ((my  $argument) = shift());
        if (($argument->isa('Perlito5::AST::Apply') && ($argument->code() eq 'return'))) {
            return (('function () { ' . $argument->emit_javascript2($level, $wantarray) . ' }'))
        };
        return (('function () { return ' . $argument->emit_javascript2($level, $wantarray) . ' }'))
    }
}};
package Perlito5::Javascript2::LexicalBlock;
do {{
    sub Perlito5::Javascript2::LexicalBlock::new {
        ((my  $class) = shift());
        bless({@_}, $class)
    };
    sub Perlito5::Javascript2::LexicalBlock::block {
        $_[0]->{        'block'}
    };
    sub Perlito5::Javascript2::LexicalBlock::needs_return {
        $_[0]->{        'needs_return'}
    };
    sub Perlito5::Javascript2::LexicalBlock::top_level {
        $_[0]->{        'top_level'}
    };
    sub Perlito5::Javascript2::LexicalBlock::has_decl {
        ((my  $self) = $_[0]);
        ((my  $type) = $_[1]);
        for my $decl (@{$self->{'block'}}) {
            if (defined($decl)) {
                if ((($decl->isa('Perlito5::AST::Decl') && ($decl->decl() eq $type)) || ($decl->isa('Perlito5::AST::Apply') && ($decl->code() eq $type)))) {
                    return (1)
                };
                if (($decl->isa('Perlito5::AST::Apply') && ($decl->code() eq 'infix:<=>'))) {
                    ((my  $var) = $decl->arguments()->[0]);
                    if ((($var->isa('Perlito5::AST::Decl') && ($var->decl() eq $type)) || ($decl->isa('Perlito5::AST::Apply') && ($decl->code() eq $type)))) {
                        return (1)
                    }
                }
            }
        };
        return (0)
    };
    sub Perlito5::Javascript2::LexicalBlock::emit_javascript2 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        ((my  $wantarray) = shift());
        (my  @block);
        for (@{$self->{'block'}}) {
            if (defined($_)) {
                push(@block, $_ )
            }
        };
        if (!(@block)) {
            return ((Perlito5::Javascript2::tab($level) . 'null;'))
        };
        ((my  $out) = '');
        (my  @str);
        ((my  $has_local) = $self->has_decl('local'));
        ((my  $create_context) = ($self->{'create_context'} && $self->has_decl('my')));
        ((my  $outer_pkg) = $Perlito5::PKG_NAME);
        ((my  $outer_throw) = $Perlito5::THROW);
        unshift(@{$Perlito5::VAR}, {});
        if ($self->{'top_level'}) {
            ($Perlito5::THROW = 0)
        };
        if ($has_local) {
            ($out = ($out . (Perlito5::Javascript2::tab($level) . 'var local_idx = p5LOCAL.length;' . chr(10))))
        };
        if ($self->{'top_level'}) {
            ($level)++
        };
        if ($create_context) {
            ($out = ($out . (Perlito5::Javascript2::tab($level) . '(function () {' . chr(10))));
            ($level)++
        };
        ((my  $tab) = Perlito5::Javascript2::tab($level));
        (my  $last_statement);
        if ($self->{'needs_return'}) {
            ($last_statement = pop(@block))
        };
        for my $decl (@block) {
            if (((ref($decl) eq 'Perlito5::AST::Apply') && ($decl->code() eq 'package'))) {
                ($Perlito5::PKG_NAME = $decl->{'namespace'});
                ($Perlito5::VAR->[0]->{'$_'} = {'decl', 'our', 'namespace', $Perlito5::PKG_NAME});
                ($Perlito5::VAR->[0]->{'$a'} = {'decl', 'our', 'namespace', $Perlito5::PKG_NAME});
                ($Perlito5::VAR->[0]->{'$b'} = {'decl', 'our', 'namespace', $Perlito5::PKG_NAME});
                ($Perlito5::VAR->[0]->{'$AUTOLOAD'} = {'decl', 'our', 'namespace', $Perlito5::PKG_NAME})
            };
            if ($decl->isa('Perlito5::AST::Decl')) {
                push(@str, $decl->emit_javascript2_init() )
            };
            if (($decl->isa('Perlito5::AST::Apply') && ($decl->code() eq 'my'))) {
                for (@{$decl->{'arguments'}}) {
                    if ($_->isa('Perlito5::AST::Var')) {
                        ((my  $d) = Perlito5::AST::Decl->new('decl', $decl->code(), 'var', $_));
                        push(@str, $d->emit_javascript2_init() )
                    }
                }
            };
            if (($decl->isa('Perlito5::AST::Apply') && ($decl->code() eq 'infix:<=>'))) {
                ((my  $arg) = $decl->{'arguments'}->[0]);
                if ($arg->isa('Perlito5::AST::Decl')) {
                    push(@str, $arg->emit_javascript2_init() )
                };
                if (($arg->isa('Perlito5::AST::Apply') && ($arg->code() eq 'my'))) {
                    for (@{$arg->{'arguments'}}) {
                        if ($_->isa('Perlito5::AST::Var')) {
                            ((my  $d) = Perlito5::AST::Decl->new('decl', $arg->code(), 'var', $_));
                            push(@str, $d->emit_javascript2_init() )
                        }
                    }
                }
            };
            if (!((($decl->isa('Perlito5::AST::Decl') && ($decl->decl() eq 'my'))))) {
                push(@str, ($decl->emit_javascript2($level, 'void') . ';') )
            }
        };
        if (($self->{'needs_return'} && $last_statement)) {
            if ($last_statement->isa('Perlito5::AST::Decl')) {
                push(@str, $last_statement->emit_javascript2_init() )
            };
            if (($last_statement->isa('Perlito5::AST::Apply') && ($last_statement->code() eq 'infix:<=>'))) {
                if ($last_statement->{'arguments'}->[0]->isa('Perlito5::AST::Decl')) {
                    push(@str, $last_statement->{'arguments'}->[0]->emit_javascript2_init() )
                }
            };
            if (((($last_statement->isa('Perlito5::AST::Apply') && ($last_statement->code() eq 'return')) && $self->{'top_level'}) && @{$last_statement->{'arguments'}})) {
                ($last_statement = $last_statement->{'arguments'}->[0])
            };
            if ($last_statement->isa('Perlito5::AST::If')) {
                ((my  $cond) = $last_statement->cond());
                ((my  $body) = $last_statement->body());
                ((my  $otherwise) = $last_statement->otherwise());
                ($body = Perlito5::Javascript2::LexicalBlock->new('block', $body->stmts(), 'needs_return', 1));
                push(@str, ('if ( ' . Perlito5::Javascript2::to_bool($cond, ($level + 1)) . ' ) {' . chr(10) . $body->emit_javascript2(($level + 1)) . chr(10) . Perlito5::Javascript2::tab($level) . '}') );
                if ($otherwise) {
                    ($otherwise = Perlito5::Javascript2::LexicalBlock->new('block', $otherwise->stmts(), 'needs_return', 1));
                    push(@str, (chr(10) . Perlito5::Javascript2::tab($level) . 'else {' . chr(10) . $otherwise->emit_javascript2(($level + 1)) . chr(10) . Perlito5::Javascript2::tab($level) . '}') )
                }
            }
            else {
                if ($last_statement->isa('Perlito5::AST::Lit::Block')) {
                    ((my  $body) = Perlito5::Javascript2::LexicalBlock->new('block', $last_statement->{'stmts'}, 'needs_return', 1));
                    push(@str, ('for (var i_ = 0; i_ < 1 ; i_++) {' . chr(10) . $body->emit_javascript2(($level + 1)) . chr(10) . Perlito5::Javascript2::tab($level) . '}') )
                }
                else {
                    if (((($last_statement->isa('Perlito5::AST::For') || $last_statement->isa('Perlito5::AST::While')) || ($last_statement->isa('Perlito5::AST::Apply') && ($last_statement->code() eq 'goto'))) || ($last_statement->isa('Perlito5::AST::Apply') && ($last_statement->code() eq 'return')))) {
                        push(@str, $last_statement->emit_javascript2($level, 'runtime') )
                    }
                    else {
                        if ($has_local) {
                            push(@str, ('return p5cleanup_local(local_idx, (' . Perlito5::Javascript2::to_runtime_context([$last_statement], $level) . '));') )
                        }
                        else {
                            push(@str, ('return (' . Perlito5::Javascript2::to_runtime_context([$last_statement], $level) . ');') )
                        }
                    }
                }
            }
        };
        if ($has_local) {
            push(@str, 'p5cleanup_local(local_idx, null);' )
        };
        if ($create_context) {
            ($level)--;
            push(@str, '})();' )
        };
        if (($self->{'top_level'} && $Perlito5::THROW)) {
            ($level)--;
            ($out = ($out . (Perlito5::Javascript2::tab($level) . 'try {' . chr(10) . join(chr(10), map(($tab . $_), @str)) . chr(10) . Perlito5::Javascript2::tab($level) . '}' . chr(10) . Perlito5::Javascript2::tab($level) . 'catch(err) {' . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . 'if ( err instanceof Error ) {' . chr(10) . Perlito5::Javascript2::tab(($level + 2)) . 'throw(err);' . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . '}' . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . 'else {' . chr(10) . Perlito5::Javascript2::tab(($level + 2)) . (($has_local ? 'return p5cleanup_local(local_idx, err)' : 'return(err)')) . ';' . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . '}' . chr(10) . Perlito5::Javascript2::tab($level) . '}')))
        }
        else {
            ($out = ($out . join(chr(10), map(($tab . $_), @str))))
        };
        ($Perlito5::PKG_NAME = $outer_pkg);
        if ($self->{'top_level'}) {
            ($Perlito5::THROW = $outer_throw)
        };
        shift(@{$Perlito5::VAR});
        return ($out)
    }
}};
package Perlito5::AST::CompUnit;
do {{
    sub Perlito5::AST::CompUnit::emit_javascript2 {
        ((my  $self) = $_[0]);
        ((my  $level) = $_[1]);
        ((my  $str) = ('(function () {' . chr(10) . Perlito5::Javascript2::LexicalBlock->new('block', $self->{'body'}, 'needs_return', 0)->emit_javascript2(($level + 1)) . chr(10) . Perlito5::Javascript2::tab($level) . '})()' . chr(10)));
        return ($str)
    };
    sub Perlito5::AST::CompUnit::emit_javascript2_program {
        ((my  $comp_units) = shift());
        ($Perlito5::PKG_NAME = 'main');
        ((my  $str) = ('' . 'var p5want = null;' . chr(10) . 'var ' . Perlito5::Javascript2::pkg_new_var() . ' = p5pkg[' . chr(39) . $Perlito5::PKG_NAME . chr(39) . '];' . chr(10)));
        ($Perlito5::VAR = [{'@_', {'decl', 'my'}, '$@', {'decl', 'our', 'namespace', 'main'}, '$|', {'decl', 'our', 'namespace', 'main'}, '$^O', {'decl', 'our', 'namespace', 'main'}, '%ENV', {'decl', 'our', 'namespace', 'main'}, '%INC', {'decl', 'our', 'namespace', 'main'}, '@#', {'decl', 'our', 'namespace', 'main'}, '@ARGV', {'decl', 'our', 'namespace', 'main'}, '@INC', {'decl', 'our', 'namespace', 'main'}, '$_', {'decl', 'our', 'namespace', $Perlito5::PKG_NAME}, '$a', {'decl', 'our', 'namespace', $Perlito5::PKG_NAME}, '$b', {'decl', 'our', 'namespace', $Perlito5::PKG_NAME}, '$AUTOLOAD', {'decl', 'our', 'namespace', $Perlito5::PKG_NAME}}]);
        for my $comp_unit (@{$comp_units}) {
            ($str = ($str . $comp_unit->emit_javascript2() . chr(10)))
        };
        return ($str)
    }
}};
package Perlito5::AST::Val::Int;
do {{
    sub Perlito5::AST::Val::Int::emit_javascript2 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        $self->{        'int'}
    }
}};
package Perlito5::AST::Val::Num;
do {{
    sub Perlito5::AST::Val::Num::emit_javascript2 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        $self->{        'num'}
    }
}};
package Perlito5::AST::Val::Buf;
do {{
    sub Perlito5::AST::Val::Buf::emit_javascript2 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        Perlito5::Javascript2::escape_string($self->{'buf'})
    }
}};
package Perlito5::AST::Lit::Block;
do {{
    sub Perlito5::AST::Lit::Block::emit_javascript2 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        ((my  $init) = '');
        if (($self->{'name'} eq 'INIT')) {
            ((my  $tmp) = ('p5pkg.main._tmp' . Perlito5::Javascript2::get_label()));
            ($init = (Perlito5::Javascript2::tab(($level + 2)) . ('if (' . $tmp . ') { return }; ' . $tmp . ' = 1;' . chr(10))))
        };
        return (('p5for_lex(' . 'function () {' . chr(10) . $init . (Perlito5::Javascript2::LexicalBlock->new('block', $self->{'stmts'}, 'needs_return', 0, 'top_level', 0))->emit_javascript2(($level + 2)) . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . '}, ' . '[0], ' . $self->emit_javascript2_continue($level) . ', ' . '"' . (($self->{'label'} || '')) . '"' . ')'))
    };
    sub Perlito5::AST::Lit::Block::emit_javascript2_continue {
        ((my  $self) = shift());
        ((my  $level) = shift());
        if ((!($self->{'continue'}) || !(@{$self->{'continue'}->{'stmts'}}))) {
            return ('false')
        };
        return (('function () {' . chr(10) . (Perlito5::Javascript2::LexicalBlock->new('block', $self->{'continue'}->stmts(), 'needs_return', 0, 'top_level', 0))->emit_javascript2(($level + 2)) . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . '}'))
    }
}};
package Perlito5::AST::Index;
do {{
    sub Perlito5::AST::Index::emit_javascript2 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        if (($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '$'))) {
            ((my  $v) = Perlito5::AST::Var->new('sigil', '@', 'namespace', $self->{'obj'}->namespace(), 'name', $self->{'obj'}->name()));
            return (($v->emit_javascript2($level) . '[' . 'p5idx(' . $v->emit_javascript2($level) . ',' . Perlito5::Javascript2::to_num($self->{'index_exp'}, $level) . ')' . ']'))
        };
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && ($self->{'obj'}->{'code'} eq 'prefix:<$>'))) {
            return (Perlito5::AST::Call->new('method', 'postcircumfix:<[ ]>', 'invocant', $self->{'obj'}->{'arguments'}->[0], 'arguments', $self->{'index_exp'})->emit_javascript2($level))
        };
        (Perlito5::Javascript2::emit_javascript2_autovivify($self->{'obj'}, $level, 'array') . '._array_[' . 'p5idx(' . Perlito5::Javascript2::emit_javascript2_autovivify($self->{'obj'}, $level, 'array') . '._array_,' . Perlito5::Javascript2::to_num($self->{'index_exp'}, $level) . ')' . ']')
    }
}};
package Perlito5::AST::Lookup;
do {{
    sub Perlito5::AST::Lookup::emit_javascript2 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        if (($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '$'))) {
            ((my  $v) = Perlito5::AST::Var->new('sigil', '%', 'namespace', $self->{'obj'}->namespace(), 'name', $self->{'obj'}->name()));
            return (($v->emit_javascript2($level) . '[' . $self->autoquote($self->{'index_exp'})->emit_javascript2($level) . ']'))
        };
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && ($self->{'obj'}->{'code'} eq 'prefix:<$>'))) {
            return (Perlito5::AST::Call->new('method', 'postcircumfix:<{ }>', 'invocant', $self->{'obj'}->{'arguments'}->[0], 'arguments', $self->{'index_exp'})->emit_javascript2($level))
        };
        (Perlito5::Javascript2::emit_javascript2_autovivify($self->{'obj'}, $level, 'hash') . '._hash_[' . $self->autoquote($self->{'index_exp'})->emit_javascript2($level) . ']')
    }
}};
package Perlito5::AST::Var;
do {{
    ((my  $table) = {'$', 'v_', '@', 'List_', '%', 'Hash_', '&', ''});
    sub Perlito5::AST::Var::emit_javascript2 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        ((my  $wantarray) = shift());
        ((my  $str_name) = $self->{'name'});
        if (($str_name eq chr(92))) {
            ($str_name = chr(92) . chr(92))
        };
        if (($str_name eq '"')) {
            ($str_name = chr(92) . '"')
        };
        ((my  $perl5_name) = $self->perl5_name_javascript2());
        (my  $decl_type);
        ((my  $decl) = $self->perl5_get_decl_javascript2($perl5_name));
        if ($decl) {
            ($decl_type = $decl->{'decl'})
        }
        else {
            if ((!($self->{'namespace'}) && ($self->{'sigil'} ne '*'))) {
                if ($Perlito5::STRICT) {
                    die(('Global symbol "' . $perl5_name . '" requires explicit package name'))
                };
                ($decl_type = 'our');
                ($self->{'namespace'} = $Perlito5::PKG_NAME);
                ((my  $sigil) = (($self->{'sigil'} eq '$#') ? '@' : $self->{'sigil'}));
                ((my  $s) = ('p5pkg["' . $self->{'namespace'} . '"]["' . $table->{$sigil} . $str_name . '"]'));
                if (($sigil eq '@')) {
                    ($s = ($s . ' || (' . $s . ' = [])'));
                    ($s = ('p5pkg[' . $s . ', "' . $self->{'namespace'} . '"]["' . $table->{$sigil} . $str_name . '"]'));
                    if ((($self->{'sigil'} eq '@') && ($wantarray eq 'scalar'))) {
                        ($s = ($s . '.length'))
                    }
                }
                else {
                    if (($sigil eq '%')) {
                        ($s = ($s . ' || (' . $s . ' = {})'));
                        ($s = ('p5pkg[' . $s . ', "' . $self->{'namespace'} . '"]["' . $table->{$sigil} . $str_name . '"]'))
                    }
                };
                if (($self->{'sigil'} eq '$#')) {
                    return (('(' . $s . '.length - 1)'))
                };
                return ($s)
            }
        };
        if (($self->{'sigil'} eq '@')) {
            if (($wantarray eq 'scalar')) {
                return (($self->emit_javascript2($level, 'list') . '.length'))
            };
            if (($wantarray eq 'runtime')) {
                return (('(p5want' . ' ? ' . $self->emit_javascript2($level, 'list') . ' : ' . $self->emit_javascript2($level, 'list') . '.length' . ')'))
            }
        };
        if (($self->{'sigil'} eq '&')) {
            return (('p5pkg["' . (($self->{'namespace'} || $Perlito5::PKG_NAME)) . '"]["' . $str_name . '"]'))
        };
        if (($self->{'sigil'} eq '*')) {
            return (('p5pkg["' . (($self->{'namespace'} || $Perlito5::PKG_NAME)) . '"]["' . $str_name . '"]'))
        };
        if (($decl_type eq 'our')) {
            ((my  $sigil) = (($self->{'sigil'} eq '$#') ? '@' : $self->{'sigil'}));
            ((my  $s) = ('p5pkg["' . (($self->{'namespace'} || $decl->{'namespace'})) . '"]["' . $table->{$sigil} . $str_name . '"]'));
            if (($self->{'sigil'} eq '$#')) {
                return (('(' . $s . '.length - 1)'))
            };
            return ($s)
        };
        ((my  $ns) = '');
        if ($self->{'namespace'}) {
            ($ns = ('p5pkg["' . $self->{'namespace'} . '"]'));
            if (($self->{'sigil'} eq '$#')) {
                return (('(' . $ns . '["' . $table->{'@'} . $str_name . '"].length - 1)'))
            };
            return (($ns . '["' . $table->{$self->{'sigil'}} . $str_name . '"]'))
        };
        if (($self->{'sigil'} eq '$#')) {
            return (('(' . $ns . $table->{'@'} . $str_name . '.length - 1)'))
        };
        ($ns . $table->{$self->{'sigil'}} . $str_name)
    };
    sub Perlito5::AST::Var::perl5_name_javascript2 {
        ((my  $self) = shift());
        ((my  $sigil) = $self->{'sigil'});
        if (($sigil eq '$#')) {
            ($sigil = '@')
        };
        ($sigil . (($self->{'namespace'} ? ($self->{'namespace'} . '::') : '')) . $self->{'name'})
    };
    sub Perlito5::AST::Var::perl5_get_decl_javascript2 {
        ((my  $self) = shift());
        ((my  $perl5_name) = shift());
        for (@{$Perlito5::VAR}) {
            if (exists($_->{$perl5_name})) {
                return ($_->{$perl5_name})
            }
        };
        return (undef())
    }
}};
package Perlito5::AST::Decl;
do {{
    sub Perlito5::AST::Decl::emit_javascript2 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        $self->{'var'}->emit_javascript2($level)
    };
    sub Perlito5::AST::Decl::emit_javascript2_init {
        ((my  $self) = shift());
        ((my  $env) = {'decl', $self->{'decl'}});
        ((my  $perl5_name) = $self->{'var'}->perl5_name_javascript2());
        if (($self->{'decl'} ne 'my')) {
            if ((($self->{'decl'} eq 'our') && $self->{'var'}->{'namespace'})) {
                die(('No package name allowed for variable ' . $perl5_name . ' in "our"'))
            };
            if (($self->{'var'}->{'namespace'} eq '')) {
                ((my  $decl_namespace) = '');
                ((my  $decl) = $self->{'var'}->perl5_get_decl_javascript2($perl5_name));
                if (((($self->{'decl'} eq 'local') && $decl) && ((($decl->{'decl'} eq 'our') || ($decl->{'decl'} eq 'local'))))) {
                    ($decl_namespace = $decl->{'namespace'})
                };
                ($env->{'namespace'} = ($decl_namespace || $Perlito5::PKG_NAME))
            }
        };
        ($Perlito5::VAR->[0]->{$perl5_name} = $env);
        if (($self->{'decl'} eq 'my')) {
            ((my  $str) = '');
            ($str = ($str . 'var ' . $self->{'var'}->emit_javascript2() . ' = '));
            if (($self->{'var'}->sigil() eq '%')) {
                ($str = ($str . '{};'))
            }
            else {
                if (($self->{'var'}->sigil() eq '@')) {
                    ($str = ($str . '[];'))
                }
                else {
                    ($str = ($str . 'null;'))
                }
            };
            return ($str)
        }
        else {
            if (($self->{'decl'} eq 'our')) {
                return (('// our ' . $self->{'var'}->emit_javascript2()))
            }
            else {
                if (($self->{'decl'} eq 'local')) {
                    ((my  $perl5_name) = $self->{'var'}->perl5_name_javascript2());
                    ((my  $decl_namespace) = '');
                    ((my  $decl) = $self->{'var'}->perl5_get_decl_javascript2($perl5_name));
                    if (($decl && ((($decl->{'decl'} eq 'our') || ($decl->{'decl'} eq 'local'))))) {
                        ($decl_namespace = $decl->{'namespace'})
                    };
                    ((my  $ns) = ('p5pkg["' . ((($self->{'var'}->{'namespace'} || $decl_namespace) || $Perlito5::PKG_NAME)) . '"]'));
                    return (('p5set_local(' . $ns . ',' . Perlito5::Javascript2::escape_string($self->{'var'}->{'name'}) . ',' . Perlito5::Javascript2::escape_string($self->{'var'}->{'sigil'}) . '); '))
                }
                else {
                    if (($self->{'decl'} eq 'state')) {
                        return (('// state ' . $self->{'var'}->emit_javascript2()))
                    }
                    else {
                        die(('not implemented: Perlito5::AST::Decl ' . chr(39) . $self->{'decl'} . chr(39)))
                    }
                }
            }
        }
    }
}};
package Perlito5::AST::Proto;
do {{
    sub Perlito5::AST::Proto::emit_javascript2 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        if (($self->{'name'} eq '__PACKAGE__')) {
            return (Perlito5::Javascript2::pkg())
        };
        ('p5pkg["' . $self->{'name'} . '"]')
    }
}};
package Perlito5::AST::Call;
do {{
    sub Perlito5::AST::Call::emit_javascript2 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        ((my  $wantarray) = shift());
        ((my  $meth) = $self->{'method'});
        if (($meth eq 'postcircumfix:<[ ]>')) {
            return ((Perlito5::Javascript2::emit_javascript2_autovivify($self->{'invocant'}, $level, 'array') . '._array_[' . 'p5idx(' . Perlito5::Javascript2::emit_javascript2_autovivify($self->{'invocant'}, $level, 'array') . '._array_,' . Perlito5::Javascript2::to_num($self->{'arguments'}) . ')' . ']'))
        };
        if (($meth eq 'postcircumfix:<{ }>')) {
            return ((Perlito5::Javascript2::emit_javascript2_autovivify($self->{'invocant'}, $level, 'hash') . '._hash_[' . Perlito5::AST::Lookup->autoquote($self->{'arguments'})->emit_javascript2($level, 'list') . ']'))
        };
        ((my  $invocant) = $self->{'invocant'}->emit_javascript2());
        if (($meth eq 'postcircumfix:<( )>')) {
            return (('(' . $invocant . ')(' . Perlito5::Javascript2::to_list($self->{'arguments'}) . ', ' . ((($wantarray eq 'list') ? '1' : (($wantarray eq 'scalar') ? '0' : (($wantarray eq 'void') ? 'null' : 'p5want')))) . ')'))
        };
        if ((ref($meth) eq 'Perlito5::AST::Var')) {
            ($meth = $meth->emit_javascript2())
        }
        else {
            ($meth = ('"' . $meth . '"'))
        };
        return (('p5call(' . $invocant . ', ' . $meth . ', ' . Perlito5::Javascript2::to_list($self->{'arguments'}) . ', ' . ((($wantarray eq 'list') ? '1' : (($wantarray eq 'scalar') ? '0' : (($wantarray eq 'void') ? 'null' : 'p5want')))) . ')'))
    }
}};
package Perlito5::AST::Apply;
do {{
    sub Perlito5::AST::Apply::emit_regex_javascript2 {
        ((my  $op) = shift());
        ((my  $var) = shift());
        ((my  $regex) = shift());
        if ($regex->isa('Perlito5::AST::Var')) {
            ($regex = {'code', 'p5:m', 'arguments', [$regex, '']})
        };
        (my  $str);
        ((my  $code) = $regex->{'code'});
        ((my  $regex_args) = $regex->{'arguments'});
        if (($code eq 'p5:s')) {
            ($str = ($var->emit_javascript2() . ' = p5str(' . $var->emit_javascript2() . ').replace(/' . $regex_args->[0]->{'buf'} . '/' . $regex_args->[2] . ', ' . $regex_args->[1]->emit_javascript2() . ')'))
        }
        else {
            if (($code eq 'p5:m')) {
                ((my  $ast) = $regex_args->[0]);
                if ($ast->isa('Perlito5::AST::Val::Buf')) {
                    ($str = ('(' . 'p5str(' . $var->emit_javascript2() . ')' . '.match(/' . $ast->{'buf'} . '/' . $regex_args->[1] . ')' . ' ? 1 : 0)'))
                }
                else {
                    ($str = ('(new RegExp(' . $ast->emit_javascript2() . ', ' . '"' . $regex_args->[1] . '"' . '))' . '.exec(' . 'p5str(' . $var->emit_javascript2() . ')' . ')'))
                }
            }
            else {
                if (($code eq 'p5:tr')) {
                    ($str = ('p5tr(' . $var->emit_javascript2() . ', ' . $regex_args->[0]->emit_javascript2() . ', ' . $regex_args->[1]->emit_javascript2() . ')'))
                }
                else {
                    die(('Error: regex emitter - unknown operator ' . $code))
                }
            }
        };
        if (($op eq '=~')) {
            return ($str)
        };
        if (($op eq '!~')) {
            return (('!(' . $str . ')'))
        };
        die('Error: regex emitter')
    };
    ((my  %emit_js) = ('infix:<=~>', sub {
    ((my  $self) = $_[0]);
    emit_regex_javascript2('=~', $self->{'arguments'}->[0], $self->{'arguments'}->[1])
}, 'infix:<!~>', sub {
    ((my  $self) = $_[0]);
    emit_regex_javascript2('!~', $self->{'arguments'}->[0], $self->{'arguments'}->[1])
}, 'p5:s', sub {
    ((my  $self) = $_[0]);
    emit_regex_javascript2('=~', Perlito5::AST::Var->new('sigil', '$', 'namespace', '', 'name', '_'), $self)
}, 'p5:m', sub {
    ((my  $self) = $_[0]);
    emit_regex_javascript2('=~', Perlito5::AST::Var->new('sigil', '$', 'namespace', '', 'name', '_'), $self)
}, 'p5:tr', sub {
    ((my  $self) = $_[0]);
    emit_regex_javascript2('=~', Perlito5::AST::Var->new('sigil', '$', 'namespace', '', 'name', '_'), $self)
}, '__PACKAGE__', sub {
    ((my  $self) = $_[0]);
    ('"' . $Perlito5::PKG_NAME . '"')
}, 'wantarray', sub {
    ((my  $self) = $_[0]);
    'p5want'
}, 'package', sub {
    ((my  $self) = $_[0]);
    ('var ' . Perlito5::Javascript2::pkg_new_var() . ' = p5make_package("' . $self->{'namespace'} . '")')
}, 'infix:<=>>', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    (Perlito5::AST::Lookup->autoquote($self->{'arguments'}->[0])->emit_javascript2($level) . ', ' . $self->{'arguments'}->[1]->emit_javascript2($level))
}, 'infix:<cmp>', sub {
    ((my  $self) = $_[0]);
    ('p5cmp(' . join(', ', map(Perlito5::Javascript2::to_str($_), @{$self->{'arguments'}})) . ')')
}, 'infix:<<=>>', sub {
    ((my  $self) = $_[0]);
    ('p5cmp(' . join(', ', map(Perlito5::Javascript2::to_num($_), @{$self->{'arguments'}})) . ')')
}, 'infix:<**>', sub {
    ((my  $self) = $_[0]);
    ('Math.pow(' . join(', ', map(Perlito5::Javascript2::to_num($_), @{$self->{'arguments'}})) . ')')
}, 'prefix:<!>', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ('!( ' . Perlito5::Javascript2::to_bool($self->{'arguments'}->[0], $level) . ')')
}, 'prefix:<not>', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ('!( ' . Perlito5::Javascript2::to_bool($self->{'arguments'}->[0], $level) . ')')
}, 'prefix:<~>', sub {
    ((my  $self) = $_[0]);
    ('p5complement( ' . Perlito5::Javascript2::to_num($self->{'arguments'}->[0]) . ')')
}, 'prefix:<->', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    ('-( ' . $self->{'arguments'}->[0]->emit_javascript2($level, 'scalar') . ')')
}, 'prefix:<+>', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    ('(' . $self->{'arguments'}->[0]->emit_javascript2($level, $wantarray) . ')')
}, 'require', sub {
    ((my  $self) = $_[0]);
    ('p5pkg["Perlito5::Grammar::Use"]["require"]([' . Perlito5::Javascript2::to_str($self->{'arguments'}->[0]) . ', ' . (($self->{'arguments'}->[0]->{'bareword'} ? 1 : 0)) . '])')
}, 'prefix:<$>', sub {
    ((my  $self) = $_[0]);
    ((my  $arg) = $self->{'arguments'}->[0]);
    (Perlito5::Javascript2::emit_javascript2_autovivify($arg, $level, 'scalar') . '._scalar_')
}, 'prefix:<@>', sub {
    ((my  $self) = $_[0]);
    ((my  $level) = $_[1]);
    ((my  $arg) = $self->{'arguments'}->[0]);
    (Perlito5::Javascript2::emit_javascript2_autovivify($arg, $level, 'array') . '._array_')
}, 'prefix:<$#>', sub {
    ((my  $self) = $_[0]);
    ((my  $level) = $_[1]);
    ((my  $arg) = $self->{'arguments'}->[0]);
    ('(' . Perlito5::Javascript2::emit_javascript2_autovivify($arg, $level, 'array') . '._array_.length - 1)')
}, 'prefix:<%>', sub {
    ((my  $self) = $_[0]);
    ((my  $level) = $_[1]);
    ((my  $arg) = $self->{'arguments'}->[0]);
    (Perlito5::Javascript2::emit_javascript2_autovivify($arg, $level, 'hash') . '._hash_')
}, 'prefix:<&>', sub {
    ((my  $self) = $_[0]);
    ((my  $level) = $_[1]);
    ((my  $arg) = $self->{'arguments'}->[0]);
    ('p5code_lookup_by_name("' . $Perlito5::PKG_NAME . '", ' . $arg->emit_javascript2($level) . ')')
}, 'circumfix:<[ ]>', sub {
    ((my  $self) = $_[0]);
    ('(new p5ArrayRef(' . Perlito5::Javascript2::to_list($self->{'arguments'}) . '))')
}, 'circumfix:<{ }>', sub {
    ((my  $self) = $_[0]);
    ('(new p5HashRef(' . Perlito5::Javascript2::to_list($self->{'arguments'}, $level, 'hash') . '))')
}, 'prefix:<' . chr(92) . '>', sub {
    ((my  $self) = $_[0]);
    ((my  $level) = $_[1]);
    ((my  $arg) = $self->{'arguments'}->[0]);
    if ($arg->isa('Perlito5::AST::Var')) {
        if (($arg->sigil() eq '@')) {
            return (('(new p5ArrayRef(' . $arg->emit_javascript2($level) . '))'))
        };
        if (($arg->sigil() eq '%')) {
            return (('(new p5HashRef(' . $arg->emit_javascript2($level) . '))'))
        };
        if (($arg->sigil() eq '*')) {
            return (('(new p5GlobRef(' . $arg->emit_javascript2($level) . '))'))
        };
        if (($arg->sigil() eq '&')) {
            if ($arg->{'namespace'}) {
                return (('p5pkg["' . $arg->{'namespace'} . '"].' . $arg->{'name'}))
            }
            else {
                return ((Perlito5::Javascript2::pkg() . '.' . $arg->{'name'}))
            }
        }
    };
    return (('(new p5ScalarRef(' . $arg->emit_javascript2($level) . '))'))
}, 'postfix:<++>', sub {
    ((my  $self) = $_[0]);
    ('(' . join(' ', map($_->emit_javascript2(), @{$self->{'arguments'}})) . ')++')
}, 'postfix:<-->', sub {
    ((my  $self) = $_[0]);
    ('(' . join(' ', map($_->emit_javascript2(), @{$self->{'arguments'}})) . ')--')
}, 'prefix:<++>', sub {
    ((my  $self) = $_[0]);
    ('++(' . join(' ', map($_->emit_javascript2(), @{$self->{'arguments'}})) . ')')
}, 'prefix:<-->', sub {
    ((my  $self) = $_[0]);
    ('--(' . join(' ', map($_->emit_javascript2(), @{$self->{'arguments'}})) . ')')
}, 'infix:<x>', sub {
    ((my  $self) = $_[0]);
    ('p5str_replicate(' . join(', ', map($_->emit_javascript2(), @{$self->{'arguments'}})) . ')')
}, 'list:<.>', sub {
    ((my  $self) = $_[0]);
    ('(' . join(' + ', map(Perlito5::Javascript2::to_str($_), @{$self->{'arguments'}})) . ')')
}, 'list:<,>', sub {
    ((my  $self) = $_[0]);
    Perlito5::Javascript2::to_list($self->{'arguments'})
}, 'infix:<..>', sub {
    ((my  $self) = $_[0]);
    ('(function (a) { ' . 'for (var i=' . $self->{'arguments'}->[0]->emit_javascript2() . ', l=' . $self->{'arguments'}->[1]->emit_javascript2() . '; ' . 'i<=l; ++i)' . '{ ' . 'a.push(i) ' . '}; ' . 'return a ' . '})([])')
}, 'delete', sub {
    ((my  $self) = $_[0]);
    ('(delete ' . $self->{'arguments'}->[0]->emit_javascript2() . ')')
}, 'scalar', sub {
    ((my  $self) = $_[0]);
    Perlito5::Javascript2::to_scalar($self->{'arguments'}, ($level + 1))
}, 'ternary:<? :>', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    ('( ' . Perlito5::Javascript2::to_bool($self->{'arguments'}->[0]) . ' ? ' . ($self->{'arguments'}->[1])->emit_javascript2($level, $wantarray) . ' : ' . ($self->{'arguments'}->[2])->emit_javascript2($level, $wantarray) . ')')
}, 'my', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    ('p5context(' . '[' . join(', ', map($_->emit_javascript2($level, $wantarray), @{$self->{'arguments'}})) . '], ' . ((($wantarray eq 'runtime') ? 'p5want' : (($wantarray eq 'list') ? 1 : 0))) . ')')
}, 'local', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    ('p5context(' . '[' . join(', ', map($_->emit_javascript2($level, $wantarray), @{$self->{'arguments'}})) . '], ' . ((($wantarray eq 'runtime') ? 'p5want' : (($wantarray eq 'list') ? 1 : 0))) . ')')
}, 'circumfix:<( )>', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    ('p5context(' . '[' . join(', ', map($_->emit_javascript2($level, $wantarray), @{$self->{'arguments'}})) . '], ' . ((($wantarray eq 'runtime') ? 'p5want' : (($wantarray eq 'list') ? 1 : 0))) . ')')
}, 'infix:<=>', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    ((my  $parameters) = $self->{'arguments'}->[0]);
    ((my  $arguments) = $self->{'arguments'}->[1]);
    if (($parameters->isa('Perlito5::AST::Apply') && (((($parameters->code() eq 'my') || ($parameters->code() eq 'local')) || ($parameters->code() eq 'circumfix:<( )>'))))) {
        ((my  $tmp) = ('tmp' . Perlito5::Javascript2::get_label()));
        ((my  $tmp2) = ('tmp' . Perlito5::Javascript2::get_label()));
        return (('(function () { ' . 'var ' . $tmp . ' = ' . Perlito5::Javascript2::to_list([$arguments], ($level + 1)) . '; ' . 'var ' . $tmp2 . ' = ' . $tmp . '.slice(0); ' . join('; ', (map(+(((($_->isa('Perlito5::AST::Apply') && ($_->code() eq 'undef')) ? ($tmp . '.shift()') : (($_->sigil() eq '$') ? ($_->emit_javascript2() . ' = ' . $tmp . '.shift()') : (($_->sigil() eq '@') ? ($_->emit_javascript2() . ' = ' . $tmp . '; ' . $tmp . ' = []') : (($_->sigil() eq '%') ? ($_->emit_javascript2() . ' = p5a_to_h(' . $tmp . '); ' . $tmp . ' = []') : die('not implemented'))))))), @{$parameters->arguments()})),('return ' . $tmp2)) . ' })()'))
    };
    if ((($parameters->isa('Perlito5::AST::Var') && ($parameters->sigil() eq '$')) || ($parameters->isa('Perlito5::AST::Decl') && ($parameters->var()->sigil() eq '$')))) {
        return (('(' . $parameters->emit_javascript2() . ' = ' . Perlito5::Javascript2::to_scalar([$arguments], ($level + 1)) . ')'))
    };
    if ((($parameters->isa('Perlito5::AST::Var') && ($parameters->sigil() eq '@')) || ($parameters->isa('Perlito5::AST::Decl') && ($parameters->var()->sigil() eq '@')))) {
        return (('(' . $parameters->emit_javascript2() . ' = ' . Perlito5::Javascript2::to_list([$arguments], ($level + 1)) . ')'))
    }
    else {
        if ((($parameters->isa('Perlito5::AST::Var') && ($parameters->sigil() eq '%')) || ($parameters->isa('Perlito5::AST::Decl') && ($parameters->var()->sigil() eq '%')))) {
            return (('(' . $parameters->emit_javascript2() . ' = ' . Perlito5::Javascript2::to_list([$arguments], ($level + 1), 'hash') . ')'))
        }
    };
    ('(' . $parameters->emit_javascript2($level) . ' = ' . $arguments->emit_javascript2(($level + 1)) . ')')
}, 'break', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ($Perlito5::THROW = 1);
    'throw(new p5_error("break", ""))'
}, 'next', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ($Perlito5::THROW = 1);
    ((my  $label) = ($self->{'arguments'}->[0]->{'code'} || ''));
    ('throw(new p5_error("next", "' . $label . '"))')
}, 'last', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ($Perlito5::THROW = 1);
    ((my  $label) = ($self->{'arguments'}->[0]->{'code'} || ''));
    ('throw(new p5_error("last", "' . $label . '"))')
}, 'redo', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ($Perlito5::THROW = 1);
    ((my  $label) = ($self->{'arguments'}->[0]->{'code'} || ''));
    ('throw(new p5_error("redo", "' . $label . '"))')
}, 'return', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ($Perlito5::THROW = 1);
    ('throw(' . Perlito5::Javascript2::to_runtime_context($self->{'arguments'}, $level) . ')')
}, 'goto', sub {
    ((my  $self) = $_[0]);
    ($Perlito5::THROW = 1);
    ('throw((' . $self->{'arguments'}->[0]->emit_javascript2() . ')([List__, p5want]))')
}, 'do', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    ((my  $ast) = Perlito5::AST::Apply->new('code', 'eval', 'namespace', '', 'arguments', [Perlito5::AST::Apply->new('code', 'slurp', 'namespace', 'Perlito5::IO', 'arguments', $self->{'arguments'})]));
    $ast->emit_javascript2($level)
}, 'eval', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    ($Perlito5::THROW = 1);
    ((my  $arg) = $self->{'arguments'}->[0]);
    (my  $eval);
    if ($arg->isa('Perlito5::AST::Do')) {
        ($eval = $arg->emit_javascript2(($level + 1), $wantarray))
    }
    else {
        ((my  $var_env_perl5) = Perlito5::Dumper::Dumper($Perlito5::VAR));
        ((my  $m) = Perlito5::Expression->term_square($var_env_perl5, 0));
        ($m = Perlito5::Expression::expand_list(Perlito5::Match::flat($m)->[2]));
        ((my  $var_env_js) = ('(new p5ArrayRef(' . Perlito5::Javascript2::to_list($m) . '))'));
        ($eval = ('eval(perl5_to_js(' . Perlito5::Javascript2::to_str($arg) . ', ' . '"' . $Perlito5::PKG_NAME . '", ' . $var_env_js . ', ' . '"' . $wantarray . '"' . '))'))
    };
    ('(function (p5want) {' . chr(10) . 'var r = null;' . chr(10) . 'p5pkg["main"]["v_@"] = "";' . chr(10) . 'try {' . chr(10) . 'r = ' . $eval . chr(10) . '}' . chr(10) . 'catch(err) {' . chr(10) . 'if ( err instanceof p5_error ) {' . chr(10) . 'p5pkg["main"]["v_@"] = err;' . chr(10) . '}' . chr(10) . 'else if ( err instanceof Error ) {' . chr(10) . 'p5pkg["main"]["v_@"] = err;' . chr(10) . '}' . chr(10) . 'else {' . chr(10) . 'return(err);' . chr(10) . '}' . chr(10) . '}' . chr(10) . 'return r;' . chr(10) . '})(' . ((($wantarray eq 'list') ? '1' : (($wantarray eq 'scalar') ? '0' : (($wantarray eq 'void') ? 'null' : 'p5want')))) . ')')
}, 'undef', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    if (($self->{'arguments'} && @{$self->{'arguments'}})) {
        return (('(' . $self->{'arguments'}->[0]->emit_javascript2() . ' = null)'))
    };
    return ('null')
}, 'defined', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    ('(' . join(' ', map($_->emit_javascript2($level), @{$self->{'arguments'}})) . ' != null)')
}, 'shift', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    if (($self->{'arguments'} && @{$self->{'arguments'}})) {
        return ((Perlito5::Javascript2::pkg() . '.shift([' . join(', ', map($_->emit_javascript2($level), @{$self->{'arguments'}})) . '])'))
    };
    return ((Perlito5::Javascript2::pkg() . '.shift([List__])'))
}, 'map', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    ((my  @in) = @{$self->{'arguments'}});
    ((my  $fun) = shift(@in));
    ((my  $list) = Perlito5::Javascript2::to_list(\@in));
    if ((ref($fun) eq 'Perlito5::AST::Lit::Block')) {
        ($fun = $fun->{'stmts'})
    }
    else {
        ($fun = [$fun])
    };
    ('p5map(' . Perlito5::Javascript2::pkg() . ', ' . 'function (p5want) {' . chr(10) . (Perlito5::Javascript2::LexicalBlock->new('block', $fun, 'needs_return', 1, 'top_level', 0))->emit_javascript2(($level + 1)) . chr(10) . Perlito5::Javascript2::tab($level) . '}, ' . $list . ')')
}, 'grep', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    ((my  @in) = @{$self->{'arguments'}});
    ((my  $fun) = shift(@in));
    ((my  $list) = Perlito5::Javascript2::to_list(\@in));
    if ((ref($fun) eq 'Perlito5::AST::Lit::Block')) {
        ($fun = $fun->{'stmts'})
    }
    else {
        ($fun = [$fun])
    };
    ('p5grep(' . Perlito5::Javascript2::pkg() . ', ' . 'function (p5want) {' . chr(10) . (Perlito5::Javascript2::LexicalBlock->new('block', $fun, 'needs_return', 1, 'top_level', 0))->emit_javascript2(($level + 1)) . chr(10) . Perlito5::Javascript2::tab($level) . '}, ' . $list . ')')
}, 'sort', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    ((my  @in) = @{$self->{'arguments'}});
    (my  $fun);
    (my  $list);
    if ((ref($in[0]) eq 'Perlito5::AST::Lit::Block')) {
        ($fun = shift(@in));
        ($fun = ('function (p5want) {' . chr(10) . (Perlito5::Javascript2::LexicalBlock->new('block', $fun->{'stmts'}, 'needs_return', 1, 'top_level', 0))->emit_javascript2(($level + 1)) . chr(10) . Perlito5::Javascript2::tab($level) . '}'))
    }
    else {
        ($fun = 'null')
    };
    ($list = Perlito5::Javascript2::to_list(\@in));
    ('p5sort(' . Perlito5::Javascript2::pkg() . ', ' . $fun . ', ' . $list . ')')
}, 'infix:<//>', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    ('p5defined_or' . '(' . $self->{'arguments'}->[0]->emit_javascript2($level, 'scalar') . ', ' . Perlito5::Javascript2::emit_function_javascript2($level, $wantarray, $self->{'arguments'}->[1]) . ')')
}, 'exists', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    ((my  $arg) = $self->{'arguments'}->[0]);
    if ($arg->isa('Perlito5::AST::Lookup')) {
        ((my  $v) = $arg->obj());
        if (($v->isa('Perlito5::AST::Var') && ($v->sigil() eq '$'))) {
            ($v = Perlito5::AST::Var->new('sigil', '%', 'namespace', $v->namespace(), 'name', $v->name()));
            return (('(' . $v->emit_javascript2() . ').hasOwnProperty(' . $arg->autoquote($arg->{'index_exp'})->emit_javascript2($level) . ')'))
        };
        return (('(' . $v->emit_javascript2() . ')._hash_.hasOwnProperty(' . $arg->autoquote($arg->{'index_exp'})->emit_javascript2($level) . ')'))
    };
    if ($arg->isa('Perlito5::AST::Call')) {
        if (($arg->method() eq 'postcircumfix:<{ }>')) {
            return (('(' . $arg->invocant()->emit_javascript2() . ')._hash_.hasOwnProperty(' . Perlito5::AST::Lookup->autoquote($arg->{'arguments'})->emit_javascript2($level) . ')'))
        }
    }
}));
    sub Perlito5::AST::Apply::emit_javascript2 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        ((my  $wantarray) = shift());
        ((my  $apply) = $self->op_assign());
        if ($apply) {
            return ($apply->emit_javascript2($level))
        };
        ((my  $code) = $self->{'code'});
        if ((ref($code) ne '')) {
            ((my  @args) = ());
            for (@{$self->{'arguments'}}) {
                push(@args, $_->emit_javascript2() )
            };
            return (('(' . $self->{'code'}->emit_javascript2($level) . ')(' . join(',', @args) . ')'))
        };
        if (exists($emit_js{$code})) {
            return ($emit_js{$code}->($self, $level, $wantarray))
        };
        if (exists($Perlito5::Javascript2::op_infix_js_str{$code})) {
            return (('(' . join($Perlito5::Javascript2::op_infix_js_str{$code}, map(Perlito5::Javascript2::to_str($_), @{$self->{'arguments'}})) . ')'))
        };
        if (exists($Perlito5::Javascript2::op_infix_js_num{$code})) {
            return (('(' . join($Perlito5::Javascript2::op_infix_js_num{$code}, map(Perlito5::Javascript2::to_num($_), @{$self->{'arguments'}})) . ')'))
        };
        if (exists($Perlito5::Javascript2::op_prefix_js_str{$code})) {
            return (($Perlito5::Javascript2::op_prefix_js_str{$code} . '(' . Perlito5::Javascript2::to_str($self->{'arguments'}->[0]) . ')'))
        };
        if ((($code eq 'infix:<&&>') || ($code eq 'infix:<and>'))) {
            return (('p5and' . '(' . $self->{'arguments'}->[0]->emit_javascript2($level, 'scalar') . ', ' . Perlito5::Javascript2::emit_function_javascript2($level, $wantarray, $self->{'arguments'}->[1]) . ')'))
        };
        if ((($code eq 'infix:<||>') || ($code eq 'infix:<or>'))) {
            return (('p5or' . '(' . $self->{'arguments'}->[0]->emit_javascript2($level, 'scalar') . ', ' . Perlito5::Javascript2::emit_function_javascript2($level, $wantarray, $self->{'arguments'}->[1]) . ')'))
        };
        if ($self->{'namespace'}) {
            if ((($self->{'namespace'} eq 'JS') && ($code eq 'inline'))) {
                if ($self->{'arguments'}->[0]->isa('Perlito5::AST::Val::Buf')) {
                    return ($self->{'arguments'}->[0]->{'buf'})
                }
                else {
                    die('JS::inline needs a string constant')
                }
            };
            ($code = ('p5pkg["' . $self->{'namespace'} . '"].' . $code))
        }
        else {
            ($code = (Perlito5::Javascript2::pkg() . '.' . $code))
        };
        (my  $sig);
        do {{
            ((my  $name) = $self->{'code'});
            ((my  $namespace) = ($self->{'namespace'} || $Perlito5::PKG_NAME));
            ((my  $effective_name) = ($namespace . '::' . $self->{'code'}));
            if (exists($Perlito5::PROTO->{$effective_name})) {
                ($sig = $Perlito5::PROTO->{$effective_name})
            }
            else {
                if ((((!($self->{'namespace'}) || ($namespace eq 'CORE'))) && exists($Perlito5::CORE_PROTO->{('CORE::' . $name)}))) {
                    ($effective_name = ('CORE::' . $name));
                    ($sig = $Perlito5::CORE_PROTO->{$effective_name})
                }
                else {
                    if ($self->{'bareword'}) {
                        if ($Perlito5::STRICT) {
                            die(('Bareword "' . $name . '" not allowed while "strict subs" in use'))
                        };
                        return (Perlito5::Javascript2::escape_string(((($self->{'namespace'} ? ($self->{'namespace'} . '::') : '')) . $name)))
                    }
                }
            }
        }};
        if (((((($self->{'code'} eq 'say') || ($self->{'code'} eq 'print'))) && !($self->{'namespace'})) && $self->{'bareword'})) {
            ($self->{'arguments'} = [Perlito5::AST::Var->new('sigil', '$', 'namespace', '', 'name', '_')])
        };
        if ($sig) {
            ((my  @out) = ());
            ((my  @in) = @{($self->{'arguments'} || [])});
            ((my  $optional) = 0);
            for ( ; length($sig); do {{

}} ) {
                ((my  $c) = substr($sig, 0, 1));
                if (($c eq ';')) {
                    ($optional = 1)
                }
                else {
                    if ((($c eq '$') || ($c eq '_'))) {
                        if ((@in || !($optional))) {
                            push(@out, shift(@in)->emit_javascript2($level, 'scalar') )
                        }
                    }
                    else {
                        if (($c eq '@')) {
                            if ((@in || !($optional))) {
                                push(@out, Perlito5::Javascript2::to_list(\@in) )
                            };
                            (@in = ())
                        }
                        else {
                            if (($c eq '*')) {
                                if ((@in || !($optional))) {
                                    ((my  $arg) = shift(@in));
                                    if ($arg->{'bareword'}) {
                                        push(@out, ('p5pkg["' . (($arg->{'namespace'} || $Perlito5::PKG_NAME)) . '"]["f_' . $arg->{'code'} . '"]') )
                                    }
                                    else {
                                        push(@out, $arg->emit_javascript2($level, 'scalar') )
                                    }
                                }
                            }
                            else {
                                if (($c eq chr(92))) {
                                    if ((substr($sig, 0, 2) eq chr(92) . '$')) {
                                        ($sig = substr($sig, 1));
                                        if ((@in || !($optional))) {
                                            push(@out, shift(@in)->emit_javascript2($level, 'scalar') )
                                        }
                                    }
                                    else {
                                        if (((substr($sig, 0, 2) eq chr(92) . '@') || (substr($sig, 0, 2) eq chr(92) . '%'))) {
                                            ($sig = substr($sig, 1));
                                            if ((@in || !($optional))) {
                                                push(@out, shift(@in)->emit_javascript2($level, 'list') )
                                            }
                                        }
                                        else {
                                            if ((substr($sig, 0, 5) eq chr(92) . '[@%]')) {
                                                ($sig = substr($sig, 4));
                                                if ((@in || !($optional))) {
                                                    push(@out, shift(@in)->emit_javascript2($level, 'list') )
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                };
                ($sig = substr($sig, 1))
            };
            return (($code . '([' . join(', ', @out) . '], ' . ((($wantarray eq 'list') ? '1' : (($wantarray eq 'scalar') ? '0' : (($wantarray eq 'void') ? 'null' : 'p5want')))) . ')'))
        };
        ((my  @args) = ());
        ((my  $arg_list) = Perlito5::Javascript2::to_list_preprocess($self->{'arguments'}));
        for (@{$arg_list}) {
            push(@args, $_->emit_javascript2($level) )
        };
        ((my  $arg_code) = (($self->{'code'} eq 'scalar') ? ('[' . join(', ', @args) . ']') : Perlito5::Javascript2::to_list($arg_list)));
        ($code . '(' . $arg_code . ', ' . ((($wantarray eq 'list') ? '1' : (($wantarray eq 'scalar') ? '0' : (($wantarray eq 'void') ? 'null' : 'p5want')))) . ')')
    }
}};
package Perlito5::AST::If;
do {{
    sub Perlito5::AST::If::emit_javascript2 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        ((my  $cond) = $self->{'cond'});
        ((my  $body) = Perlito5::Javascript2::LexicalBlock->new('block', $self->{'body'}->stmts(), 'needs_return', 0, 'create_context', 1));
        ((my  $s) = ('if ( ' . Perlito5::Javascript2::to_bool($cond, ($level + 1)) . ' ) {' . chr(10) . $body->emit_javascript2(($level + 1)) . chr(10) . Perlito5::Javascript2::tab($level) . '}'));
        if (@{$self->{'otherwise'}->stmts()}) {
            ((my  $otherwise) = Perlito5::Javascript2::LexicalBlock->new('block', $self->{'otherwise'}->stmts(), 'needs_return', 0, 'create_context', 1));
            ($s = ($s . chr(10) . Perlito5::Javascript2::tab($level) . 'else {' . chr(10) . $otherwise->emit_javascript2(($level + 1)) . chr(10) . Perlito5::Javascript2::tab($level) . '}'))
        };
        return ($s)
    }
}};
package Perlito5::AST::When;
do {{
    sub Perlito5::AST::When::emit_javascript2 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        ((my  $cond) = $self->{'cond'});
        ((my  $body) = Perlito5::Javascript2::LexicalBlock->new('block', $self->{'body'}->stmts(), 'needs_return', 0, 'create_context', 1));
        ((my  $expr) = Perlito5::AST::Apply->new('code', 'infix:<==>', 'arguments', [Perlito5::AST::Var->new('sigil', '$', 'namespace', '', 'name', '_'), $cond]));
        ((my  $s) = ('if ( ' . Perlito5::Javascript2::to_bool($expr, ($level + 1)) . ' ) {' . chr(10) . $body->emit_javascript2(($level + 1)) . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . 'throw(new p5_error("next", "' . $label . '"))' . Perlito5::Javascript2::tab($level) . '}'));
        return ($s)
    }
}};
package Perlito5::AST::While;
do {{
    sub Perlito5::AST::While::emit_javascript2 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        ((my  $cond) = $self->{'cond'});
        return (('p5while(' . 'function () {' . chr(10) . (Perlito5::Javascript2::LexicalBlock->new('block', $self->{'body'}->stmts(), 'needs_return', 0, 'top_level', 0))->emit_javascript2(($level + 2)) . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . '}, ' . Perlito5::Javascript2::emit_function_javascript2($level, 0, $cond) . ', ' . Perlito5::AST::Lit::Block::emit_javascript2_continue($self, $level) . ', ' . '"' . (($self->{'label'} || '')) . '"' . ')'))
    }
}};
package Perlito5::AST::For;
do {{
    sub Perlito5::AST::For::emit_javascript2 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        if ((ref($self->{'cond'}) eq 'ARRAY')) {
            ((my  $body) = Perlito5::Javascript2::LexicalBlock->new('block', $self->{'body'}->stmts(), 'needs_return', 0, 'create_context', 1));
            return (('for ( ' . (($self->{'cond'}->[0] ? ($self->{'cond'}->[0]->emit_javascript2(($level + 1)) . '; ') : '; ')) . (($self->{'cond'}->[1] ? ($self->{'cond'}->[1]->emit_javascript2(($level + 1)) . '; ') : '; ')) . (($self->{'cond'}->[2] ? ($self->{'cond'}->[2]->emit_javascript2(($level + 1)) . ' ') : ' ')) . ') {' . chr(10) . $body->emit_javascript2(($level + 1)) . chr(10) . Perlito5::Javascript2::tab($level) . '}'))
        };
        ((my  $cond) = Perlito5::Javascript2::to_list([$self->{'cond'}], ($level + 1)));
        if ($self->{'body'}->sig()) {
            ((my  $v) = $self->{'body'}->sig());
            ($Perlito5::VAR->[0]->{$v->perl5_name_javascript2()} = {'decl', 'my'});
            ((my  $sig) = $v->emit_javascript2(($level + 1)));
            return (('p5for_lex(' . ('function (' . $sig . ') {' . chr(10)) . (Perlito5::Javascript2::LexicalBlock->new('block', $self->{'body'}->stmts(), 'needs_return', 0, 'top_level', 0))->emit_javascript2(($level + 2)) . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . '}, ' . $cond . ', ' . Perlito5::AST::Lit::Block::emit_javascript2_continue($self, $level) . ', ' . '"' . (($self->{'label'} || '')) . '"' . ')'))
        }
        else {
            return (('p5for(' . Perlito5::Javascript2::pkg() . ', ' . 'function () {' . chr(10) . (Perlito5::Javascript2::LexicalBlock->new('block', $self->{'body'}->stmts(), 'needs_return', 0, 'top_level', 0))->emit_javascript2(($level + 2)) . chr(10) . Perlito5::Javascript2::tab(($level + 1)) . '}, ' . $cond . ', ' . Perlito5::AST::Lit::Block::emit_javascript2_continue($self, $level) . ', ' . '"' . (($self->{'label'} || '')) . '"' . ')'))
        }
    }
}};
package Perlito5::AST::Sub;
do {{
    sub Perlito5::AST::Sub::emit_javascript2 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        ((my  $s) = ('function (List__, p5want) {' . chr(10) . (Perlito5::Javascript2::LexicalBlock->new('block', $self->{'block'}, 'needs_return', 1, 'top_level', 1))->emit_javascript2(($level + 1)) . chr(10) . Perlito5::Javascript2::tab($level) . '}'));
        if ($self->{'name'}) {
            return (('p5make_sub("' . $self->{'namespace'} . '", "' . $self->{'name'} . '", ' . $s . ')'))
        }
        else {
            return ($s)
        }
    }
}};
package Perlito5::AST::Do;
do {{
    sub Perlito5::AST::Do::emit_javascript2 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        ((my  $wantarray) = shift());
        ((my  $block) = $self->simplify()->block());
        return (('(function () {' . chr(10) . (Perlito5::Javascript2::LexicalBlock->new('block', $block, 'needs_return', 1))->emit_javascript2(($level + 1), $wantarray) . chr(10) . Perlito5::Javascript2::tab($level) . '})()'))
    }
}};
package Perlito5::AST::Use;
do {{
    sub Perlito5::AST::Use::emit_javascript2 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        Perlito5::Grammar::Use::emit_time_eval($self);
        ('// ' . $self->{'code'} . ' ' . $self->{'mod'} . chr(10))
    }
}};

;

# use Perlito5::Javascript2::Emitter
;
package main;
undef();
package Perlito5::Javascript2::Runtime;
sub Perlito5::Javascript2::Runtime::emit_javascript2 {
    return ((('//' . chr(10) . '// lib/Perlito5/Javascript2/Runtime.js' . chr(10) . '//' . chr(10) . '// Runtime for "Perlito" Perl5-in-Javascript2' . chr(10) . '//' . chr(10) . '// AUTHORS' . chr(10) . '//' . chr(10) . '// Flavio Soibelmann Glock  fglock@gmail.com' . chr(10) . '//' . chr(10) . '// COPYRIGHT' . chr(10) . '//' . chr(10) . '// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.' . chr(10) . '//' . chr(10) . '// This program is free software; you can redistribute it and/or modify it' . chr(10) . '// under the same terms as Perl itself.' . chr(10) . '//' . chr(10) . '// See http://www.perl.com/perl/misc/Artistic.html' . chr(10) . chr(10) . 'var isNode = typeof require != "undefined";' . chr(10) . chr(10) . 'if (typeof p5pkg !== "object") {' . chr(10) . '    p5pkg = {};' . chr(10) . '    p5LOCAL = [];' . chr(10) . chr(10) . '    var universal = function () {};' . chr(10) . '    p5pkg.UNIVERSAL = new universal();' . chr(10) . '    p5pkg.UNIVERSAL._ref_ = "UNIVERSAL";' . chr(10) . '    p5pkg.UNIVERSAL.isa = function (List__) {' . chr(10) . '        // TODO - use @ISA' . chr(10) . '        return List__[0]._class_._ref_ == List__[1]' . chr(10) . '    };' . chr(10) . '    p5pkg.UNIVERSAL.can = function (List__) {' . chr(10) . '        var o = List__[0];' . chr(10) . '        var s = List__[1];' . chr(10) . '        if ( s.indexOf("::") == -1 ) {' . chr(10) . '            return p5method_lookup(s, o._class_._ref__, {})' . chr(10) . '        }' . chr(10) . '        var c = s.split("::");' . chr(10) . '        s = c.pop(); ' . chr(10) . '        return p5method_lookup(s, c.join("::"), {});' . chr(10) . '    };' . chr(10) . '    p5pkg.UNIVERSAL.DOES = p5pkg.UNIVERSAL.can;' . chr(10) . chr(10) . '    var core = function () {};' . chr(10) . '    p5pkg["CORE"] = new core();' . chr(10) . '    p5pkg["CORE"]._ref_ = "CORE";' . chr(10) . chr(10) . '    var core_global = function () {};' . chr(10) . '    core_global.prototype = p5pkg.CORE;' . chr(10) . '    p5pkg["CORE::GLOBAL"] = new core_global();' . chr(10) . '    p5pkg["CORE::GLOBAL"]._ref_ = "CORE::GLOBAL";' . chr(10) . chr(10) . '    p5_error = function (type, v) {' . chr(10) . '        this.type = type;' . chr(10) . '        this.v = v;' . chr(10) . '        this.toString = function(){' . chr(10) . '            if (this.type == ' . chr(39) . 'break' . chr(39) . ') {' . chr(10) . '                return ' . chr(39) . 'Can' . chr(92) . chr(39) . 't "break" outside a given block' . chr(39) . chr(10) . '            }' . chr(10) . '            if (this.type == ' . chr(39) . 'next' . chr(39) . ' || this.type == ' . chr(39) . 'last' . chr(39) . ' || this.type == ' . chr(39) . 'redo' . chr(39) . ') {' . chr(10) . '                if (this.v == "") { return ' . chr(39) . 'Can' . chr(92) . chr(39) . 't "' . chr(39) . ' + this.type + ' . chr(39) . '" outside a loop block' . chr(39) . ' }' . chr(10) . '                return ' . chr(39) . 'Label not found for "' . chr(39) . ' + this.type + ' . chr(39) . ' ' . chr(39) . ' + this.v + ' . chr(39) . '"' . chr(39) . ';' . chr(10) . '            }' . chr(10) . '            return this.v;' . chr(10) . '        };' . chr(10) . '    };' . chr(10) . '    p5_error.prototype = Error.prototype;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5make_package(pkg_name) {' . chr(10) . '    if (!p5pkg.hasOwnProperty(pkg_name)) {' . chr(10) . '        var tmp = function () {};' . chr(10) . '        tmp.prototype = p5pkg["CORE::GLOBAL"];' . chr(10) . '        p5pkg[pkg_name] = new tmp();' . chr(10) . '        p5pkg[pkg_name]._ref_ = pkg_name;' . chr(10) . '        p5pkg[pkg_name]._class_ = p5pkg[pkg_name];  // XXX memory leak' . chr(10) . chr(10) . '        // TODO - add the other package global variables' . chr(10) . '        p5pkg[pkg_name]["List_ISA"] = [];' . chr(10) . '        p5pkg[pkg_name]["v_a"] = null;' . chr(10) . '        p5pkg[pkg_name]["v_b"] = null;' . chr(10) . '        p5pkg[pkg_name]["v__"] = null;' . chr(10) . '        p5pkg[pkg_name]["v_AUTOLOAD"] = null;' . chr(10) . '    }' . chr(10) . '    return p5pkg[pkg_name];' . chr(10) . '}' . chr(10) . chr(10) . 'function p5code_lookup_by_name(package_name, sub_name) {' . chr(10) . '    // sub_name can have an optional namespace' . chr(10) . '    var parts = sub_name.split(/::/);' . chr(10) . '    if (parts.length > 1) {' . chr(10) . '        sub_name = parts.pop();' . chr(10) . '        package_name = parts.join("::");' . chr(10) . '    }' . chr(10) . '    if (p5pkg.hasOwnProperty(package_name)) {' . chr(10) . '        var c = p5pkg[package_name];' . chr(10) . '        if ( c.hasOwnProperty(sub_name) ) {' . chr(10) . '            return c[sub_name]' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return null;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5get_class_for_method(method, class_name, seen) {' . chr(10) . '    // default mro' . chr(10) . '    // TODO - cache the methods that were already looked up' . chr(10) . '    if ( p5pkg[class_name].hasOwnProperty(method) ) {' . chr(10) . '        return class_name' . chr(10) . '    }' . chr(10) . '    var isa = p5pkg[class_name].List_ISA;' . chr(10) . '    for (var i = 0; i < isa.length; i++) {' . chr(10) . '        if (!seen[isa[i]]) {' . chr(10) . '            var m = p5get_class_for_method(method, isa[i]);' . chr(10) . '            if (m) {' . chr(10) . '                return m ' . chr(10) . '            }' . chr(10) . '            seen[isa[i]]++;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '}' . chr(10) . chr(10) . 'function p5method_lookup(method, class_name, seen) {' . chr(10) . '    var c = p5get_class_for_method(method, class_name, seen);' . chr(10) . '    if (c) {' . chr(10) . '        return p5pkg[c][method]' . chr(10) . '    }' . chr(10) . '    if ( p5pkg.UNIVERSAL.hasOwnProperty(method) ) {' . chr(10) . '        return p5pkg.UNIVERSAL[method]' . chr(10) . '    }' . chr(10) . '}' . chr(10) . chr(10) . 'function p5call(invocant, method, list) {' . chr(10) . '    list.unshift(invocant);' . chr(10) . chr(10) . '    if ( invocant.hasOwnProperty("_class_") ) {' . chr(10) . chr(10) . '        if ( invocant._class_.hasOwnProperty(method) ) {' . chr(10) . '            return invocant._class_[method](list)' . chr(10) . '        }' . chr(10) . '        var m = p5method_lookup(method, invocant._class_._ref_, {});' . chr(10) . '        if (m) {' . chr(10) . '            return m(list)' . chr(10) . '        }' . chr(10) . chr(10) . '        // method can have an optional namespace' . chr(10) . '        var pkg_name = method.split(/::/);' . chr(10) . '        if (pkg_name.length > 1) {' . chr(10) . '            var name = pkg_name.pop();' . chr(10) . '            pkg_name = pkg_name.join("::");' . chr(10) . '            m = p5method_lookup(name, pkg_name, {});' . chr(10) . '            if (m) {' . chr(10) . '                return m(list)' . chr(10) . '            }' . chr(10) . '            p5pkg.CORE.die(["method not found: ", name, " in class ", pkg_name]);' . chr(10) . '        }' . chr(10) . chr(10) . '        pkg_name = p5get_class_for_method(' . chr(39) . 'AUTOLOAD' . chr(39) . ', invocant._class_._ref_, {}) || p5get_class_for_method(' . chr(39) . 'AUTOLOAD' . chr(39) . ', "UNIVERSAL", {});' . chr(10) . '        if (pkg_name) {' . chr(10) . '            p5pkg[pkg_name]["v_AUTOLOAD"] = invocant._class_._ref_ + "::" + method;' . chr(10) . '            return p5pkg[pkg_name]["AUTOLOAD"](list);' . chr(10) . '        }' . chr(10) . chr(10) . '        p5pkg.CORE.die(["method not found: ", method, " in class ", invocant._class_._ref_]);' . chr(10) . chr(10) . '    }' . chr(10) . chr(10) . '    // the invocant doesn' . chr(39) . 't have a class' . chr(10) . chr(10) . '    if (typeof invocant === "string") {' . chr(10) . '        var aclass = p5make_package(invocant);' . chr(10) . '        return p5call(aclass, method, list);' . chr(10) . '    }' . chr(10) . chr(10) . '    p5pkg.CORE.die(["Can' . chr(39) . 't call method ", method, " on unblessed reference"]);' . chr(10) . chr(10) . '}' . chr(10) . chr(10) . 'p5make_package("main");' . chr(10) . 'p5pkg["main"]["v_@"] = [];      // $@' . chr(10) . 'p5pkg["main"]["v_|"] = 0;       // $|' . chr(10) . 'p5pkg["main"]["List_#"] = [];   // @#' . chr(10) . 'p5pkg["main"]["v_^O"] = isNode ? "node.js" : "javascript2";' . chr(10) . 'p5pkg["main"]["List_INC"] = [];' . chr(10) . 'p5pkg["main"]["Hash_INC"] = {};' . chr(10) . 'p5pkg["main"]["List_ARGV"] = [];' . chr(10) . 'p5pkg["main"]["Hash_ENV"] = {};' . chr(10) . 'if (isNode) {' . chr(10) . '    p5pkg["main"]["List_ARGV"] = process.argv.splice(2);' . chr(10) . '    p5pkg["main"]["Hash_ENV"]  = process.env;' . chr(10) . '    p5pkg["main"]["v_$"]       = process.pid;' . chr(10) . '} else if (typeof arguments === "object") {' . chr(10) . '    p5pkg["main"]["List_ARGV"] = arguments;' . chr(10) . '}' . chr(10) . chr(10) . 'p5make_package("Perlito5");' . chr(10) . 'p5make_package("Perlito5::IO");' . chr(10) . 'p5make_package("Perlito5::Runtime");' . chr(10) . 'p5make_package("Perlito5::Grammar");' . chr(10) . chr(10) . 'function p5make_sub(pkg_name, sub_name, func) {' . chr(10) . '    p5pkg[pkg_name][sub_name] = func;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5set_local(namespace, name, sigil) {' . chr(10) . '    var v = name;' . chr(10) . '    if (sigil == "$") {' . chr(10) . '        v = "v_"+name;' . chr(10) . '    }' . chr(10) . '    p5LOCAL.push([namespace, v, namespace[v]]);' . chr(10) . '}' . chr(10) . chr(10) . 'function p5cleanup_local(idx, value) {' . chr(10) . '    while (p5LOCAL.length > idx) {' . chr(10) . '        l = p5LOCAL.pop();' . chr(10) . '        l[0][l[1]] = l[2];' . chr(10) . '    }' . chr(10) . '    return value;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5HashRef(o) {' . chr(10) . '    this._hash_ = o;' . chr(10) . '    this._ref_ = "HASH";' . chr(10) . '    this.bool = function() { return 1 };' . chr(10) . '}' . chr(10) . chr(10) . 'function p5ArrayRef(o) {' . chr(10) . '    this._array_ = o;' . chr(10) . '    this._ref_ = "ARRAY";' . chr(10) . '    this.bool = function() { return 1 };' . chr(10) . '}' . chr(10) . chr(10) . 'function p5ScalarRef(o) {' . chr(10) . '    this._scalar_ = o;' . chr(10) . '    this._ref_ = "SCALAR";' . chr(10) . '    this.bool = function() { return 1 };' . chr(10) . '}' . chr(10) . chr(10) . 'function p5GlobRef(o) {' . chr(10) . '    this._scalar_ = o;' . chr(10) . '    this._ref_ = "GLOB";' . chr(10) . '    this.bool = function() { return 1 };' . chr(10) . '}' . chr(10) . chr(10) . 'if (isNode) {' . chr(10) . '    var fs = require("fs");' . chr(10) . '    p5make_sub("Perlito5::IO", "slurp", function(List__) {' . chr(10) . '        return fs.readFileSync(List__[0],"utf8");' . chr(10) . '    });' . chr(10) . '} else {' . chr(10) . '    p5make_sub("Perlito5::IO", "slurp", function(List__) {' . chr(10) . '        var filename = List__[0];' . chr(10) . '        if (typeof readFile == "function") {' . chr(10) . '            return readFile(filename);' . chr(10) . '        }' . chr(10) . '        if (typeof read == "function") {' . chr(10) . '            // v8' . chr(10) . '            return read(filename);' . chr(10) . '        }' . chr(10) . '        p5pkg.CORE.die(["Perlito5::IO::slurp() not implemented"]);' . chr(10) . '    });' . chr(10) . '}' . chr(10) . chr(10) . 'p5context = function(List__, p5want) {' . chr(10) . '    if (p5want) {' . chr(10) . '        return p5list_to_a.apply(null, List__);' . chr(10) . '    }' . chr(10) . '    // scalar: return the last value' . chr(10) . '    var o = List__;' . chr(10) . '    while (o instanceof Array) {' . chr(10) . '        o =   o.length' . chr(10) . '            ? o[o.length-1]' . chr(10) . '            : null;' . chr(10) . '    }' . chr(10) . '    return o;' . chr(10) . '}' . chr(10) . chr(10) . 'p5list_to_a = function() {' . chr(10) . '    var res = [];' . chr(10) . '    for (i = 0; i < arguments.length; i++) {' . chr(10) . '        var o = arguments[i];' . chr(10) . '        if  (  o == null' . chr(10) . '            || o._class_    // perl5 blessed reference' . chr(10) . '            || o._ref_      // perl5 un-blessed reference' . chr(10) . '            )' . chr(10) . '        {' . chr(10) . '            res.push(o);' . chr(10) . '        }' . chr(10) . '        else if (o instanceof Array) {' . chr(10) . '            // perl5 array' . chr(10) . '            for (j = 0; j < o.length; j++) {' . chr(10) . '                res.push(o[j]);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        else if (typeof o === "object") {' . chr(10) . '            // perl5 hash' . chr(10) . '            for(var j in o) {' . chr(10) . '                if (o.hasOwnProperty(j)) {' . chr(10) . '                    res.push(j);' . chr(10) . '                    res.push(o[j]);' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            // non-ref' . chr(10) . '            res.push(o);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return res;' . chr(10) . '};' . chr(10) . chr(10) . 'p5a_to_h = function(a) {' . chr(10) . '    var res = {};' . chr(10) . '    for (i = 0; i < a.length; i+=2) {' . chr(10) . '        res[p5str(a[i])] = a[i+1];' . chr(10) . '    }' . chr(10) . '    return res;' . chr(10) . '};' . chr(10) . chr(10) . 'p5idx = function(a, i) {' . chr(10) . '    return i >= 0 ? i : a.length + i' . chr(10) . '};' . chr(10) . chr(10) . 'p5str = function(o) {' . chr(10) . '    if (o == null) {' . chr(10) . '        return "";' . chr(10) . '    }' . chr(10) . '    if (typeof o === "object" && (o instanceof Array)) {' . chr(10) . '        return CORE.join(["", o]);' . chr(10) . '    }' . chr(10) . '    // if (typeof o.string === "function") {' . chr(10) . '    //     return o.string();' . chr(10) . '    // }' . chr(10) . '    if (typeof o == "number" && Math.abs(o) < 0.0001 && o != 0) {' . chr(10) . '        return o.toExponential().replace(/e-(' . chr(92) . 'd)$/,"e-0$1");' . chr(10) . '    }' . chr(10) . '    if (typeof o === "boolean") {' . chr(10) . '        return o ? "1" : "";' . chr(10) . '    }' . chr(10) . '    if (typeof o !== "string") {' . chr(10) . '        return "" + o;' . chr(10) . '    }' . chr(10) . '    return o;' . chr(10) . '};' . chr(10) . chr(10) . 'p5num = function(o) {' . chr(10) . '    if (o == null) {' . chr(10) . '        return 0;' . chr(10) . '    }' . chr(10) . '    if (typeof o === "object" && (o instanceof Array)) {' . chr(10) . '        return o.length;' . chr(10) . '    }' . chr(10) . '    // if (typeof o.num === "function") {' . chr(10) . '    //     return o.num();' . chr(10) . '    // }' . chr(10) . '    if (typeof o !== "number") {' . chr(10) . '        return parseFloat(p5str(o));' . chr(10) . '    }' . chr(10) . '    return o;' . chr(10) . '};' . chr(10) . chr(10) . 'p5bool = function(o) {' . chr(10) . '    if (o) {' . chr(10) . '        if (typeof o === "boolean") {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        if (typeof o === "number") {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        if (typeof o === "string") {' . chr(10) . '            return o != "" && o != "0";' . chr(10) . '        }' . chr(10) . '        // if (typeof o.bool === "function") {' . chr(10) . '        //     return o.bool();' . chr(10) . '        // }' . chr(10) . '        if (typeof o.length === "number") {' . chr(10) . '            return o.length;' . chr(10) . '        }' . chr(10) . '        if (o instanceof Error) {' . chr(10) . '            return true;' . chr(10) . '        }' . chr(10) . '        for (var i in o) {' . chr(10) . '            return true;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return false;' . chr(10) . '};' . chr(10) . chr(10) . 'p5and = function(a, fb) {' . chr(10) . '    if (p5bool(a)) {' . chr(10) . '        return fb();' . chr(10) . '    }' . chr(10) . '    return a;' . chr(10) . '};' . chr(10) . chr(10) . 'p5or = function(a, fb) {' . chr(10) . '    if (p5bool(a)) {' . chr(10) . '        return a;' . chr(10) . '    }' . chr(10) . '    return fb();' . chr(10) . '};' . chr(10) . chr(10) . 'p5defined_or = function(a, fb) {' . chr(10) . '    if (a == null) {' . chr(10) . '        return fb();' . chr(10) . '    }' . chr(10) . '    return a;' . chr(10) . '};' . chr(10) . chr(10) . 'p5cmp = function(a, b) {' . chr(10) . '    return a > b ? 1 : a < b ? -1 : 0 ' . chr(10) . '};' . chr(10) . chr(10) . 'p5complement = function(a) {' . chr(10) . '    return a < 0 ? ~a : 4294967295 - a' . chr(10) . '    // return a < 0 ? ~a : 18446744073709551615 - a' . chr(10) . '};' . chr(10) . chr(10) . 'p5str_replicate = function(o, n) {' . chr(10) . '    n = p5num(n);' . chr(10) . '    return n ? Array(n + 1).join(o) : "";' . chr(10) . '};' . chr(10) . chr(10) . 'p5str_inc = function(s) {' . chr(10) . '    s = p5str(s);' . chr(10) . '    if (s.length < 2) {' . chr(10) . '        if (s.match(/[012345678ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy]/)) {' . chr(10) . '            return String.fromCharCode(s.charCodeAt(0) + 1);' . chr(10) . '        }' . chr(10) . '        if (s == "9") {' . chr(10) . '            return "10";' . chr(10) . '        }' . chr(10) . '        if (s == "Z") {' . chr(10) . '            return "AA";' . chr(10) . '        }' . chr(10) . '        if (s == "z") {' . chr(10) . '            return "aa";' . chr(10) . '        }' . chr(10) . '        return "1";' . chr(10) . '    }' . chr(10) . '    var c = p5str_inc(s.substr(s.length-1, 1));' . chr(10) . '    if (c.length == 1) {' . chr(10) . '        return s.substr(0, s.length-1) + c;' . chr(10) . '    }' . chr(10) . '    return p5str_inc(s.substr(0, s.length-1)) + c.substr(c.length-1, 1);' . chr(10) . '};' . chr(10) . chr(10) . 'p5for = function(namespace, func, args, cont, label) {' . chr(10) . '    var _redo = false;' . chr(10) . '    var v_old = namespace["v__"];' . chr(10) . '    for(var i = 0; i < args.length; i++) {' . chr(10) . '        namespace["v__"] = args[i];' . chr(10) . '        try {' . chr(10) . '            func()' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            if (err instanceof p5_error && err.v == label) {' . chr(10) . '                if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { i--; _redo = true }' . chr(10) . '                else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                throw(err)' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        if (cont) {' . chr(10) . '            try {' . chr(10) . '                if (!_redo) { cont() }' . chr(10) . '            }' . chr(10) . '            catch(err) {' . chr(10) . '                if (err instanceof p5_error && err.v == label) {' . chr(10) . '                    if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                    else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }' . chr(10) . '                    else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '                }            ' . chr(10) . '                else {' . chr(10) . '                    throw(err)' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '       }' . chr(10) . '   }' . chr(10) . '    namespace["v__"] = v_old;' . chr(10) . '};' . chr(10) . chr(10) . 'p5for_lex = function(func, args, cont, label) {' . chr(10) . '    var _redo = false;' . chr(10) . '    for(var i = 0; i < args.length; i++) {' . chr(10) . '        try {' . chr(10) . '            func(args[i])' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            if (err instanceof p5_error && err.v == label) {' . chr(10) . '                if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { i--; _redo = true }' . chr(10) . '                else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '            }            ' . chr(10) . '            else {' . chr(10) . '                throw(err)' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        if (cont) {' . chr(10) . '            try {' . chr(10) . '                if (!_redo) { cont() }' . chr(10) . '            }' . chr(10) . '            catch(err) {' . chr(10) . '                if (err instanceof p5_error && err.v == label) {' . chr(10) . '                    if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                    else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }' . chr(10) . '                    else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '                }            ' . chr(10) . '                else {' . chr(10) . '                    throw(err)' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . 'p5while = function(func, cond, cont, label) {' . chr(10) . '    var _redo = false;' . chr(10) . '    while (_redo || p5bool(cond())) {' . chr(10) . '        _redo = false;' . chr(10) . '        try {' . chr(10) . '            func()' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            if (err instanceof p5_error && err.v == label) {' . chr(10) . '                if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }' . chr(10) . '                else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '            }            ' . chr(10) . '            else {' . chr(10) . '                throw(err)' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        if (cont) {' . chr(10) . '            try {' . chr(10) . '                if (!_redo) { cont() }' . chr(10) . '            }' . chr(10) . '            catch(err) {' . chr(10) . '                if (err instanceof p5_error && err.v == label) {' . chr(10) . '                    if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                    else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }' . chr(10) . '                    else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '                }            ' . chr(10) . '                else {' . chr(10) . '                    throw(err)' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . 'p5map = function(namespace, func, args) {' . chr(10) . '    var v_old = namespace["v__"];' . chr(10) . '    var out = [];' . chr(10) . '    for(var i = 0; i < args.length; i++) {' . chr(10) . '        namespace["v__"] = args[i];' . chr(10) . '        var o = p5list_to_a(func(1));' . chr(10) . '        for(var j = 0; j < o.length; j++) {' . chr(10) . '            out.push(o[j]);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    namespace["v__"] = v_old;' . chr(10) . '    return out;' . chr(10) . '};' . chr(10) . chr(10) . 'p5grep = function(namespace, func, args) {' . chr(10) . '    var v_old = namespace["v__"];' . chr(10) . '    var out = [];' . chr(10) . '    for(var i = 0; i < args.length; i++) {' . chr(10) . '        namespace["v__"] = args[i];' . chr(10) . '        if (p5bool(func(0))) {' . chr(10) . '            out.push(args[i])' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    namespace["v__"] = v_old;' . chr(10) . '    return out;' . chr(10) . '};' . chr(10) . chr(10) . 'p5sort = function(namespace, func, args) {' . chr(10) . '    var a_old = namespace["v_a"];' . chr(10) . '    var b_old = namespace["v_b"];' . chr(10) . '    var out = ' . chr(10) . '        func == null' . chr(10) . '        ? args.sort()' . chr(10) . '        : args.sort(' . chr(10) . '            function(a, b) {' . chr(10) . '                namespace["v_a"] = a;' . chr(10) . '                namespace["v_b"] = b;' . chr(10) . '                return func(0);' . chr(10) . '            }' . chr(10) . '        );' . chr(10) . '    namespace["v_a"] = a_old;' . chr(10) . '    namespace["v_b"] = b_old;' . chr(10) . '    return out;' . chr(10) . '};' . chr(10) . chr(10) . 'perl5_to_js = function( source, namespace, var_env_js, p5want ) {' . chr(10) . '    // CORE.say(["source: [" + source + "]"]);' . chr(10) . chr(10) . '    var strict_old = p5pkg["Perlito5"].v_STRICT;' . chr(10) . '    var var_env_js_old = p5pkg["Perlito5"].v_VAR;' . chr(10) . '    p5pkg["Perlito5"].v_VAR = var_env_js;' . chr(10) . chr(10) . '    var namespace_old = p5pkg["Perlito5"].v_PKG_NAME;' . chr(10) . '    p5pkg["Perlito5"].v_PKG_NAME = namespace;' . chr(10) . chr(10) . '    match = p5call(p5pkg["Perlito5::Grammar"], "exp_stmts", [source, 0]);' . chr(10) . chr(10) . '    if ( !match || match._hash_.to != source.length ) {' . chr(10) . '        CORE.die(["Syntax error in eval near pos ", match._hash_.to]);' . chr(10) . '    }' . chr(10) . chr(10) . '    ast = p5pkg.CORE.bless([' . chr(10) . '        new p5HashRef({' . chr(10) . '            block:  p5pkg.CORE.bless([' . chr(10) . '                        new p5HashRef({' . chr(10) . '                            stmts:   p5pkg["Perlito5::Match"].flat([match])' . chr(10) . '                        }),' . chr(10) . '                        p5pkg["Perlito5::AST::Lit::Block"]' . chr(10) . '                    ])' . chr(10) . '        }),' . chr(10) . '        p5pkg["Perlito5::AST::Do"]' . chr(10) . '    ]);' . chr(10) . chr(10) . '    // CORE.say(["ast: [" + ast + "]"]);' . chr(10) . '    js_code = p5call(ast, "emit_javascript2", [0, p5want]);' . chr(10) . '    // CORE.say(["js-source: [" + js_code + "]"]);' . chr(10) . chr(10) . '    p5pkg["Perlito5"].v_PKG_NAME = namespace_old;' . chr(10) . '    p5pkg["Perlito5"].v_VAR      = var_env_js_old;' . chr(10) . '    p5pkg["Perlito5"].v_STRICT = strict_old;' . chr(10) . '    return js_code;' . chr(10) . '}' . chr(10) . chr(10))))
};
1;

;

# use Perlito5::Javascript2::Runtime
;
package main;
undef();
package Perlito5::Javascript2::CORE;
sub Perlito5::Javascript2::CORE::emit_javascript2 {
    return ((('//' . chr(10) . '//' . chr(10) . '// lib/Perlito5/Javascript2/CORE.js' . chr(10) . '//' . chr(10) . '// CORE functions for "Perlito" Perl5-in-Javascript2' . chr(10) . '//' . chr(10) . '// AUTHORS' . chr(10) . '//' . chr(10) . '// Flavio Soibelmann Glock  fglock@gmail.com' . chr(10) . '//' . chr(10) . '// COPYRIGHT' . chr(10) . '//' . chr(10) . '// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.' . chr(10) . '//' . chr(10) . '// This program is free software; you can redistribute it and/or modify it' . chr(10) . '// under the same terms as Perl itself.' . chr(10) . '//' . chr(10) . '// See http://www.perl.com/perl/misc/Artistic.html' . chr(10) . chr(10) . 'var CORE = p5pkg.CORE;' . chr(10) . chr(10) . 'var isNode = typeof require != "undefined";' . chr(10) . 'if (isNode) {' . chr(10) . '    CORE.print = function(List__) {' . chr(10) . '        var i;' . chr(10) . '        for (i = 0; i < List__.length; i++) {' . chr(10) . '            process.stdout.write(p5str(List__[i]));' . chr(10) . '        }' . chr(10) . '        return 1;' . chr(10) . '    }' . chr(10) . '} else {' . chr(10) . '    CORE.print = function(List__) {' . chr(10) . '        var i;' . chr(10) . '        for (i = 0; i < List__.length; i++) {' . chr(10) . '            write(p5str(List__[i]));' . chr(10) . '        }' . chr(10) . '        return 1;' . chr(10) . '    };' . chr(10) . '}' . chr(10) . chr(10) . 'CORE.say = function(List__) {' . chr(10) . '    CORE.print(List__);' . chr(10) . '    return CORE.print(["' . chr(92) . 'n"]);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.die = function(List__) {' . chr(10) . '    var i;' . chr(10) . '    var s = "";' . chr(10) . '    for (i = 0; i < List__.length; i++) {' . chr(10) . '        s = s + p5str(List__[i]);' . chr(10) . '    }' . chr(10) . '    p5pkg["main"]["v_@"] = "Died: " + s;' . chr(10) . '    throw(new p5_error("die", "Died: " + s));' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.warn = function(List__) {' . chr(10) . '    var i;' . chr(10) . '    var s = "";' . chr(10) . '    for (i = 0; i < List__.length; i++) {' . chr(10) . '        s = s + p5str(List__[i]);' . chr(10) . '    }' . chr(10) . '    CORE.print(["Warning: " + s + "' . chr(92) . 'n"]);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.bless = function(List__) {' . chr(10) . '    var o        = List__[0];' . chr(10) . '    var pkg_name = List__[1];' . chr(10) . '    if (typeof pkg_name === "object") {' . chr(10) . '        // bless {}, Class' . chr(10) . '        o._class_ = pkg_name;' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . '    if (!p5pkg.hasOwnProperty(pkg_name)) {' . chr(10) . '        p5make_package(pkg_name);' . chr(10) . '    }' . chr(10) . '    o._class_ = p5pkg[pkg_name];' . chr(10) . '    return o;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.chr = function(List__) {' . chr(10) . '    var v = p5num(List__[0]);' . chr(10) . '    return String.fromCharCode(v >= 0 ? v : 65533);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.ord = function(List__) {' . chr(10) . '    return p5str(List__[0]).charCodeAt(0);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.oct = function(List__) {' . chr(10) . '    var v = List__[0];' . chr(10) . '    var b = v.substr(0,2);' . chr(10) . '    v = v.replace("_", "");' . chr(10) . '    if (b == "0b" || b == "0B") { return parseInt(v.substr(2), 2)  }' . chr(10) . '    if (b == "0x" || b == "0X") { return parseInt(v.substr(2), 16) }' . chr(10) . '    return parseInt(v, 8);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.abs   = function(List__) { return Math.abs(List__[0]) };' . chr(10) . 'CORE.exp   = function(List__) { return Math.exp(List__[0]) };' . chr(10) . 'CORE.log   = function(List__) { return Math.log(List__[0]) };' . chr(10) . 'CORE.cos   = function(List__) { return Math.cos(List__[0]) };' . chr(10) . 'CORE.sin   = function(List__) { return Math.sin(List__[0]) };' . chr(10) . 'CORE.sqrt  = function(List__) { return Math.sqrt(List__[0]) };' . chr(10) . 'CORE.atan2 = function(List__) { return Math.atan2(List__[0], List__[1]) };' . chr(10) . 'CORE.int   = function(List__) { return List__[0] > 0 ? Math.floor(List__[0]) : Math.ceil(List__[0]) };' . chr(10) . chr(10) . 'CORE.rand = function(List__) {' . chr(10) . '    var v = p5num(List__[0]) || 1;' . chr(10) . '    return Math.random() * v;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.lc      = function(List__) { return p5str(List__[0]).toLowerCase() };' . chr(10) . 'CORE.uc      = function(List__) { return p5str(List__[0]).toUpperCase() };' . chr(10) . chr(10) . 'CORE.lcfirst = function(List__) {' . chr(10) . '    var s = p5str(List__[0]);' . chr(10) . '    var c = s.length > 0 ? s.slice(0,1).toLowerCase() : "";' . chr(10) . '    s = s.length > 1 ? s.substr(1) : "";' . chr(10) . '    return c + s' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.ucfirst = function(List__) {' . chr(10) . '    var s = p5str(List__[0]);' . chr(10) . '    var c = s.length > 0 ? s.slice(0,1).toUpperCase() : "";' . chr(10) . '    s = s.length > 1 ? s.substr(1) : "";' . chr(10) . '    return c + s' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.quotemeta = function(List__) {' . chr(10) . '    var s = p5str(List__[0]);' . chr(10) . '    var out = [];' . chr(10) . '    for(var i = 0; i < s.length; i++) {' . chr(10) . '        if (s.substr(i, 1).match(/[^0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz]/)) {' . chr(10) . '            out.push(String.fromCharCode(92));' . chr(10) . '        }' . chr(10) . '        out.push(s.substr(i, 1));' . chr(10) . '    }' . chr(10) . '    return out.join("");       ' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.substr = function(List__) {' . chr(10) . '    var expr        = List__[0];' . chr(10) . '    var offset      = List__[1];' . chr(10) . '    var length      = List__[2];' . chr(10) . '    var replacement = List__[3];' . chr(10) . '    if (length < 0) {' . chr(10) . '        var s = p5str(expr);' . chr(10) . '        length = s.length - offset + length;' . chr(10) . '    } ' . chr(10) . '    return p5str(expr).substr(offset, length);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.values = function(List__, p5want) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    delete o["_each_"];' . chr(10) . '    if (p5want) {' . chr(10) . '        if (o == null) {' . chr(10) . '            return [];' . chr(10) . '        };' . chr(10) . '        if (typeof o.values === "function") {' . chr(10) . '            return o.values();' . chr(10) . '        }' . chr(10) . '        var out = [];' . chr(10) . '        for (var i in o) {' . chr(10) . '            out.push(o[i]);' . chr(10) . '        }' . chr(10) . '        return out;' . chr(10) . '    }' . chr(10) . '    return CORE.keys(List__, p5want);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.keys = function(List__, p5want) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    delete o["_each_"];' . chr(10) . '    if (p5want) {' . chr(10) . '        if (o == null) {' . chr(10) . '            return [];' . chr(10) . '        }' . chr(10) . '        if (typeof o.keys === "function") {' . chr(10) . '            return o.keys();' . chr(10) . '        }' . chr(10) . '        var out = [];' . chr(10) . '        for (var i in o) {' . chr(10) . '            out.push(i);' . chr(10) . '        }' . chr(10) . '        return out;' . chr(10) . '    }' . chr(10) . '    else {' . chr(10) . '        if (o == null) {' . chr(10) . '            return 0;' . chr(10) . '        }' . chr(10) . '        if (typeof o.keys === "function") {' . chr(10) . '            return CORE.scalar([o.keys()]);' . chr(10) . '        }' . chr(10) . '        var out = 0;' . chr(10) . '        for (var i in o) {' . chr(10) . '            out++;' . chr(10) . '        }' . chr(10) . '        return out;' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.each = function(List__, p5want) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    if (o.hasOwnProperty("_each_")) {' . chr(10) . '        return o._each_(p5want)' . chr(10) . '    }' . chr(10) . '    var keys = CORE.keys([o], 1);' . chr(10) . '    var i = 0;' . chr(10) . '    o._each_ = function () {' . chr(10) . '        if (i < keys.length) {' . chr(10) . '            i++;' . chr(10) . '            return p5want ? [keys[i-1], o[keys[i-1]]] : keys[i-1];' . chr(10) . '        }' . chr(10) . '        i = 0;' . chr(10) . '        return p5want ? [] : null;' . chr(10) . '    };' . chr(10) . '    return o._each_(p5want);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.reverse = function(List__) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    if (o == null) {' . chr(10) . '        return "";' . chr(10) . '    }' . chr(10) . '    if (typeof o === "string") {' . chr(10) . '        return o.split("").reverse().join("")' . chr(10) . '    }' . chr(10) . '    var out = [];' . chr(10) . '    for(var i = 0; i < o.length; i++) {' . chr(10) . '        out.unshift(o[i]);' . chr(10) . '    }' . chr(10) . '    return out;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.splice = function(List__, p5want) {' . chr(10) . '    var array  = List__.shift();' . chr(10) . '    // CORE.say([ array ]);' . chr(10) . '    var offset = p5num(List__.shift());' . chr(10) . '    var limit  = List__.length ? p5num(List__.shift()) : (array.length + 1);' . chr(10) . chr(10) . '    if (limit < 0) {' . chr(10) . '        limit = array.length + limit - 1;' . chr(10) . '    }' . chr(10) . chr(10) . '    var list = [offset, limit];' . chr(10) . '    for(var i = 0; i < List__.length; i++) {' . chr(10) . '        list = p5list_to_a( list, List__[i]);' . chr(10) . '    }' . chr(10) . chr(10) . '    out = array.splice.apply(array, list);' . chr(10) . '    // CORE.say([ CORE.join([":",array]), " ofs=", offset, " lim=", limit, " list=", list, " out=", CORE.join([":",out])  ]);' . chr(10) . '    return p5want ? out : out.pop();' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.pop = function(List__) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    if (o.length == null) {' . chr(10) . '        return null;' . chr(10) . '    }' . chr(10) . '    return o.pop();' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.shift = function(List__) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    if (o.length == null) {' . chr(10) . '        return null;' . chr(10) . '    }' . chr(10) . '    return o.shift();' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.push = function(List__) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    var v = List__[1];' . chr(10) . '    for(var i = 0; i < v.length; i++) {' . chr(10) . '        o.push(v[i]);' . chr(10) . '    }' . chr(10) . '    return o.length;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.unshift = function(List__) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    var v = List__[1];' . chr(10) . '    for(var i = v.length-1; i >= 0; i--) {' . chr(10) . '        o.unshift(v[i]);' . chr(10) . '    }' . chr(10) . '    return o.length;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.join = function(List__) {' . chr(10) . '    var s = List__[0];' . chr(10) . '    var o = List__[1];' . chr(10) . '    return o.join(s);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.index = function(List__) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    var s = List__[1];' . chr(10) . '    try {' . chr(10) . '        return o.indexOf(s, p5num(List__[2]));' . chr(10) . '    }' . chr(10) . '    catch(err) {' . chr(10) . '        return -1;' . chr(10) . '    }' . chr(10) . '};' . chr(10) . 'CORE.rindex = function(List__) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    var s = List__[1];' . chr(10) . '    try {' . chr(10) . '        if (List__.length > 2) {' . chr(10) . '            var i = p5num(List__[2]);' . chr(10) . '            if (i < 0) {' . chr(10) . '                if (s.length == 0) {' . chr(10) . '                    return 0;' . chr(10) . '                }' . chr(10) . '                return -1;' . chr(10) . '            }' . chr(10) . '            return o.lastIndexOf(s, i);' . chr(10) . '        }' . chr(10) . '        return o.lastIndexOf(s);' . chr(10) . '    }' . chr(10) . '    catch(err) {' . chr(10) . '        return -1;' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.length = function(List__) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    if (typeof o.string === "function") {' . chr(10) . '        return o.string().length;' . chr(10) . '    }' . chr(10) . '    return o.length;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.pack    = function(List__) { CORE.warn([ "CORE::pack not implemented" ]) };' . chr(10) . 'CORE.unpack  = function(List__) { CORE.warn([ "CORE::unpack not implemented" ]) };' . chr(10) . chr(10) . 'CORE.ref = function(List__) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    if (o == null) {' . chr(10) . '        return "";' . chr(10) . '    }' . chr(10) . '    if (o._class_ && typeof o._class_._ref_ === "string") {' . chr(10) . '        // blessed reference' . chr(10) . '        return o._class_._ref_;' . chr(10) . '    }' . chr(10) . '    if (typeof o._ref_ === "string") {' . chr(10) . '        // un-blessed reference' . chr(10) . '        return o._ref_;' . chr(10) . '    }' . chr(10) . '    if (typeof o === "function") {' . chr(10) . '        return "CODE";' . chr(10) . '    }' . chr(10) . '    return "";' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.split = function(List__) {' . chr(10) . '    var pattern = List__[0];' . chr(10) . '    var s       = List__[1];' . chr(10) . '    var limit   = List__[2];' . chr(10) . '    if (typeof pattern === "string") {' . chr(10) . '        if (pattern == " ") {' . chr(10) . '            var res = [];' . chr(10) . '            for (var i_ = 0, a_ = s.split(/(?: |' . chr(92) . 'n)+/); i_ < a_.length ; i_++) {' . chr(10) . '                if (a_[i_] != "") {' . chr(10) . '                    res.push(a_[i_])' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            return res;' . chr(10) . '        }' . chr(10) . '        return s.split(pattern);' . chr(10) . '    }' . chr(10) . '    CORE.die(["not implemented"]);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.prototype = function(List__, data) {' . chr(10) . '    var name = List__[0];' . chr(10) . '    // TODO - fully qualify "name" using information from "data"' . chr(10) . '    // XXX - lookup in CORE::GLOBAL?' . chr(10) . '    p5pkg["Perlito5"].v_PROTO._hash_[name] || p5pkg["Perlito5"].v_CORE_PROTO._hash_[name]' . chr(10) . '};' . chr(10) . chr(10))))
};
1;

;

# use Perlito5::Javascript2::CORE
;
package main;
undef();
package Perlito5::Javascript2::IO;
sub Perlito5::Javascript2::IO::emit_javascript2 {
    return ((('//' . chr(10) . '//' . chr(10) . '// lib/Perlito5/Javascript2/IO.js' . chr(10) . '//' . chr(10) . '// I/O functions for "Perlito" Perl5-in-Javascript2' . chr(10) . '//' . chr(10) . '// AUTHORS' . chr(10) . '//' . chr(10) . '// Flavio Soibelmann Glock  fglock@gmail.com' . chr(10) . '//' . chr(10) . '// COPYRIGHT' . chr(10) . '//' . chr(10) . '// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.' . chr(10) . '//' . chr(10) . '// This program is free software; you can redistribute it and/or modify it' . chr(10) . '// under the same terms as Perl itself.' . chr(10) . '//' . chr(10) . '// See http://www.perl.com/perl/misc/Artistic.html' . chr(10) . chr(10) . 'var isNode = typeof require != "undefined";' . chr(10) . 'if (isNode) {' . chr(10) . chr(10) . '    var fs = require("fs");' . chr(10) . chr(10) . '    p5atime = function(s) {' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat["atime"];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5mtime = function(s) {' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat["mtime"];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5ctime = function(s) {' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat["ctime"];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5size = function(s) {' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat["size"];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5is_file = function(s) {' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat.isFile() ? 1 : 0;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5is_directory = function(s) {' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat.isDirectory() ? 1 : 0;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5file_exists = function(s) {' . chr(10) . '        return p5is_file(s) || p5is_directory(s);' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.chdir = function(List__) {' . chr(10) . '        try {' . chr(10) . '            process.chdir(p5str(List__[0]));' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.close = function(List__) {' . chr(10) . '        try {' . chr(10) . '            fs.closeSync(p5str(List__[0]));' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.exit = function(List__) {' . chr(10) . '        process.exit(List__[0]);' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.rename = function(List__) {' . chr(10) . '        try {' . chr(10) . '            fs.renameSync(p5str(List__[0]), p5str(List__[1]));' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.unlink = function(List__) {' . chr(10) . '        var count = 0;' . chr(10) . '        try {' . chr(10) . '            for(var i = 0; i < List__.length; i++) {' . chr(10) . '                fs.unlinkSync(p5str(List__[i]));' . chr(10) . '                count++;' . chr(10) . '            }' . chr(10) . '            return count;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return count;' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '}' . chr(10) . chr(10))))
};
1;

;

# use Perlito5::Javascript2::IO
;
package main;
undef();
package Perlito5::Javascript2::Sprintf;
sub Perlito5::Javascript2::Sprintf::emit_javascript2 {
    return ((('/**' . chr(10) . ' * Copyright (c) 2010 Jakob Westhoff' . chr(10) . ' *' . chr(10) . ' * Permission is hereby granted, free of charge, to any person obtaining a copy' . chr(10) . ' * of this software and associated documentation files (the "Software"), to deal' . chr(10) . ' * in the Software without restriction, including without limitation the rights' . chr(10) . ' * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell' . chr(10) . ' * copies of the Software, and to permit persons to whom the Software is' . chr(10) . ' * furnished to do so, subject to the following conditions:' . chr(10) . ' * ' . chr(10) . ' * The above copyright notice and this permission notice shall be included in' . chr(10) . ' * all copies or substantial portions of the Software.' . chr(10) . ' * ' . chr(10) . ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR' . chr(10) . ' * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,' . chr(10) . ' * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE' . chr(10) . ' * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER' . chr(10) . ' * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,' . chr(10) . ' * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN' . chr(10) . ' * THE SOFTWARE.' . chr(10) . ' */' . chr(10) . chr(10) . 'CORE.sprintf = function(List__) {' . chr(10) . '    var format = List__[0];' . chr(10) . '    var list = List__[1];' . chr(10) . chr(10) . '    // Check for format definition' . chr(10) . '    if ( typeof format != ' . chr(39) . 'string' . chr(39) . ' ) {' . chr(10) . '        CORE.die(["sprintf: The first arguments need to be a valid format string."]);' . chr(10) . '    }' . chr(10) . '    ' . chr(10) . '    /**' . chr(10) . '     * Define the regex to match a formating string' . chr(10) . '     * The regex consists of the following parts:' . chr(10) . '     * percent sign to indicate the start' . chr(10) . '     * (optional) sign specifier' . chr(10) . '     * (optional) padding specifier' . chr(10) . '     * (optional) alignment specifier' . chr(10) . '     * (optional) width specifier' . chr(10) . '     * (optional) precision specifier' . chr(10) . '     * type specifier:' . chr(10) . '     *  % - literal percent sign' . chr(10) . '     *  b - binary number' . chr(10) . '     *  c - ASCII character represented by the given value' . chr(10) . '     *  d - signed decimal number' . chr(10) . '     *  f - floating point value' . chr(10) . '     *  o - octal number' . chr(10) . '     *  s - string' . chr(10) . '     *  x - hexadecimal number (lowercase characters)' . chr(10) . '     *  X - hexadecimal number (uppercase characters)' . chr(10) . '     */' . chr(10) . '    var r = new RegExp( /%(' . chr(92) . '+)?([0 ]|' . chr(39) . '(.))?(-)?([0-9]+)?(' . chr(92) . '.([0-9]+))?([%bcdfosxX])/g );' . chr(10) . chr(10) . '    /**' . chr(10) . '     * Each format string is splitted into the following parts:' . chr(10) . '     * 0: Full format string' . chr(10) . '     * 1: sign specifier (+)' . chr(10) . '     * 2: padding specifier (0/<space>/' . chr(39) . '<any char>)' . chr(10) . '     * 3: if the padding character starts with a ' . chr(39) . ' this will be the real ' . chr(10) . '     *    padding character' . chr(10) . '     * 4: alignment specifier' . chr(10) . '     * 5: width specifier' . chr(10) . '     * 6: precision specifier including the dot' . chr(10) . '     * 7: precision specifier without the dot' . chr(10) . '     * 8: type specifier' . chr(10) . '     */' . chr(10) . '    var parts      = [];' . chr(10) . '    var paramIndex = 0;' . chr(10) . '    while ( part = r.exec( format ) ) {' . chr(10) . '        // Check if an input value has been provided, for the current' . chr(10) . '        // format string' . chr(10) . '        if ( paramIndex >= list.length ) {' . chr(10) . '            CORE.die(["sprintf: At least one argument was missing."]);' . chr(10) . '        }' . chr(10) . chr(10) . '        parts[parts.length] = {' . chr(10) . '            /* beginning of the part in the string */' . chr(10) . '            begin: part.index,' . chr(10) . '            /* end of the part in the string */' . chr(10) . '            end: part.index + part[0].length,' . chr(10) . '            /* force sign */' . chr(10) . '            sign: ( part[1] == ' . chr(39) . '+' . chr(39) . ' ),' . chr(10) . '            /* is the given data negative */' . chr(10) . '            negative: ( parseInt( list[paramIndex] ) < 0 ) ? true : false,' . chr(10) . '            /* padding character (default: <space>) */' . chr(10) . '            padding: ( part[2] == undefined )' . chr(10) . '                     ? ( ' . chr(39) . ' ' . chr(39) . ' ) /* default */' . chr(10) . '                     : ( ( part[2].substring( 0, 1 ) == "' . chr(39) . '" ) ' . chr(10) . '                         ? ( part[3] ) /* use special char */' . chr(10) . '                         : ( part[2] ) /* use normal <space> or zero */' . chr(10) . '                       ),' . chr(10) . '            /* should the output be aligned left?*/' . chr(10) . '            alignLeft: ( part[4] == ' . chr(39) . '-' . chr(39) . ' ),' . chr(10) . '            /* width specifier (number or false) */' . chr(10) . '            width: ( part[5] != undefined ) ? part[5] : false,' . chr(10) . '            /* precision specifier (number or false) */' . chr(10) . '            precision: ( part[7] != undefined ) ? part[7] : false,' . chr(10) . '            /* type specifier */' . chr(10) . '            type: part[8],' . chr(10) . '            /* the given data associated with this part converted to a string */' . chr(10) . '            data: ( part[8] != ' . chr(39) . '%' . chr(39) . ' ) ? String ( list[paramIndex++] ) : false' . chr(10) . '        };' . chr(10) . '    }' . chr(10) . chr(10) . '    var newString = "";' . chr(10) . '    var start = 0;' . chr(10) . '    // Generate our new formated string' . chr(10) . '    for( var i=0; i<parts.length; ++i ) {' . chr(10) . '        // Add first unformated string part' . chr(10) . '        newString += format.substring( start, parts[i].begin );' . chr(10) . '        ' . chr(10) . '        // Mark the new string start' . chr(10) . '        start = parts[i].end;' . chr(10) . chr(10) . '        // Create the appropriate preformat substitution' . chr(10) . '        // This substitution is only the correct type conversion. All the' . chr(10) . '        // different options and flags haven' . chr(39) . 't been applied to it at this' . chr(10) . '        // point' . chr(10) . '        var preSubstitution = "";' . chr(10) . '        switch ( parts[i].type ) {' . chr(10) . '            case ' . chr(39) . '%' . chr(39) . ':' . chr(10) . '                preSubstitution = "%";' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'b' . chr(39) . ':' . chr(10) . '                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 2 );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'c' . chr(39) . ':' . chr(10) . '                preSubstitution = String.fromCharCode( Math.abs( parseInt( parts[i].data ) ) );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'd' . chr(39) . ':' . chr(10) . '                preSubstitution = String( Math.abs( parseInt( parts[i].data ) ) );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'f' . chr(39) . ':' . chr(10) . '                preSubstitution = ( parts[i].precision == false )' . chr(10) . '                                  ? ( String( ( Math.abs( parseFloat( parts[i].data ) ) ) ) )' . chr(10) . '                                  : ( Math.abs( parseFloat( parts[i].data ) ).toFixed( parts[i].precision ) );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'o' . chr(39) . ':' . chr(10) . '                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 8 );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 's' . chr(39) . ':' . chr(10) . '                preSubstitution = parts[i].data.substring( 0, parts[i].precision ? parts[i].precision : parts[i].data.length ); /* Cut if precision is defined */' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'x' . chr(39) . ':' . chr(10) . '                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 16 ).toLowerCase();' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'X' . chr(39) . ':' . chr(10) . '                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 16 ).toUpperCase();' . chr(10) . '            break;' . chr(10) . '            default:' . chr(10) . '                throw ' . chr(39) . 'sprintf: Unknown type "' . chr(39) . ' + parts[i].type + ' . chr(39) . '" detected. This should never happen. Maybe the regex is wrong.' . chr(39) . ';' . chr(10) . '        }' . chr(10) . chr(10) . '        // The % character is a special type and does not need further processing' . chr(10) . '        if ( parts[i].type ==  "%" ) {' . chr(10) . '            newString += preSubstitution;' . chr(10) . '            continue;' . chr(10) . '        }' . chr(10) . chr(10) . '        // Modify the preSubstitution by taking sign, padding and width' . chr(10) . '        // into account' . chr(10) . chr(10) . '        // Pad the string based on the given width' . chr(10) . '        if ( parts[i].width != false ) {' . chr(10) . '            // Padding needed?' . chr(10) . '            if ( parts[i].width > preSubstitution.length ) ' . chr(10) . '            {' . chr(10) . '                var origLength = preSubstitution.length;' . chr(10) . '                for( var j = 0; j < parts[i].width - origLength; ++j ) ' . chr(10) . '                {' . chr(10) . '                    preSubstitution = ( parts[i].alignLeft == true ) ' . chr(10) . '                                      ? ( preSubstitution + parts[i].padding )' . chr(10) . '                                      : ( parts[i].padding + preSubstitution );' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . chr(10) . '        // Add a sign symbol if neccessary or enforced, but only if we are' . chr(10) . '        // not handling a string' . chr(10) . '        if ( parts[i].type == ' . chr(39) . 'b' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'd' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'o' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'f' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'x' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'X' . chr(39) . ' ) {' . chr(10) . '            if ( parts[i].negative == true ) {' . chr(10) . '                preSubstitution = "-" + preSubstitution;' . chr(10) . '            }' . chr(10) . '            else if ( parts[i].sign == true ) {' . chr(10) . '                preSubstitution = "+" + preSubstitution;' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . chr(10) . '        // Add the substitution to the new string' . chr(10) . '        newString += preSubstitution;' . chr(10) . '    }' . chr(10) . chr(10) . '    // Add the last part of the given format string, which may still be there' . chr(10) . '    newString += format.substring( start, format.length );' . chr(10) . chr(10) . '    return newString;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.printf = function(List__) {' . chr(10) . '    return CORE.print([ CORE.sprintf(List__) ]);' . chr(10) . '};' . chr(10) . chr(10))))
};
1;

;

# use Perlito5::Javascript2::Sprintf
;
package main;
undef();

# use Perlito5::AST
;

# use Perlito5::Dumper
;
package Perlito5::Javascript3;
do {{
    ((my  $label_count) = 100);
    (my  %label);
    sub Perlito5::Javascript3::pkg {
        ('p5pkg["' . $Perlito5::PKG_NAME . '"]')
    };
    sub Perlito5::Javascript3::pkg_new_var {
        ($label{$Perlito5::PKG_NAME} = ('p5' . ($label_count)++))
    };
    sub Perlito5::Javascript3::get_label {
        ($label_count)++
    };
    sub Perlito5::Javascript3::tab {
        ((my  $level) = shift());
join("", chr(9) x $level)
    };
    ((our  %op_prefix_js_str) = ('prefix:<-A>', 'p5atime', 'prefix:<-C>', 'p5ctime', 'prefix:<-M>', 'p5mtime', 'prefix:<-d>', 'p5is_directory', 'prefix:<-e>', 'p5file_exists', 'prefix:<-f>', 'p5is_file', 'prefix:<-s>', 'p5size'));
    ((our  %op_infix_js_str) = ('infix:<eq>', ' == ', 'infix:<ne>', ' != ', 'infix:<le>', ' <= ', 'infix:<ge>', ' >= '));
    ((our  %op_infix_js_num) = ('infix:<==>', ' == ', 'infix:<!=>', ' != ', 'infix:<+>', ' + ', 'infix:<->', ' - ', 'infix:<*>', ' * ', 'infix:</>', ' / ', 'infix:<%>', ' % ', 'infix:<>>', ' > ', 'infix:<<>', ' < ', 'infix:<>=>', ' >= ', 'infix:<<=>', ' <= ', 'infix:<&>', ' & ', 'infix:<|>', ' | ', 'infix:<^>', ' ^ ', 'infix:<>>>', ' >>> ', 'infix:<<<>', ' << '));
    ((our  %op_to_bool) = map(+(($_, 1)), ('prefix:<!>', 'infix:<!=>', 'infix:<==>', 'infix:<<=>', 'infix:<>=>', 'infix:<>>', 'infix:<<>', 'infix:<eq>', 'infix:<ne>', 'infix:<ge>', 'infix:<le>', 'prefix:<not>', 'exists', 'defined')));
    ((our  %op_to_str) = map(+(($_, 1)), ('substr', 'join', 'list:<.>', 'chr')));
    ((our  %op_to_num) = map(+(($_, 1)), ('length', 'index', 'ord', 'oct', 'infix:<->', 'infix:<+>', 'infix:<*>', 'infix:</>', 'infix:<%>', 'infix:<**>')));
    ((my  %safe_char) = (' ', 1, '!', 1, '"', 1, '#', 1, '$', 1, '%', 1, '&', 1, '(', 1, ')', 1, '*', 1, '+', 1, ',', 1, '-', 1, '.', 1, '/', 1, ':', 1, ';', 1, '<', 1, '=', 1, '>', 1, '?', 1, '@', 1, '[', 1, ']', 1, '^', 1, '_', 1, '`', 1, '{', 1, '|', 1, '}', 1, '~', 1));
    sub Perlito5::Javascript3::escape_string {
        ((my  $s) = shift());
        (my  @out);
        ((my  $tmp) = '');
        if (($s eq '')) {
            return (chr(39) . chr(39))
        };
        for my $i ((0 .. (length($s) - 1))) {
            ((my  $c) = substr($s, $i, 1));
            if ((((((($c ge 'a') && ($c le 'z'))) || ((($c ge 'A') && ($c le 'Z')))) || ((($c ge '0') && ($c le '9')))) || exists($safe_char{$c}))) {
                ($tmp = ($tmp . $c))
            }
            else {
                if (($tmp ne '')) {
                    push(@out, (chr(39) . $tmp . chr(39)) )
                };
                push(@out, ('String.fromCharCode(' . ord($c) . ')') );
                ($tmp = '')
            }
        };
        if (($tmp ne '')) {
            push(@out, (chr(39) . $tmp . chr(39)) )
        };
        return (join(' + ', @out))
    };
    sub Perlito5::Javascript3::to_str {
        ((my  $cond) = shift());
        ((my  $level) = shift());
        ((my  $wantarray) = 'scalar');
        if (((($cond->isa('Perlito5::AST::Apply') && ($cond->code() eq 'circumfix:<( )>')) && $cond->{'arguments'}) && @{$cond->{'arguments'}})) {
            return (to_str($cond->{'arguments'}->[0], $level))
        };
        if ((($cond->isa('Perlito5::AST::Val::Buf')) || (($cond->isa('Perlito5::AST::Apply') && exists($op_to_str{$cond->code()}))))) {
            return ($cond->emit_javascript3($level, $wantarray))
        }
        else {
            return (('p5str(' . $cond->emit_javascript3($level, $wantarray) . ')'))
        }
    };
    sub Perlito5::Javascript3::to_num {
        ((my  $cond) = shift());
        ((my  $level) = shift());
        ((my  $wantarray) = 'scalar');
        if ((($cond->isa('Perlito5::AST::Val::Int') || $cond->isa('Perlito5::AST::Val::Num')) || (($cond->isa('Perlito5::AST::Apply') && exists($op_to_num{$cond->code()}))))) {
            return ($cond->emit_javascript3($level, $wantarray))
        }
        else {
            return (('p5num(' . $cond->emit_javascript3($level, $wantarray) . ')'))
        }
    };
    sub Perlito5::Javascript3::to_bool {
        ((my  $cond) = shift());
        ((my  $level) = shift());
        ((my  $wantarray) = 'scalar');
        if (((($cond->isa('Perlito5::AST::Apply') && ($cond->code() eq 'circumfix:<( )>')) && $cond->{'arguments'}) && @{$cond->{'arguments'}})) {
            return (to_bool($cond->{'arguments'}->[0], $level))
        };
        if (($cond->isa('Perlito5::AST::Apply') && ((($cond->code() eq 'infix:<&&>') || ($cond->code() eq 'infix:<and>'))))) {
            return (('(' . to_bool($cond->{'arguments'}->[0], $level) . ' && ' . to_bool($cond->{'arguments'}->[1], $level) . ')'))
        };
        if (($cond->isa('Perlito5::AST::Apply') && ((($cond->code() eq 'infix:<||>') || ($cond->code() eq 'infix:<or>'))))) {
            return (('(' . to_bool($cond->{'arguments'}->[0], $level) . ' || ' . to_bool($cond->{'arguments'}->[1], $level) . ')'))
        };
        if (((($cond->isa('Perlito5::AST::Val::Int')) || ($cond->isa('Perlito5::AST::Val::Num'))) || (($cond->isa('Perlito5::AST::Apply') && exists($op_to_bool{$cond->code()}))))) {
            return ($cond->emit_javascript3($level, $wantarray))
        }
        else {
            return (('p5bool(' . $cond->emit_javascript3($level, $wantarray) . ')'))
        }
    };
    sub Perlito5::Javascript3::is_scalar {
        (((((!($_[0]->isa('Perlito5::AST::Val::Int')) && !($_[0]->isa('Perlito5::AST::Val::Num'))) && !($_[0]->isa('Perlito5::AST::Val::Buf'))) && !($_[0]->isa('Perlito5::AST::Sub'))) && !((($_[0]->isa('Perlito5::AST::Var') && ($_[0]->{'sigil'} eq '$'))))) && !((($_[0]->isa('Perlito5::AST::Apply') && ((((exists($op_to_str{$_[0]->{'code'}}) || exists($op_to_num{$_[0]->{'code'}})) || exists($op_to_bool{$_[0]->{'code'}})) || ($_[0]->{'code'} eq 'prefix:<' . chr(92) . '>')))))))
    };
    sub Perlito5::Javascript3::to_value {
        ((my  $v) = shift());
        ((my  $level) = shift());
        ((my  $wantarray) = shift());
        return ((!($v) ? 'null' : (($v->isa('Perlito5::AST::Var') && ($v->sigil() eq '$')) ? ($v->emit_javascript3($level, $wantarray) . '.FETCH()') : $v->emit_javascript3($level, $wantarray))))
    };
    sub Perlito5::Javascript3::to_list {
        ((my  $items) = to_list_preprocess($_[0]));
        ((my  $level) = $_[1]);
        ((my  $literal_type) = ($_[2] || 'array'));
        ((my  $wantarray) = 'list');
        ((my  $interpolate) = 0);
        for (@{$items}) {
            if (is_scalar($_)) {
                ($interpolate = 1)
            }
        };
        if (($literal_type eq 'hash')) {
            if (!($interpolate)) {
                (my  @out);
                ((my  $printable) = 1);
                ((my  @in) = @{$items});
                for ( ; @in; do {{

}} ) {
                    ((my  $k) = shift(@in));
                    ((my  $v) = shift(@in));
                    ($k = $k->emit_javascript3($level, 0));
                    if (($k =~ m![ \[]!)) {
                        ($printable = 0)
                    };
                    ($v = to_value($v, $level, $wantarray));
                    push(@out, ($k . ' : ' . $v) )
                };
                if ($printable) {
                    return (('{' . join(', ', @out) . '}'))
                }
            };
            return (('p5a_to_h(' . to_list($items, $level, 'array') . ')'))
        };
        ($interpolate ? (('p5list_to_a(' . join(', ', map($_->emit_javascript3($level, $wantarray), @{$items})) . ')')) : (('[' . join(', ', map(to_value($_, $level, $wantarray), @{$items})) . ']')))
    };
    sub Perlito5::Javascript3::to_list_preprocess {
        (my  @items);
        for my $item (@{$_[0]}) {
            if (($item->isa('Perlito5::AST::Apply') && (((($item->code() eq 'circumfix:<( )>') || ($item->code() eq 'list:<,>')) || ($item->code() eq 'infix:<=>>'))))) {
                if (($item->isa('Perlito5::AST::Apply') && ($item->code() eq 'infix:<=>>'))) {
                    ($item->{'arguments'}->[0] = Perlito5::AST::Lookup->autoquote($item->{'arguments'}->[0]))
                };
                for my $arg (@{to_list_preprocess($item->arguments())}) {
                    push(@items, $arg )
                }
            }
            else {
                push(@items, $item )
            }
        };
        return (\@items)
    };
    sub Perlito5::Javascript3::to_scalar {
        ((my  $items) = to_scalar_preprocess($_[0]));
        ((my  $level) = $_[1]);
        ((my  $wantarray) = 'scalar');
        (@{$items} ? ('(' . join(', ', map($_->emit_javascript3($level, $wantarray), @{$items})) . ')') : 'null')
    };
    sub Perlito5::Javascript3::to_scalar_preprocess {
        (my  @items);
        for my $item (@{$_[0]}) {
            if (($item->isa('Perlito5::AST::Apply') && ((($item->code() eq 'list:<,>') || ($item->code() eq 'infix:<=>>'))))) {
                if (($item->isa('Perlito5::AST::Apply') && ($item->code() eq 'infix:<=>>'))) {
                    ($item->{'arguments'}->[0] = Perlito5::AST::Lookup->autoquote($item->{'arguments'}->[0]))
                };
                for my $arg (@{to_scalar_preprocess($item->arguments())}) {
                    push(@items, $arg )
                }
            }
            else {
                push(@items, $item )
            }
        };
        return (\@items)
    };
    sub Perlito5::Javascript3::to_runtime_context {
        ((my  $items) = to_scalar_preprocess($_[0]));
        ((my  $level) = $_[1]);
        ((my  $wantarray) = 'runtime');
        if (((@{$items} == 1) && is_scalar($items->[0]))) {
            return ($items->[0]->emit_javascript3($level, $wantarray))
        };
        ('p5context(' . '[' . join(', ', map($_->emit_javascript3($level, $wantarray), @{$items})) . ']' . ', p5want)')
    };
    sub Perlito5::Javascript3::autoquote {
        ((my  $index) = shift());
        ((my  $level) = shift());
        if (($index->isa('Perlito5::AST::Apply') && $index->{'bareword'})) {
            ($index = Perlito5::AST::Val::Buf->new('buf', ((($index->{'namespace'} ? ($index->{'namespace'} . '::') : '')) . $index->{'code'})))
        };
        return (to_str($index, $level))
    };
    sub Perlito5::Javascript3::emit_javascript3_autovivify {
        ((my  $obj) = shift());
        ((my  $level) = shift());
        ((my  $type) = shift());
        ((my  $wantarray) = 'scalar');
        return ($obj->emit_javascript3($level, $wantarray, $type))
    };
    sub Perlito5::Javascript3::emit_function_javascript3 {
        ((my  $level) = shift());
        ((my  $wantarray) = shift());
        ((my  $argument) = shift());
        if (($argument->isa('Perlito5::AST::Apply') && ($argument->code() eq 'return'))) {
            return (('function () { ' . $argument->emit_javascript3($level, $wantarray) . ' }'))
        };
        return (('function () { return ' . $argument->emit_javascript3($level, $wantarray) . ' }'))
    }
}};
package Perlito5::Javascript3::LexicalBlock;
do {{
    sub Perlito5::Javascript3::LexicalBlock::new {
        ((my  $class) = shift());
        bless({@_}, $class)
    };
    sub Perlito5::Javascript3::LexicalBlock::block {
        $_[0]->{        'block'}
    };
    sub Perlito5::Javascript3::LexicalBlock::needs_return {
        $_[0]->{        'needs_return'}
    };
    sub Perlito5::Javascript3::LexicalBlock::top_level {
        $_[0]->{        'top_level'}
    };
    sub Perlito5::Javascript3::LexicalBlock::has_decl {
        ((my  $self) = $_[0]);
        ((my  $type) = $_[1]);
        for my $decl (@{$self->{'block'}}) {
            if (defined($decl)) {
                if ((($decl->isa('Perlito5::AST::Decl') && ($decl->decl() eq $type)) || ($decl->isa('Perlito5::AST::Apply') && ($decl->code() eq $type)))) {
                    return (1)
                };
                if (($decl->isa('Perlito5::AST::Apply') && ($decl->code() eq 'infix:<=>'))) {
                    ((my  $var) = $decl->arguments()->[0]);
                    if ((($var->isa('Perlito5::AST::Decl') && ($var->decl() eq $type)) || ($decl->isa('Perlito5::AST::Apply') && ($decl->code() eq $type)))) {
                        return (1)
                    }
                }
            }
        };
        return (0)
    };
    sub Perlito5::Javascript3::LexicalBlock::emit_javascript3 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        ((my  $wantarray) = shift());
        (my  @block);
        for (@{$self->{'block'}}) {
            if (defined($_)) {
                push(@block, $_ )
            }
        };
        if (!(@block)) {
            return ((Perlito5::Javascript3::tab($level) . 'null;'))
        };
        ((my  $out) = '');
        (my  @str);
        ((my  $has_local) = $self->has_decl('local'));
        ((my  $create_context) = ($self->{'create_context'} && $self->has_decl('my')));
        ((my  $outer_pkg) = $Perlito5::PKG_NAME);
        ((my  $outer_throw) = $Perlito5::THROW);
        unshift(@{$Perlito5::VAR}, {});
        if ($self->{'top_level'}) {
            ($Perlito5::THROW = 0)
        };
        if ($has_local) {
            ($out = ($out . (Perlito5::Javascript3::tab($level) . 'var local_idx = p5LOCAL.length;' . chr(10))))
        };
        if ($self->{'top_level'}) {
            ($level)++
        };
        if ($create_context) {
            ($out = ($out . (Perlito5::Javascript3::tab($level) . '(function () {' . chr(10))));
            ($level)++
        };
        ((my  $tab) = Perlito5::Javascript3::tab($level));
        (my  $last_statement);
        if ($self->{'needs_return'}) {
            ($last_statement = pop(@block))
        };
        for my $decl (@block) {
            if (((ref($decl) eq 'Perlito5::AST::Apply') && ($decl->code() eq 'package'))) {
                ($Perlito5::PKG_NAME = $decl->{'namespace'});
                ($Perlito5::VAR->[0]->{'$_'} = {'decl', 'our', 'namespace', $Perlito5::PKG_NAME});
                ($Perlito5::VAR->[0]->{'$a'} = {'decl', 'our', 'namespace', $Perlito5::PKG_NAME});
                ($Perlito5::VAR->[0]->{'$b'} = {'decl', 'our', 'namespace', $Perlito5::PKG_NAME});
                ($Perlito5::VAR->[0]->{'$AUTOLOAD'} = {'decl', 'our', 'namespace', $Perlito5::PKG_NAME})
            };
            if ($decl->isa('Perlito5::AST::Decl')) {
                push(@str, $decl->emit_javascript3_init() )
            };
            if (($decl->isa('Perlito5::AST::Apply') && ($decl->code() eq 'my'))) {
                for (@{$decl->{'arguments'}}) {
                    if ($_->isa('Perlito5::AST::Var')) {
                        ((my  $d) = Perlito5::AST::Decl->new('decl', $decl->code(), 'var', $_));
                        push(@str, $d->emit_javascript3_init() )
                    }
                }
            };
            if (($decl->isa('Perlito5::AST::Apply') && ($decl->code() eq 'infix:<=>'))) {
                ((my  $arg) = $decl->{'arguments'}->[0]);
                if ($arg->isa('Perlito5::AST::Decl')) {
                    push(@str, $arg->emit_javascript3_init() )
                };
                if (($arg->isa('Perlito5::AST::Apply') && ($arg->code() eq 'my'))) {
                    for (@{$arg->{'arguments'}}) {
                        if ($_->isa('Perlito5::AST::Var')) {
                            ((my  $d) = Perlito5::AST::Decl->new('decl', $arg->code(), 'var', $_));
                            push(@str, $d->emit_javascript3_init() )
                        }
                    }
                }
            };
            if (!((($decl->isa('Perlito5::AST::Decl') && ($decl->decl() eq 'my'))))) {
                push(@str, ($decl->emit_javascript3($level, 'void') . ';') )
            }
        };
        if (($self->{'needs_return'} && $last_statement)) {
            if ($last_statement->isa('Perlito5::AST::Decl')) {
                push(@str, $last_statement->emit_javascript3_init() )
            };
            if (($last_statement->isa('Perlito5::AST::Apply') && ($last_statement->code() eq 'infix:<=>'))) {
                if ($last_statement->{'arguments'}->[0]->isa('Perlito5::AST::Decl')) {
                    push(@str, $last_statement->{'arguments'}->[0]->emit_javascript3_init() )
                }
            };
            if (((($last_statement->isa('Perlito5::AST::Apply') && ($last_statement->code() eq 'return')) && $self->{'top_level'}) && @{$last_statement->{'arguments'}})) {
                ($last_statement = $last_statement->{'arguments'}->[0])
            };
            if ($last_statement->isa('Perlito5::AST::If')) {
                ((my  $cond) = $last_statement->cond());
                ((my  $body) = $last_statement->body());
                ((my  $otherwise) = $last_statement->otherwise());
                ($body = Perlito5::Javascript3::LexicalBlock->new('block', $body->stmts(), 'needs_return', 1));
                push(@str, ('if ( ' . Perlito5::Javascript3::to_bool($cond, ($level + 1)) . ' ) {' . chr(10) . $body->emit_javascript3(($level + 1)) . chr(10) . Perlito5::Javascript3::tab($level) . '}') );
                if ($otherwise) {
                    ($otherwise = Perlito5::Javascript3::LexicalBlock->new('block', $otherwise->stmts(), 'needs_return', 1));
                    push(@str, (chr(10) . Perlito5::Javascript3::tab($level) . 'else {' . chr(10) . $otherwise->emit_javascript3(($level + 1)) . chr(10) . Perlito5::Javascript3::tab($level) . '}') )
                }
            }
            else {
                if ($last_statement->isa('Perlito5::AST::Lit::Block')) {
                    ((my  $body) = Perlito5::Javascript3::LexicalBlock->new('block', $last_statement->{'stmts'}, 'needs_return', 1));
                    push(@str, ('for (var i_ = 0; i_ < 1 ; i_++) {' . chr(10) . $body->emit_javascript3(($level + 1)) . chr(10) . Perlito5::Javascript3::tab($level) . '}') )
                }
                else {
                    if (((($last_statement->isa('Perlito5::AST::For') || $last_statement->isa('Perlito5::AST::While')) || ($last_statement->isa('Perlito5::AST::Apply') && ($last_statement->code() eq 'goto'))) || ($last_statement->isa('Perlito5::AST::Apply') && ($last_statement->code() eq 'return')))) {
                        push(@str, $last_statement->emit_javascript3($level, 'runtime') )
                    }
                    else {
                        if ($has_local) {
                            push(@str, ('return p5cleanup_local(local_idx, (' . Perlito5::Javascript3::to_runtime_context([$last_statement], $level) . '));') )
                        }
                        else {
                            push(@str, ('return (' . Perlito5::Javascript3::to_runtime_context([$last_statement], $level) . ');') )
                        }
                    }
                }
            }
        };
        if ($has_local) {
            push(@str, 'p5cleanup_local(local_idx, null);' )
        };
        if ($create_context) {
            ($level)--;
            push(@str, '})();' )
        };
        if (($self->{'top_level'} && $Perlito5::THROW)) {
            ($level)--;
            ($out = ($out . (Perlito5::Javascript3::tab($level) . 'try {' . chr(10) . join(chr(10), map(($tab . $_), @str)) . chr(10) . Perlito5::Javascript3::tab($level) . '}' . chr(10) . Perlito5::Javascript3::tab($level) . 'catch(err) {' . chr(10) . Perlito5::Javascript3::tab(($level + 1)) . 'if ( err instanceof Error ) {' . chr(10) . Perlito5::Javascript3::tab(($level + 2)) . 'throw(err);' . chr(10) . Perlito5::Javascript3::tab(($level + 1)) . '}' . chr(10) . Perlito5::Javascript3::tab(($level + 1)) . 'else {' . chr(10) . Perlito5::Javascript3::tab(($level + 2)) . (($has_local ? 'return p5cleanup_local(local_idx, err)' : 'return(err)')) . ';' . chr(10) . Perlito5::Javascript3::tab(($level + 1)) . '}' . chr(10) . Perlito5::Javascript3::tab($level) . '}')))
        }
        else {
            ($out = ($out . join(chr(10), map(($tab . $_), @str))))
        };
        ($Perlito5::PKG_NAME = $outer_pkg);
        if ($self->{'top_level'}) {
            ($Perlito5::THROW = $outer_throw)
        };
        shift(@{$Perlito5::VAR});
        return ($out)
    }
}};
package Perlito5::AST::CompUnit;
do {{
    sub Perlito5::AST::CompUnit::emit_javascript3 {
        ((my  $self) = $_[0]);
        ((my  $level) = $_[1]);
        ((my  $str) = ('(function () {' . chr(10) . Perlito5::Javascript3::LexicalBlock->new('block', $self->{'body'}, 'needs_return', 0)->emit_javascript3(($level + 1)) . chr(10) . Perlito5::Javascript3::tab($level) . '})()' . chr(10)));
        return ($str)
    };
    sub Perlito5::AST::CompUnit::emit_javascript3_program {
        ((my  $comp_units) = shift());
        ($Perlito5::PKG_NAME = 'main');
        ((my  $str) = ('' . 'var p5want = null;' . chr(10) . 'var ' . Perlito5::Javascript3::pkg_new_var() . ' = p5pkg[' . chr(39) . $Perlito5::PKG_NAME . chr(39) . '];' . chr(10)));
        ($Perlito5::VAR = [{'@_', {'decl', 'my'}, '$@', {'decl', 'our', 'namespace', 'main'}, '$|', {'decl', 'our', 'namespace', 'main'}, '$^O', {'decl', 'our', 'namespace', 'main'}, '%ENV', {'decl', 'our', 'namespace', 'main'}, '%INC', {'decl', 'our', 'namespace', 'main'}, '@#', {'decl', 'our', 'namespace', 'main'}, '@ARGV', {'decl', 'our', 'namespace', 'main'}, '@INC', {'decl', 'our', 'namespace', 'main'}, '$_', {'decl', 'our', 'namespace', $Perlito5::PKG_NAME}, '$a', {'decl', 'our', 'namespace', $Perlito5::PKG_NAME}, '$b', {'decl', 'our', 'namespace', $Perlito5::PKG_NAME}, '$AUTOLOAD', {'decl', 'our', 'namespace', $Perlito5::PKG_NAME}}]);
        for my $comp_unit (@{$comp_units}) {
            ($str = ($str . $comp_unit->emit_javascript3() . chr(10)))
        };
        return ($str)
    }
}};
package Perlito5::AST::Val::Int;
do {{
    sub Perlito5::AST::Val::Int::emit_javascript3 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        $self->{        'int'}
    }
}};
package Perlito5::AST::Val::Num;
do {{
    sub Perlito5::AST::Val::Num::emit_javascript3 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        $self->{        'num'}
    }
}};
package Perlito5::AST::Val::Buf;
do {{
    sub Perlito5::AST::Val::Buf::emit_javascript3 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        Perlito5::Javascript3::escape_string($self->{'buf'})
    }
}};
package Perlito5::AST::Lit::Block;
do {{
    sub Perlito5::AST::Lit::Block::emit_javascript3 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        ((my  $init) = '');
        if (($self->{'name'} eq 'INIT')) {
            ((my  $tmp) = ('p5pkg.main._tmp' . Perlito5::Javascript3::get_label()));
            ($init = (Perlito5::Javascript3::tab(($level + 2)) . ('if (' . $tmp . ') { return }; ' . $tmp . ' = 1;' . chr(10))))
        };
        return (('p5for_lex(' . 'function () {' . chr(10) . $init . (Perlito5::Javascript3::LexicalBlock->new('block', $self->{'stmts'}, 'needs_return', 0, 'top_level', 0))->emit_javascript3(($level + 2)) . chr(10) . Perlito5::Javascript3::tab(($level + 1)) . '}, ' . '[0], ' . $self->emit_javascript3_continue($level) . ', ' . '"' . (($self->{'label'} || '')) . '"' . ')'))
    };
    sub Perlito5::AST::Lit::Block::emit_javascript3_continue {
        ((my  $self) = shift());
        ((my  $level) = shift());
        if ((!($self->{'continue'}) || !(@{$self->{'continue'}->{'stmts'}}))) {
            return ('false')
        };
        return (('function () {' . chr(10) . (Perlito5::Javascript3::LexicalBlock->new('block', $self->{'continue'}->stmts(), 'needs_return', 0, 'top_level', 0))->emit_javascript3(($level + 2)) . chr(10) . Perlito5::Javascript3::tab(($level + 1)) . '}'))
    }
}};
package Perlito5::AST::Index;
do {{
    sub Perlito5::AST::Index::emit_javascript3 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        ((my  $wantarray) = shift());
        ((my  $type) = shift());
        ($type = ($type ? ('"' . $type . '"') : 'null'));
        if (($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '$'))) {
            ((my  $v) = Perlito5::AST::Var->new('sigil', '@', 'namespace', $self->{'obj'}->namespace(), 'name', $self->{'obj'}->name()));
            return (($v->emit_javascript3($level) . '.aget(' . Perlito5::Javascript3::to_num($self->{'index_exp'}, $level) . ', ' . $type . ')'))
        };
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && ($self->{'obj'}->{'code'} eq 'prefix:<$>'))) {
            return ((Perlito5::Javascript3::emit_javascript3_autovivify($self->{'obj'}->{'arguments'}->[0], $level, 'array') . '.aget(' . Perlito5::Javascript3::to_num($self->{'index_exp'}) . ', ' . $type . ')'))
        };
        return ((Perlito5::Javascript3::emit_javascript3_autovivify($self->{'obj'}, $level, 'array') . '.aget(' . Perlito5::Javascript3::to_num($self->{'index_exp'}, $level) . ', ' . $type . ')'))
    };
    sub Perlito5::AST::Index::emit_javascript3_set {
        ((my  $self) = shift());
        ((my  $arguments) = shift());
        ((my  $level) = shift());
        if (($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '$'))) {
            ((my  $v) = Perlito5::AST::Var->new('sigil', '@', 'namespace', $self->{'obj'}->namespace(), 'name', $self->{'obj'}->name()));
            return (($v->emit_javascript3($level) . '.aset(' . Perlito5::Javascript3::to_num($self->{'index_exp'}, ($level + 1)) . ', ' . Perlito5::Javascript3::to_scalar([$arguments], ($level + 1)) . ')'))
        };
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && ($self->{'obj'}->{'code'} eq 'prefix:<$>'))) {
            return ((Perlito5::Javascript3::emit_javascript3_autovivify($self->{'obj'}->{'arguments'}->[0], $level, 'array') . '.aset(' . Perlito5::Javascript3::to_num($self->{'index_exp'}) . ', ' . Perlito5::Javascript3::to_scalar([$arguments], ($level + 1)) . ')'))
        };
        return ((Perlito5::Javascript3::emit_javascript3_autovivify($self->{'obj'}, $level, 'array') . '.aset(' . Perlito5::Javascript3::to_num($self->{'index_exp'}, ($level + 1)) . ', ' . Perlito5::Javascript3::to_scalar([$arguments], ($level + 1)) . ')'))
    }
}};
package Perlito5::AST::Lookup;
do {{
    sub Perlito5::AST::Lookup::emit_javascript3 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        ((my  $wantarray) = shift());
        ((my  $type) = shift());
        ($type = ($type ? ('"' . $type . '"') : 'null'));
        if (($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '$'))) {
            ((my  $v) = Perlito5::AST::Var->new('sigil', '%', 'namespace', $self->{'obj'}->namespace(), 'name', $self->{'obj'}->name()));
            return ((Perlito5::Javascript3::emit_javascript3_autovivify($v, $level, 'hash') . '.hget(' . Perlito5::Javascript3::autoquote($self->{'index_exp'}, $level) . ', ' . $type . ')'))
        };
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && ($self->{'obj'}->{'code'} eq 'prefix:<$>'))) {
            return ((Perlito5::Javascript3::emit_javascript3_autovivify($self->{'obj'}->{'arguments'}->[0], $level, 'hash') . '.hget(' . Perlito5::Javascript3::autoquote($self->{'index_exp'}, $level, 'list') . ', ' . $type . ')'))
        };
        (Perlito5::Javascript3::emit_javascript3_autovivify($self->{'obj'}, $level, 'hash') . '.hget(' . Perlito5::Javascript3::autoquote($self->{'index_exp'}, $level) . ', ' . $type . ')')
    };
    sub Perlito5::AST::Lookup::emit_javascript3_set {
        ((my  $self) = shift());
        ((my  $arguments) = shift());
        ((my  $level) = shift());
        if (($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '$'))) {
            ((my  $v) = Perlito5::AST::Var->new('sigil', '%', 'namespace', $self->{'obj'}->namespace(), 'name', $self->{'obj'}->name()));
            return (($v->emit_javascript3($level) . '.hset(' . Perlito5::Javascript3::autoquote($self->{'index_exp'}, $level) . ', ' . Perlito5::Javascript3::to_scalar([$arguments], ($level + 1)) . ')'))
        };
        if (($self->{'obj'}->isa('Perlito5::AST::Apply') && ($self->{'obj'}->{'code'} eq 'prefix:<$>'))) {
            return ((Perlito5::Javascript3::emit_javascript3_autovivify($self->{'obj'}->{'arguments'}->[0], $level, 'hash') . '.hset(' . Perlito5::Javascript3::autoquote($self->{'index_exp'}, $level, 'list') . ', ' . Perlito5::Javascript3::to_scalar([$arguments], ($level + 1)) . ')'))
        };
        (Perlito5::Javascript3::emit_javascript3_autovivify($self->{'obj'}, $level, 'hash') . '.hset(' . Perlito5::Javascript3::autoquote($self->{'index_exp'}, $level) . ', ' . Perlito5::Javascript3::to_scalar([$arguments], ($level + 1)) . ')')
    }
}};
package Perlito5::AST::Var;
do {{
    ((my  $table) = {'$', 'v_', '@', 'List_', '%', 'Hash_', '&', ''});
    sub Perlito5::AST::Var::emit_javascript3 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        ((my  $wantarray) = shift());
        ((my  $str_name) = $self->{'name'});
        if (($str_name eq chr(92))) {
            ($str_name = chr(92) . chr(92))
        };
        if (($str_name eq '"')) {
            ($str_name = chr(92) . '"')
        };
        ((my  $perl5_name) = $self->perl5_name());
        (my  $decl_type);
        ((my  $decl) = $self->perl5_get_decl($perl5_name));
        if ($decl) {
            ($decl_type = $decl->{'decl'})
        }
        else {
            if ((!($self->{'namespace'}) && ($self->{'sigil'} ne '*'))) {
                if ($Perlito5::STRICT) {
                    die(('Global symbol "' . $perl5_name . '" requires explicit package name'))
                };
                ($self->{'namespace'} = $Perlito5::PKG_NAME)
            }
        };
        if (($self->{'sigil'} eq '@')) {
            if (($wantarray eq 'scalar')) {
                return (($self->emit_javascript3($level, 'list') . '.FETCHSIZE()'))
            };
            if (($wantarray eq 'runtime')) {
                return (('(p5want' . ' ? ' . $self->emit_javascript3($level, 'list') . ' : ' . $self->emit_javascript3($level, 'list') . '.FETCHSIZE()' . ')'))
            }
        };
        if (($self->{'sigil'} eq '&')) {
            return (('p5pkg["' . (($self->{'namespace'} || $Perlito5::PKG_NAME)) . '"]["' . $str_name . '"]'))
        };
        if (($self->{'sigil'} eq '*')) {
            return (('p5pkg["' . (($self->{'namespace'} || $Perlito5::PKG_NAME)) . '"]["' . $str_name . '"]'))
        };
        if (($decl_type eq 'our')) {
            ((my  $sigil) = (($self->{'sigil'} eq '$#') ? '@' : $self->{'sigil'}));
            ((my  $s) = ('p5pkg["' . (($self->{'namespace'} || $decl->{'namespace'})) . '"]["' . $table->{$sigil} . $str_name . '"]'));
            if (($self->{'sigil'} eq '$#')) {
                return (('(' . $s . '.FETCHSIZE() - 1)'))
            };
            return ($s)
        };
        ((my  $ns) = '');
        if ($self->{'namespace'}) {
            do {{
                if (($self->{'sigil'} eq '$#')) {
                    return (('(p5global("@", "' . $self->{'namespace'} . '", "' . $str_name . '").FETCHSIZE() - 1)'))
                };
                return (('p5global("' . $self->{'sigil'} . '", "' . $self->{'namespace'} . '", "' . $str_name . '")'))
            }}
        };
        if (($self->{'sigil'} eq '$#')) {
            return (('(' . $ns . $table->{'@'} . $str_name . '.FETCHSIZE() - 1)'))
        };
        ($ns . $table->{$self->{'sigil'}} . $str_name)
    };
    sub Perlito5::AST::Var::perl5_name {
        ((my  $self) = shift());
        ((my  $sigil) = $self->{'sigil'});
        if (($sigil eq '$#')) {
            ($sigil = '@')
        };
        ($sigil . (($self->{'namespace'} ? ($self->{'namespace'} . '::') : '')) . $self->{'name'})
    };
    sub Perlito5::AST::Var::perl5_get_decl {
        ((my  $self) = shift());
        ((my  $perl5_name) = shift());
        for (@{$Perlito5::VAR}) {
            if (exists($_->{$perl5_name})) {
                return ($_->{$perl5_name})
            }
        };
        return (undef())
    }
}};
package Perlito5::AST::Decl;
do {{
    sub Perlito5::AST::Decl::emit_javascript3 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        $self->{'var'}->emit_javascript3($level)
    };
    sub Perlito5::AST::Decl::emit_javascript3_init {
        ((my  $self) = shift());
        ((my  $env) = {'decl', $self->{'decl'}});
        ((my  $perl5_name) = $self->{'var'}->perl5_name());
        if (($self->{'decl'} ne 'my')) {
            if ((($self->{'decl'} eq 'our') && $self->{'var'}->{'namespace'})) {
                die(('No package name allowed for variable ' . $perl5_name . ' in "our"'))
            };
            if (($self->{'var'}->{'namespace'} eq '')) {
                ((my  $decl_namespace) = '');
                ((my  $decl) = $self->{'var'}->perl5_get_decl($perl5_name));
                if (((($self->{'decl'} eq 'local') && $decl) && ((($decl->{'decl'} eq 'our') || ($decl->{'decl'} eq 'local'))))) {
                    ($decl_namespace = $decl->{'namespace'})
                };
                ($env->{'namespace'} = ($decl_namespace || $Perlito5::PKG_NAME))
            }
        };
        ($Perlito5::VAR->[0]->{$perl5_name} = $env);
        if (($self->{'decl'} eq 'my')) {
            ((my  $str) = '');
            ($str = ($str . 'var ' . $self->{'var'}->emit_javascript3() . ' = '));
            if (($self->{'var'}->sigil() eq '%')) {
                ($str = ($str . 'new p5Hash({});'))
            }
            else {
                if (($self->{'var'}->sigil() eq '@')) {
                    ($str = ($str . 'new p5Array([]);'))
                }
                else {
                    ($str = ($str . 'new p5Scalar(null);'))
                }
            };
            return ($str)
        }
        else {
            if (($self->{'decl'} eq 'our')) {
                ((my  $str_name) = $self->{'var'}->{'name'});
                if (($str_name eq chr(92))) {
                    ($str_name = chr(92) . chr(92))
                };
                if (($str_name eq '"')) {
                    ($str_name = chr(92) . '"')
                };
                return (('p5global("' . $self->{'var'}->{'sigil'} . '", ' . '"' . (($self->{'var'}->{'namespace'} || $Perlito5::PKG_NAME)) . '", ' . '"' . $str_name . '")'))
            }
            else {
                if (($self->{'decl'} eq 'local')) {
                    ((my  $perl5_name) = $self->{'var'}->perl5_name());
                    ((my  $decl_namespace) = '');
                    ((my  $decl) = $self->{'var'}->perl5_get_decl($perl5_name));
                    if (($decl && ((($decl->{'decl'} eq 'our') || ($decl->{'decl'} eq 'local'))))) {
                        ($decl_namespace = $decl->{'namespace'})
                    };
                    ((my  $ns) = ('p5pkg["' . ((($self->{'var'}->{'namespace'} || $decl_namespace) || $Perlito5::PKG_NAME)) . '"]'));
                    return (('p5set_local(' . $ns . ',' . Perlito5::Javascript3::escape_string($self->{'var'}->{'name'}) . ',' . Perlito5::Javascript3::escape_string($self->{'var'}->{'sigil'}) . '); '))
                }
                else {
                    if (($self->{'decl'} eq 'state')) {
                        return (('// state ' . $self->{'var'}->emit_javascript3()))
                    }
                    else {
                        die(('not implemented: Perlito5::AST::Decl ' . chr(39) . $self->{'decl'} . chr(39)))
                    }
                }
            }
        }
    }
}};
package Perlito5::AST::Proto;
do {{
    sub Perlito5::AST::Proto::emit_javascript3 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        if (($self->{'name'} eq '__PACKAGE__')) {
            return (Perlito5::Javascript3::pkg())
        };
        ('p5pkg["' . $self->{'name'} . '"]')
    }
}};
package Perlito5::AST::Call;
do {{
    sub Perlito5::AST::Call::emit_javascript3 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        ((my  $wantarray) = shift());
        ((my  $type) = shift());
        ($type = ($type ? ('"' . $type . '"') : 'null'));
        ((my  $meth) = $self->{'method'});
        if (($meth eq 'postcircumfix:<[ ]>')) {
            return ((Perlito5::Javascript3::emit_javascript3_autovivify($self->{'invocant'}, $level, 'array') . '.aget(' . Perlito5::Javascript3::to_num($self->{'arguments'}) . ', ' . $type . ')'))
        };
        if (($meth eq 'postcircumfix:<{ }>')) {
            return ((Perlito5::Javascript3::emit_javascript3_autovivify($self->{'invocant'}, $level, 'hash') . '.hget(' . Perlito5::Javascript3::autoquote($self->{'arguments'}, $level, 'list') . ', ' . $type . ')'))
        };
        ((my  $invocant) = $self->{'invocant'}->emit_javascript3());
        if (($meth eq 'postcircumfix:<( )>')) {
            return (('p5code(' . $invocant . ')(' . Perlito5::Javascript3::to_list($self->{'arguments'}) . ', ' . ((($wantarray eq 'list') ? '1' : (($wantarray eq 'scalar') ? '0' : (($wantarray eq 'void') ? 'null' : 'p5want')))) . ')'))
        };
        if ((ref($meth) eq 'Perlito5::AST::Var')) {
            ($meth = $meth->emit_javascript3())
        }
        else {
            ($meth = ('"' . $meth . '"'))
        };
        return (('p5call(' . $invocant . ', ' . $meth . ', ' . Perlito5::Javascript3::to_list($self->{'arguments'}) . ', ' . ((($wantarray eq 'list') ? '1' : (($wantarray eq 'scalar') ? '0' : (($wantarray eq 'void') ? 'null' : 'p5want')))) . ')'))
    }
}};
package Perlito5::AST::Apply;
do {{
    sub Perlito5::AST::Apply::emit_regex_javascript3 {
        ((my  $op) = shift());
        ((my  $var) = shift());
        ((my  $regex) = shift());
        if ($regex->isa('Perlito5::AST::Var')) {
            ($regex = {'code', 'p5:m', 'arguments', [$regex, '']})
        };
        (my  $str);
        ((my  $code) = $regex->{'code'});
        ((my  $regex_args) = $regex->{'arguments'});
        if (($code eq 'p5:s')) {
            ($str = ($var->emit_javascript3() . '.assign(p5str(' . $var->emit_javascript3() . ').replace(/' . $regex_args->[0]->{'buf'} . '/' . $regex_args->[2] . ', ' . $regex_args->[1]->emit_javascript3() . '))'))
        }
        else {
            if (($code eq 'p5:m')) {
                ((my  $ast) = $regex_args->[0]);
                if ($ast->isa('Perlito5::AST::Val::Buf')) {
                    ($str = ('(' . 'p5str(' . $var->emit_javascript3() . ')' . '.match(/' . $ast->{'buf'} . '/' . $regex_args->[1] . ')' . ' ? 1 : 0)'))
                }
                else {
                    ($str = ('(new RegExp(' . $ast->emit_javascript3() . ', ' . '"' . $regex_args->[1] . '"' . '))' . '.exec(' . 'p5str(' . $var->emit_javascript3() . ')' . ')'))
                }
            }
            else {
                if (($code eq 'p5:tr')) {
                    ($str = ('p5tr(' . $var->emit_javascript3() . ', ' . $regex_args->[0]->emit_javascript3() . ', ' . $regex_args->[1]->emit_javascript3() . ')'))
                }
                else {
                    die(('Error: regex emitter - unknown operator ' . $code))
                }
            }
        };
        if (($op eq '=~')) {
            return ($str)
        };
        if (($op eq '!~')) {
            return (('!(' . $str . ')'))
        };
        die('Error: regex emitter')
    };
    ((my  %emit_js) = ('infix:<=~>', sub {
    ((my  $self) = $_[0]);
    emit_regex_javascript3('=~', $self->{'arguments'}->[0], $self->{'arguments'}->[1])
}, 'infix:<!~>', sub {
    ((my  $self) = $_[0]);
    emit_regex_javascript3('!~', $self->{'arguments'}->[0], $self->{'arguments'}->[1])
}, 'p5:s', sub {
    ((my  $self) = $_[0]);
    emit_regex_javascript3('=~', Perlito5::AST::Var->new('sigil', '$', 'namespace', '', 'name', '_'), $self)
}, 'p5:m', sub {
    ((my  $self) = $_[0]);
    emit_regex_javascript3('=~', Perlito5::AST::Var->new('sigil', '$', 'namespace', '', 'name', '_'), $self)
}, 'p5:tr', sub {
    ((my  $self) = $_[0]);
    emit_regex_javascript3('=~', Perlito5::AST::Var->new('sigil', '$', 'namespace', '', 'name', '_'), $self)
}, '__PACKAGE__', sub {
    ((my  $self) = $_[0]);
    ('"' . $Perlito5::PKG_NAME . '"')
}, 'wantarray', sub {
    ((my  $self) = $_[0]);
    'p5want'
}, 'package', sub {
    ((my  $self) = $_[0]);
    ('var ' . Perlito5::Javascript3::pkg_new_var() . ' = p5make_package("' . $self->{'namespace'} . '")')
}, 'infix:<=>>', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    (Perlito5::Javascript3::autoquote($self->{'arguments'}->[0], $level) . ', ' . $self->{'arguments'}->[1]->emit_javascript3($level))
}, 'infix:<cmp>', sub {
    ((my  $self) = $_[0]);
    ('p5cmp(' . join(', ', map(Perlito5::Javascript3::to_str($_), @{$self->{'arguments'}})) . ')')
}, 'infix:<<=>>', sub {
    ((my  $self) = $_[0]);
    ('p5cmp(' . join(', ', map(Perlito5::Javascript3::to_num($_), @{$self->{'arguments'}})) . ')')
}, 'infix:<**>', sub {
    ((my  $self) = $_[0]);
    ('Math.pow(' . join(', ', map(Perlito5::Javascript3::to_num($_), @{$self->{'arguments'}})) . ')')
}, 'prefix:<!>', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ('!( ' . Perlito5::Javascript3::to_bool($self->{'arguments'}->[0], $level) . ')')
}, 'prefix:<not>', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ('!( ' . Perlito5::Javascript3::to_bool($self->{'arguments'}->[0], $level) . ')')
}, 'prefix:<~>', sub {
    ((my  $self) = $_[0]);
    ('p5complement( ' . Perlito5::Javascript3::to_num($self->{'arguments'}->[0]) . ')')
}, 'prefix:<->', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    ('-( ' . $self->{'arguments'}->[0]->emit_javascript3($level, 'scalar') . ')')
}, 'prefix:<+>', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    ('(' . $self->{'arguments'}->[0]->emit_javascript3($level, $wantarray) . ')')
}, 'require', sub {
    ((my  $self) = $_[0]);
    ((my  $arg) = $self->{'arguments'}->[0]);
    if ($arg->isa('Perlito5::AST::Val::Num')) {
        return ('1')
    };
    ('p5pkg["Perlito5::Grammar::Use"].require([' . Perlito5::Javascript3::to_str($self->{'arguments'}->[0]) . ', ' . (($self->{'arguments'}->[0]->{'bareword'} ? 1 : 0)) . '])')
}, 'prefix:<$>', sub {
    ((my  $self) = $_[0]);
    ((my  $arg) = $self->{'arguments'}->[0]);
    (Perlito5::Javascript3::emit_javascript3_autovivify($arg, $level, 'scalar') . '.sderef()')
}, 'prefix:<@>', sub {
    ((my  $self) = $_[0]);
    ((my  $level) = $_[1]);
    ((my  $arg) = $self->{'arguments'}->[0]);
    (Perlito5::Javascript3::emit_javascript3_autovivify($arg, $level, 'array') . '.aderef()')
}, 'prefix:<$#>', sub {
    ((my  $self) = $_[0]);
    ((my  $level) = $_[1]);
    ((my  $arg) = $self->{'arguments'}->[0]);
    ('(' . Perlito5::Javascript3::emit_javascript3_autovivify($arg, $level, 'array') . '.aderef().FETCHSIZE() - 1)')
}, 'prefix:<%>', sub {
    ((my  $self) = $_[0]);
    ((my  $level) = $_[1]);
    ((my  $arg) = $self->{'arguments'}->[0]);
    (Perlito5::Javascript3::emit_javascript3_autovivify($arg, $level, 'hash') . '.hderef()')
}, 'prefix:<&>', sub {
    ((my  $self) = $_[0]);
    ((my  $level) = $_[1]);
    ((my  $arg) = $self->{'arguments'}->[0]);
    ('p5code_lookup_by_name("' . $Perlito5::PKG_NAME . '", ' . $arg->emit_javascript3($level) . ')')
}, 'circumfix:<[ ]>', sub {
    ((my  $self) = $_[0]);
    ('(new p5ArrayRef(new p5Array(' . Perlito5::Javascript3::to_list($self->{'arguments'}) . ')))')
}, 'circumfix:<{ }>', sub {
    ((my  $self) = $_[0]);
    ('(new p5HashRef(new p5Hash(' . Perlito5::Javascript3::to_list($self->{'arguments'}, $level, 'hash') . ')))')
}, 'prefix:<' . chr(92) . '>', sub {
    ((my  $self) = $_[0]);
    ((my  $level) = $_[1]);
    ((my  $arg) = $self->{'arguments'}->[0]);
    if ($arg->isa('Perlito5::AST::Var')) {
        if (($arg->sigil() eq '@')) {
            return (('(new p5ArrayRef(' . $arg->emit_javascript3($level) . '))'))
        };
        if (($arg->sigil() eq '%')) {
            return (('(new p5HashRef(' . $arg->emit_javascript3($level) . '))'))
        };
        if (($arg->sigil() eq '*')) {
            return (('(new p5GlobRef(' . $arg->emit_javascript3($level) . '))'))
        };
        if (($arg->sigil() eq '&')) {
            if ($arg->{'namespace'}) {
                return (('p5pkg["' . $arg->{'namespace'} . '"].' . $arg->{'name'}))
            }
            else {
                return ((Perlito5::Javascript3::pkg() . '.' . $arg->{'name'}))
            }
        }
    };
    return (('(new p5ScalarRef(' . $arg->emit_javascript3($level) . '))'))
}, 'postfix:<++>', sub {
    ((my  $self) = $_[0]);
    (Perlito5::Javascript3::emit_javascript3_autovivify($self->{'arguments'}->[0], $level, 'lvalue') . '.p5postincr()')
}, 'postfix:<-->', sub {
    ((my  $self) = $_[0]);
    (Perlito5::Javascript3::emit_javascript3_autovivify($self->{'arguments'}->[0], $level, 'lvalue') . '.p5postdecr()')
}, 'prefix:<++>', sub {
    ((my  $self) = $_[0]);
    (Perlito5::Javascript3::emit_javascript3_autovivify($self->{'arguments'}->[0], $level, 'lvalue') . '.p5incr()')
}, 'prefix:<-->', sub {
    ((my  $self) = $_[0]);
    (Perlito5::Javascript3::emit_javascript3_autovivify($self->{'arguments'}->[0], $level, 'lvalue') . '.p5decr()')
}, 'infix:<x>', sub {
    ((my  $self) = $_[0]);
    ('p5str_replicate(' . join(', ', map($_->emit_javascript3(), @{$self->{'arguments'}})) . ')')
}, 'list:<.>', sub {
    ((my  $self) = $_[0]);
    ('(' . join(' + ', map(Perlito5::Javascript3::to_str($_), @{$self->{'arguments'}})) . ')')
}, 'list:<,>', sub {
    ((my  $self) = $_[0]);
    Perlito5::Javascript3::to_list($self->{'arguments'})
}, 'infix:<..>', sub {
    ((my  $self) = $_[0]);
    ('(function (a) { ' . 'for (var i=' . $self->{'arguments'}->[0]->emit_javascript3() . ', l=' . $self->{'arguments'}->[1]->emit_javascript3() . '; ' . 'i<=l; ++i)' . '{ ' . 'a.push(i) ' . '}; ' . 'return a ' . '})([])')
}, 'delete', sub {
    ((my  $self) = $_[0]);
    ('(delete ' . $self->{'arguments'}->[0]->emit_javascript3() . ')')
}, 'scalar', sub {
    ((my  $self) = $_[0]);
    Perlito5::Javascript3::to_scalar($self->{'arguments'}, ($level + 1))
}, 'ternary:<? :>', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    ('( ' . Perlito5::Javascript3::to_bool($self->{'arguments'}->[0]) . ' ? ' . ($self->{'arguments'}->[1])->emit_javascript3($level, $wantarray) . ' : ' . ($self->{'arguments'}->[2])->emit_javascript3($level, $wantarray) . ')')
}, 'my', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    ('p5context(' . '[' . join(', ', map($_->emit_javascript3($level, $wantarray), @{$self->{'arguments'}})) . '], ' . ((($wantarray eq 'runtime') ? 'p5want' : (($wantarray eq 'list') ? 1 : 0))) . ')')
}, 'our', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    ('p5context(' . '[' . join(', ', map($_->emit_javascript3($level, $wantarray), @{$self->{'arguments'}})) . '], ' . ((($wantarray eq 'runtime') ? 'p5want' : (($wantarray eq 'list') ? 1 : 0))) . ')')
}, 'local', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    ('p5context(' . '[' . join(', ', map($_->emit_javascript3($level, $wantarray), @{$self->{'arguments'}})) . '], ' . ((($wantarray eq 'runtime') ? 'p5want' : (($wantarray eq 'list') ? 1 : 0))) . ')')
}, 'circumfix:<( )>', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    ('p5context(' . '[' . join(', ', map($_->emit_javascript3($level, $wantarray), @{$self->{'arguments'}})) . '], ' . ((($wantarray eq 'runtime') ? 'p5want' : (($wantarray eq 'list') ? 1 : 0))) . ')')
}, 'infix:<=>', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    ((my  $parameters) = $self->{'arguments'}->[0]);
    ((my  $arguments) = $self->{'arguments'}->[1]);
    if (($parameters->isa('Perlito5::AST::Apply') && ($parameters->code() eq 'prefix:<*>'))) {
        return (('p5set_glob(' . $parameters->{'arguments'}->[0]->emit_javascript3() . ', ' . Perlito5::Javascript3::to_scalar([$arguments], ($level + 1)) . ')'))
    };
    if (($parameters->isa('Perlito5::AST::Apply') && ((((($parameters->code() eq 'my') || ($parameters->code() eq 'our')) || ($parameters->code() eq 'local')) || ($parameters->code() eq 'circumfix:<( )>'))))) {
        ((my  $tmp) = ('tmp' . Perlito5::Javascript3::get_label()));
        ((my  $tmp2) = ('tmp' . Perlito5::Javascript3::get_label()));
        return (('(function () { ' . 'var ' . $tmp . ' = ' . Perlito5::Javascript3::to_list([$arguments], ($level + 1)) . '; ' . 'var ' . $tmp2 . ' = ' . $tmp . '.slice(0); ' . join('; ', (map(+(((($_->isa('Perlito5::AST::Apply') && ($_->code() eq 'undef')) ? ($tmp . '.shift()') : (($_->sigil() eq '$') ? ($_->emit_javascript3() . '.assign(' . $tmp . '.shift())') : (($_->sigil() eq '@') ? ($_->emit_javascript3() . '.assign(' . $tmp . '); ' . $tmp . ' = []') : (($_->sigil() eq '%') ? ($_->emit_javascript3() . '.assign(p5a_to_h(' . $tmp . ')); ' . $tmp . ' = []') : die('not implemented'))))))), @{$parameters->arguments()})),('return ' . $tmp2)) . ' })()'))
    };
    if ((($parameters->isa('Perlito5::AST::Var') && ($parameters->sigil() eq '$')) || ($parameters->isa('Perlito5::AST::Decl') && ($parameters->var()->sigil() eq '$')))) {
        return (('' . $parameters->emit_javascript3() . '.assign(' . Perlito5::Javascript3::to_scalar([$arguments], ($level + 1)) . ')'))
    };
    if (($parameters->isa('Perlito5::AST::Call') && ($parameters->{'method'} eq 'postcircumfix:<[ ]>'))) {
        return ((Perlito5::Javascript3::emit_javascript3_autovivify($parameters->{'invocant'}, $level, 'array') . '.aset(' . Perlito5::Javascript3::to_num($parameters->{'arguments'}) . ', ' . Perlito5::Javascript3::to_scalar([$arguments], ($level + 1)) . ')'))
    }
    else {
        if (($parameters->isa('Perlito5::AST::Call') && ($parameters->{'method'} eq 'postcircumfix:<{ }>'))) {
            return ((Perlito5::Javascript3::emit_javascript3_autovivify($parameters->{'invocant'}, $level, 'hash') . '.hset(' . Perlito5::Javascript3::autoquote($parameters->{'arguments'}, $level) . ', ' . Perlito5::Javascript3::to_scalar([$arguments], ($level + 1)) . ')'))
        }
        else {
            if ($parameters->isa('Perlito5::AST::Index')) {
                return ($parameters->emit_javascript3_set($arguments, ($level + 1)))
            }
            else {
                if ($parameters->isa('Perlito5::AST::Lookup')) {
                    return ($parameters->emit_javascript3_set($arguments, ($level + 1)))
                }
            }
        }
    };
    if (($parameters->isa('Perlito5::AST::Var') && ($parameters->sigil() eq '@'))) {
        return (($parameters->emit_javascript3() . '.assign(new p5Array(' . Perlito5::Javascript3::to_list([$arguments], ($level + 1)) . '))'))
    }
    else {
        if (($parameters->isa('Perlito5::AST::Decl') && ($parameters->var()->sigil() eq '@'))) {
            return (($parameters->var()->emit_javascript3() . '.assign(new p5Array(' . Perlito5::Javascript3::to_list([$arguments], ($level + 1)) . '))'))
        }
        else {
            if ((($parameters->isa('Perlito5::AST::Var') && ($parameters->sigil() eq '%')) || ($parameters->isa('Perlito5::AST::Decl') && ($parameters->var()->sigil() eq '%')))) {
                return (($parameters->emit_javascript3() . '.assign(new p5Hash(' . Perlito5::Javascript3::to_list([$arguments], ($level + 1), 'hash') . '))'))
            }
        }
    };
    if (($parameters->isa('Perlito5::AST::Var') && ($parameters->sigil() eq '*'))) {
        return (('(' . $parameters->emit_javascript3($level) . ' = ' . $arguments->emit_javascript3(($level + 1)) . ')'))
    };
    say(Perlito5::Dumper::Dumper($parameters));
    die('assignment: don' . chr(39) . 't know what to do with left side isa ', ref($parameters))
}, 'break', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ($Perlito5::THROW = 1);
    'throw(new p5_error("break", ""))'
}, 'next', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ($Perlito5::THROW = 1);
    ((my  $label) = ($self->{'arguments'}->[0]->{'code'} || ''));
    ('throw(new p5_error("next", "' . $label . '"))')
}, 'last', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ($Perlito5::THROW = 1);
    ((my  $label) = ($self->{'arguments'}->[0]->{'code'} || ''));
    ('throw(new p5_error("last", "' . $label . '"))')
}, 'redo', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ($Perlito5::THROW = 1);
    ((my  $label) = ($self->{'arguments'}->[0]->{'code'} || ''));
    ('throw(new p5_error("redo", "' . $label . '"))')
}, 'return', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ($Perlito5::THROW = 1);
    ('throw(' . Perlito5::Javascript3::to_runtime_context($self->{'arguments'}, $level) . ')')
}, 'goto', sub {
    ((my  $self) = $_[0]);
    ($Perlito5::THROW = 1);
    ('throw((' . $self->{'arguments'}->[0]->emit_javascript3() . ')([List__, p5want]))')
}, 'do', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    ((my  $ast) = Perlito5::AST::Apply->new('code', 'eval', 'namespace', '', 'arguments', [Perlito5::AST::Apply->new('code', 'slurp', 'namespace', 'Perlito5::IO', 'arguments', $self->{'arguments'})]));
    $ast->emit_javascript3($level)
}, 'eval', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    ($Perlito5::THROW = 1);
    ((my  $arg) = $self->{'arguments'}->[0]);
    (my  $eval);
    if ($arg->isa('Perlito5::AST::Do')) {
        ($eval = $arg->emit_javascript3(($level + 1), $wantarray))
    }
    else {
        ((my  $var_env_perl5) = Perlito5::Dumper::Dumper($Perlito5::VAR));
        ((my  $m) = Perlito5::Expression->term_square($var_env_perl5, 0));
        ($m = Perlito5::Expression::expand_list(Perlito5::Match::flat($m)->[2]));
        ((my  $var_env_js) = ('(new p5ArrayRef(new p5Array(' . Perlito5::Javascript3::to_list($m) . ')))'));
        ($eval = ('eval(perl5_to_js(' . Perlito5::Javascript3::to_str($arg) . ', ' . '"' . $Perlito5::PKG_NAME . '", ' . $var_env_js . ', ' . '"' . $wantarray . '"' . '))'))
    };
    ('(function (p5want) {' . chr(10) . 'var r = null;' . chr(10) . 'p5pkg["main"]["v_@"].assign("");' . chr(10) . 'try {' . chr(10) . 'r = ' . $eval . chr(10) . '}' . chr(10) . 'catch(err) {' . chr(10) . 'if ( err instanceof p5_error ) {' . chr(10) . 'p5pkg["main"]["v_@"].assign(err);' . chr(10) . '}' . chr(10) . 'else if ( err instanceof Error ) {' . chr(10) . 'p5pkg["main"]["v_@"].assign(err);' . chr(10) . '}' . chr(10) . 'else {' . chr(10) . 'return(err);' . chr(10) . '}' . chr(10) . '}' . chr(10) . 'return r;' . chr(10) . '})(' . ((($wantarray eq 'list') ? '1' : (($wantarray eq 'scalar') ? '0' : (($wantarray eq 'void') ? 'null' : 'p5want')))) . ')')
}, 'undef', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    if (($self->{'arguments'} && @{$self->{'arguments'}})) {
        return (($self->{'arguments'}->[0]->emit_javascript3() . '.assign(null)'))
    };
    return ('null')
}, 'shift', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    if (($self->{'arguments'} && @{$self->{'arguments'}})) {
        return ((Perlito5::Javascript3::pkg() . '.shift([' . join(', ', map($_->emit_javascript3($level), @{$self->{'arguments'}})) . '])'))
    };
    return ((Perlito5::Javascript3::pkg() . '.shift([List__])'))
}, 'map', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    ((my  @in) = @{$self->{'arguments'}});
    ((my  $fun) = shift(@in));
    ((my  $list) = Perlito5::Javascript3::to_list(\@in));
    if ((ref($fun) eq 'Perlito5::AST::Lit::Block')) {
        ($fun = $fun->{'stmts'})
    }
    else {
        ($fun = [$fun])
    };
    ('p5map(' . Perlito5::Javascript3::pkg() . ', ' . 'function (p5want) {' . chr(10) . (Perlito5::Javascript3::LexicalBlock->new('block', $fun, 'needs_return', 1, 'top_level', 0))->emit_javascript3(($level + 1)) . chr(10) . Perlito5::Javascript3::tab($level) . '}, ' . $list . ')')
}, 'grep', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    ((my  @in) = @{$self->{'arguments'}});
    ((my  $fun) = shift(@in));
    ((my  $list) = Perlito5::Javascript3::to_list(\@in));
    if ((ref($fun) eq 'Perlito5::AST::Lit::Block')) {
        ($fun = $fun->{'stmts'})
    }
    else {
        ($fun = [$fun])
    };
    ('p5grep(' . Perlito5::Javascript3::pkg() . ', ' . 'function (p5want) {' . chr(10) . (Perlito5::Javascript3::LexicalBlock->new('block', $fun, 'needs_return', 1, 'top_level', 0))->emit_javascript3(($level + 1)) . chr(10) . Perlito5::Javascript3::tab($level) . '}, ' . $list . ')')
}, 'sort', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    ((my  @in) = @{$self->{'arguments'}});
    (my  $fun);
    (my  $list);
    if ((ref($in[0]) eq 'Perlito5::AST::Lit::Block')) {
        ($fun = shift(@in));
        ($fun = ('function (p5want) {' . chr(10) . (Perlito5::Javascript3::LexicalBlock->new('block', $fun->{'stmts'}, 'needs_return', 1, 'top_level', 0))->emit_javascript3(($level + 1)) . chr(10) . Perlito5::Javascript3::tab($level) . '}'))
    }
    else {
        ($fun = 'null')
    };
    ($list = Perlito5::Javascript3::to_list(\@in));
    ('p5sort(' . Perlito5::Javascript3::pkg() . ', ' . $fun . ', ' . $list . ')')
}, 'infix:<//>', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    ('p5defined_or' . '(' . $self->{'arguments'}->[0]->emit_javascript3($level, 'scalar') . ', ' . Perlito5::Javascript3::emit_function_javascript3($level, $wantarray, $self->{'arguments'}->[1]) . ')')
}, 'exists', sub {
    ((my  $self) = shift());
    ((my  $level) = shift());
    ((my  $wantarray) = shift());
    ((my  $arg) = $self->{'arguments'}->[0]);
    if ($arg->isa('Perlito5::AST::Lookup')) {
        ((my  $v) = $arg->obj());
        if (($v->isa('Perlito5::AST::Var') && ($v->sigil() eq '$'))) {
            ($v = Perlito5::AST::Var->new('sigil', '%', 'namespace', $v->namespace(), 'name', $v->name()));
            return (('(' . $v->emit_javascript3() . ').exists(' . Perlito5::Javascript3::autoquote($arg->{'index_exp'}, $level) . ')'))
        };
        return (('(' . $v->emit_javascript3() . ').hderef().exists(' . Perlito5::Javascript3::autoquote($arg->{'index_exp'}, $level) . ')'))
    };
    if ($arg->isa('Perlito5::AST::Call')) {
        if (($arg->method() eq 'postcircumfix:<{ }>')) {
            return (('(' . $arg->invocant()->emit_javascript3() . ').hderef().exists(' . Perlito5::Javascript3::autoquote($arg->{'arguments'}, $level) . ')'))
        }
    }
}));
    sub Perlito5::AST::Apply::emit_javascript3 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        ((my  $wantarray) = shift());
        ((my  $apply) = $self->op_assign());
        if ($apply) {
            return ($apply->emit_javascript3($level))
        };
        ((my  $code) = $self->{'code'});
        if ((ref($code) ne '')) {
            ((my  @args) = ());
            for (@{$self->{'arguments'}}) {
                push(@args, $_->emit_javascript3() )
            };
            return (('p5code(' . $self->{'code'}->emit_javascript3($level) . ')(' . join(',', @args) . ')'))
        };
        if (exists($emit_js{$code})) {
            return ($emit_js{$code}->($self, $level, $wantarray))
        };
        if (exists($Perlito5::Javascript3::op_infix_js_str{$code})) {
            return (('(' . join($Perlito5::Javascript3::op_infix_js_str{$code}, map(Perlito5::Javascript3::to_str($_), @{$self->{'arguments'}})) . ')'))
        };
        if (exists($Perlito5::Javascript3::op_infix_js_num{$code})) {
            return (('(' . join($Perlito5::Javascript3::op_infix_js_num{$code}, map(Perlito5::Javascript3::to_num($_), @{$self->{'arguments'}})) . ')'))
        };
        if (exists($Perlito5::Javascript3::op_prefix_js_str{$code})) {
            return (($Perlito5::Javascript3::op_prefix_js_str{$code} . '(' . Perlito5::Javascript3::to_str($self->{'arguments'}->[0]) . ')'))
        };
        if ((($code eq 'infix:<&&>') || ($code eq 'infix:<and>'))) {
            return (('p5and' . '(' . $self->{'arguments'}->[0]->emit_javascript3($level, 'scalar') . ', ' . Perlito5::Javascript3::emit_function_javascript3($level, $wantarray, $self->{'arguments'}->[1]) . ')'))
        };
        if ((($code eq 'infix:<||>') || ($code eq 'infix:<or>'))) {
            return (('p5or' . '(' . $self->{'arguments'}->[0]->emit_javascript3($level, 'scalar') . ', ' . Perlito5::Javascript3::emit_function_javascript3($level, $wantarray, $self->{'arguments'}->[1]) . ')'))
        };
        if ($self->{'namespace'}) {
            if ((($self->{'namespace'} eq 'JS') && ($code eq 'inline'))) {
                if ($self->{'arguments'}->[0]->isa('Perlito5::AST::Val::Buf')) {
                    return ($self->{'arguments'}->[0]->{'buf'})
                }
                else {
                    die('JS::inline needs a string constant')
                }
            };
            ($code = ('p5pkg["' . $self->{'namespace'} . '"].' . $code))
        }
        else {
            ($code = (Perlito5::Javascript3::pkg() . '.' . $code))
        };
        (my  $sig);
        do {{
            ((my  $name) = $self->{'code'});
            ((my  $namespace) = ($self->{'namespace'} || $Perlito5::PKG_NAME));
            ((my  $effective_name) = ($namespace . '::' . $self->{'code'}));
            if (exists($Perlito5::PROTO->{$effective_name})) {
                ($sig = $Perlito5::PROTO->{$effective_name})
            }
            else {
                if ((((!($self->{'namespace'}) || ($namespace eq 'CORE'))) && exists($Perlito5::CORE_PROTO->{('CORE::' . $name)}))) {
                    ($effective_name = ('CORE::' . $name));
                    ($sig = $Perlito5::CORE_PROTO->{$effective_name})
                }
                else {
                    if ($self->{'bareword'}) {
                        if ($Perlito5::STRICT) {
                            die(('Bareword "' . $name . '" not allowed while "strict subs" in use'))
                        };
                        return (Perlito5::Javascript3::escape_string(((($self->{'namespace'} ? ($self->{'namespace'} . '::') : '')) . $name)))
                    }
                }
            }
        }};
        if (((((($self->{'code'} eq 'say') || ($self->{'code'} eq 'print'))) && !($self->{'namespace'})) && $self->{'bareword'})) {
            ($self->{'arguments'} = [Perlito5::AST::Var->new('sigil', '$', 'namespace', '', 'name', '_')])
        };
        if ($sig) {
            ((my  @out) = ());
            ((my  @in) = @{($self->{'arguments'} || [])});
            ((my  $optional) = 0);
            for ( ; length($sig); do {{

}} ) {
                ((my  $c) = substr($sig, 0, 1));
                if (($c eq ';')) {
                    ($optional = 1)
                }
                else {
                    if ((($c eq '$') || ($c eq '_'))) {
                        if ((@in || !($optional))) {
                            push(@out, shift(@in)->emit_javascript3($level, 'scalar') )
                        }
                    }
                    else {
                        if (($c eq '@')) {
                            if ((@in || !($optional))) {
                                push(@out, ('new p5Array(' . Perlito5::Javascript3::to_list(\@in) . ')') )
                            };
                            (@in = ())
                        }
                        else {
                            if (($c eq '*')) {
                                if ((@in || !($optional))) {
                                    ((my  $arg) = shift(@in));
                                    if ($arg->{'bareword'}) {
                                        push(@out, ('p5pkg["' . (($arg->{'namespace'} || $Perlito5::PKG_NAME)) . '"]["f_' . $arg->{'code'} . '"]') )
                                    }
                                    else {
                                        push(@out, $arg->emit_javascript3($level, 'scalar') )
                                    }
                                }
                            }
                            else {
                                if (($c eq chr(92))) {
                                    if ((substr($sig, 0, 2) eq chr(92) . '$')) {
                                        ($sig = substr($sig, 1));
                                        if ((@in || !($optional))) {
                                            push(@out, shift(@in)->emit_javascript3($level, 'scalar') )
                                        }
                                    }
                                    else {
                                        if (((substr($sig, 0, 2) eq chr(92) . '@') || (substr($sig, 0, 2) eq chr(92) . '%'))) {
                                            ($sig = substr($sig, 1));
                                            if ((@in || !($optional))) {
                                                push(@out, shift(@in)->emit_javascript3($level, 'list') )
                                            }
                                        }
                                        else {
                                            if ((substr($sig, 0, 5) eq chr(92) . '[@%]')) {
                                                ($sig = substr($sig, 4));
                                                if ((@in || !($optional))) {
                                                    push(@out, shift(@in)->emit_javascript3($level, 'list') )
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                };
                ($sig = substr($sig, 1))
            };
            return (($code . '([' . join(', ', @out) . '], ' . ((($wantarray eq 'list') ? '1' : (($wantarray eq 'scalar') ? '0' : (($wantarray eq 'void') ? 'null' : 'p5want')))) . ')'))
        };
        ((my  @args) = ());
        ((my  $arg_list) = Perlito5::Javascript3::to_list_preprocess($self->{'arguments'}));
        for (@{$arg_list}) {
            push(@args, $_->emit_javascript3($level) )
        };
        ((my  $arg_code) = (($self->{'code'} eq 'scalar') ? ('[' . join(', ', @args) . ']') : ('p5param_list(' . join(', ', map($_->emit_javascript3($level, 'list', 'lvalue'), @{$arg_list})) . ')')));
        ($code . '(' . $arg_code . ', ' . ((($wantarray eq 'list') ? '1' : (($wantarray eq 'scalar') ? '0' : (($wantarray eq 'void') ? 'null' : 'p5want')))) . ')')
    }
}};
package Perlito5::AST::If;
do {{
    sub Perlito5::AST::If::emit_javascript3 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        ((my  $cond) = $self->{'cond'});
        ((my  $body) = Perlito5::Javascript3::LexicalBlock->new('block', $self->{'body'}->stmts(), 'needs_return', 0, 'create_context', 1));
        ((my  $s) = ('if ( ' . Perlito5::Javascript3::to_bool($cond, ($level + 1)) . ' ) {' . chr(10) . $body->emit_javascript3(($level + 1)) . chr(10) . Perlito5::Javascript3::tab($level) . '}'));
        if (@{$self->{'otherwise'}->stmts()}) {
            ((my  $otherwise) = Perlito5::Javascript3::LexicalBlock->new('block', $self->{'otherwise'}->stmts(), 'needs_return', 0, 'create_context', 1));
            ($s = ($s . chr(10) . Perlito5::Javascript3::tab($level) . 'else {' . chr(10) . $otherwise->emit_javascript3(($level + 1)) . chr(10) . Perlito5::Javascript3::tab($level) . '}'))
        };
        return ($s)
    }
}};
package Perlito5::AST::When;
do {{
    sub Perlito5::AST::When::emit_javascript3 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        ((my  $cond) = $self->{'cond'});
        ((my  $body) = Perlito5::Javascript3::LexicalBlock->new('block', $self->{'body'}->stmts(), 'needs_return', 0, 'create_context', 1));
        ((my  $expr) = Perlito5::AST::Apply->new('code', 'infix:<==>', 'arguments', [Perlito5::AST::Var->new('sigil', '$', 'namespace', '', 'name', '_'), $cond]));
        ((my  $s) = ('if ( ' . Perlito5::Javascript3::to_bool($expr, ($level + 1)) . ' ) {' . chr(10) . $body->emit_javascript3(($level + 1)) . chr(10) . Perlito5::Javascript3::tab(($level + 1)) . 'throw(new p5_error("next", "' . $label . '"))' . Perlito5::Javascript3::tab($level) . '}'));
        return ($s)
    }
}};
package Perlito5::AST::While;
do {{
    sub Perlito5::AST::While::emit_javascript3 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        ((my  $cond) = $self->{'cond'});
        return (('p5while(' . 'function () {' . chr(10) . (Perlito5::Javascript3::LexicalBlock->new('block', $self->{'body'}->stmts(), 'needs_return', 0, 'top_level', 0))->emit_javascript3(($level + 2)) . chr(10) . Perlito5::Javascript3::tab(($level + 1)) . '}, ' . Perlito5::Javascript3::emit_function_javascript3($level, 0, $cond) . ', ' . Perlito5::AST::Lit::Block::emit_javascript3_continue($self, $level) . ', ' . '"' . (($self->{'label'} || '')) . '"' . ')'))
    }
}};
package Perlito5::AST::For;
do {{
    sub Perlito5::AST::For::emit_javascript3 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        if ((ref($self->{'cond'}) eq 'ARRAY')) {
            ((my  $body) = Perlito5::Javascript3::LexicalBlock->new('block', $self->{'body'}->stmts(), 'needs_return', 0, 'create_context', 1));
            return (('for ( ' . (($self->{'cond'}->[0] ? ($self->{'cond'}->[0]->emit_javascript3(($level + 1)) . '; ') : '; ')) . (($self->{'cond'}->[1] ? ($self->{'cond'}->[1]->emit_javascript3(($level + 1)) . '; ') : '; ')) . (($self->{'cond'}->[2] ? ($self->{'cond'}->[2]->emit_javascript3(($level + 1)) . ' ') : ' ')) . ') {' . chr(10) . $body->emit_javascript3(($level + 1)) . chr(10) . Perlito5::Javascript3::tab($level) . '}'))
        };
        ((my  $cond) = Perlito5::Javascript3::to_list([$self->{'cond'}], ($level + 1)));
        if ($self->{'body'}->sig()) {
            ((my  $v) = $self->{'body'}->sig());
            ($Perlito5::VAR->[0]->{$v->perl5_name()} = {'decl', 'my'});
            ((my  $sig) = $v->emit_javascript3(($level + 1)));
            return (('p5for_lex(' . ('function (' . $sig . ') {' . chr(10)) . (Perlito5::Javascript3::LexicalBlock->new('block', $self->{'body'}->stmts(), 'needs_return', 0, 'top_level', 0))->emit_javascript3(($level + 2)) . chr(10) . Perlito5::Javascript3::tab(($level + 1)) . '}, ' . $cond . ', ' . Perlito5::AST::Lit::Block::emit_javascript3_continue($self, $level) . ', ' . '"' . (($self->{'label'} || '')) . '"' . ')'))
        }
        else {
            return (('p5for(' . Perlito5::Javascript3::pkg() . ', ' . 'function () {' . chr(10) . (Perlito5::Javascript3::LexicalBlock->new('block', $self->{'body'}->stmts(), 'needs_return', 0, 'top_level', 0))->emit_javascript3(($level + 2)) . chr(10) . Perlito5::Javascript3::tab(($level + 1)) . '}, ' . $cond . ', ' . Perlito5::AST::Lit::Block::emit_javascript3_continue($self, $level) . ', ' . '"' . (($self->{'label'} || '')) . '"' . ')'))
        }
    }
}};
package Perlito5::AST::Sub;
do {{
    sub Perlito5::AST::Sub::emit_javascript3 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        ((my  $s) = ('function (List__, p5want) {' . chr(10) . Perlito5::Javascript3::tab(($level + 1)) . 'List__ = new p5Array(List__);' . chr(10) . (Perlito5::Javascript3::LexicalBlock->new('block', $self->{'block'}, 'needs_return', 1, 'top_level', 1))->emit_javascript3($level) . chr(10) . Perlito5::Javascript3::tab($level) . '}'));
        if ($self->{'name'}) {
            return (('p5make_sub("' . $self->{'namespace'} . '", "' . $self->{'name'} . '", ' . $s . ')'))
        }
        else {
            return ($s)
        }
    }
}};
package Perlito5::AST::Do;
do {{
    sub Perlito5::AST::Do::emit_javascript3 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        ((my  $wantarray) = shift());
        ((my  $block) = $self->simplify()->block());
        return (('(function () {' . chr(10) . (Perlito5::Javascript3::LexicalBlock->new('block', $block, 'needs_return', 1))->emit_javascript3(($level + 1), $wantarray) . chr(10) . Perlito5::Javascript3::tab($level) . '})()'))
    }
}};
package Perlito5::AST::Use;
do {{
    sub Perlito5::AST::Use::emit_javascript3 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        Perlito5::Grammar::Use::emit_time_eval($self);
        ('// ' . $self->{'code'} . ' ' . $self->{'mod'} . chr(10))
    }
}};

;

# use Perlito5::Javascript3::Emitter
;
package main;
undef();
package Perlito5::Javascript3::Runtime;
sub Perlito5::Javascript3::Runtime::emit_javascript3 {
    return ((('//' . chr(10) . '// lib/Perlito5/Javascript3/Runtime.js' . chr(10) . '//' . chr(10) . '// Runtime for "Perlito" Perl5-in-Javascript3' . chr(10) . '//' . chr(10) . '// AUTHORS' . chr(10) . '//' . chr(10) . '// Flavio Soibelmann Glock  fglock@gmail.com' . chr(10) . '//' . chr(10) . '// COPYRIGHT' . chr(10) . '//' . chr(10) . '// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.' . chr(10) . '//' . chr(10) . '// This program is free software; you can redistribute it and/or modify it' . chr(10) . '// under the same terms as Perl itself.' . chr(10) . '//' . chr(10) . '// See http://www.perl.com/perl/misc/Artistic.html' . chr(10) . chr(10) . 'var isNode = typeof require != "undefined";' . chr(10) . chr(10) . 'if (typeof p5pkg !== "object") {' . chr(10) . '    p5pkg = {};' . chr(10) . '    p5LOCAL = [];' . chr(10) . chr(10) . '    var universal = function () {};' . chr(10) . '    p5pkg.UNIVERSAL = new universal();' . chr(10) . '    p5pkg.UNIVERSAL._ref_ = "UNIVERSAL";' . chr(10) . '    p5pkg.UNIVERSAL.isa = function (List__) {' . chr(10) . '        // TODO - use @ISA' . chr(10) . '        var o = List__[0];' . chr(10) . '        var s = p5str(List__[1]);' . chr(10) . '        if (o instanceof p5Scalar) {' . chr(10) . '            o = o.FETCH();' . chr(10) . '        }' . chr(10) . '        return o._class_._ref_ == s' . chr(10) . '    };' . chr(10) . '    p5pkg.UNIVERSAL.can = function (List__) {' . chr(10) . '        var o = List__[0];' . chr(10) . '        var s = p5str(List__[1]);' . chr(10) . '        if (o instanceof p5Scalar) {' . chr(10) . '            o = o.FETCH();' . chr(10) . '        }' . chr(10) . '        if ( s.indexOf("::") == -1 ) {' . chr(10) . '            return p5method_lookup(s, o._class_._ref__, {})' . chr(10) . '        }' . chr(10) . '        var c = s.split("::");' . chr(10) . '        s = c.pop(); ' . chr(10) . '        return p5method_lookup(s, c.join("::"), {});' . chr(10) . '    };' . chr(10) . '    p5pkg.UNIVERSAL.DOES = p5pkg.UNIVERSAL.can;' . chr(10) . chr(10) . '    var core = function () {};' . chr(10) . '    p5pkg["CORE"] = new core();' . chr(10) . '    p5pkg["CORE"]._ref_ = "CORE";' . chr(10) . chr(10) . '    var core_global = function () {};' . chr(10) . '    core_global.prototype = p5pkg.CORE;' . chr(10) . '    p5pkg["CORE::GLOBAL"] = new core_global();' . chr(10) . '    p5pkg["CORE::GLOBAL"]._ref_ = "CORE::GLOBAL";' . chr(10) . chr(10) . '    p5_error = function (type, v) {' . chr(10) . '        this.type = type;' . chr(10) . '        this.v = v;' . chr(10) . '        this.toString = function(){' . chr(10) . '            if (this.type == ' . chr(39) . 'break' . chr(39) . ') {' . chr(10) . '                return ' . chr(39) . 'Can' . chr(92) . chr(39) . 't "break" outside a given block' . chr(39) . chr(10) . '            }' . chr(10) . '            if (this.type == ' . chr(39) . 'next' . chr(39) . ' || this.type == ' . chr(39) . 'last' . chr(39) . ' || this.type == ' . chr(39) . 'redo' . chr(39) . ') {' . chr(10) . '                if (this.v == "") { return ' . chr(39) . 'Can' . chr(92) . chr(39) . 't "' . chr(39) . ' + this.type + ' . chr(39) . '" outside a loop block' . chr(39) . ' }' . chr(10) . '                return ' . chr(39) . 'Label not found for "' . chr(39) . ' + this.type + ' . chr(39) . ' ' . chr(39) . ' + this.v + ' . chr(39) . '"' . chr(39) . ';' . chr(10) . '            }' . chr(10) . '            return this.v;' . chr(10) . '        };' . chr(10) . '    };' . chr(10) . '    p5_error.prototype = Error.prototype;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5make_package(pkg_name) {' . chr(10) . '    if (!p5pkg.hasOwnProperty(pkg_name)) {' . chr(10) . '        var tmp = function () {};' . chr(10) . '        tmp.prototype = p5pkg["CORE::GLOBAL"];' . chr(10) . '        p5pkg[pkg_name] = new tmp();' . chr(10) . '        p5pkg[pkg_name]._ref_ = pkg_name;' . chr(10) . '        p5pkg[pkg_name]._class_ = p5pkg[pkg_name];  // XXX memory leak' . chr(10) . chr(10) . '        // TODO - add the other package global variables' . chr(10) . '        p5pkg[pkg_name]["List_ISA"] = new p5Array([]);' . chr(10) . '        p5pkg[pkg_name]["v_a"] = new p5Scalar(null);' . chr(10) . '        p5pkg[pkg_name]["v_b"] = new p5Scalar(null);' . chr(10) . '        p5pkg[pkg_name]["v__"] = new p5Scalar(null);' . chr(10) . '        p5pkg[pkg_name]["v_AUTOLOAD"] = new p5Scalar(null);' . chr(10) . '    }' . chr(10) . '    return p5pkg[pkg_name];' . chr(10) . '}' . chr(10) . chr(10) . 'function p5code_lookup_by_name(package_name, sub_name) {' . chr(10) . '    // sub_name can have an optional namespace' . chr(10) . '    var parts = sub_name.split(/::/);' . chr(10) . '    if (parts.length > 1) {' . chr(10) . '        sub_name = parts.pop();' . chr(10) . '        package_name = parts.join("::");' . chr(10) . '    }' . chr(10) . '    if (p5pkg.hasOwnProperty(package_name)) {' . chr(10) . '        var c = p5pkg[package_name];' . chr(10) . '        if ( c.hasOwnProperty(sub_name) ) {' . chr(10) . '            return c[sub_name]' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return null;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5get_class_for_method(method, class_name, seen) {' . chr(10) . '    // default mro' . chr(10) . '    // TODO - cache the methods that were already looked up' . chr(10) . '    if ( p5pkg[class_name].hasOwnProperty(method) ) {' . chr(10) . '        return class_name' . chr(10) . '    }' . chr(10) . '    var isa = p5pkg[class_name].List_ISA;' . chr(10) . '    for (var i = 0; i < isa.length; i++) {' . chr(10) . '        if (!seen[isa[i]]) {' . chr(10) . '            var m = p5get_class_for_method(method, isa[i]);' . chr(10) . '            if (m) {' . chr(10) . '                return m ' . chr(10) . '            }' . chr(10) . '            seen[isa[i]]++;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '}' . chr(10) . chr(10) . 'function p5method_lookup(method, class_name, seen) {' . chr(10) . '    var c = p5get_class_for_method(method, class_name, seen);' . chr(10) . '    if (c) {' . chr(10) . '        return p5pkg[c][method]' . chr(10) . '    }' . chr(10) . '    if ( p5pkg.UNIVERSAL.hasOwnProperty(method) ) {' . chr(10) . '        return p5pkg.UNIVERSAL[method]' . chr(10) . '    }' . chr(10) . '}' . chr(10) . chr(10) . 'function p5call(invocant, method, list) {' . chr(10) . '    list.unshift(invocant);' . chr(10) . chr(10) . '    if (invocant instanceof p5Scalar) {' . chr(10) . '        // TODO - move p5call() to p5Scalar method' . chr(10) . '        invocant = invocant._v_;' . chr(10) . '    }' . chr(10) . chr(10) . '    if ( invocant.hasOwnProperty("_class_") ) {' . chr(10) . chr(10) . '        if ( invocant._class_.hasOwnProperty(method) ) {' . chr(10) . '            return invocant._class_[method](list)' . chr(10) . '        }' . chr(10) . '        var m = p5method_lookup(method, invocant._class_._ref_, {});' . chr(10) . '        if (m) {' . chr(10) . '            return m(list)' . chr(10) . '        }' . chr(10) . chr(10) . '        // method can have an optional namespace' . chr(10) . '        var pkg_name = method.split(/::/);' . chr(10) . '        if (pkg_name.length > 1) {' . chr(10) . '            var name = pkg_name.pop();' . chr(10) . '            pkg_name = pkg_name.join("::");' . chr(10) . '            m = p5method_lookup(name, pkg_name, {});' . chr(10) . '            if (m) {' . chr(10) . '                return m(list)' . chr(10) . '            }' . chr(10) . '            p5pkg.CORE.die(["method not found: ", name, " in class ", pkg_name]);' . chr(10) . '        }' . chr(10) . chr(10) . '        pkg_name = p5get_class_for_method(' . chr(39) . 'AUTOLOAD' . chr(39) . ', invocant._class_._ref_, {}) || p5get_class_for_method(' . chr(39) . 'AUTOLOAD' . chr(39) . ', "UNIVERSAL", {});' . chr(10) . '        if (pkg_name) {' . chr(10) . '            p5pkg[pkg_name]["v_AUTOLOAD"] = invocant._class_._ref_ + "::" + method;' . chr(10) . '            return p5pkg[pkg_name]["AUTOLOAD"](list);' . chr(10) . '        }' . chr(10) . chr(10) . '        p5pkg.CORE.die(["method not found: ", method, " in class ", invocant._class_._ref_]);' . chr(10) . chr(10) . '    }' . chr(10) . chr(10) . '    // the invocant doesn' . chr(39) . 't have a class' . chr(10) . chr(10) . '    if (typeof invocant === "string") {' . chr(10) . '        var aclass = p5make_package(invocant);' . chr(10) . '        return p5call(aclass, method, list);' . chr(10) . '    }' . chr(10) . chr(10) . '    p5pkg.CORE.die(["Can' . chr(39) . 't call method ", method, " on unblessed reference"]);' . chr(10) . chr(10) . '}' . chr(10) . chr(10) . 'p5make_package("main");' . chr(10) . 'p5pkg["main"]["v_@"]       = new p5Scalar("");  // $@' . chr(10) . 'p5pkg["main"]["v_|"]       = new p5Scalar(0);   // $|' . chr(10) . 'p5pkg["main"]["List_#"]    = new p5Array([]);   // @#' . chr(10) . 'p5pkg["main"]["v_^O"]      = new p5Scalar(isNode ? "node.js" : "javascript3");' . chr(10) . 'p5pkg["main"]["List_INC"]  = new p5Array([]);' . chr(10) . 'p5pkg["main"]["Hash_INC"]  = new p5Hash({});' . chr(10) . 'p5pkg["main"]["List_ARGV"] = new p5Array([]);' . chr(10) . 'p5pkg["main"]["Hash_ENV"]  = new p5Hash({});' . chr(10) . 'if (isNode) {' . chr(10) . '    p5pkg["main"]["List_ARGV"] = new p5Array(process.argv.splice(2));' . chr(10) . '    p5pkg["main"]["Hash_ENV"]  = new p5Hash(process.env);' . chr(10) . '    p5pkg["main"]["v_$"]       = new p5Scalar(process.pid);' . chr(10) . '} else if (typeof arguments === "object") {' . chr(10) . '    p5pkg["main"]["List_ARGV"] = new p5Array(arguments);' . chr(10) . '}' . chr(10) . chr(10) . 'p5make_package("Perlito5");' . chr(10) . 'p5make_package("Perlito5::IO");' . chr(10) . 'p5make_package("Perlito5::Runtime");' . chr(10) . 'p5make_package("Perlito5::Grammar");' . chr(10) . chr(10) . 'function p5make_sub(pkg_name, sub_name, func) {' . chr(10) . '    p5pkg[pkg_name][sub_name] = func;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5set_glob(name, data) {' . chr(10) . '    if ( name.indexOf("::") == -1 ) {' . chr(10) . '        p5pkg[ p5pkg["Perlito5"].v_PKG_NAME.FETCH() ][name] = data;' . chr(10) . '        return data;' . chr(10) . '    }' . chr(10) . '    var c = name.split("::");' . chr(10) . '    s = c.pop(); ' . chr(10) . '    var pkg = c.join("::");' . chr(10) . '    p5make_package(pkg);' . chr(10) . '    p5pkg[pkg][s] = data;' . chr(10) . '    return data;' . chr(10) . '}' . chr(10) . chr(10) . 'var sigils = { ' . chr(39) . '@' . chr(39) . ' : ' . chr(39) . 'List_' . chr(39) . ', ' . chr(39) . '%' . chr(39) . ' : ' . chr(39) . 'Hash_' . chr(39) . ', ' . chr(39) . '$' . chr(39) . ' : ' . chr(39) . 'v_' . chr(39) . ' };' . chr(10) . chr(10) . 'function p5set_local(namespace, name, sigil) {' . chr(10) . '    var vname = sigils[sigil] + name;' . chr(10) . '    p5LOCAL.push([namespace, vname, namespace[vname]]);' . chr(10) . chr(10) . '    if (sigil == ' . chr(39) . '$' . chr(39) . ') {' . chr(10) . '        namespace[vname] = new p5Scalar(null);' . chr(10) . '    }' . chr(10) . '    else if (sigil == ' . chr(39) . '@' . chr(39) . ') {' . chr(10) . '        namespace[vname] = new p5Array([]);' . chr(10) . '    }' . chr(10) . '    else if (sigil == ' . chr(39) . '%' . chr(39) . ') {' . chr(10) . '        namespace[vname] = new p5Hash({});' . chr(10) . '    }' . chr(10) . '    return namespace[vname];' . chr(10) . '}' . chr(10) . chr(10) . 'function p5cleanup_local(idx, value) {' . chr(10) . '    while (p5LOCAL.length > idx) {' . chr(10) . '        l = p5LOCAL.pop();' . chr(10) . '        l[0][l[1]] = l[2];' . chr(10) . '    }' . chr(10) . '    return value;' . chr(10) . '}' . chr(10) . chr(10) . 'function p5global(sigil, namespace, name) {' . chr(10) . '    // TODO - autovivify namespace' . chr(10) . '    var vname = sigils[sigil] + name;' . chr(10) . '    var v = p5pkg[namespace][vname];' . chr(10) . '    if (v != null) {' . chr(10) . '        return v;' . chr(10) . '    }' . chr(10) . '    if (sigil == ' . chr(39) . '$' . chr(39) . ') {' . chr(10) . '        p5pkg[namespace][vname] = new p5Scalar(null);' . chr(10) . '    }' . chr(10) . '    else if (sigil == ' . chr(39) . '@' . chr(39) . ') {' . chr(10) . '        p5pkg[namespace][vname] = new p5Array([]);' . chr(10) . '    }' . chr(10) . '    else if (sigil == ' . chr(39) . '%' . chr(39) . ') {' . chr(10) . '        p5pkg[namespace][vname] = new p5Hash({});' . chr(10) . '    }' . chr(10) . '    return p5pkg[namespace][vname];' . chr(10) . '}' . chr(10) . chr(10) . 'function p5HashRef(o) {' . chr(10) . '    this._href_ = o;' . chr(10) . '    this._ref_ = "HASH";' . chr(10) . '    this.p5bool = function() { return 1 };' . chr(10) . '    this.p5string = function() {' . chr(10) . '        return "HASH(0x0000)";  // TODO' . chr(10) . '    };' . chr(10) . '    this.hderef = function() {' . chr(10) . '        return this._href_;' . chr(10) . '    };' . chr(10) . '    this.hset = function(i, v) {' . chr(10) . '        return this._href_.hset(i, v);' . chr(10) . '    };' . chr(10) . '    this.hget = function(i, autoviv) {' . chr(10) . '        return this._href_.hget(i, autoviv);' . chr(10) . '    }' . chr(10) . '}' . chr(10) . chr(10) . 'function p5ArrayRef(o) {' . chr(10) . '    this._aref_ = o;' . chr(10) . '    this._ref_ = "ARRAY";' . chr(10) . '    this.p5bool = function() { return 1 };' . chr(10) . '    this.p5string = function() {' . chr(10) . '        return "ARRAY(0x0000)";  // TODO' . chr(10) . '    };' . chr(10) . '    this.aderef = function() {' . chr(10) . '        return this._aref_;' . chr(10) . '    };' . chr(10) . '    this.aset = function(i, v) {' . chr(10) . '        return this._aref_.aset(i, v);' . chr(10) . '    }' . chr(10) . '    this.aget = function(i, autoviv) {' . chr(10) . '        return this._aref_.aget(i, autoviv);' . chr(10) . '    }' . chr(10) . '}' . chr(10) . chr(10) . 'function p5ScalarRef(o) {' . chr(10) . '    this._scalar_ = o;' . chr(10) . '    this._ref_ = "SCALAR";' . chr(10) . '    this.p5bool = function() { return 1 };' . chr(10) . '    this.p5string = function() {' . chr(10) . '        return "SCALAR(0x0000)";  // TODO' . chr(10) . '    };' . chr(10) . '    this.sderef = function() {' . chr(10) . '        return this._scalar_;' . chr(10) . '    };' . chr(10) . '}' . chr(10) . chr(10) . 'function p5GlobRef(o) {' . chr(10) . '    this._scalar_ = o;' . chr(10) . '    this._ref_ = "GLOB";' . chr(10) . '    this.p5bool = function() { return 1 };' . chr(10) . '    this.p5string = function() {' . chr(10) . '        return "GLOB(0x0000)";  // TODO' . chr(10) . '    };' . chr(10) . '}' . chr(10) . chr(10) . 'function p5Array(o) {' . chr(10) . '    // TODO - array slice' . chr(10) . '    this._array_ = o;' . chr(10) . '    this._ref_ = "";' . chr(10) . '    this.p5bool = function() {' . chr(10) . '        return this._array_.length != 0' . chr(10) . '    };' . chr(10) . '    this.p5string = function() {' . chr(10) . '        return ' . chr(39) . chr(39) . ' + this._array_.length;' . chr(10) . '    };' . chr(10) . '    this.p5num = function() {' . chr(10) . '        return this._array_.length;' . chr(10) . '    };' . chr(10) . '    this.aset = function(i, v) {' . chr(10) . '        if (i < 0) {' . chr(10) . '            i = this._array_.length + i;' . chr(10) . '        }' . chr(10) . '        if (this._array_[i] instanceof p5Scalar) {' . chr(10) . '            this._array_[i].assign(v);' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            if (v instanceof p5Scalar) {' . chr(10) . '                this._array_[i] = v._v_;' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                this._array_[i] = v;' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        return v;' . chr(10) . '    };' . chr(10) . '    this.aget = function(i, autoviv) {' . chr(10) . '        if (i < 0) {' . chr(10) . '            i = this._array_.length + i;' . chr(10) . '        }' . chr(10) . '        if (autoviv) {' . chr(10) . '            if (autoviv == ' . chr(39) . 'lvalue' . chr(39) . ') {' . chr(10) . '                if (this._array_.length < i) {' . chr(10) . '                    // don' . chr(39) . 't vivify yet; create a proxy object' . chr(10) . '                    // attach a _proxy_ to the scalar' . chr(10) . '                    var v = new p5Scalar(null);' . chr(10) . '                    v._proxy_ = { _arrayobj_ : this, _key_ : i };' . chr(10) . '                    return v;' . chr(10) . '                }' . chr(10) . '                if (!(this._array_[i] instanceof p5Scalar)) {' . chr(10) . '                    this._array_[i] = new p5Scalar(this._array_[i]);' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            else if (autoviv == ' . chr(39) . 'array' . chr(39) . ') {' . chr(10) . '                if (!(this._array_[i] instanceof p5ArrayRef) &&' . chr(10) . '                    !(this._array_[i] instanceof p5Scalar))' . chr(10) . '                {' . chr(10) . '                    this._array_[i] = new p5ArrayRef(new p5Array([]));' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            else if (autoviv == ' . chr(39) . 'hash' . chr(39) . ') {' . chr(10) . '                if (!(this._array_[i] instanceof p5HashRef) &&' . chr(10) . '                    !(this._array_[i] instanceof p5Scalar))' . chr(10) . '                {' . chr(10) . '                    this._array_[i] = new p5HashRef(new p5Hash({}));' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        return this._array_[i];' . chr(10) . '    };' . chr(10) . '    this.get_values = function(o) {' . chr(10) . '        // add values to the param (a native js list)' . chr(10) . '        for(var i = 0; i < this._array_.length; i++) {' . chr(10) . '            o.push(this._array_[i]);' . chr(10) . '        }' . chr(10) . '        return o;' . chr(10) . '    };' . chr(10) . '    this.get_lvalues = function(o) {' . chr(10) . '        // add lvalues to the param (a native js list)' . chr(10) . '        for(var i = 0; i < this._array_.length; i++) {' . chr(10) . '            o.push(this._array_[i] instanceof p5Scalar ? this._array_[i] : this.aget(i, "lvalue"));' . chr(10) . '        }' . chr(10) . '        return o;' . chr(10) . '    };' . chr(10) . '    this.assign = function(a) {' . chr(10) . '        if (a instanceof Array) {' . chr(10) . '            // TODO - cleanup, this shouldn' . chr(39) . 't happen' . chr(10) . '            this._array_ = a;' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            this._array_ = a._array_;' . chr(10) . '        }' . chr(10) . '        return this;' . chr(10) . '    };' . chr(10) . chr(10) . '    // operations that can be tie()' . chr(10) . '    this.FETCHSIZE = function() {' . chr(10) . '        return this._array_.length;' . chr(10) . '    };' . chr(10) . '    this.PUSH = function(v) {' . chr(10) . '        for(var i = 0; i < v._array_.length; i++) {' . chr(10) . '            this._array_.push(v._array_[i] instanceof p5Scalar ? v._array_[i]._v_ :  v._array_[i]);' . chr(10) . '        }' . chr(10) . '        return this._array_.length;' . chr(10) . '    };' . chr(10) . '    this.UNSHIFT = function(v) {' . chr(10) . '        for(var i = v._array_.length-1; i >= 0; i--) {' . chr(10) . '            this._array_.unshift(v._array_[i] instanceof p5Scalar ? v._array_[i]._v_ :  v._array_[i]);' . chr(10) . '        }' . chr(10) . '        return this._array_.length;' . chr(10) . '    };' . chr(10) . '    this.POP = function() {' . chr(10) . '        if (this._array_.length == null) {' . chr(10) . '            return null;' . chr(10) . '        }' . chr(10) . '        return this._array_.pop();' . chr(10) . '    };' . chr(10) . '    this.SHIFT = function(v) {' . chr(10) . '        if (this._array_.length == null) {' . chr(10) . '            return null;' . chr(10) . '        }' . chr(10) . '        return this._array_.shift();' . chr(10) . '    };' . chr(10) . '}' . chr(10) . chr(10) . 'function p5Hash(o) {' . chr(10) . '    // TODO - hash slice' . chr(10) . '    this._hash_ = o;' . chr(10) . '    this._ref_ = "";' . chr(10) . '    this.p5bool = function() {' . chr(10) . '        o = this._hash_;' . chr(10) . '        for (var i in o) {' . chr(10) . '            return true;' . chr(10) . '        }' . chr(10) . '        return false;' . chr(10) . '    };' . chr(10) . '    this.p5string = function() {' . chr(10) . '        return ' . chr(39) . chr(39) . ' + this.p5num() + ' . chr(39) . '/8' . chr(39) . ';' . chr(10) . '    };' . chr(10) . '    this.p5num = function() {' . chr(10) . '        var out = 0;' . chr(10) . '        for (var i in this._hash_) {' . chr(10) . '            out++;' . chr(10) . '        }' . chr(10) . '        return out;' . chr(10) . '    };' . chr(10) . '    this.exists = function(i) {' . chr(10) . '        return this._hash_.hasOwnProperty(i);' . chr(10) . '    };' . chr(10) . '    this.hset = function(i, v) {' . chr(10) . '        if (this._hash_[i] instanceof p5Scalar) {' . chr(10) . '            this._hash_[i].assign(v);' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            if (v instanceof p5Scalar) {' . chr(10) . '                this._hash_[i] = v._v_;' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                this._hash_[i] = v;' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        return v;' . chr(10) . '    };' . chr(10) . '    this.hget = function(i, autoviv) {' . chr(10) . '        if (autoviv) {' . chr(10) . '            if (autoviv == ' . chr(39) . 'lvalue' . chr(39) . ') {' . chr(10) . '                if (! this._hash_.hasOwnProperty(i)) {' . chr(10) . '                    // don' . chr(39) . 't autovivify yet; create a proxy object' . chr(10) . '                    // attach a _proxy_ key to the scalar' . chr(10) . '                    var v = new p5Scalar(null);' . chr(10) . '                    v._proxy_ = { _hashobj_ : this, _key_ : i };' . chr(10) . '                    return v;' . chr(10) . '                }' . chr(10) . '                if (!(this._hash_[i] instanceof p5Scalar)) {' . chr(10) . '                    this._hash_[i] = new p5Scalar(this._hash_[i]);' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            else if (autoviv == ' . chr(39) . 'array' . chr(39) . ') {' . chr(10) . '                if (!(this._hash_[i] instanceof p5ArrayRef) &&' . chr(10) . '                    !(this._hash_[i] instanceof p5Scalar))' . chr(10) . '                {' . chr(10) . '                    this._hash_[i] = new p5ArrayRef(new p5Array([]));' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            else if (autoviv == ' . chr(39) . 'hash' . chr(39) . ') {' . chr(10) . '                if (!(this._hash_[i] instanceof p5HashRef) &&' . chr(10) . '                    !(this._hash_[i] instanceof p5Scalar))' . chr(10) . '                {' . chr(10) . '                    this._hash_[i] = new p5HashRef(new p5Hash({}));' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        return this._hash_[i];' . chr(10) . '    };' . chr(10) . '    this.get_values = function(o) {' . chr(10) . '        // add a native list of values to the param' . chr(10) . '        for (var i in this._hash_) {' . chr(10) . '            o.push(i);' . chr(10) . '            o.push(this._hash_[i]);' . chr(10) . '        }' . chr(10) . '        return o;' . chr(10) . '    };' . chr(10) . '    this.get_lvalues = function(o) {' . chr(10) . '        // add a native list of lvalues to the param' . chr(10) . '        for (var i in this._hash_) {' . chr(10) . '            o.push(i);' . chr(10) . '            o.push(this._hash_[i] instanceof p5Scalar ? this._hash_[i] : this.hget(i, "lvalue"));' . chr(10) . '        }' . chr(10) . '        return o;' . chr(10) . '    };' . chr(10) . '    this.assign = function(h) {' . chr(10) . '        if (h instanceof p5Hash) {' . chr(10) . '            this._hash_ = h._hash_;' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            // TODO - cleanup, this shouldn' . chr(39) . 't happen' . chr(10) . '            this._hash_ = h;' . chr(10) . '        }' . chr(10) . '        return this;' . chr(10) . '    }' . chr(10) . '}' . chr(10) . chr(10) . 'function p5Scalar(o) {' . chr(10) . '    this._v_ = o;' . chr(10) . '    this._ref_ = "";' . chr(10) . chr(10) . '    // be a value' . chr(10) . '    this.p5bool = function() {' . chr(10) . '        return p5bool(this._v_);' . chr(10) . '    };' . chr(10) . '    this.p5string = function() {' . chr(10) . '        return p5str(this._v_);' . chr(10) . '    };' . chr(10) . '    this.p5num = function() {' . chr(10) . '        return p5num(this._v_);' . chr(10) . '    };' . chr(10) . '    this.p5code = function() {' . chr(10) . '        return p5code(this._v_);' . chr(10) . '    };' . chr(10) . '    this.p5incr = function() {' . chr(10) . '        this._v_ = p5incr(this._v_);' . chr(10) . '        return this._v_;' . chr(10) . '    };' . chr(10) . '    this.p5postincr = function() {' . chr(10) . '        var v = this._v_;' . chr(10) . '        this._v_ = p5incr(this._v_);' . chr(10) . '        return v;' . chr(10) . '    };' . chr(10) . '    this.p5decr = function() {' . chr(10) . '        this._v_ = p5decr(this._v_);' . chr(10) . '        return this._v_;' . chr(10) . '    };' . chr(10) . '    this.p5postdecr = function() {' . chr(10) . '        var v = this._v_;' . chr(10) . '        this._v_ = p5decr(this._v_);' . chr(10) . '        return v;' . chr(10) . '    };' . chr(10) . chr(10) . '    // be a scalar ref' . chr(10) . '    this.sderef = function(i) {' . chr(10) . '        // TODO - autovivify scalar (with proxy object?)' . chr(10) . '        return this._v_.sderef();' . chr(10) . '    };' . chr(10) . chr(10) . '    // be an array ref' . chr(10) . '    this.aderef = function() {' . chr(10) . '        // TODO - autovivify array (with proxy object?)' . chr(10) . '        return this._v_.aderef();' . chr(10) . '    };' . chr(10) . '    this.aget = function(i, autoviv) {' . chr(10) . '        // TODO - autovivify array (with proxy object?)' . chr(10) . '        if (this._v_ == null) {' . chr(10) . '            this._v_ = new p5ArrayRef(new p5Array([]));' . chr(10) . '        }' . chr(10) . '        return this._v_.aget(i, autoviv);' . chr(10) . '    };' . chr(10) . '    this.aset = function(i, v) {' . chr(10) . '        if (this._v_ == null) {' . chr(10) . '            this._v_ = new p5ArrayRef(new p5Array([]));' . chr(10) . '        }' . chr(10) . '        return this._v_.aset(i, v);' . chr(10) . '    };' . chr(10) . chr(10) . '    // be a hash ref' . chr(10) . '    this.hderef = function() {' . chr(10) . '        // TODO - autovivify hash (with proxy object?)' . chr(10) . '        if (this._v_ == null) {' . chr(10) . '            this._v_ = new p5HashRef(new p5Hash([]));' . chr(10) . '        }' . chr(10) . '        return this._v_.hderef();' . chr(10) . '    };' . chr(10) . '    this.hget = function(i, autoviv) {' . chr(10) . '        // TODO - autovivify hash (with proxy object?)' . chr(10) . '        if (this._v_ == null) {' . chr(10) . '            this._v_ = new p5HashRef(new p5Hash([]));' . chr(10) . '        }' . chr(10) . '        return this._v_.hget(i, autoviv);' . chr(10) . '    }' . chr(10) . '    this.hset = function(i, v) {' . chr(10) . '        if (this._v_ == null) {' . chr(10) . '            this._v_ = new p5HashRef(new p5Hash([]));' . chr(10) . '        }' . chr(10) . '        return this._v_.hset(i, v);' . chr(10) . '    }' . chr(10) . chr(10) . '    // be a container' . chr(10) . '    this.get_values = function(o) {' . chr(10) . '        // add a native list of values to the param' . chr(10) . '        o.push(this);' . chr(10) . '        return o;' . chr(10) . '    };' . chr(10) . '    this.get_lvalues = function(o) {' . chr(10) . '        // add a native list of lvalues to the param' . chr(10) . '        o.push(this);' . chr(10) . '        return o;' . chr(10) . '    };' . chr(10) . '    this.assign = function(v) {' . chr(10) . '        if (this._proxy_) {' . chr(10) . '            // this scalar is a proxy to some other container' . chr(10) . '            // write-through' . chr(10) . '            if (this._proxy_._arrayobj_) {' . chr(10) . '                this._proxy_._arrayobj_.aset(this._proxy_._key_, v);' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                this._proxy_._hashobj_.hset(this._proxy_._key_, v);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        if (v instanceof p5Scalar) {' . chr(10) . '            this._v_ = v._v_;' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            // TODO - cleanup, this shouldn' . chr(39) . 't happen' . chr(10) . '            this._v_ = v;' . chr(10) . '        }' . chr(10) . '        return this;' . chr(10) . '    };' . chr(10) . chr(10) . '    // operations that can be tie()' . chr(10) . '    this.FETCH = function() {' . chr(10) . '        // not an lvalue' . chr(10) . '        return this._v_;' . chr(10) . '    };' . chr(10) . '}' . chr(10) . chr(10) . 'p5param_list = function() {' . chr(10) . '    var res = [];' . chr(10) . '    for (i = 0; i < arguments.length; i++) {' . chr(10) . '        if (arguments[i] == null) {' . chr(10) . '            res.push(null)' . chr(10) . '        }' . chr(10) . '        else if (arguments[i].hasOwnProperty("get_lvalues")) {' . chr(10) . '            // container' . chr(10) . '            arguments[i].get_lvalues(res);' . chr(10) . '        }' . chr(10) . '        else if (arguments[i] instanceof Array) {' . chr(10) . '            // js Array -- possibly generated by p5context()' . chr(10) . '            // maybe too late to get lvalues -- needs more testing' . chr(10) . '            // this doesn' . chr(39) . 't handle nested Array' . chr(10) . '            o = arguments[i];' . chr(10) . '            for (j = 0; j < o.length; j++) {' . chr(10) . '                res.push(o[j]);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            // non-container' . chr(10) . '            res.push(arguments[i]);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return res;' . chr(10) . '};' . chr(10) . chr(10) . 'p5list_to_a = function() {' . chr(10) . '    var res = [];' . chr(10) . '    for (i = 0; i < arguments.length; i++) {' . chr(10) . '        if (arguments[i] == null) {' . chr(10) . '            res.push(null)' . chr(10) . '        }' . chr(10) . '        else if (arguments[i].hasOwnProperty("get_values")) {' . chr(10) . '            // container' . chr(10) . '            arguments[i].get_values(res);' . chr(10) . '        }' . chr(10) . '        else if (arguments[i] instanceof Array) {' . chr(10) . '            // js Array -- possibly generated by p5context()' . chr(10) . '            o = arguments[i];' . chr(10) . '            for (j = 0; j < o.length; j++) {' . chr(10) . '                res.push(o[j]);' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        else {' . chr(10) . '            // non-container' . chr(10) . '            res.push(arguments[i]);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return res;' . chr(10) . '};' . chr(10) . chr(10) . 'p5a_to_h = function(a) {' . chr(10) . '    var res = {};' . chr(10) . '    for (i = 0; i < a.length; i+=2) {' . chr(10) . '        res[p5str(a[i])] = a[i+1];' . chr(10) . '    }' . chr(10) . '    return res;' . chr(10) . '};' . chr(10) . chr(10) . 'if (isNode) {' . chr(10) . '    var fs = require("fs");' . chr(10) . '    p5make_sub("Perlito5::IO", "slurp", function(List__) {' . chr(10) . '        var filename = p5str(List__[0]);' . chr(10) . '        return fs.readFileSync(filename, "utf8");' . chr(10) . '    });' . chr(10) . '} else {' . chr(10) . '    p5make_sub("Perlito5::IO", "slurp", function(List__) {' . chr(10) . '        var filename = p5str(List__[0]);' . chr(10) . '        if (typeof readFile == "function") {' . chr(10) . '            return readFile(filename);' . chr(10) . '        }' . chr(10) . '        if (typeof read == "function") {' . chr(10) . '            // v8' . chr(10) . '            return read(filename);' . chr(10) . '        }' . chr(10) . '        p5pkg.CORE.die(["Perlito5::IO::slurp() not implemented"]);' . chr(10) . '    });' . chr(10) . '}' . chr(10) . chr(10) . 'p5context = function(List__, p5want) {' . chr(10) . '    if (p5want) {' . chr(10) . '        return p5list_to_a.apply(null, List__);' . chr(10) . '    }' . chr(10) . '    // scalar: return the last value' . chr(10) . '    var o = List__;' . chr(10) . '    while (o instanceof Array) {' . chr(10) . '        o =   o.length' . chr(10) . '            ? o[o.length-1]' . chr(10) . '            : null;' . chr(10) . '    }' . chr(10) . '    return o;' . chr(10) . '}' . chr(10) . chr(10) . 'p5code = function(o) {' . chr(10) . '    if (typeof o === "function") {' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . '    return o.p5code();' . chr(10) . '};' . chr(10) . chr(10) . 'p5str = function(o) {' . chr(10) . '    if (o == null) {' . chr(10) . '        return "";' . chr(10) . '    }' . chr(10) . '    if (typeof o === "object" && (o instanceof Array)) {' . chr(10) . '        return CORE.join(["", o]);' . chr(10) . '    }' . chr(10) . '    if (typeof o.p5string === "function") {' . chr(10) . '        return o.p5string();' . chr(10) . '    }' . chr(10) . '    if (typeof o == "number" && Math.abs(o) < 0.0001 && o != 0) {' . chr(10) . '        return o.toExponential().replace(/e-(' . chr(92) . 'd)$/,"e-0$1");' . chr(10) . '    }' . chr(10) . '    if (typeof o === "boolean") {' . chr(10) . '        return o ? "1" : "";' . chr(10) . '    }' . chr(10) . '    if (typeof o !== "string") {' . chr(10) . '        return "" + o;' . chr(10) . '    }' . chr(10) . '    return o;' . chr(10) . '};' . chr(10) . chr(10) . 'p5num = function(o) {' . chr(10) . '    if (o == null) {' . chr(10) . '        return 0;' . chr(10) . '    }' . chr(10) . '    if (typeof o === "object" && (o instanceof Array)) {' . chr(10) . '        return o.length;' . chr(10) . '    }' . chr(10) . '    if (typeof o.p5num === "function") {' . chr(10) . '        return o.p5num();' . chr(10) . '    }' . chr(10) . '    if (typeof o !== "number") {' . chr(10) . '        return parseFloat(p5str(o));' . chr(10) . '    }' . chr(10) . '    return o;' . chr(10) . '};' . chr(10) . chr(10) . 'p5bool = function(o) {' . chr(10) . '    if (o) {' . chr(10) . '        if (typeof o === "boolean") {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        if (typeof o === "number") {' . chr(10) . '            return o;' . chr(10) . '        }' . chr(10) . '        if (typeof o === "string") {' . chr(10) . '            return o != "" && o != "0";' . chr(10) . '        }' . chr(10) . '        if (typeof o.p5bool === "function") {' . chr(10) . '            return o.p5bool();' . chr(10) . '        }' . chr(10) . '        if (typeof o.length === "number") {' . chr(10) . '            return o.length;' . chr(10) . '        }' . chr(10) . '        if (o instanceof Error) {' . chr(10) . '            return true;' . chr(10) . '        }' . chr(10) . '        for (var i in o) {' . chr(10) . '            return true;' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    return false;' . chr(10) . '};' . chr(10) . chr(10) . 'p5incr = function(o) {' . chr(10) . '    if (typeof o === "number") {' . chr(10) . '        return o + 1;' . chr(10) . '    }' . chr(10) . '    return p5str_inc(p5str(o));' . chr(10) . '};' . chr(10) . chr(10) . 'p5decr = function(o) {' . chr(10) . '    if (typeof o === "number") {' . chr(10) . '        return o - 1;' . chr(10) . '    }' . chr(10) . '    return p5num(o) - 1;' . chr(10) . '};' . chr(10) . chr(10) . 'p5and = function(a, fb) {' . chr(10) . '    if (p5bool(a)) {' . chr(10) . '        return fb();' . chr(10) . '    }' . chr(10) . '    return a;' . chr(10) . '};' . chr(10) . chr(10) . 'p5or = function(a, fb) {' . chr(10) . '    if (p5bool(a)) {' . chr(10) . '        return a;' . chr(10) . '    }' . chr(10) . '    return fb();' . chr(10) . '};' . chr(10) . chr(10) . 'p5defined_or = function(a, fb) {' . chr(10) . '    if (a == null) {' . chr(10) . '        return fb();' . chr(10) . '    }' . chr(10) . '    return a;' . chr(10) . '};' . chr(10) . chr(10) . 'p5cmp = function(a, b) {' . chr(10) . '    return a > b ? 1 : a < b ? -1 : 0 ' . chr(10) . '};' . chr(10) . chr(10) . 'p5complement = function(a) {' . chr(10) . '    return a < 0 ? ~a : 4294967295 - a' . chr(10) . '    // return a < 0 ? ~a : 18446744073709551615 - a' . chr(10) . '};' . chr(10) . chr(10) . 'p5str_replicate = function(o, n) {' . chr(10) . '    n = p5num(n);' . chr(10) . '    return n ? Array(n + 1).join(o) : "";' . chr(10) . '};' . chr(10) . chr(10) . 'p5str_inc = function(s) {' . chr(10) . '    s = p5str(s);' . chr(10) . '    if (s.length < 2) {' . chr(10) . '        if (s.match(/[012345678ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy]/)) {' . chr(10) . '            return String.fromCharCode(s.charCodeAt(0) + 1);' . chr(10) . '        }' . chr(10) . '        if (s == "9") {' . chr(10) . '            return "10";' . chr(10) . '        }' . chr(10) . '        if (s == "Z") {' . chr(10) . '            return "AA";' . chr(10) . '        }' . chr(10) . '        if (s == "z") {' . chr(10) . '            return "aa";' . chr(10) . '        }' . chr(10) . '        return "1";' . chr(10) . '    }' . chr(10) . '    var c = p5str_inc(s.substr(s.length-1, 1));' . chr(10) . '    if (c.length == 1) {' . chr(10) . '        return s.substr(0, s.length-1) + c;' . chr(10) . '    }' . chr(10) . '    return p5str_inc(s.substr(0, s.length-1)) + c.substr(c.length-1, 1);' . chr(10) . '};' . chr(10) . chr(10) . 'p5for = function(namespace, func, args, cont, label) {' . chr(10) . '    var _redo = false;' . chr(10) . chr(10) . '    var v_old = namespace["v__"];' . chr(10) . '    namespace["v__"] = new p5Scalar(null);' . chr(10) . chr(10) . '    for(var i = 0; i < args.length; i++) {' . chr(10) . '        namespace["v__"].assign(args[i]);   // ??? - should this be a bind?' . chr(10) . '        try {' . chr(10) . '            func()' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            if (err instanceof p5_error && err.v == label) {' . chr(10) . '                if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { i--; _redo = true }' . chr(10) . '                else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '            }' . chr(10) . '            else {' . chr(10) . '                throw(err)' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        if (cont) {' . chr(10) . '            try {' . chr(10) . '                if (!_redo) { cont() }' . chr(10) . '            }' . chr(10) . '            catch(err) {' . chr(10) . '                if (err instanceof p5_error && err.v == label) {' . chr(10) . '                    if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                    else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }' . chr(10) . '                    else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '                }            ' . chr(10) . '                else {' . chr(10) . '                    throw(err)' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    namespace["v__"] = v_old;' . chr(10) . '};' . chr(10) . chr(10) . 'p5for_lex = function(func, args, cont, label) {' . chr(10) . '    var _redo = false;' . chr(10) . '    var _arg  = new p5Scalar(null);' . chr(10) . '    for(var i = 0; i < args.length; i++) {' . chr(10) . '        try {' . chr(10) . '            _arg.assign(args[i]);' . chr(10) . '            func(_arg)' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            if (err instanceof p5_error && err.v == label) {' . chr(10) . '                if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { i--; _redo = true }' . chr(10) . '                else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '            }            ' . chr(10) . '            else {' . chr(10) . '                throw(err)' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        if (cont) {' . chr(10) . '            try {' . chr(10) . '                if (!_redo) { cont() }' . chr(10) . '            }' . chr(10) . '            catch(err) {' . chr(10) . '                if (err instanceof p5_error && err.v == label) {' . chr(10) . '                    if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                    else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }' . chr(10) . '                    else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '                }            ' . chr(10) . '                else {' . chr(10) . '                    throw(err)' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . 'p5while = function(func, cond, cont, label) {' . chr(10) . '    var _redo = false;' . chr(10) . '    while (_redo || p5bool(cond())) {' . chr(10) . '        _redo = false;' . chr(10) . '        try {' . chr(10) . '            func()' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            if (err instanceof p5_error && err.v == label) {' . chr(10) . '                if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }' . chr(10) . '                else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '            }            ' . chr(10) . '            else {' . chr(10) . '                throw(err)' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '        if (cont) {' . chr(10) . '            try {' . chr(10) . '                if (!_redo) { cont() }' . chr(10) . '            }' . chr(10) . '            catch(err) {' . chr(10) . '                if (err instanceof p5_error && err.v == label) {' . chr(10) . '                    if (err.type == ' . chr(39) . 'last' . chr(39) . ') { return }' . chr(10) . '                    else if (err.type == ' . chr(39) . 'redo' . chr(39) . ') { _redo = true }' . chr(10) . '                    else if (err.type != ' . chr(39) . 'next' . chr(39) . ') { throw(err) }' . chr(10) . '                }            ' . chr(10) . '                else {' . chr(10) . '                    throw(err)' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . 'p5map = function(namespace, func, args) {' . chr(10) . '    var v_old = namespace["v__"];' . chr(10) . '    namespace["v__"] = new p5Scalar(null);' . chr(10) . chr(10) . '    var out = [];' . chr(10) . '    for(var i = 0; i < args.length; i++) {' . chr(10) . '        namespace["v__"].assign(args[i]);' . chr(10) . '        var o = p5list_to_a(func(1));' . chr(10) . '        for(var j = 0; j < o.length; j++) {' . chr(10) . '            out.push(o[j]);' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    namespace["v__"] = v_old;' . chr(10) . '    return out;' . chr(10) . '};' . chr(10) . chr(10) . 'p5grep = function(namespace, func, args) {' . chr(10) . '    var v_old = namespace["v__"];' . chr(10) . '    namespace["v__"] = new p5Scalar(null);' . chr(10) . chr(10) . '    var out = [];' . chr(10) . '    for(var i = 0; i < args.length; i++) {' . chr(10) . '        namespace["v__"].assign(args[i]);' . chr(10) . '        if (p5bool(func(0))) {' . chr(10) . '            out.push(args[i])' . chr(10) . '        }' . chr(10) . '    }' . chr(10) . '    namespace["v__"] = v_old;' . chr(10) . '    return out;' . chr(10) . '};' . chr(10) . chr(10) . 'p5sort = function(namespace, func, args) {' . chr(10) . '    var a_old = namespace["v_a"];' . chr(10) . '    var b_old = namespace["v_b"];' . chr(10) . '    namespace["v_a"] = new p5Scalar(null);' . chr(10) . '    namespace["v_b"] = new p5Scalar(null);' . chr(10) . chr(10) . '    var out = ' . chr(10) . '        func == null' . chr(10) . '        ? args.sort()' . chr(10) . '        : args.sort(' . chr(10) . '            function(a, b) {' . chr(10) . '                namespace["v_a"].assign(a);' . chr(10) . '                namespace["v_b"].assign(b);' . chr(10) . '                return func(0);' . chr(10) . '            }' . chr(10) . '        );' . chr(10) . '    namespace["v_a"] = a_old;' . chr(10) . '    namespace["v_b"] = b_old;' . chr(10) . '    return out;' . chr(10) . '};' . chr(10) . chr(10) . 'perl5_to_js = function( source, namespace, var_env_js, p5want ) {' . chr(10) . '    // CORE.say(["source: [" + source + "]"]);' . chr(10) . chr(10) . '    var strict_old = p5global("$", "Perlito5", "STRICT").FETCH();' . chr(10) . '    var var_env_js_old = p5global("$", "Perlito5", "VAR").FETCH();' . chr(10) . '    p5pkg["Perlito5"].v_VAR.assign(var_env_js);' . chr(10) . chr(10) . '    var namespace_old = p5global("$", "Perlito5", "PKG_NAME").FETCH();' . chr(10) . '    p5pkg["Perlito5"].v_PKG_NAME.assign(namespace);' . chr(10) . chr(10) . '    match = p5call(p5pkg["Perlito5::Grammar"], "exp_stmts", [source, 0]);' . chr(10) . chr(10) . '    if ( !p5bool(match) || p5str(match.hget("to")) != source.length ) {' . chr(10) . '        CORE.die(["Syntax error in eval near pos ", match.hget("to") ]);' . chr(10) . '    }' . chr(10) . chr(10) . '    ast = p5pkg.CORE.bless([' . chr(10) . '        new p5HashRef(new p5Hash({' . chr(10) . '            block:  p5pkg.CORE.bless([' . chr(10) . '                        new p5HashRef(new p5Hash({' . chr(10) . '                            stmts:   p5pkg["Perlito5::Match"].flat([match])' . chr(10) . '                        })),' . chr(10) . '                        p5pkg["Perlito5::AST::Lit::Block"]' . chr(10) . '                    ])' . chr(10) . '        })),' . chr(10) . '        p5pkg["Perlito5::AST::Do"]' . chr(10) . '    ]);' . chr(10) . chr(10) . '    // CORE.say(["ast: [" + ast + "]"]);' . chr(10) . '    js_code = p5call(ast, "emit_javascript3", [0, p5want]);' . chr(10) . '    // CORE.say(["js-source: [" + js_code + "]"]);' . chr(10) . chr(10) . '    p5pkg["Perlito5"].v_PKG_NAME.assign(namespace_old);' . chr(10) . '    p5pkg["Perlito5"].v_VAR.assign(var_env_js_old);' . chr(10) . '    p5pkg["Perlito5"].v_STRICT.assign(strict_old);' . chr(10) . '    return js_code;' . chr(10) . '}' . chr(10) . chr(10))))
};
1;

;

# use Perlito5::Javascript3::Runtime
;
package main;
undef();
package Perlito5::Javascript3::CORE;
sub Perlito5::Javascript3::CORE::emit_javascript3 {
    return ((('//' . chr(10) . '//' . chr(10) . '// lib/Perlito5/Javascript3/CORE.js' . chr(10) . '//' . chr(10) . '// CORE functions for "Perlito" Perl5-in-Javascript3' . chr(10) . '//' . chr(10) . '// AUTHORS' . chr(10) . '//' . chr(10) . '// Flavio Soibelmann Glock  fglock@gmail.com' . chr(10) . '//' . chr(10) . '// COPYRIGHT' . chr(10) . '//' . chr(10) . '// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.' . chr(10) . '//' . chr(10) . '// This program is free software; you can redistribute it and/or modify it' . chr(10) . '// under the same terms as Perl itself.' . chr(10) . '//' . chr(10) . '// See http://www.perl.com/perl/misc/Artistic.html' . chr(10) . chr(10) . 'var CORE = p5pkg.CORE;' . chr(10) . chr(10) . 'var isNode = typeof require != "undefined";' . chr(10) . 'if (isNode) {' . chr(10) . '    CORE.print = function(List__) {' . chr(10) . '        var i;' . chr(10) . '        for (i = 0; i < List__.length; i++) {' . chr(10) . '            process.stdout.write(p5str(List__[i]));' . chr(10) . '        }' . chr(10) . '        return 1;' . chr(10) . '    }' . chr(10) . '} else {' . chr(10) . '    CORE.print = function(List__) {' . chr(10) . '        var i;' . chr(10) . '        for (i = 0; i < List__.length; i++) {' . chr(10) . '            write(p5str(List__[i]));' . chr(10) . '        }' . chr(10) . '        return 1;' . chr(10) . '    };' . chr(10) . '}' . chr(10) . chr(10) . 'CORE.say = function(List__) {' . chr(10) . '    CORE.print(List__);' . chr(10) . '    return CORE.print(["' . chr(92) . 'n"]);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.die = function(List__) {' . chr(10) . '    var o = List__[0]._array_;   // prototype is ' . chr(39) . '@' . chr(39) . chr(10) . '    var i;' . chr(10) . '    var s = "";' . chr(10) . '    for (i = 0; i < o.length; i++) {' . chr(10) . '        s = s + p5str(o[i]);' . chr(10) . '    }' . chr(10) . '    try {' . chr(10) . '        s = s + "' . chr(92) . 'n" + new Error().stack;' . chr(10) . '    }' . chr(10) . '    catch(err) { }' . chr(10) . '    p5pkg["main"]["v_@"].assign("Died: " + s);' . chr(10) . '    throw(new p5_error("die", "Died: " + s));' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.warn = function(List__) {' . chr(10) . '    var o = List__[0]._array_;   // prototype is ' . chr(39) . '@' . chr(39) . chr(10) . '    var i;' . chr(10) . '    var s = "";' . chr(10) . '    for (i = 0; i < o.length; i++) {' . chr(10) . '        s = s + p5str(o[i]);' . chr(10) . '    }' . chr(10) . '    try {' . chr(10) . '        s = s + "' . chr(92) . 'n" + new Error().stack;' . chr(10) . '    }' . chr(10) . '    catch(err) { }' . chr(10) . '    CORE.print(["Warning: " + s + "' . chr(92) . 'n"]);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.bless = function(List__) {' . chr(10) . '    var o        = List__[0];' . chr(10) . '    var pkg_name = List__[1];' . chr(10) . '    if (o instanceof p5Scalar) {' . chr(10) . '        o = o._v_;' . chr(10) . '    }' . chr(10) . '    if (pkg_name instanceof p5Scalar) {' . chr(10) . '        pkg_name = pkg_name._v_;' . chr(10) . '    }' . chr(10) . '    if (typeof pkg_name === "object") {' . chr(10) . '        // bless {}, Class' . chr(10) . '        o._class_ = pkg_name;' . chr(10) . '        return o;' . chr(10) . '    }' . chr(10) . '    if (!p5pkg.hasOwnProperty(pkg_name)) {' . chr(10) . '        p5make_package(pkg_name);' . chr(10) . '    }' . chr(10) . '    o._class_ = p5pkg[pkg_name];' . chr(10) . '    return o;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.caller = function(List__, p5want) {' . chr(10) . '    if (p5want) {' . chr(10) . '        return p5pkg["Perlito5"]["CALLER"][0];' . chr(10) . '    }' . chr(10) . '    return p5pkg["Perlito5"]["CALLER"][0][0];' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.chr = function(List__) {' . chr(10) . '    var v = p5num(List__[0]);' . chr(10) . '    return String.fromCharCode(v >= 0 ? v : 65533);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.ord = function(List__) {' . chr(10) . '    return p5str(List__[0]).charCodeAt(0);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.oct = function(List__) {' . chr(10) . '    var v = p5str(List__[0]);' . chr(10) . '    var b = v.substr(0,2);' . chr(10) . '    v = v.replace("_", "");' . chr(10) . '    if (b == "0b" || b == "0B") { return parseInt(v.substr(2), 2)  }' . chr(10) . '    if (b == "0x" || b == "0X") { return parseInt(v.substr(2), 16) }' . chr(10) . '    return parseInt(v, 8);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.abs   = function(List__) { return Math.abs(p5num(List__[0])) };' . chr(10) . 'CORE.exp   = function(List__) { return Math.exp(p5num(List__[0])) };' . chr(10) . 'CORE.log   = function(List__) { return Math.log(p5num(List__[0])) };' . chr(10) . 'CORE.cos   = function(List__) { return Math.cos(p5num(List__[0])) };' . chr(10) . 'CORE.sin   = function(List__) { return Math.sin(p5num(List__[0])) };' . chr(10) . 'CORE.sqrt  = function(List__) { return Math.sqrt(p5num(List__[0])) };' . chr(10) . 'CORE.atan2 = function(List__) { return Math.atan2(p5num(List__[0]), p5num(List__[1])) };' . chr(10) . 'CORE.int   = function(List__) { ' . chr(10) . '    var v = p5num(List__[0]);' . chr(10) . '    return v > 0 ? Math.floor(v) : Math.ceil(v)' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.rand = function(List__) {' . chr(10) . '    var v = p5num(List__[0]) || 1;' . chr(10) . '    return Math.random() * v;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.lc      = function(List__) { return p5str(List__[0]).toLowerCase() };' . chr(10) . 'CORE.uc      = function(List__) { return p5str(List__[0]).toUpperCase() };' . chr(10) . chr(10) . 'CORE.lcfirst = function(List__) {' . chr(10) . '    var s = p5str(List__[0]);' . chr(10) . '    var c = s.length > 0 ? s.slice(0,1).toLowerCase() : "";' . chr(10) . '    s = s.length > 1 ? s.substr(1) : "";' . chr(10) . '    return c + s' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.ucfirst = function(List__) {' . chr(10) . '    var s = p5str(List__[0]);' . chr(10) . '    var c = s.length > 0 ? s.slice(0,1).toUpperCase() : "";' . chr(10) . '    s = s.length > 1 ? s.substr(1) : "";' . chr(10) . '    return c + s' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.quotemeta = function(List__) {' . chr(10) . '    var s = p5str(List__[0]);' . chr(10) . '    var out = [];' . chr(10) . '    for(var i = 0; i < s.length; i++) {' . chr(10) . '        if (s.substr(i, 1).match(/[^0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz]/)) {' . chr(10) . '            out.push(String.fromCharCode(92));' . chr(10) . '        }' . chr(10) . '        out.push(s.substr(i, 1));' . chr(10) . '    }' . chr(10) . '    return out.join("");       ' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.substr = function(List__) {' . chr(10) . chr(10) . '    // TODO - lvalue substr()' . chr(10) . chr(10) . '    var s           = p5str(List__[0]);' . chr(10) . '    var offset      = p5num(List__[1]);' . chr(10) . '    var length      = List__.length > 2 ? p5num(List__[2]) : s.length;' . chr(10) . '    var replacement = List__[3];' . chr(10) . chr(10) . '    if (length < 0) {' . chr(10) . '        length = s.length - offset + length;' . chr(10) . '    }' . chr(10) . '    return s.substr(offset, length);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.defined = function(List__) {' . chr(10) . '    return (List__[0] instanceof p5Scalar) ? ( List__[0]._v_ != null ) : ( List__[0] != null )' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.values = function(List__, p5want) {' . chr(10) . '    var o = List__[0]._hash_;' . chr(10) . '    delete o["_each_"];' . chr(10) . '    if (p5want) {' . chr(10) . '        if (o == null) {' . chr(10) . '            return new p5Array([]);' . chr(10) . '        };' . chr(10) . '        if (typeof o.values === "function") {' . chr(10) . '            return o.values();' . chr(10) . '        }' . chr(10) . '        var out = [];' . chr(10) . '        for (var i in o) {' . chr(10) . '            out.push(o[i]);' . chr(10) . '        }' . chr(10) . '        return new p5Array(out);' . chr(10) . '    }' . chr(10) . '    return CORE.keys(List__, p5want);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.keys = function(List__, p5want) {' . chr(10) . '    var o = List__[0]._hash_;' . chr(10) . '    delete o["_each_"];' . chr(10) . '    if (p5want) {' . chr(10) . '        if (o == null) {' . chr(10) . '            return new p5Array([]);' . chr(10) . '        }' . chr(10) . '        if (typeof o.keys === "function") {' . chr(10) . '            return o.keys();' . chr(10) . '        }' . chr(10) . '        var out = [];' . chr(10) . '        for (var i in o) {' . chr(10) . '            out.push(i);' . chr(10) . '        }' . chr(10) . '        return new p5Array(out);' . chr(10) . '    }' . chr(10) . '    else {' . chr(10) . '        if (o == null) {' . chr(10) . '            return 0;' . chr(10) . '        }' . chr(10) . '        if (typeof o.keys === "function") {' . chr(10) . '            return CORE.scalar([o.keys()]);' . chr(10) . '        }' . chr(10) . '        var out = 0;' . chr(10) . '        for (var i in o) {' . chr(10) . '            out++;' . chr(10) . '        }' . chr(10) . '        return out;' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.each = function(List__, p5want) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    if (o.hasOwnProperty("_each_")) {' . chr(10) . '        return o._each_(p5want)' . chr(10) . '    }' . chr(10) . '    var keys = CORE.keys([o], 1);' . chr(10) . '    var i = 0;' . chr(10) . '    o._each_ = function () {' . chr(10) . '        if (i < keys.length) {' . chr(10) . '            i++;' . chr(10) . '            return p5want ? [keys[i-1], o[keys[i-1]]] : keys[i-1];' . chr(10) . '        }' . chr(10) . '        i = 0;' . chr(10) . '        return p5want ? [] : null;' . chr(10) . '    };' . chr(10) . '    return o._each_(p5want);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.reverse = function(List__) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    if (o == null) {' . chr(10) . '        return "";' . chr(10) . '    }' . chr(10) . '    if (typeof o === "string") {' . chr(10) . '        return o.split("").reverse().join("")' . chr(10) . '    }' . chr(10) . '    var out = [];' . chr(10) . '    for(var i = 0; i < o.length; i++) {' . chr(10) . '        out.unshift(o[i]);' . chr(10) . '    }' . chr(10) . '    return out;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.splice = function(List__, p5want) {' . chr(10) . '    var array  = List__.shift()._array_;' . chr(10) . '    // CORE.say([ array ]);' . chr(10) . '    var offset = p5num(List__.shift());' . chr(10) . '    var limit  = List__.length ? p5num(List__.shift()) : (array.length + 1);' . chr(10) . chr(10) . '    if (limit < 0) {' . chr(10) . '        limit = array.length + limit - 1;' . chr(10) . '    }' . chr(10) . chr(10) . '    var list = [offset, limit];' . chr(10) . '    for(var i = 0; i < List__.length; i++) {' . chr(10) . '        list = p5list_to_a( list, List__[i]);' . chr(10) . '    }' . chr(10) . chr(10) . '    out = array.splice.apply(array, list);' . chr(10) . '    // CORE.say([ CORE.join([":",array]), " ofs=", offset, " lim=", limit, " list=", list, " out=", CORE.join([":",out])  ]);' . chr(10) . '    return p5want ? out : out.pop();' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.pop = function(List__) {' . chr(10) . '    return List__[0].POP();' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.shift = function(List__) {' . chr(10) . '    return List__[0].SHIFT();' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.push = function(List__) {' . chr(10) . '    return List__[0].PUSH(List__[1]);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.unshift = function(List__) {' . chr(10) . '    return List__[0].UNSHIFT(List__[1]);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.join = function(List__) {' . chr(10) . '    var s = List__[0];' . chr(10) . '    var o = List__[1]._array_;' . chr(10) . '    var a = [];' . chr(10) . '    for (i = 0; i < o.length; i++) {' . chr(10) . '        a.push( p5str(o[i]) );' . chr(10) . '    }' . chr(10) . '    return a.join(s);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.index = function(List__) {' . chr(10) . '    try {' . chr(10) . '        return p5str(List__[0]).indexOf(p5str(List__[1]), p5num(List__[2]));' . chr(10) . '    }' . chr(10) . '    catch(err) {' . chr(10) . '        return -1;' . chr(10) . '    }' . chr(10) . '};' . chr(10) . 'CORE.rindex = function(List__) {' . chr(10) . '    var o = p5str(List__[0]);' . chr(10) . '    var s = List__[1];' . chr(10) . '    try {' . chr(10) . '        if (List__.length > 2) {' . chr(10) . '            var i = p5num(List__[2]);' . chr(10) . '            if (i < 0) {' . chr(10) . '                if (s.length == 0) {' . chr(10) . '                    return 0;' . chr(10) . '                }' . chr(10) . '                return -1;' . chr(10) . '            }' . chr(10) . '            return o.lastIndexOf(s, i);' . chr(10) . '        }' . chr(10) . '        return o.lastIndexOf(s);' . chr(10) . '    }' . chr(10) . '    catch(err) {' . chr(10) . '        return -1;' . chr(10) . '    }' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.length = function(List__) {' . chr(10) . '    var o = p5str(List__[0]);' . chr(10) . '    return o.length;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.pack    = function(List__) { CORE.warn([ "CORE::pack not implemented" ]) };' . chr(10) . 'CORE.unpack  = function(List__) { CORE.warn([ "CORE::unpack not implemented" ]) };' . chr(10) . chr(10) . 'CORE.ref = function(List__) {' . chr(10) . '    var o = List__[0];' . chr(10) . '    if (o instanceof p5Scalar) {' . chr(10) . '        o = o._v_;' . chr(10) . '    }' . chr(10) . '    if (o == null) {' . chr(10) . '        return "";' . chr(10) . '    }' . chr(10) . '    if (o._class_ && typeof o._class_._ref_ === "string") {' . chr(10) . '        // blessed reference' . chr(10) . '        return o._class_._ref_;' . chr(10) . '    }' . chr(10) . '    if (typeof o._ref_ === "string") {' . chr(10) . '        // un-blessed reference' . chr(10) . '        return o._ref_;' . chr(10) . '    }' . chr(10) . '    if (typeof o === "function") {' . chr(10) . '        return "CODE";' . chr(10) . '    }' . chr(10) . '    return "";' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.split = function(List__) {' . chr(10) . '    var pattern = List__[0];' . chr(10) . '    var s       = List__[1];' . chr(10) . '    var limit   = List__[2];' . chr(10) . '    if (typeof pattern === "string") {' . chr(10) . '        if (pattern == " ") {' . chr(10) . '            var res = [];' . chr(10) . '            for (var i_ = 0, a_ = s.split(/(?: |' . chr(92) . 'n)+/); i_ < a_.length ; i_++) {' . chr(10) . '                if (a_[i_] != "") {' . chr(10) . '                    res.push(a_[i_])' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '            return res;' . chr(10) . '        }' . chr(10) . '        return s.split(pattern);' . chr(10) . '    }' . chr(10) . '    CORE.die(["not implemented"]);' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.prototype = function(List__, data) {' . chr(10) . '    var name = List__[0];' . chr(10) . '    // TODO - fully qualify "name" using information from "data"' . chr(10) . '    // XXX - lookup in CORE::GLOBAL?' . chr(10) . '    p5pkg["Perlito5"].v_PROTO._hash_[name] || p5pkg["Perlito5"].v_CORE_PROTO._hash_[name]' . chr(10) . '};' . chr(10) . chr(10))))
};
1;

;

# use Perlito5::Javascript3::CORE
;
package main;
undef();
package Perlito5::Javascript3::IO;
sub Perlito5::Javascript3::IO::emit_javascript3 {
    return ((('//' . chr(10) . '//' . chr(10) . '// lib/Perlito5/Javascript3/IO.js' . chr(10) . '//' . chr(10) . '// I/O functions for "Perlito" Perl5-in-Javascript3' . chr(10) . '//' . chr(10) . '// AUTHORS' . chr(10) . '//' . chr(10) . '// Flavio Soibelmann Glock  fglock@gmail.com' . chr(10) . '//' . chr(10) . '// COPYRIGHT' . chr(10) . '//' . chr(10) . '// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.' . chr(10) . '//' . chr(10) . '// This program is free software; you can redistribute it and/or modify it' . chr(10) . '// under the same terms as Perl itself.' . chr(10) . '//' . chr(10) . '// See http://www.perl.com/perl/misc/Artistic.html' . chr(10) . chr(10) . 'var isNode = typeof require != "undefined";' . chr(10) . 'if (isNode) {' . chr(10) . chr(10) . '    var fs = require("fs");' . chr(10) . chr(10) . '    p5atime = function(s) {' . chr(10) . '        s = p5str(s);' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat["atime"];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5mtime = function(s) {' . chr(10) . '        s = p5str(s);' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat["mtime"];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5ctime = function(s) {' . chr(10) . '        s = p5str(s);' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat["ctime"];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5size = function(s) {' . chr(10) . '        s = p5str(s);' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat["size"];' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5is_file = function(s) {' . chr(10) . '        s = p5str(s);' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat.isFile() ? 1 : 0;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5is_directory = function(s) {' . chr(10) . '        s = p5str(s);' . chr(10) . '        try {' . chr(10) . '            var stat = fs.statSync(s); return stat.isDirectory() ? 1 : 0;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . '    p5file_exists = function(s) {' . chr(10) . '        s = p5str(s);' . chr(10) . '        return p5is_file(s) || p5is_directory(s);' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.chdir = function(List__) {' . chr(10) . '        try {' . chr(10) . '            process.chdir(p5str(List__[0]));' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.close = function(List__) {' . chr(10) . '        try {' . chr(10) . '            fs.closeSync(p5str(List__[0]));' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.exit = function(List__) {' . chr(10) . '        process.exit(List__[0]);' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.rename = function(List__) {' . chr(10) . '        try {' . chr(10) . '            fs.renameSync(p5str(List__[0]), p5str(List__[1]));' . chr(10) . '            return 1;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return ' . chr(39) . chr(39) . ';' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '    CORE.unlink = function(List__) {' . chr(10) . '        var count = 0;' . chr(10) . '        try {' . chr(10) . '            for(var i = 0; i < List__.length; i++) {' . chr(10) . '                fs.unlinkSync(p5str(List__[i]));' . chr(10) . '                count++;' . chr(10) . '            }' . chr(10) . '            return count;' . chr(10) . '        }' . chr(10) . '        catch(err) {' . chr(10) . '            p5pkg["main"]["v_!"] = err;' . chr(10) . '            return count;' . chr(10) . '        }' . chr(10) . '    };' . chr(10) . chr(10) . '}' . chr(10) . chr(10))))
};
1;

;

# use Perlito5::Javascript3::IO
;
package main;
undef();
package Perlito5::Javascript3::Sprintf;
sub Perlito5::Javascript3::Sprintf::emit_javascript3 {
    return ((('/**' . chr(10) . ' * Copyright (c) 2010 Jakob Westhoff' . chr(10) . ' *' . chr(10) . ' * Permission is hereby granted, free of charge, to any person obtaining a copy' . chr(10) . ' * of this software and associated documentation files (the "Software"), to deal' . chr(10) . ' * in the Software without restriction, including without limitation the rights' . chr(10) . ' * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell' . chr(10) . ' * copies of the Software, and to permit persons to whom the Software is' . chr(10) . ' * furnished to do so, subject to the following conditions:' . chr(10) . ' * ' . chr(10) . ' * The above copyright notice and this permission notice shall be included in' . chr(10) . ' * all copies or substantial portions of the Software.' . chr(10) . ' * ' . chr(10) . ' * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR' . chr(10) . ' * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,' . chr(10) . ' * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE' . chr(10) . ' * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER' . chr(10) . ' * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,' . chr(10) . ' * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN' . chr(10) . ' * THE SOFTWARE.' . chr(10) . ' */' . chr(10) . chr(10) . 'CORE.sprintf = function(List__) {' . chr(10) . '    var format = List__[0];' . chr(10) . '    var list = List__[1];' . chr(10) . chr(10) . '    // Check for format definition' . chr(10) . '    if ( typeof format != ' . chr(39) . 'string' . chr(39) . ' ) {' . chr(10) . '        CORE.die(["sprintf: The first arguments need to be a valid format string."]);' . chr(10) . '    }' . chr(10) . '    ' . chr(10) . '    /**' . chr(10) . '     * Define the regex to match a formating string' . chr(10) . '     * The regex consists of the following parts:' . chr(10) . '     * percent sign to indicate the start' . chr(10) . '     * (optional) sign specifier' . chr(10) . '     * (optional) padding specifier' . chr(10) . '     * (optional) alignment specifier' . chr(10) . '     * (optional) width specifier' . chr(10) . '     * (optional) precision specifier' . chr(10) . '     * type specifier:' . chr(10) . '     *  % - literal percent sign' . chr(10) . '     *  b - binary number' . chr(10) . '     *  c - ASCII character represented by the given value' . chr(10) . '     *  d - signed decimal number' . chr(10) . '     *  f - floating point value' . chr(10) . '     *  o - octal number' . chr(10) . '     *  s - string' . chr(10) . '     *  x - hexadecimal number (lowercase characters)' . chr(10) . '     *  X - hexadecimal number (uppercase characters)' . chr(10) . '     */' . chr(10) . '    var r = new RegExp( /%(' . chr(92) . '+)?([0 ]|' . chr(39) . '(.))?(-)?([0-9]+)?(' . chr(92) . '.([0-9]+))?([%bcdfosxX])/g );' . chr(10) . chr(10) . '    /**' . chr(10) . '     * Each format string is splitted into the following parts:' . chr(10) . '     * 0: Full format string' . chr(10) . '     * 1: sign specifier (+)' . chr(10) . '     * 2: padding specifier (0/<space>/' . chr(39) . '<any char>)' . chr(10) . '     * 3: if the padding character starts with a ' . chr(39) . ' this will be the real ' . chr(10) . '     *    padding character' . chr(10) . '     * 4: alignment specifier' . chr(10) . '     * 5: width specifier' . chr(10) . '     * 6: precision specifier including the dot' . chr(10) . '     * 7: precision specifier without the dot' . chr(10) . '     * 8: type specifier' . chr(10) . '     */' . chr(10) . '    var parts      = [];' . chr(10) . '    var paramIndex = 0;' . chr(10) . '    while ( part = r.exec( format ) ) {' . chr(10) . '        // Check if an input value has been provided, for the current' . chr(10) . '        // format string' . chr(10) . '        if ( paramIndex >= list.length ) {' . chr(10) . '            CORE.die(["sprintf: At least one argument was missing."]);' . chr(10) . '        }' . chr(10) . chr(10) . '        parts[parts.length] = {' . chr(10) . '            /* beginning of the part in the string */' . chr(10) . '            begin: part.index,' . chr(10) . '            /* end of the part in the string */' . chr(10) . '            end: part.index + part[0].length,' . chr(10) . '            /* force sign */' . chr(10) . '            sign: ( part[1] == ' . chr(39) . '+' . chr(39) . ' ),' . chr(10) . '            /* is the given data negative */' . chr(10) . '            negative: ( parseInt( list[paramIndex] ) < 0 ) ? true : false,' . chr(10) . '            /* padding character (default: <space>) */' . chr(10) . '            padding: ( part[2] == undefined )' . chr(10) . '                     ? ( ' . chr(39) . ' ' . chr(39) . ' ) /* default */' . chr(10) . '                     : ( ( part[2].substring( 0, 1 ) == "' . chr(39) . '" ) ' . chr(10) . '                         ? ( part[3] ) /* use special char */' . chr(10) . '                         : ( part[2] ) /* use normal <space> or zero */' . chr(10) . '                       ),' . chr(10) . '            /* should the output be aligned left?*/' . chr(10) . '            alignLeft: ( part[4] == ' . chr(39) . '-' . chr(39) . ' ),' . chr(10) . '            /* width specifier (number or false) */' . chr(10) . '            width: ( part[5] != undefined ) ? part[5] : false,' . chr(10) . '            /* precision specifier (number or false) */' . chr(10) . '            precision: ( part[7] != undefined ) ? part[7] : false,' . chr(10) . '            /* type specifier */' . chr(10) . '            type: part[8],' . chr(10) . '            /* the given data associated with this part converted to a string */' . chr(10) . '            data: ( part[8] != ' . chr(39) . '%' . chr(39) . ' ) ? String ( list[paramIndex++] ) : false' . chr(10) . '        };' . chr(10) . '    }' . chr(10) . chr(10) . '    var newString = "";' . chr(10) . '    var start = 0;' . chr(10) . '    // Generate our new formated string' . chr(10) . '    for( var i=0; i<parts.length; ++i ) {' . chr(10) . '        // Add first unformated string part' . chr(10) . '        newString += format.substring( start, parts[i].begin );' . chr(10) . '        ' . chr(10) . '        // Mark the new string start' . chr(10) . '        start = parts[i].end;' . chr(10) . chr(10) . '        // Create the appropriate preformat substitution' . chr(10) . '        // This substitution is only the correct type conversion. All the' . chr(10) . '        // different options and flags haven' . chr(39) . 't been applied to it at this' . chr(10) . '        // point' . chr(10) . '        var preSubstitution = "";' . chr(10) . '        switch ( parts[i].type ) {' . chr(10) . '            case ' . chr(39) . '%' . chr(39) . ':' . chr(10) . '                preSubstitution = "%";' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'b' . chr(39) . ':' . chr(10) . '                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 2 );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'c' . chr(39) . ':' . chr(10) . '                preSubstitution = String.fromCharCode( Math.abs( parseInt( parts[i].data ) ) );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'd' . chr(39) . ':' . chr(10) . '                preSubstitution = String( Math.abs( parseInt( parts[i].data ) ) );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'f' . chr(39) . ':' . chr(10) . '                preSubstitution = ( parts[i].precision == false )' . chr(10) . '                                  ? ( String( ( Math.abs( parseFloat( parts[i].data ) ) ) ) )' . chr(10) . '                                  : ( Math.abs( parseFloat( parts[i].data ) ).toFixed( parts[i].precision ) );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'o' . chr(39) . ':' . chr(10) . '                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 8 );' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 's' . chr(39) . ':' . chr(10) . '                preSubstitution = parts[i].data.substring( 0, parts[i].precision ? parts[i].precision : parts[i].data.length ); /* Cut if precision is defined */' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'x' . chr(39) . ':' . chr(10) . '                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 16 ).toLowerCase();' . chr(10) . '            break;' . chr(10) . '            case ' . chr(39) . 'X' . chr(39) . ':' . chr(10) . '                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 16 ).toUpperCase();' . chr(10) . '            break;' . chr(10) . '            default:' . chr(10) . '                throw ' . chr(39) . 'sprintf: Unknown type "' . chr(39) . ' + parts[i].type + ' . chr(39) . '" detected. This should never happen. Maybe the regex is wrong.' . chr(39) . ';' . chr(10) . '        }' . chr(10) . chr(10) . '        // The % character is a special type and does not need further processing' . chr(10) . '        if ( parts[i].type ==  "%" ) {' . chr(10) . '            newString += preSubstitution;' . chr(10) . '            continue;' . chr(10) . '        }' . chr(10) . chr(10) . '        // Modify the preSubstitution by taking sign, padding and width' . chr(10) . '        // into account' . chr(10) . chr(10) . '        // Pad the string based on the given width' . chr(10) . '        if ( parts[i].width != false ) {' . chr(10) . '            // Padding needed?' . chr(10) . '            if ( parts[i].width > preSubstitution.length ) ' . chr(10) . '            {' . chr(10) . '                var origLength = preSubstitution.length;' . chr(10) . '                for( var j = 0; j < parts[i].width - origLength; ++j ) ' . chr(10) . '                {' . chr(10) . '                    preSubstitution = ( parts[i].alignLeft == true ) ' . chr(10) . '                                      ? ( preSubstitution + parts[i].padding )' . chr(10) . '                                      : ( parts[i].padding + preSubstitution );' . chr(10) . '                }' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . chr(10) . '        // Add a sign symbol if neccessary or enforced, but only if we are' . chr(10) . '        // not handling a string' . chr(10) . '        if ( parts[i].type == ' . chr(39) . 'b' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'd' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'o' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'f' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'x' . chr(39) . ' ' . chr(10) . '          || parts[i].type == ' . chr(39) . 'X' . chr(39) . ' ) {' . chr(10) . '            if ( parts[i].negative == true ) {' . chr(10) . '                preSubstitution = "-" + preSubstitution;' . chr(10) . '            }' . chr(10) . '            else if ( parts[i].sign == true ) {' . chr(10) . '                preSubstitution = "+" + preSubstitution;' . chr(10) . '            }' . chr(10) . '        }' . chr(10) . chr(10) . '        // Add the substitution to the new string' . chr(10) . '        newString += preSubstitution;' . chr(10) . '    }' . chr(10) . chr(10) . '    // Add the last part of the given format string, which may still be there' . chr(10) . '    newString += format.substring( start, format.length );' . chr(10) . chr(10) . '    return newString;' . chr(10) . '};' . chr(10) . chr(10) . 'CORE.printf = function(List__) {' . chr(10) . '    return CORE.print([ CORE.sprintf(List__) ]);' . chr(10) . '};' . chr(10) . chr(10))))
};
1;

;

# use Perlito5::Javascript3::Sprintf
;
package main;
undef();
package Perlito5::AST::Apply;
((my  %op) = ('infix:<+=>', 'infix:<+>', 'infix:<-=>', 'infix:<->', 'infix:<*=>', 'infix:<*>', 'infix:</=>', 'infix:</>', 'infix:<||=>', 'infix:<||>', 'infix:<&&=>', 'infix:<&&>', 'infix:<|=>', 'infix:<|>', 'infix:<&=>', 'infix:<&>', 'infix:<//=>', 'infix:<//>', 'infix:<.=>', 'list:<.>'));
sub Perlito5::AST::Apply::op_assign {
    ((my  $self) = $_[0]);
    ((my  $code) = $self->{'code'});
    if (ref($code)) {
        return (0)
    };
    if (exists($op{$code})) {
        return (Perlito5::AST::Apply->new('code', 'infix:<=>', 'arguments', [$self->{'arguments'}->[0], Perlito5::AST::Apply->new('code', $op{$code}, 'arguments', $self->{'arguments'})]))
    };
    return (0)
};
package Perlito5::AST::Do;
sub Perlito5::AST::Do::simplify {
    ((my  $self) = $_[0]);
    (my  $block);
    if ($self->{'block'}->isa('Perlito5::AST::Lit::Block')) {
        ($block = $self->{'block'}->stmts())
    }
    else {
        ($block = [$self->{'block'}])
    };
    if ((scalar(@{$block}) == 1)) {
        ((my  $stmt) = $block->[0]);
        if (($stmt->isa('Perlito5::AST::Apply') && ($stmt->code() eq 'circumfix:<( )>'))) {
            ((my  $args) = $stmt->arguments());
            if ((@{$args} == 1)) {
                return (Perlito5::AST::Do->new('block', $args->[0])->simplify())
            };
            return (Perlito5::AST::Do->new('block', $block))
        };
        if ($stmt->isa('Perlito5::AST::Do')) {
            return ($stmt->simplify())
        }
    };
    return (Perlito5::AST::Do->new('block', $block))
};

;

# use Perlito5::Macro
;
package main;
undef();

# use Perlito5::AST
;
package Perlito5::Perl5;
do {{
    sub Perlito5::Perl5::tab {
        ((my  $level) = shift());
join("", '    ' x $level)
    };
    ((my  %safe_char) = (' ', 1, '!', 1, '"', 1, '#', 1, '$', 1, '%', 1, '&', 1, '(', 1, ')', 1, '*', 1, '+', 1, ',', 1, '-', 1, '.', 1, '/', 1, ':', 1, ';', 1, '<', 1, '=', 1, '>', 1, '?', 1, '@', 1, '[', 1, ']', 1, '^', 1, '_', 1, '`', 1, '{', 1, '|', 1, '}', 1, '~', 1));
    sub Perlito5::Perl5::escape_string {
        ((my  $s) = shift());
        (my  @out);
        ((my  $tmp) = '');
        if (($s eq '')) {
            return (chr(39) . chr(39))
        };
        for my $i ((0 .. (length($s) - 1))) {
            ((my  $c) = substr($s, $i, 1));
            if ((((((($c ge 'a') && ($c le 'z'))) || ((($c ge 'A') && ($c le 'Z')))) || ((($c ge '0') && ($c le '9')))) || exists($safe_char{$c}))) {
                ($tmp = ($tmp . $c))
            }
            else {
                if (($tmp ne '')) {
                    push(@out, (chr(39) . $tmp . chr(39)) )
                };
                push(@out, ('chr(' . ord($c) . ')') );
                ($tmp = '')
            }
        };
        if (($tmp ne '')) {
            push(@out, (chr(39) . $tmp . chr(39)) )
        };
        return (join(' . ', @out))
    }
}};
package Perlito5::AST::CompUnit;
do {{
    sub Perlito5::AST::CompUnit::emit_perl5 {
        ((my  $self) = $_[0]);
        ((my  $level) = $_[1]);
        (my  @body);
        for (@{$self->{'body'}}) {
            if (defined($_)) {
                push(@body, $_ )
            }
        };
        (Perlito5::Perl5::tab($level) . 'package ' . $self->{'name'} . ';' . chr(10) . join(';' . chr(10), map($_->emit_perl5($level), @body)) . ';' . chr(10) . chr(10))
    };
    sub Perlito5::AST::CompUnit::emit_perl5_program {
        ((my  $comp_units) = $_[0]);
        ((my  $str) = 'use v5.10;' . chr(10));
        for my $comp_unit (@{$comp_units}) {
            ($str = ($str . $comp_unit->emit_perl5(0)))
        };
        ($str = ($str . '1;' . chr(10)));
        return ($str)
    }
}};
package Perlito5::AST::Val::Int;
do {{
    sub Perlito5::AST::Val::Int::emit_perl5 {
        ((my  $self) = $_[0]);
        ((my  $level) = $_[1]);
        (Perlito5::Perl5::tab($level) . $self->{'int'})
    }
}};
package Perlito5::AST::Val::Num;
do {{
    sub Perlito5::AST::Val::Num::emit_perl5 {
        ((my  $self) = $_[0]);
        ((my  $level) = $_[1]);
        (Perlito5::Perl5::tab($level) . $self->{'num'})
    }
}};
package Perlito5::AST::Val::Buf;
do {{
    sub Perlito5::AST::Val::Buf::emit_perl5 {
        ((my  $self) = $_[0]);
        ((my  $level) = $_[1]);
        (Perlito5::Perl5::tab($level) . Perlito5::Perl5::escape_string($self->{'buf'}))
    }
}};
package Perlito5::AST::Lit::Block;
do {{
    sub Perlito5::AST::Lit::Block::emit_perl5 {
        ((my  $self) = $_[0]);
        ((my  $level) = $_[1]);
        (Perlito5::Perl5::tab($level) . 'do {{' . chr(10) . join(';' . chr(10), map($_->emit_perl5(($level + 1)), @{$self->{'stmts'}})) . chr(10) . Perlito5::Perl5::tab($level) . '}}')
    }
}};
package Perlito5::AST::Index;
do {{
    sub Perlito5::AST::Index::emit_perl5 {
        ((my  $self) = $_[0]);
        ((my  $level) = $_[1]);
        if (($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '$'))) {
            ((my  $v) = $self->{'obj'});
            return (($v->emit_perl5($level) . '[' . $self->{'index_exp'}->emit_perl5() . ']'))
        };
        ($self->{'obj'}->emit_perl5($level) . '->[' . $self->{'index_exp'}->emit_perl5() . ']')
    }
}};
package Perlito5::AST::Lookup;
do {{
    sub Perlito5::AST::Lookup::emit_perl5 {
        ((my  $self) = $_[0]);
        ((my  $level) = $_[1]);
        if (($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '$'))) {
            ((my  $v) = $self->{'obj'});
            return (($v->emit_perl5($level) . '{' . $self->autoquote($self->{'index_exp'})->emit_perl5($level) . '}'))
        };
        ($self->{'obj'}->emit_perl5($level) . '->{' . $self->autoquote($self->{'index_exp'})->emit_perl5($level) . '}')
    }
}};
package Perlito5::AST::Var;
do {{
    sub Perlito5::AST::Var::emit_perl5 {
        ((my  $self) = $_[0]);
        ((my  $level) = $_[1]);
        ((my  $str_name) = $self->{'name'});
        if (($str_name eq chr(92))) {
            ($str_name = chr(92) . chr(92))
        };
        if (($str_name eq '"')) {
            ($str_name = chr(92) . '"')
        };
        ((my  $perl5_name) = $self->perl5_name());
        (my  $decl_type);
        ((my  $decl) = $self->perl5_get_decl($perl5_name));
        if ($decl) {
            ($decl_type = $decl->{'decl'})
        }
        else {
            if ((!($self->{'namespace'}) && ($self->{'sigil'} ne '*'))) {

            }
        };
        ((my  $ns) = '');
        if ($self->{'namespace'}) {
            if ((($self->{'namespace'} eq 'main') && (substr($self->{'name'}, 0, 1) eq '^'))) {
                return ((Perlito5::Perl5::tab($level) . $self->{'sigil'} . '{' . $self->{'name'} . '}'))
            }
            else {
                ($ns = ($self->{'namespace'} . '::'))
            }
        };
        ((my  $c) = substr($self->{'name'}, 0, 1));
        if (((((($c ge 'a') && ($c le 'z'))) || ((($c ge 'A') && ($c le 'Z')))) || (($c eq '_')))) {
            return ((Perlito5::Perl5::tab($level) . $self->{'sigil'} . $ns . $self->{'name'}))
        };
        return ((Perlito5::Perl5::tab($level) . $self->{'sigil'} . '{' . chr(39) . $ns . $str_name . chr(39) . '}'))
    }
}};
package Perlito5::AST::Proto;
do {{
    sub Perlito5::AST::Proto::emit_perl5 {
        ((my  $self) = $_[0]);
        ((my  $level) = $_[1]);
        (Perlito5::Perl5::tab($level) . $self->{'name'})
    }
}};
package Perlito5::AST::Call;
do {{
    sub Perlito5::AST::Call::emit_perl5 {
        ((my  $self) = $_[0]);
        ((my  $level) = $_[1]);
        ((my  $invocant) = $self->{'invocant'}->emit_perl5());
        if (($self->{'method'} eq 'postcircumfix:<[ ]>')) {
            return ((Perlito5::Perl5::tab($level) . $invocant . '->[' . $self->{'arguments'}->emit_perl5() . ']'))
        };
        if (($self->{'method'} eq 'postcircumfix:<{ }>')) {
            return ((Perlito5::Perl5::tab($level) . $invocant . '->{' . Perlito5::AST::Lookup->autoquote($self->{'arguments'})->emit_perl5($level) . '}'))
        };
        ((my  $meth) = $self->{'method'});
        if (($meth eq 'postcircumfix:<( )>')) {
            ($meth = '')
        };
        if ((ref($meth) eq 'Perlito5::AST::Var')) {
            ($meth = $meth->emit_perl5())
        };
        (Perlito5::Perl5::tab($level) . $invocant . '->' . $meth . '(' . join(', ', map($_->emit_perl5(), @{$self->{'arguments'}})) . ')')
    }
}};
package Perlito5::AST::Apply;
do {{
    ((my  %op_prefix_perl5) = ('say', 'say', 'print', 'print', 'keys', 'keys', 'values', 'values', 'warn', 'warn', 'prefix:<!>', '!', 'prefix:<++>', '++', 'prefix:<-->', '--', 'prefix:<+>', '+', 'prefix:<->', '-', 'prefix:<-d>', '-d', 'prefix:<-e>', '-e', 'prefix:<-f>', '-f', 'prefix:<not>', 'not', 'prefix:<~>', '~'));
    ((my  %op_infix_perl5) = ('list:<,>', ', ', 'list:<.>', ' . ', 'infix:<+>', ' + ', 'infix:<->', ' - ', 'infix:<*>', ' * ', 'infix:</>', ' / ', 'infix:<%>', ' % ', 'infix:<**>', ' ** ', 'infix:<>>', ' > ', 'infix:<<>', ' < ', 'infix:<>=>', ' >= ', 'infix:<<=>', ' <= ', 'infix:<&>', ' & ', 'infix:<|>', ' | ', 'infix:<^>', ' ^ ', 'infix:<&&>', ' && ', 'infix:<||>', ' || ', 'infix:<and>', ' and ', 'infix:<or>', ' or ', 'infix:<//>', ' // ', 'infix:<eq>', ' eq ', 'infix:<ne>', ' ne ', 'infix:<le>', ' le ', 'infix:<ge>', ' ge ', 'infix:<==>', ' == ', 'infix:<!=>', ' != ', 'infix:<=~>', ' =~ ', 'infix:<!~>', ' !~ '));
    sub Perlito5::AST::Apply::emit_perl5 {
        ((my  $self) = $_[0]);
        ((my  $level) = $_[1]);
        ((my  $apply) = $self->op_assign());
        if ($apply) {
            return ($apply->emit_perl5($level))
        };
        ((my  $ns) = '');
        if ($self->{'namespace'}) {
            ($ns = ($self->{'namespace'} . '::'))
        };
        ((my  $code) = ($ns . $self->{'code'}));
        if ((ref($code) ne '')) {
            return ((Perlito5::Perl5::tab($level) . '(' . $self->{'code'}->emit_perl5() . ')->(' . join(', ', map($_->emit_perl5(), @{$self->{'arguments'}})) . ')'))
        };
        if (exists($op_infix_perl5{$code})) {
            return ((Perlito5::Perl5::tab($level) . '(' . join($op_infix_perl5{$code}, (map($_->emit_perl5(), @{$self->{'arguments'}}))) . ')'))
        };
        if (exists($op_prefix_perl5{$code})) {
            return ((Perlito5::Perl5::tab($level) . $op_prefix_perl5{$code} . '(' . join(', ', map($_->emit_perl5(), @{$self->{'arguments'}})) . ')'))
        };
        if (($self->{'code'} eq 'p5:s')) {
            return ((Perlito5::Perl5::tab($level) . 's!' . $self->{'arguments'}->[0]->{'buf'} . '!' . $self->{'arguments'}->[1]->{'buf'} . '!' . $self->{'arguments'}->[2]))
        };
        if (($self->{'code'} eq 'p5:m')) {
            (my  $s);
            if ($self->{'arguments'}->[0]->isa('Perlito5::AST::Val::Buf')) {
                ($s = $self->{'arguments'}->[0]->{'buf'})
            }
            else {
                for my $ast (@{$self->{'arguments'}->[0]->{'arguments'}}) {
                    if ($ast->isa('Perlito5::AST::Val::Buf')) {
                        ($s = ($s . $ast->{'buf'}))
                    }
                    else {
                        ($s = ($s . $ast->emit_perl5()))
                    }
                }
            };
            return ((Perlito5::Perl5::tab($level) . 'm!' . $s . '!' . $self->{'arguments'}->[1]))
        };
        if (($self->{'code'} eq 'p5:tr')) {
            return ((Perlito5::Perl5::tab($level) . 'tr!' . $self->{'arguments'}->[0]->{'buf'} . '!' . $self->{'arguments'}->[1]->{'buf'} . '!'))
        };
        if (($code eq '__PACKAGE__')) {
            return (('"' . $Perlito5::PKG_NAME . '"'))
        };
        if (($self->{'code'} eq 'package')) {
            return ((Perlito5::Perl5::tab($level) . 'package ' . $self->{'namespace'}))
        };
        if (($code eq 'undef')) {
            return ((Perlito5::Perl5::tab($level) . 'undef()'))
        };
        if (($code eq 'scalar')) {
            return ((Perlito5::Perl5::tab($level) . 'scalar(' . ($self->{'arguments'}->[0]->emit_perl5()) . ')'))
        };
        if (($code eq 'pop')) {
            return ((Perlito5::Perl5::tab($level) . 'pop(' . ($self->{'arguments'}->[0]->emit_perl5()) . ')'))
        };
        if (($code eq 'push')) {
            return ((Perlito5::Perl5::tab($level) . 'push(' . ($self->{'arguments'}->[0]->emit_perl5()) . ', ' . ($self->{'arguments'}->[1])->emit_perl5() . ' )'))
        };
        if (($code eq 'shift')) {
            if (($self->{'arguments'} && @{$self->{'arguments'}})) {
                return ((Perlito5::Perl5::tab($level) . 'shift(' . join(' ', map($_->emit_perl5(), @{$self->{'arguments'}})) . ')'))
            };
            return ('shift()')
        };
        if (($code eq 'unshift')) {
            return ((Perlito5::Perl5::tab($level) . 'unshift(' . $self->{'arguments'}->[0]->emit_perl5() . ', ' . $self->{'arguments'}->[1]->emit_perl5() . ')'))
        };
        if (($code eq 'map')) {
            ((my  $str) = shift(@{$self->{'arguments'}}));
            return ((Perlito5::Perl5::tab($level) . 'map(' . $str->emit_perl5() . ', ' . join(',', map($_->emit_perl5(), @{$self->{'arguments'}})) . ')'))
        };
        if (($code eq 'infix:<x>')) {
            return (('join("", ' . join(' x ', map($_->emit_perl5(), @{$self->{'arguments'}})) . ')'))
        };
        if (($code eq 'infix:<=>>')) {
            return ((Perlito5::Perl5::tab($level) . Perlito5::AST::Lookup->autoquote($self->{'arguments'}->[0])->emit_perl5($level) . ', ' . $self->{'arguments'}->[1]->emit_perl5($level)))
        };
        if (($code eq 'join')) {
            ((my  $str) = shift(@{$self->{'arguments'}}));
            return ((Perlito5::Perl5::tab($level) . 'join(' . $str->emit_perl5() . ', ' . join(',', map($_->emit_perl5(), @{$self->{'arguments'}})) . ')'))
        };
        if (($code eq 'circumfix:<[ ]>')) {
            return ((Perlito5::Perl5::tab($level) . '[' . join(', ', map($_->emit_perl5(), @{$self->{'arguments'}})) . ']'))
        };
        if (($code eq 'circumfix:<{ }>')) {
            return ((Perlito5::Perl5::tab($level) . '{' . join(', ', map($_->emit_perl5(), @{$self->{'arguments'}})) . '}'))
        };
        if (($code eq 'prefix:<' . chr(92) . '>')) {
            return ((Perlito5::Perl5::tab($level) . chr(92) . join(' ', map($_->emit_perl5(), @{$self->{'arguments'}})) . ''))
        };
        if (($code eq 'prefix:<$>')) {
            return ((Perlito5::Perl5::tab($level) . '${' . join(' ', map($_->emit_perl5(), @{$self->{'arguments'}})) . '}'))
        };
        if (($code eq 'prefix:<@>')) {
            return ((Perlito5::Perl5::tab($level) . '@{' . join(' ', map($_->emit_perl5(), @{$self->{'arguments'}})) . '}'))
        };
        if (($code eq 'prefix:<%>')) {
            return ((Perlito5::Perl5::tab($level) . '%{' . join(' ', map($_->emit_perl5(), @{$self->{'arguments'}})) . '}'))
        };
        if (($code eq 'prefix:<&>')) {
            return ((Perlito5::Perl5::tab($level) . '&{' . join(' ', map($_->emit_perl5(), @{$self->{'arguments'}})) . '}'))
        };
        if (($code eq 'prefix:<$#>')) {
            return ((Perlito5::Perl5::tab($level) . '$#{' . join(' ', map($_->emit_perl5(), @{$self->{'arguments'}})) . '}'))
        };
        if (($code eq 'postfix:<++>')) {
            return ((Perlito5::Perl5::tab($level) . '(' . join(' ', map($_->emit_perl5(), @{$self->{'arguments'}})) . ')++'))
        };
        if (($code eq 'postfix:<-->')) {
            return ((Perlito5::Perl5::tab($level) . '(' . join(' ', map($_->emit_perl5(), @{$self->{'arguments'}})) . ')--'))
        };
        if (($code eq 'infix:<..>')) {
            return ((Perlito5::Perl5::tab($level) . '(' . join(' .. ', map($_->emit_perl5(), @{$self->{'arguments'}})) . ')'))
        };
        if (($code eq 'ternary:<? :>')) {
            return ((Perlito5::Perl5::tab($level) . '(' . $self->{'arguments'}->[0]->emit_perl5() . ' ? ' . $self->{'arguments'}->[1]->emit_perl5() . ' : ' . $self->{'arguments'}->[2]->emit_perl5() . ')'))
        };
        if (($code eq 'circumfix:<( )>')) {
            return ((Perlito5::Perl5::tab($level) . '(' . join(', ', map($_->emit_perl5(), @{$self->{'arguments'}})) . ')'))
        };
        if (($code eq 'infix:<=>')) {
            return ((Perlito5::Perl5::tab($level) . emit_perl5_bind($self->{'arguments'}->[0], $self->{'arguments'}->[1])))
        };
        if (($code eq 'require')) {
            return (('Perlito5::Grammar::Use::require(' . $self->{'arguments'}->[0]->emit_perl5() . ')'))
        };
        if (($code eq 'do')) {
            ((my  $ast) = Perlito5::AST::Apply->new('code', 'eval', 'namespace', '', 'arguments', [Perlito5::AST::Apply->new('code', 'slurp', 'namespace', 'Perlito5::IO', 'arguments', $self->{'arguments'})]));
            return ($ast->emit_perl5($level))
        };
        if (($code eq 'eval')) {
            ((my  $arg) = $self->{'arguments'}->[0]);
            (my  $eval);
            if ($arg->isa('Perlito5::AST::Do')) {
                ($eval = $arg->emit_perl5(($level + 1), $wantarray))
            }
            else {
                ($eval = ('(do { ' . 'my $m = Perlito5::Grammar->exp_stmts(' . $arg->emit_perl5(($level + 1), 'scalar') . ', 0);' . 'my $source; ' . '$source .= (defined $_ ? $_->emit_perl5(0, "scalar") : "") . ";' . chr(92) . 'n" ' . 'for @{ Perlito5::Match::flat($m) }; ' . 'eval $source;' . '})'))
            };
            return ((Perlito5::Perl5::tab($level) . $eval))
        };
        if (($code eq 'return')) {
            return ((Perlito5::Perl5::tab($level) . 'return (' . join(', ', map($_->emit_perl5(), @{$self->{'arguments'}})) . ')'))
        };
        if (($self->{'bareword'} && !(@{$self->{'arguments'}}))) {
            return ((Perlito5::Perl5::tab($level) . $code))
        };
        (Perlito5::Perl5::tab($level) . $code . '(' . join(', ', map($_->emit_perl5(), @{$self->{'arguments'}})) . ')')
    };
    sub Perlito5::AST::Apply::emit_perl5_bind {
        ((my  $parameters) = shift());
        ((my  $arguments) = shift());
        if ($parameters->isa('Perlito5::AST::Call')) {
            if ((($parameters->method() eq 'postcircumfix:<{ }>') || ($parameters->method() eq 'postcircumfix:<[ ]>'))) {
                return (('(' . $parameters->emit_perl5() . ' = ' . $arguments->emit_perl5() . ')'))
            }
        };
        ('(' . $parameters->emit_perl5() . ' = ' . $arguments->emit_perl5() . ')')
    }
}};
package Perlito5::AST::If;
do {{
    sub Perlito5::AST::If::emit_perl5 {
        ((my  $self) = $_[0]);
        ((my  $level) = $_[1]);
        return ((Perlito5::Perl5::tab($level) . 'if (' . $self->{'cond'}->emit_perl5() . ') {' . chr(10) . (($self->{'body'} ? (join(';' . chr(10), map($_->emit_perl5(($level + 1)), @{$self->{'body'}->stmts()})) . chr(10)) : '')) . Perlito5::Perl5::tab($level) . '}' . ((($self->{'otherwise'} && scalar(@{$self->{'otherwise'}->stmts()})) ? ((chr(10) . Perlito5::Perl5::tab($level) . 'else {' . chr(10) . join(';' . chr(10), map($_->emit_perl5(($level + 1)), @{$self->{'otherwise'}->stmts()})) . chr(10) . Perlito5::Perl5::tab($level) . '}')) : ''))))
    }
}};
package Perlito5::AST::When;
do {{
    sub Perlito5::AST::When::emit_perl5 {
        ((my  $self) = $_[0]);
        ((my  $level) = $_[1]);
        return ((Perlito5::Perl5::tab($level) . 'when (' . $self->{'cond'}->emit_perl5() . ') {' . chr(10) . (($self->{'body'} ? (join(';' . chr(10), map($_->emit_perl5(($level + 1)), @{$self->{'body'}->stmts()})) . chr(10)) : '')) . Perlito5::Perl5::tab($level) . '}'))
    }
}};
package Perlito5::AST::While;
do {{
    sub Perlito5::AST::While::emit_perl5 {
        ((my  $self) = $_[0]);
        ((my  $level) = $_[1]);
        ((my  $cond) = $self->{'cond'});
        (Perlito5::Perl5::tab($level) . 'for ( ' . (($self->{'init'} ? ($self->{'init'}->emit_perl5() . '; ') : '; ')) . (($cond ? ($cond->emit_perl5() . '; ') : '; ')) . (($self->{'continue'} ? ($self->{'continue'}->emit_perl5() . ' ') : ' ')) . ') {' . chr(10) . join(';' . chr(10), map($_->emit_perl5(($level + 1)), @{$self->{'body'}->stmts()})) . chr(10) . Perlito5::Perl5::tab($level) . '}')
    }
}};
package Perlito5::AST::For;
do {{
    sub Perlito5::AST::For::emit_perl5 {
        ((my  $self) = $_[0]);
        ((my  $level) = $_[1]);
        (my  $cond);
        if ((ref($self->{'cond'}) eq 'ARRAY')) {
            ($cond = ((($self->{'cond'}->[0] ? ($self->{'cond'}->[0]->emit_javascript(($level + 1)) . '; ') : '; ')) . (($self->{'cond'}->[1] ? ($self->{'cond'}->[1]->emit_javascript(($level + 1)) . '; ') : '; ')) . (($self->{'cond'}->[2] ? ($self->{'cond'}->[2]->emit_javascript(($level + 1)) . ' ') : ' '))))
        }
        else {
            ($cond = $self->{'cond'}->emit_perl5())
        };
        (my  $sig);
        if ($self->{'body'}->sig()) {
            ($sig = ('my ' . $self->{'body'}->sig()->emit_perl5() . ' '))
        };
        return ((Perlito5::Perl5::tab($level) . 'for ' . $sig . '(' . $cond . ') {' . chr(10) . join(';' . chr(10), map($_->emit_perl5(($level + 1)), @{$self->{'body'}->stmts()})) . chr(10) . Perlito5::Perl5::tab($level) . '}'))
    }
}};
package Perlito5::AST::Decl;
do {{
    sub Perlito5::AST::Decl::emit_perl5 {
        ((my  $self) = $_[0]);
        ((my  $level) = $_[1]);
        ((my  $decl) = $self->{'decl'});
        ((my  $str) = ('(' . $self->{'decl'} . ' ' . $self->{'type'} . ' ' . $self->{'var'}->emit_perl5() . ')'));
        return ((Perlito5::Perl5::tab($level) . $str))
    }
}};
package Perlito5::AST::Sub;
do {{
    sub Perlito5::AST::Sub::emit_perl5 {
        ((my  $self) = $_[0]);
        ((my  $level) = $_[1]);
        ((my  $name) = '');
        if ($self->{'name'}) {
            ($name = ($self->{'namespace'} . '::' . $self->{'name'} . ' '))
        };
        ((my  $sig) = $self->{'sig'});
        ((my  $i) = 0);
        (Perlito5::Perl5::tab($level) . 'sub ' . $name . '{' . chr(10) . join(';' . chr(10), map($_->emit_perl5(($level + 1)), @{$self->{'block'}})) . chr(10) . Perlito5::Perl5::tab($level) . '}')
    }
}};
package Perlito5::AST::Do;
do {{
    sub Perlito5::AST::Do::emit_perl5 {
        ((my  $self) = $_[0]);
        ((my  $level) = $_[1]);
        ((my  $block) = $self->simplify()->block());
        (Perlito5::Perl5::tab($level) . '(do {' . chr(10) . join(';' . chr(10), map((defined($_) && $_->emit_perl5(($level + 1))), @{$block})) . chr(10) . Perlito5::Perl5::tab($level) . '})')
    }
}};
package Perlito5::AST::Use;
do {{
    sub Perlito5::AST::Use::emit_perl5 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        Perlito5::Grammar::Use::emit_time_eval($self);
        return ((chr(10) . Perlito5::Perl5::tab($level) . '# ' . $self->{'code'} . ' ' . $self->{'mod'} . chr(10)))
    }
}};

;

# use Perlito5::Perl5::Emitter
;
package main;
package Perlito5::Perl5::Runtime;
sub Perlito5::Perl5::Runtime::emit_perl5 {
    return (((chr(10) . 'package Perlito5::IO;' . chr(10) . chr(10) . 'sub slurp {' . chr(10) . '    my $source_filename = shift;' . chr(10) . '    open FILE, $source_filename' . chr(10) . '      or die "Cannot read $source_filename' . chr(92) . 'n";' . chr(10) . '    local $/ = undef;' . chr(10) . '    $source = <FILE>;' . chr(10) . '    close FILE;' . chr(10) . '    return $source;' . chr(10) . '}' . chr(10) . chr(10))))
};
1;

;

# use Perlito5::Perl5::Runtime
;
package main;
undef();

# use Perlito5::AST
;
package Perlito5::Perl6;
do {{
    sub Perlito5::Perl6::tab {
        ((my  $level) = shift());
join("", chr(9) x $level)
    };
    ((my  %safe_char) = ('$', 1, '%', 1, '@', 1, '&', 1, '_', 1, ',', 1, '.', 1, ':', 1, ';', 1, '-', 1, '+', 1, '*', 1, ' ', 1, '(', 1, ')', 1, '<', 1, '=', 1, '>', 1, '[', 1, ']', 1, '{', 1, '|', 1, '}', 1));
    sub Perlito5::Perl6::escape_string {
        ((my  $s) = shift());
        (my  @out);
        ((my  $tmp) = '');
        if (($s eq '')) {
            return (chr(39) . chr(39))
        };
        for my $i ((0 .. (length($s) - 1))) {
            ((my  $c) = substr($s, $i, 1));
            if ((((((($c ge 'a') && ($c le 'z'))) || ((($c ge 'A') && ($c le 'Z')))) || ((($c ge '0') && ($c le '9')))) || exists($safe_char{$c}))) {
                ($tmp = ($tmp . $c))
            }
            else {
                if (($tmp ne '')) {
                    push(@out, (chr(39) . $tmp . chr(39)) )
                };
                push(@out, ('chr(' . ord($c) . ')') );
                ($tmp = '')
            }
        };
        if (($tmp ne '')) {
            push(@out, (chr(39) . $tmp . chr(39)) )
        };
        return (join(' ~ ', @out))
    };
    sub Perlito5::Perl6::to_str {
        ((my  $cond) = shift());
        if ($cond->isa('Perlito5::AST::Val::Buf')) {
            return ($cond->emit_perl6())
        }
        else {
            return (('(' . $cond->emit_perl6() . ')'))
        }
    };
    sub Perlito5::Perl6::to_num {
        ((my  $cond) = shift());
        if (($cond->isa('Perlito5::AST::Val::Int') || $cond->isa('Perlito5::AST::Val::Num'))) {
            return ($cond->emit_perl6())
        }
        else {
            return (('(' . $cond->emit_perl6() . ')'))
        }
    };
    sub Perlito5::Perl6::to_bool {
        ((my  $cond) = shift());
        if (((((($cond->isa('Perlito5::AST::Val::Int')) || ($cond->isa('Perlito5::AST::Val::Num'))) || (($cond->isa('Perlito5::AST::Apply') && ($cond->code() eq 'infix:<||>')))) || (($cond->isa('Perlito5::AST::Apply') && ($cond->code() eq 'infix:<&&>')))) || (($cond->isa('Perlito5::AST::Apply') && ($cond->code() eq 'prefix:<!>'))))) {
            return ($cond->emit_perl6())
        }
        else {
            return (('(' . $cond->emit_perl6() . ')'))
        }
    }
}};
package Perlito5::Perl6::LexicalBlock;
do {{
    sub Perlito5::Perl6::LexicalBlock::new {
        ((my  $class) = shift());
        bless({@_}, $class)
    };
    sub Perlito5::Perl6::LexicalBlock::block {
        $_[0]->{        'block'}
    };
    sub Perlito5::Perl6::LexicalBlock::needs_return {
        $_[0]->{        'needs_return'}
    };
    sub Perlito5::Perl6::LexicalBlock::top_level {
        $_[0]->{        'top_level'}
    };
    sub Perlito5::Perl6::LexicalBlock::emit_perl6 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        if ($self->{'top_level'}) {
            ((my  $block) = Perlito5::Perl6::LexicalBlock->new('block', $self->block(), 'needs_return', $self->needs_return(), 'top_level', 0));
            return (($block->emit_perl6(($level + 1)) . ';' . chr(10)))
        };
        (my  @block);
        for (@{$self->{'block'}}) {
            if (defined($_)) {
                push(@block, $_ )
            }
        };
        if (!(@block)) {
            return ((Perlito5::Perl6::tab($level) . ';'))
        };
        (my  @str);
        for my $decl (@block) {
            if (($decl->isa('Perlito5::AST::Decl') && ($decl->decl() eq 'my'))) {
                push(@str, (Perlito5::Perl6::tab($level) . $decl->emit_perl6_init()) )
            };
            if (($decl->isa('Perlito5::AST::Apply') && ($decl->code() eq 'infix:<=>'))) {
                ((my  $var) = $decl->arguments()->[0]);
                if (($var->isa('Perlito5::AST::Decl') && ($var->decl() eq 'my'))) {
                    push(@str, (Perlito5::Perl6::tab($level) . $var->emit_perl6_init()) )
                }
            }
        };
        for my $decl (@block) {
            if (!((($decl->isa('Perlito5::AST::Decl') && ($decl->decl() eq 'my'))))) {
                push(@str, ($decl->emit_perl6($level) . ';') )
            }
        };
        return ((join(chr(10), @str) . ';'))
    }
}};
package Perlito5::AST::CompUnit;
do {{
    sub Perlito5::AST::CompUnit::emit_perl6 {
        ((my  $self) = $_[0]);
        ((my  $level) = $_[1]);
        (my  @body);
        ((my  $i) = 0);
        for ( ; ($i <= scalar(@{$self->{'body'}})); do {{

}} ) {
            ((my  $stmt) = $self->{'body'}->[$i]);
            if (((ref($stmt) eq 'Perlito5::AST::Apply') && ($stmt->code() eq 'package'))) {
                ((my  $name) = $stmt->namespace());
                (my  @stmts);
                ($i)++;
                for ( ; (($i <= scalar(@{$self->{'body'}})) && !((((ref($self->{'body'}->[$i]) eq 'Perlito5::AST::Apply') && ($self->{'body'}->[$i]->code() eq 'package'))))); do {{

}} ) {
                    push(@stmts, $self->{'body'}->[$i] );
                    ($i)++
                };
                push(@body, Perlito5::AST::CompUnit->new('name', $name, 'body', \@stmts) )
            }
            else {
                if (defined($stmt)) {
                    push(@body, $stmt )
                };
                ($i)++
            }
        };
        ((my  $class_name) = $self->{'name'});
        ((my  $str) = ('package ' . $class_name . '{' . chr(10)));
        for my $decl (@body) {
            if (($decl->isa('Perlito5::AST::Decl') && (($decl->decl() eq 'my')))) {
                ($str = ($str . '  ' . $decl->emit_perl6_init()))
            };
            if (($decl->isa('Perlito5::AST::Apply') && ($decl->code() eq 'infix:<=>'))) {
                ((my  $var) = $decl->arguments()->[0]);
                if (($var->isa('Perlito5::AST::Decl') && ($var->decl() eq 'my'))) {
                    ($str = ($str . '  ' . $var->emit_perl6_init()))
                }
            }
        };
        for my $decl (@body) {
            if ($decl->isa('Perlito5::AST::Sub')) {
                ($str = ($str . ($decl)->emit_perl6(($level + 1)) . ';' . chr(10)))
            }
        };
        for my $decl (@body) {
            if (((defined($decl) && (!((($decl->isa('Perlito5::AST::Decl') && ($decl->decl() eq 'my')))))) && (!(($decl->isa('Perlito5::AST::Sub')))))) {
                ($str = ($str . ($decl)->emit_perl6(($level + 1)) . ';' . chr(10)))
            }
        };
        ($str . '}' . chr(10))
    };
    sub Perlito5::AST::CompUnit::emit_perl6_program {
        ((my  $comp_units) = shift());
        ((my  $str) = '');
        for my $comp_unit (@{$comp_units}) {
            ($str = ($str . $comp_unit->emit_perl6() . chr(10)))
        };
        return ($str)
    }
}};
package Perlito5::AST::Val::Int;
do {{
    sub Perlito5::AST::Val::Int::emit_perl6 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        (Perlito5::Perl6::tab($level) . $self->{'int'})
    }
}};
package Perlito5::AST::Val::Num;
do {{
    sub Perlito5::AST::Val::Num::emit_perl6 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        (Perlito5::Perl6::tab($level) . $self->{'num'})
    }
}};
package Perlito5::AST::Val::Buf;
do {{
    sub Perlito5::AST::Val::Buf::emit_perl6 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        (Perlito5::Perl6::tab($level) . Perlito5::Perl6::escape_string($self->{'buf'}))
    }
}};
package Perlito5::AST::Lit::Block;
do {{
    sub Perlito5::AST::Lit::Block::emit_perl6 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        ((my  $sig) = '$_');
        if ($self->{'sig'}) {
            ($sig = $self->{'sig'}->emit_perl6(($level + 1)))
        };
        return ((Perlito5::Perl6::tab($level) . ('(function (' . $sig . ') {' . chr(10)) . (Perlito5::Perl6::LexicalBlock->new('block', $self->{'stmts'}, 'needs_return', 1))->emit_perl6(($level + 1)) . chr(10) . Perlito5::Perl6::tab($level) . '})'))
    }
}};
package Perlito5::AST::Index;
do {{
    sub Perlito5::AST::Index::emit_perl6 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        if (($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '$'))) {
            ((my  $v) = Perlito5::AST::Var->new('sigil', '@', 'namespace', $self->{'obj'}->namespace(), 'name', $self->{'obj'}->name()));
            return (($v->emit_perl6($level) . '[' . $self->{'index_exp'}->emit_perl6() . ']'))
        };
        (Perlito5::Perl6::tab($level) . $self->{'obj'}->emit_perl6() . '[' . $self->{'index_exp'}->emit_perl6() . ']')
    }
}};
package Perlito5::AST::Lookup;
do {{
    sub Perlito5::AST::Lookup::emit_perl6 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        if (($self->{'obj'}->isa('Perlito5::AST::Var') && ($self->{'obj'}->sigil() eq '$'))) {
            ((my  $v) = Perlito5::AST::Var->new('sigil', '%', 'namespace', $self->{'obj'}->namespace(), 'name', $self->{'obj'}->name()));
            return (($v->emit_perl6($level) . '{' . $self->{'index_exp'}->emit_perl6() . '}'))
        };
        return (($self->{'obj'}->emit_perl6($level) . '{' . $self->{'index_exp'}->emit_perl6() . '}'))
    }
}};
package Perlito5::AST::Var;
do {{
    sub Perlito5::AST::Var::emit_perl6 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        if (($self->{'sigil'} eq '*')) {
            ((my  $ns) = 'PKG');
            if ($self->{'namespace'}) {
                ($ns = ('NAMESPACE["' . $self->{'namespace'} . '"]'))
            };
            return (($ns . '::' . $self->{'name'}))
        };
        ((my  $ns) = '');
        if ($self->{'namespace'}) {
            ($ns = ($self->{'namespace'} . '::'))
        };
        ($ns . $self->{'sigil'} . $self->{'name'})
    }
}};
package Perlito5::AST::Proto;
do {{
    sub Perlito5::AST::Proto::emit_perl6 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        (Perlito5::Perl6::tab($level) . $self->{'name'})
    }
}};
package Perlito5::AST::Call;
do {{
    sub Perlito5::AST::Call::emit_perl6 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        ((my  $invocant) = $self->{'invocant'}->emit_perl6());
        ((my  $meth) = $self->{'method'});
        if (($meth eq 'postcircumfix:<[ ]>')) {
            return ((Perlito5::Perl6::tab($level) . $invocant . '[' . $self->{'arguments'}->emit_perl6() . ']'))
        };
        if (($meth eq 'postcircumfix:<{ }>')) {
            return ((Perlito5::Perl6::tab($level) . $invocant . '{' . $self->{'arguments'}->emit_perl6() . '}'))
        };
        if (($meth eq 'postcircumfix:<( )>')) {
            ((my  @args) = ());
            for (@{$self->{'arguments'}}) {
                push(@args, $_->emit_perl6() )
            };
            return ((Perlito5::Perl6::tab($level) . '(' . $invocant . ')(' . join(',', @args) . ')'))
        };
        ((my  @args) = ($invocant));
        for (@{$self->{'arguments'}}) {
            push(@args, $_->emit_perl6() )
        };
        return ((Perlito5::Perl6::tab($level) . $invocant . '.' . $meth . '(' . join(',', @args) . ')'))
    }
}};
package Perlito5::AST::Apply;
do {{
    ((my  %op_infix_js) = ('infix:<->', ' - ', 'infix:<*>', ' * ', 'infix:<x>', ' x ', 'infix:<+>', ' + ', 'infix:<.>', ' ~ ', 'infix:</>', ' / ', 'infix:<>>', ' > ', 'infix:<<>', ' < ', 'infix:<>=>', ' >= ', 'infix:<<=>', ' <= ', 'infix:<eq>', ' eq ', 'infix:<ne>', ' ne ', 'infix:<le>', ' le ', 'infix:<ge>', ' ge ', 'infix:<==>', ' == ', 'infix:<!=>', ' != ', 'infix:<..>', ' .. ', 'infix:<&&>', ' && ', 'infix:<||>', ' || ', 'infix:<and>', ' and ', 'infix:<or>', ' or ', 'infix:<//>', ' // '));
    sub Perlito5::AST::Apply::emit_perl6 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        ((my  $apply) = $self->op_assign());
        if ($apply) {
            return ($apply->emit_perl6($level))
        };
        ((my  $code) = $self->{'code'});
        if ((ref($code) ne '')) {
            ((my  @args) = ());
            for (@{$self->{'arguments'}}) {
                push(@args, $_->emit_perl6() )
            };
            return ((Perlito5::Perl6::tab($level) . '(' . $self->{'code'}->emit_perl6() . ')(' . join(',', @args) . ')'))
        };
        if (($code eq 'infix:<=>>')) {
            return ((Perlito5::Perl6::tab($level) . join(', ', map($_->emit_perl6(), @{$self->{'arguments'}}))))
        };
        if (exists($op_infix_js{$code})) {
            return ((Perlito5::Perl6::tab($level) . '(' . join($op_infix_js{$code}, map($_->emit_perl6(), @{$self->{'arguments'}})) . ')'))
        };
        if (($code eq 'eval')) {
            return (('eval(perl5_to_js(' . Perlito5::Perl6::to_str($self->{'arguments'}->[0]) . '))'))
        };
        if (($code eq 'undef')) {
            return ((Perlito5::Perl6::tab($level) . 'Any'))
        };
        if (($code eq 'shift')) {
            if (!((($self->{'arguments'} && @{$self->{'arguments'}})))) {
                return ('shift(@_)')
            }
        };
        if (($code eq 'map')) {
            ((my  $fun) = $self->{'arguments'}->[0]);
            ((my  $list) = $self->{'arguments'}->[1]);
            return (('(function (a_) { ' . 'var out = []; ' . 'if ( a_ == null ) { return out; }; ' . 'for(var i = 0; i < a_.length; i++) { ' . 'my $_ = a_[i]; ' . 'out.push(' . $fun->emit_perl6() . ')' . '}; ' . 'return out;' . ' })(' . $list->emit_perl6() . ')'))
        };
        if ((($code eq 'bless') || ($code eq 'ref'))) {
            return (('Perlito5::Perl6::Runtime::' . $code . '( ' . join(', ', map($_->emit_perl6(), @{$self->{'arguments'}})) . ')'))
        };
        if (($code eq 'prefix:<!>')) {
            return (('!( ' . Perlito5::Perl6::to_bool($self->{'arguments'}->[0]) . ')'))
        };
        if (($code eq 'prefix:<$>')) {
            ((my  $arg) = $self->{'arguments'}->[0]);
            return (('$(' . $arg->emit_perl6() . ')'))
        };
        if (($code eq 'prefix:<@>')) {
            return (('@(' . join(' ', map($_->emit_perl6(), @{$self->{'arguments'}})) . ')'))
        };
        if (($code eq 'prefix:<%>')) {
            ((my  $arg) = $self->{'arguments'}->[0]);
            return (('%(' . $arg->emit_perl6() . ')'))
        };
        if (($code eq 'circumfix:<[ ]>')) {
            return (('[' . join(', ', map($_->emit_perl6(), @{$self->{'arguments'}})) . ']'))
        };
        if (($code eq 'circumfix:<{ }>')) {
            return (('{' . join(', ', map($_->emit_perl6(), @{$self->{'arguments'}})) . '}'))
        };
        if (($code eq 'prefix:<' . chr(92) . '>')) {
            ((my  $arg) = $self->{'arguments'}->[0]);
            if ($arg->isa('Perlito5::AST::Var')) {
                if (($arg->sigil() eq '@')) {
                    return ($arg->emit_perl6())
                };
                if (($arg->sigil() eq '%')) {
                    return (('(HashRef.new(' . $arg->emit_perl6() . '))'))
                }
            };
            return (('(ScalarRef.new(' . $arg->emit_perl6() . '))'))
        };
        if (($code eq 'postfix:<++>')) {
            return (('(' . join(' ', map($_->emit_perl6(), @{$self->{'arguments'}})) . ')++'))
        };
        if (($code eq 'postfix:<-->')) {
            return (('(' . join(' ', map($_->emit_perl6(), @{$self->{'arguments'}})) . ')--'))
        };
        if (($code eq 'prefix:<++>')) {
            return (('++(' . join(' ', map($_->emit_perl6(), @{$self->{'arguments'}})) . ')'))
        };
        if (($code eq 'prefix:<-->')) {
            return (('--(' . join(' ', map($_->emit_perl6(), @{$self->{'arguments'}})) . ')'))
        };
        if (($code eq 'prefix:<+>')) {
            return (('+(' . $self->{'arguments'}->[0]->emit_perl6() . ')'))
        };
        if (($code eq 'list:<.>')) {
            return (('(' . join(' ~ ', map(Perlito5::Perl6::to_str($_), @{$self->{'arguments'}})) . ')'))
        };
        if (($code eq 'ternary:<? :>')) {
            return ((Perlito5::Perl6::tab($level) . '( ' . Perlito5::Perl6::to_bool($self->{'arguments'}->[0]) . ' ?? ' . ($self->{'arguments'}->[1])->emit_perl6() . ' !! ' . ($self->{'arguments'}->[2])->emit_perl6() . ')'))
        };
        if (($code eq 'circumfix:<( )>')) {
            return ((Perlito5::Perl6::tab($level) . '(' . join(', ', map($_->emit_perl6(), @{$self->{'arguments'}})) . ')'))
        };
        if (($code eq 'infix:<=>')) {
            return (emit_perl6_bind($self->{'arguments'}->[0], $self->{'arguments'}->[1], $level))
        };
        if (($code eq 'return')) {
            return ((Perlito5::Perl6::tab($level) . 'return(' . ((($self->{'arguments'} && @{$self->{'arguments'}}) ? $self->{'arguments'}->[0]->emit_perl6() : '')) . ')'))
        };
        if ($self->{'namespace'}) {
            if ((($self->{'namespace'} eq 'Perl6') && ($code eq 'inline'))) {
                if ($self->{'arguments'}->[0]->isa('Perlito5::AST::Val::Buf')) {
                    return ($self->{'arguments'}->[0]->{'buf'})
                }
                else {
                    die('Perl6::inline needs a string constant')
                }
            };
            ($code = ($self->{'namespace'} . '::' . ($code)))
        };
        ((my  @args) = ());
        for (@{$self->{'arguments'}}) {
            push(@args, $_->emit_perl6() )
        };
        (Perlito5::Perl6::tab($level) . $code . '(' . join(', ', @args) . ')')
    };
    sub Perlito5::AST::Apply::emit_perl6_bind {
        ((my  $parameters) = shift());
        ((my  $arguments) = shift());
        ((my  $level) = shift());
        (Perlito5::Perl6::tab($level) . '(' . $parameters->emit_perl6() . ' = ' . $arguments->emit_perl6() . ')')
    }
}};
package Perlito5::AST::If;
do {{
    sub Perlito5::AST::If::emit_perl6 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        ((my  $cond) = $self->{'cond'});
        if (($cond->isa('Perlito5::AST::Var') && ($cond->sigil() eq '@'))) {
            ($cond = Perlito5::AST::Apply->new('code', 'prefix:<@>', 'arguments', [$cond]))
        };
        ((my  $body) = Perlito5::Perl6::LexicalBlock->new('block', $self->{'body'}->stmts(), 'needs_return', 0));
        ((my  $s) = (Perlito5::Perl6::tab($level) . 'if ( ' . Perlito5::Perl6::to_bool($cond) . ' ) {' . chr(10) . $body->emit_perl6(($level + 1)) . chr(10) . Perlito5::Perl6::tab($level) . '}'));
        if (@{$self->{'otherwise'}->stmts()}) {
            ((my  $otherwise) = Perlito5::Perl6::LexicalBlock->new('block', $self->{'otherwise'}->stmts(), 'needs_return', 0));
            ($s = ($s . chr(10) . Perlito5::Perl6::tab($level) . 'else {' . chr(10) . $otherwise->emit_perl6(($level + 1)) . chr(10) . Perlito5::Perl6::tab($level) . '}'))
        };
        return ($s)
    }
}};
package Perlito5::AST::While;
do {{
    sub Perlito5::AST::While::emit_perl6 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        ((my  $body) = Perlito5::Perl6::LexicalBlock->new('block', $self->{'body'}->stmts(), 'needs_return', 0));
        return ((Perlito5::Perl6::tab($level) . 'loop ( ' . (($self->{'init'} ? ($self->{'init'}->emit_perl6() . '; ') : '; ')) . (($self->{'cond'} ? (Perlito5::Perl6::to_bool($self->{'cond'}) . '; ') : '; ')) . (($self->{'continue'} ? ($self->{'continue'}->emit_perl6() . ' ') : ' ')) . ') {' . chr(10) . $body->emit_perl6(($level + 1)) . ' }'))
    }
}};
package Perlito5::AST::For;
do {{
    sub Perlito5::AST::For::emit_perl6 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        ((my  $cond) = $self->{'cond'});
        ((my  $body) = Perlito5::Perl6::LexicalBlock->new('block', $self->{'body'}->stmts(), 'needs_return', 0));
        ((my  $sig) = '$_');
        if ($self->{'body'}->sig()) {
            ($sig = $self->{'body'}->sig()->emit_perl6(($level + 1)))
        };
        (Perlito5::Perl6::tab($level) . 'for ' . $cond->emit_perl6() . ' -> ' . $sig . ' { ' . $body->emit_perl6(($level + 1)) . '}' . chr(10))
    }
}};
package Perlito5::AST::Decl;
do {{
    sub Perlito5::AST::Decl::emit_perl6 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        (Perlito5::Perl6::tab($level) . $self->{'var'}->emit_perl6())
    };
    sub Perlito5::AST::Decl::emit_perl6_init {
        ((my  $self) = shift());
        ($self->{'decl'} . ' ' . ($self->{'var'})->emit_perl6() . ';')
    }
}};
package Perlito5::AST::Sub;
do {{
    sub Perlito5::AST::Sub::emit_perl6 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        (Perlito5::Perl6::tab($level) . 'sub ' . (($self->{'name'} ? $self->{'name'} : '')) . '(*@_) {' . chr(10) . (Perlito5::Perl6::LexicalBlock->new('block', $self->{'block'}, 'needs_return', 1, 'top_level', 1))->emit_perl6(($level + 1)) . chr(10) . Perlito5::Perl6::tab($level) . '}')
    }
}};
package Perlito5::AST::Do;
do {{
    sub Perlito5::AST::Do::emit_perl6 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        ((my  $block) = $self->simplify()->block());
        return ((Perlito5::Perl6::tab($level) . '(do {' . chr(10) . (Perlito5::Perl6::LexicalBlock->new('block', $block, 'needs_return', 1))->emit_perl6(($level + 1)) . chr(10) . Perlito5::Perl6::tab($level) . '})'))
    }
}};
package Perlito5::AST::Use;
do {{
    sub Perlito5::AST::Use::emit_perl6 {
        ((my  $self) = shift());
        ((my  $level) = shift());
        ((my  $mod) = $self->{'mod'});
        return ((chr(10) . Perlito5::Perl6::tab($level) . '# use ' . $self->{'mod'} . ';'))
    }
}};

;

# use Perlito5::Perl6::Emitter
;

# use Perlito5::Precedence
;
package main;
package Perlito5::strict;
sub Perlito5::strict::import {
    ($Perlito5::STRICT = 1)
};
sub Perlito5::strict::unimport {
    ($Perlito5::STRICT = 0)
};
1;

;
package main;
package Perlito5::Runtime;

# use Perlito5::strict
;
if (${'main::]'}) {

}
else {
    (${'main::]'} = 5.014001)
};
($Perlito5::EXPAND_USE = 1);
($Perlito5::STRICT = 0);
($Perlito5::WARNINGS = 0);
($Perlito5::UTF8 = 0);
($Perlito5::BYTES = 0);
($Perlito5::CALLER = []);
($Perlito5::PKG_NAME = '');
for (split(':', (($ENV{'PERL5LIB'} || '')))) {
    push(@INC, $_ )
};
($Perlito5::SPECIAL_VAR = {'$_', 'ARG', '$&', '$MATCH', '$`', '$PREMATCH', '$' . chr(39), '$POSTMATCH', '$+', '$LAST_PAREN_MATCH', '@+', '@LAST_MATCH_END', '%+', '%LAST_PAREN_MATCH', '@-', '@LAST_MATCH_START', '$|', 'autoflush', '$/', '$RS', '@_', '@ARG', '< $', '$EUID', '$.', '$NR', '< $< ', '$UID', '$(', '$GID', '$#', undef(), '$@', '$EVAL_ERROR', '$=', '$FORMAT_LINES_PER_PAGE', '$,', '$OFS', '$?', '$CHILD_ERROR', '$*', undef(), '$[', undef(), '$$', '$PID', '%-', undef(), '$~', '$FORMAT_NAME', '$-', '$FORMAT_LINES_LEFT', '$&', '$MATCH', '$%', '$FORMAT_PAGE_NUMBER', '$)', '$EGID', '$]', undef(), '$!', '$ERRNO', '$;', '$SUBSEP', '$' . chr(92), '$ORS', '%!', undef(), '$"', '$LIST_SEPARATOR', '$_', '$ARG', '$:', 'FORMAT_LINE_BREAK_CHARACTERS'});
($Perlito5::CORE_OVERRIDABLE = {'say', 1, 'break', 1, 'given', 1, 'when', 1, 'default', 1, 'state', 1, 'lock', 1});
($Perlito5::CORE_PROTO = {'CORE::shutdown', '*$', 'CORE::chop', undef(), 'CORE::lstat', '*', 'CORE::rename', '$$', 'CORE::lock', chr(92) . '$', 'CORE::rand', ';$', 'CORE::gmtime', ';$', 'CORE::gethostbyname', '$', 'CORE::each', chr(92) . '[@%]', 'CORE::ref', '_', 'CORE::syswrite', '*$;$$', 'CORE::msgctl', '$$$', 'CORE::getnetbyname', '$', 'CORE::write', ';*', 'CORE::alarm', '_', 'CORE::print', undef(), 'CORE::getnetent', '', 'CORE::semget', '$$$', 'CORE::use', undef(), 'CORE::abs', '_', 'CORE::break', '', 'CORE::undef', undef(), 'CORE::no', undef(), 'CORE::eval', undef(), 'CORE::split', undef(), 'CORE::localtime', ';$', 'CORE::sort', undef(), 'CORE::chown', '@', 'CORE::endpwent', '', 'CORE::getpwent', '', 'CORE::pos', undef(), 'CORE::lcfirst', '_', 'CORE::kill', '@', 'CORE::send', '*$$;$', 'CORE::endprotoent', '', 'CORE::semctl', '$$$$', 'CORE::waitpid', '$$', 'CORE::utime', '@', 'CORE::dbmclose', chr(92) . '%', 'CORE::getpwnam', '$', 'CORE::substr', '$$;$$', 'CORE::listen', '*$', 'CORE::getprotoent', '', 'CORE::shmget', '$$$', 'CORE::our', undef(), 'CORE::readlink', '_', 'CORE::shmwrite', '$$$$', 'CORE::times', '', 'CORE::package', undef(), 'CORE::map', undef(), 'CORE::join', '$@', 'CORE::rmdir', '_', 'CORE::shmread', '$$$$', 'CORE::uc', '_', 'CORE::bless', '$;$', 'CORE::closedir', '*', 'CORE::getppid', '', 'CORE::tie', undef(), 'CORE::readdir', '*', 'CORE::gethostent', '', 'CORE::getlogin', '', 'CORE::last', undef(), 'CORE::gethostbyaddr', '$$', 'CORE::accept', '**', 'CORE::log', '_', 'CORE::tell', ';*', 'CORE::readline', ';*', 'CORE::tied', undef(), 'CORE::socket', '*$$$', 'CORE::umask', ';$', 'CORE::sysread', '*' . chr(92) . '$$;$', 'CORE::syscall', '$@', 'CORE::quotemeta', '_', 'CORE::dump', '', 'CORE::opendir', '*$', 'CORE::untie', undef(), 'CORE::truncate', '$$', 'CORE::select', ';*', 'CORE::sleep', ';$', 'CORE::seek', '*$$', 'CORE::read', '*' . chr(92) . '$$;$', 'CORE::rewinddir', '*', 'CORE::scalar', undef(), 'CORE::wantarray', '', 'CORE::oct', '_', 'CORE::bind', '*$', 'CORE::stat', '*', 'CORE::sqrt', '_', 'CORE::getc', ';*', 'CORE::fileno', '*', 'CORE::getpeername', '*', 'CORE::sin', '_', 'CORE::getnetbyaddr', '$$', 'CORE::grep', undef(), 'CORE::setservent', '$', 'CORE::sub', undef(), 'CORE::shmctl', '$$$', 'CORE::study', undef(), 'CORE::msgrcv', '$$$$$', 'CORE::setsockopt', '*$$$', 'CORE::int', '_', 'CORE::pop', ';' . chr(92) . '@', 'CORE::link', '$$', 'CORE::exec', undef(), 'CORE::setpwent', '', 'CORE::mkdir', '_;$', 'CORE::sysseek', '*$$', 'CORE::endservent', '', 'CORE::chr', '_', 'CORE::when', undef(), 'CORE::getpwuid', '$', 'CORE::setprotoent', '$', 'CORE::reverse', '@', 'CORE::say', undef(), 'CORE::goto', undef(), 'CORE::getgrent', '', 'CORE::endnetent', '', 'CORE::hex', '_', 'CORE::binmode', '*;$', 'CORE::formline', '$@', 'CORE::getgrnam', '$', 'CORE::ucfirst', '_', 'CORE::chdir', ';$', 'CORE::setnetent', '$', 'CORE::splice', chr(92) . '@;$$@', 'CORE::unlink', '@', 'CORE::time', '', 'CORE::push', chr(92) . '@@', 'CORE::exit', ';$', 'CORE::endgrent', '', 'CORE::unshift', chr(92) . '@@', 'CORE::local', undef(), 'CORE::my', undef(), 'CORE::cos', '_', 'CORE::redo', undef(), 'CORE::warn', '@', 'CORE::getsockname', '*', 'CORE::pipe', '**', 'CORE::sprintf', '$@', 'CORE::open', '*;$@', 'CORE::setpgrp', ';$$', 'CORE::exp', '_', 'CORE::seekdir', '*$', 'CORE::getservbyport', '$$', 'CORE::given', undef(), 'CORE::pack', '$@', 'CORE::msgget', '$$', 'CORE::rindex', '$$;$', 'CORE::srand', ';$', 'CORE::telldir', '*', 'CORE::connect', '*$', 'CORE::getprotobyname', '$', 'CORE::msgsnd', '$$$', 'CORE::length', '_', 'CORE::state', undef(), 'CORE::die', '@', 'CORE::delete', undef(), 'CORE::getservent', '', 'CORE::getservbyname', '$$', 'CORE::setpriority', '$$$', 'CORE::lc', '_', 'CORE::fcntl', '*$$', 'CORE::chroot', '_', 'CORE::recv', '*' . chr(92) . '$$$', 'CORE::dbmopen', chr(92) . '%$$', 'CORE::socketpair', '**$$$', 'CORE::vec', '$$$', 'CORE::system', undef(), 'CORE::defined', '_', 'CORE::index', '$$;$', 'CORE::caller', ';$', 'CORE::close', ';*', 'CORE::atan2', '$$', 'CORE::semop', '$$', 'CORE::unpack', '$;$', 'CORE::ord', '_', 'CORE::chmod', '@', 'CORE::prototype', undef(), 'CORE::getprotobynumber', '$', 'CORE::values', chr(92) . '[@%]', 'CORE::chomp', undef(), 'CORE::ioctl', '*$$', 'CORE::eof', ';*', 'CORE::crypt', '$$', 'CORE::do', undef(), 'CORE::flock', '*$', 'CORE::wait', '', 'CORE::sethostent', '$', 'CORE::return', undef(), 'CORE::getsockopt', '*$$', 'CORE::fork', '', 'CORE::require', undef(), 'CORE::format', undef(), 'CORE::readpipe', '_', 'CORE::endhostent', '', 'CORE::getpgrp', ';$', 'CORE::setgrent', '', 'CORE::keys', chr(92) . '[@%]', 'CORE::glob', undef(), 'CORE::getpriority', '$$', 'CORE::reset', ';$', 'CORE::sysopen', '*$$;$', 'CORE::continue', '', 'CORE::next', undef(), 'CORE::getgrgid', '$', 'CORE::default', undef(), 'CORE::shift', ';' . chr(92) . '@', 'CORE::symlink', '$$', 'CORE::exists', '$', 'CORE::printf', '$@'});
1;

;

# use Perlito5::Runtime
;

# use Perlito5::Dumper
;
((my  $_V5_COMPILER_NAME) = 'Perlito5');
((my  $_V5_COMPILER_VERSION) = '9.0');
((my  $source) = '');
((my  $backend) = ${^O});
((my  $execute) = 1);
((my  $verbose) = 0);
((my  $expand_use) = 1);
if ($verbose) {
    warn('// Perlito5 compiler');
    warn(('// ARGV: ' . join(' ', @ARGV)))
};
((my  $help_message) = chr(10) . 'perlito5 [switches] [programfile]' . chr(10) . '  switches:' . chr(10) . '    -h --help' . chr(10) . '    --verbose' . chr(10) . '    -V --version' . chr(10) . '    -v' . chr(10) . '    -Idirectory     specify @INC/include directory (several -I' . chr(39) . 's allowed)' . chr(10) . '    -Ctarget        target backend: js, perl5, perl6' . chr(10) . '    -Cast-perl5     emits a dump of the abstract syntax tree' . chr(10) . '    --expand_use --noexpand_use' . chr(10) . '                    expand ' . chr(39) . 'use' . chr(39) . ' statements at compile time' . chr(10) . '    -e program      one line of program (omit programfile)' . chr(10));
((my  $copyright_message) = ((('This is Perlito5 ' . $_V5_COMPILER_VERSION . ', an implementation of the Perl language.' . chr(10) . chr(10) . 'The Perl language is Copyright 1987-2012, Larry Wall' . chr(10) . 'The Perlito5 implementation is Copyright 2011, 2012 by Flavio Soibelmann Glock and others.' . chr(10) . chr(10) . 'Perl may be copied only under the terms of either the Artistic License or the' . chr(10) . 'GNU General Public License, which may be found in the Perl 5 source kit.' . chr(10) . chr(10) . 'Complete documentation for Perl, including FAQ lists, should be found on' . chr(10) . 'this system using "man perl" or "perldoc perl".  If you have access to the' . chr(10) . 'Internet, point your browser at http://www.perl.org/, the Perl Home Page.') . chr(10))));
for ( ; ((substr($ARGV[0], 0, 1) eq '-') && (substr($ARGV[0], 0, 2) ne '-e')); do {{

}} ) {
    if (($ARGV[0] eq '--verbose')) {
        ($verbose = 1);
        shift(@ARGV)
    }
    else {
        if (($ARGV[0] eq '-I')) {
            shift(@ARGV);
            ($lib = shift(@ARGV));
            unshift(@INC, $lib)
        }
        else {
            if ((substr($ARGV[0], 0, 2) eq '-I')) {
                ($lib = substr($ARGV[0], 2));
                unshift(@INC, $lib);
                shift(@ARGV)
            }
            else {
                if ((substr($ARGV[0], 0, 2) eq '-C')) {
                    ($backend = substr($ARGV[0], 2, 10));
                    ($execute = 0);
                    shift(@ARGV)
                }
                else {
                    if (($ARGV[0] eq '-MO=Deparse')) {
                        ($backend = 'perl5');
                        ($execute = 0);
                        ($expand_use = 0);
                        shift(@ARGV)
                    }
                    else {
                        if (((($ARGV[0] eq '-V')) || (($ARGV[0] eq '--version')))) {
                            ($backend = '');
                            say($_V5_COMPILER_NAME, ' ', $_V5_COMPILER_VERSION);
                            shift(@ARGV)
                        }
                        else {
                            if (($ARGV[0] eq '-v')) {
                                ($backend = '');
                                say($copyright_message);
                                shift(@ARGV)
                            }
                            else {
                                if (((($ARGV[0] eq '-h') || ($ARGV[0] eq '--help')) || !(@ARGV))) {
                                    ($backend = '');
                                    say($_V5_COMPILER_NAME, ' ', $_V5_COMPILER_VERSION, $help_message);
                                    shift(@ARGV)
                                }
                                else {
                                    if (($ARGV[0] eq '--expand_use')) {
                                        ($expand_use = 1);
                                        shift(@ARGV)
                                    }
                                    else {
                                        if (($ARGV[0] eq '--noexpand_use')) {
                                            ($expand_use = 0);
                                            shift(@ARGV)
                                        }
                                        else {
                                            die(('Unrecognized switch: ' . $ARGV[0] . '  (-h will show valid options).' . chr(10)))
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
};
if (($backend && @ARGV)) {
    if (($ARGV[0] eq '-e')) {
        shift(@ARGV);
        if ($verbose) {
            warn('// source from command line: ', $ARGV[0])
        };
        ($source = shift(@ARGV))
    }
    else {
        if ($verbose) {
            warn('// source from file: ', $ARGV[0])
        };
        ($source = Perlito5::IO::slurp(shift(@ARGV)))
    };
    if ($verbose) {
        warn('// backend: ', $backend);
        warn('now parsing')
    };
    ($Perlito5::PKG_NAME = 'main');
    ($Perlito5::PROTO = {});
    if ($execute) {
        ($Perlito5::EXPAND_USE = 1);
        local(${'@'});
        (do { my $m = Perlito5::Grammar->exp_stmts(            ('package main; no strict; no warnings; ' . $source . '; $@ = undef'), 0);my $source; $source .= (defined $_ ? $_->emit_perl5(0, "scalar") : "") . ";\n" for @{ Perlito5::Match::flat($m) }; eval $source;});
        if (${'@'}) {
            ((my  $error) = ${'@'});
            warn($error);
            exit(255)
        }
    }
    else {
        (%INC = ());
        ($Perlito5::EXPAND_USE = 0);
        (my  $m);
        (my  $ok);
                    (do {
                ($m = Perlito5::Grammar->exp_stmts($source, 0));
                ($ok = 1)
            });
        if ((!($ok) || ($m->{'to'} != length($source)))) {
            ((my  $error) = ((${'@'} || ((($m->{'to'} != length($source)) && ('Syntax Error near ' . $m->{'to'})))) || 'Unknown error'));
            warn($error);
            exit(255)
        }
        else {
            (my  $comp_units);
            if ($expand_use) {
                (my  $ok);
                                    (do {
                        ($comp_units = Perlito5::Grammar::Use::add_comp_unit(Perlito5::Match::flat($m)));
                        ($ok = 1)
                    });
                if (!($ok)) {
                    ((my  $error) = (${'@'} || 'Unknown error loading a module'));
                    warn($error);
                    exit(255)
                }
            }
            else {
                ($comp_units = Perlito5::Match::flat($m))
            };
            ($comp_units = [Perlito5::AST::CompUnit->new('name', 'main', 'body', $comp_units)]);
            if (($backend eq 'perl5')) {
                say('# Do not edit this file - Generated by ', $_V5_COMPILER_NAME, ' ', $_V5_COMPILER_VERSION);
                if ($expand_use) {
                    print(Perlito5::Perl5::Runtime->emit_perl5())
                };
                print(Perlito5::AST::CompUnit::emit_perl5_program($comp_units))
            };
            if (($backend eq 'perl6')) {
                say('# Do not edit this file - Generated by ', $_V5_COMPILER_NAME, ' ', $_V5_COMPILER_VERSION);
                print(Perlito5::AST::CompUnit::emit_perl6_program($comp_units))
            };
            if (($backend eq 'js')) {
                say('// Do not edit this file - Generated by ', $_V5_COMPILER_NAME, ' ', $_V5_COMPILER_VERSION);
                if ($expand_use) {
                    print(Perlito5::Javascript2::Runtime->emit_javascript2());
                    print(Perlito5::Javascript2::CORE->emit_javascript2());
                    print(Perlito5::Javascript2::IO->emit_javascript2());
                    print(Perlito5::Javascript2::Sprintf->emit_javascript2())
                };
                print(Perlito5::AST::CompUnit::emit_javascript2_program($comp_units))
            };
            if (($backend eq 'js3')) {
                say('// Do not edit this file - Generated by ', $_V5_COMPILER_NAME, ' ', $_V5_COMPILER_VERSION);
                if ($expand_use) {
                    print(Perlito5::Javascript3::Runtime->emit_javascript3());
                    print(Perlito5::Javascript3::CORE->emit_javascript3());
                    print(Perlito5::Javascript3::IO->emit_javascript3());
                    print(Perlito5::Javascript3::Sprintf->emit_javascript3())
                };
                print(Perlito5::AST::CompUnit::emit_javascript3_program($comp_units))
            };
            if (($backend eq 'ast-perl5')) {
                say(Perlito5::Dumper::Dumper($comp_units))
            }
            else {
                if (($backend eq 'ast-pretty')) {
                    (do { my $m = Perlito5::Grammar->exp_stmts(                        'use Data::Printer {colored=>1,class=>{expand=>"all",show_methods=>"none"}};p($comp_units);1', 0);my $source; $source .= (defined $_ ? $_->emit_perl5(0, "scalar") : "") . ";\n" for @{ Perlito5::Match::flat($m) }; eval $source;});
                    print(${'@'})
                }
            }
        }
    }
};

1;
