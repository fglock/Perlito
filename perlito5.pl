
use v5.10;
use feature 'say';

# Do not edit this file - Generated by Perlito5 9.022

{
    package main;
    package feature;
    sub feature::import {}
    sub feature::unimport {}
    1
}
{
    package main;
    package Perlito5;
    $VERSION = 9.022;
    1
}
{
    package main;
    package strict;
    $Perlito5::STRICT_REFS = 2;
    $Perlito5::STRICT_SUBS = 512;
    $Perlito5::STRICT_VARS = 1024;
    sub strict::import {
        (my($pkg), my(@args)) = @_;
        !@args && (@args = ("refs", "subs", "vars"));
        for $_ (@args) {
            $_ eq "refs" && (${^H} |= $Perlito5::STRICT_REFS);
            $_ eq "subs" && (${^H} |= $Perlito5::STRICT_SUBS);
            $_ eq "vars" && (${^H} |= $Perlito5::STRICT_VARS)
        }
    }
    sub strict::unimport {
        (my($pkg), my(@args)) = @_;
        !@args && (@args = ("refs", "subs", "vars"));
        for $_ (@args) {
            $_ eq "refs" && (${^H} &= ~$Perlito5::STRICT_REFS);
            $_ eq "subs" && (${^H} &= ~$Perlito5::STRICT_SUBS);
            $_ eq "vars" && (${^H} &= ~$Perlito5::STRICT_VARS)
        }
    }
    1
}
{
    package main;
    package warnings;
    sub warnings::import {;
        $Perlito5::WARNINGS = 1
    }
    sub warnings::unimport {;
        $Perlito5::WARNINGS = 0
    }
    sub warnings::register_categories {}
    1
}
{
    package main;
    package Perlito5::Match;
    sub Perlito5::Match::flat {
        my $self = $_[0];
        defined($self->{"capture"}) && return $self->{"capture"};
        return join('', @{$self->{"str"}}[$self->{"from"} .. $self->{"to"} - 1])
    }
    1
}
{
    package main;
    package Perlito5::Grammar::Precedence;
    sub Perlito5::Grammar::Precedence::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    my $Operator = {};
    my $Precedence = {};
    my $PrefixPrecedence = {};
    my $Assoc = {};
    sub Perlito5::Grammar::Precedence::is_assoc_type {
        my $assoc_type = shift;
        my $op_name = shift;
        return $Assoc->{$assoc_type}->{$op_name}
    }
    sub Perlito5::Grammar::Precedence::is_fixity_type {
        my $fixity_type = shift;
        my $op_name = shift;
        return $Operator->{$fixity_type}->{$op_name}
    }
    sub Perlito5::Grammar::Precedence::is_term {
        my $token = shift;
        ($token->[0] eq "term") || ($token->[0] eq "postfix_or_term") || ($token->[0] eq "postfix")
    }
    sub Perlito5::Grammar::Precedence::is_num {;
        $_[0] ge 0 && $_[0] le 9
    }
    sub Perlito5::Grammar::Precedence::is_ident_middle {
        my $c = shift;
        ($c ge "a" && $c le "z") || ($c ge "A" && $c le "Z") || ($c ge 0 && $c le 9) || ($c eq "_")
    }
    my @Parsed_op_chars = (2, 1);
    my %Parsed_op = ("?", sub {;
        Perlito5::Grammar::Expression::term_ternary($_[0], $_[1])
    }, "(", sub {;
        Perlito5::Grammar::Expression::term_paren($_[0], $_[1])
    }, "[", sub {;
        Perlito5::Grammar::Expression::term_square($_[0], $_[1])
    }, "{", sub {;
        Perlito5::Grammar::Expression::term_curly($_[0], $_[1])
    }, "->", sub {;
        Perlito5::Grammar::Expression::term_arrow($_[0], $_[1])
    });
    my @Term_chars;
    my %Term;
    sub Perlito5::Grammar::Precedence::add_term {
        my $name = shift;
        my $param = shift;
        $Term{$name} = $param;
        unshift(@Term_chars, scalar(@Term_chars) + 1)
            while @Term_chars < length($name)
    }
    my $End_token;
    my $End_token_chars;
    my %Op;
    my @Op_chars = (3, 2, 1);
    sub Perlito5::Grammar::Precedence::op_parse {
        my $str = shift;
        my $pos = shift;
        my $last_is_term = shift;
        my $tok = join('', @{$str}[$pos .. $pos + 10]);
        for my $len (@{$End_token_chars}) {
            my $term = substr($tok, 0, $len);
            if (exists($End_token->{$term})) {
                my $c1 = $str->[$pos + $len - 1];
                my $c2 = $str->[$pos + $len];
                if (!(is_ident_middle($c1) && is_ident_middle($c2)) && !($c1 eq "<" && $c2 eq "<")) {;
                    return {"str", $str, "from", $pos, "to", $pos, "capture", ["end", $term]}
                }
            }
        }
        if (!$last_is_term) {;
            for my $len (@Term_chars) {
                my $term = substr($tok, 0, $len);
                if (exists($Term{$term})) {
                    my $c1 = $str->[$pos + $len - 1];
                    my $c2 = $str->[$pos + $len];
                    if (is_num($c1) || !is_ident_middle($c1) || !is_ident_middle($c2)) {
                        my $m = $Term{$term}->($str, $pos);
                        $m && return $m
                    }
                }
            }
        }
        for my $len (@Parsed_op_chars) {
            my $op = substr($tok, 0, $len);
            if (exists($Parsed_op{$op})) {
                my $m = $Parsed_op{$op}->($str, $pos);
                $m && return $m
            }
        }
        for my $len (@Op_chars) {
            my $op = substr($tok, 0, $len);
            if (exists($Op{$op})) {
                my $c1 = $str->[$pos + $len - 1];
                my $c2 = $str->[$pos + $len];
                if ((!(is_ident_middle($c1) && is_ident_middle($c2)) && !($c1 eq "&" && $c2 eq "&")) || ($c1 eq "x" && $c2 ge 0 && $c2 le 9)) {
                    if (exists($Operator->{"infix"}->{$op}) && !exists($Operator->{"prefix"}->{$op}) && !$last_is_term) {}
                    else {;
                        return {"str", $str, "from", $pos, "to", $pos + $len, "capture", ["op", $op]}
                    }
                }
            }
        }
        return Perlito5::Grammar::Bareword::term_bareword($str, $pos)
    }
    sub Perlito5::Grammar::Precedence::add_op {
        (my($fixity), my($names), my($precedence), my($param)) = @_;
        $param //= {};
        my $assoc = $param->{"assoc"} || "left";
        for my $name (@{$names}) {
            $Operator->{$fixity}->{$name} = 1;
            $Precedence->{$name} = $precedence;
            $fixity eq "prefix" && ($PrefixPrecedence->{$name} = $precedence);
            $Assoc->{$assoc}->{$name} = 1;
            $Op{$name} = 1
        }
    }
    my $prec = 100;
    add_op("postfix", [".( )", ".[ ]", ".{ }", "( )", "[ ]", "funcall", "funcall_no_params", "methcall", "methcall_no_params", "block", "hash"], $prec);
    $prec = $prec - 1;
    add_op("prefix", ["++", "--"], $prec);
    add_op("postfix", ["++", "--"], $prec);
    $prec = $prec - 1;
    add_op("infix", ["**"], $prec, {"assoc" => "right", });
    $prec = $prec - 1;
    add_op("prefix", ["\\", "+", "-", "~", "!"], $prec);
    $prec = $prec - 1;
    add_op("infix", ["=~", "!~"], $prec);
    $prec = $prec - 1;
    add_op("infix", ["*", "/", "%", "x"], $prec);
    $prec = $prec - 1;
    add_op("infix", ["+", "-"], $prec);
    add_op("infix", ["."], $prec, {"assoc" => "list", });
    $prec = $prec - 1;
    add_op("infix", ["<<", ">>"], $prec);
    $prec = $prec - 1;
    add_op("prefix", ["-r", "-w", "-x", "-o", "-R", "-W", "-X", "-O", "-e", "-z", "-s", "-f", "-d", "-l", "-p", "-S", "-b", "-c", "-t", "-u", "-g", "-k", "-T", "-B", "-M", "-A", "-C"], $prec);
    $prec = $prec - 1;
    add_op("infix", ["lt", "le", "gt", "ge", "<=", ">=", "<", ">"], $prec, {"assoc" => "chain", });
    $prec = $prec - 1;
    add_op("infix", ["<=>", "cmp", "==", "!=", "ne", "eq"], $prec, {"assoc" => "chain", });
    $prec = $prec - 1;
    add_op("infix", ["&"], $prec);
    $prec = $prec - 1;
    add_op("infix", ["|", "^"], $prec);
    $prec = $prec - 1;
    add_op("infix", ["..", "..."], $prec);
    add_op("infix", ["~~"], $prec, {"assoc" => "chain", });
    $prec = $prec - 1;
    add_op("infix", ["&&"], $prec, {"assoc" => "right", });
    $prec = $prec - 1;
    add_op("infix", ["||"], $prec, {"assoc" => "right", });
    add_op("infix", ["//"], $prec);
    $prec = $prec - 1;
    add_op("ternary", ["? :"], $prec, {"assoc" => "right", });
    $prec = $prec - 1;
    add_op("infix", ["=", "**=", "+=", "-=", "*=", "/=", "x=", "|=", "&=", ".=", "<<=", ">>=", "%=", "||=", "&&=", "^=", "//="], $prec, {"assoc" => "right", });
    $prec = $prec - 1;
    add_op("infix", ["=>"], $prec, {"assoc" => "right", });
    $prec = $prec - 1;
    add_op("list", [","], $prec, {"assoc" => "list", });
    $prec = $prec - 1;
    add_op("prefix", ["not"], $prec);
    $prec = $prec - 1;
    add_op("infix", ["and"], $prec);
    $prec = $prec - 1;
    add_op("infix", ["or", "xor"], $prec);
    $prec = $prec - 1;
    add_op("infix", ["*start*"], $prec);
    sub Perlito5::Grammar::Precedence::get_token_precedence {
        my $token = $_[0];
        if ($token->[0] eq "prefix") {;
            return $PrefixPrecedence->{$token->[1]}
        }
        return $Precedence->{$token->[1]}
    }
    sub Perlito5::Grammar::Precedence::precedence_parse {
        my $self = shift;
        my $get_token = $self->{"get_token"};
        my $reduce = $self->{"reduce"};
        my $last_end_token = $End_token;
        my $last_end_token_chars = $End_token_chars;
        $End_token = $self->{"end_token"};
        $End_token_chars = $self->{"end_token_chars"};
        my $op_stack = [];
        my $num_stack = [];
        my $last = ["op", "*start*"];
        my $last_is_term = 0;
        my $token = $get_token->($last_is_term);
        if ($token->[0] eq "space") {;
            $token = $get_token->($last_is_term)
        }
        while ((defined($token)) && ($token->[0] ne "end")) {
            my $token_is_term = is_term($token);
            if (($token->[1] eq ",") && (($last->[1] eq "*start*") || ($last->[1] eq ","))) {;
                push(@{$num_stack}, ["term", undef])
            }
            if ($Operator->{"prefix"}->{$token->[1]} && (($last->[1] eq "*start*") || !$last_is_term)) {
                $token->[0] = "prefix";
                unshift(@{$op_stack}, $token)
            }
            elsif ($Operator->{"postfix"}->{$token->[1]} && $last_is_term) {
                my $pr = $Precedence->{$token->[1]};
                while (scalar(@{$op_stack}) && ($pr <= get_token_precedence($op_stack->[0]))) {;
                    $reduce->($op_stack, $num_stack)
                }
                if ($token->[0] ne "postfix_or_term") {;
                    $token->[0] = "postfix"
                }
                unshift(@{$op_stack}, $token);
                $token_is_term = 1
            }
            elsif ($token_is_term) {
                if ($last_is_term) {;
                    Perlito5::Compiler::error("Value tokens must be separated by an operator (did you forget a comma?)")
                }
                $token->[0] = "term";
                push(@{$num_stack}, $token)
            }
            elsif ($Precedence->{$token->[1]}) {
                my $pr = $Precedence->{$token->[1]};
                if ($Assoc->{"right"}->{$token->[1]}) {;
                    while (scalar(@{$op_stack}) && ($pr < get_token_precedence($op_stack->[0]))) {;
                        $reduce->($op_stack, $num_stack)
                    }
                }
                else {;
                    while (scalar(@{$op_stack}) && ($pr <= get_token_precedence($op_stack->[0]))) {;
                        $reduce->($op_stack, $num_stack)
                    }
                }
                if ($Operator->{"ternary"}->{$token->[1]}) {;
                    $token->[0] = "ternary"
                }
                else {;
                    $token->[0] = "infix"
                }
                unshift(@{$op_stack}, $token)
            }
            else {;
                Perlito5::Compiler::error("Unknown token: '", $token->[1], "'")
            }
            $last = $token;
            $last_is_term = $token_is_term;
            $token = $get_token->($last_is_term);
            if ($token->[0] eq "space") {;
                $token = $get_token->($last_is_term)
            }
        }
        if (defined($token) && ($token->[0] ne "end")) {;
            Perlito5::Compiler::error("Unexpected end token: ", $token)
        }
        while (scalar(@{$op_stack})) {;
            $reduce->($op_stack, $num_stack)
        }
        $End_token = $last_end_token;
        $End_token_chars = $last_end_token_chars;
        return $num_stack
    }
    1
}
{
    package main;
    package Perlito5::Grammar::Bareword;
    sub Perlito5::Grammar::Bareword::the_object {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((do {
                    my $tmp = $MATCH;
                    $MATCH = {"from", $tmp->{"to"}, "to", $tmp->{"to"}};
                    my $res = (("\$" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1));
                    $MATCH = $tmp;
                    $res ? 1 : 0
                }) && (do {
                    my $m2 = Perlito5::Grammar::Sigil::term_sigil($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Sigil::term_sigil"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Sigil::term_sigil"})->[1];
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((("{" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $m2 = Perlito5::Grammar::Expression::curly_parse($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Expression::curly_parse"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (("}" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::curly_parse"});
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((do {
                    my $m2 = Perlito5::Grammar::Print::typeglob($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Print::typeglob"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Print::typeglob"});
                    1
                }))
            })
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Bareword::term_bareword {
        my $str = $_[0];
        my $pos = $_[1];
        my $p = $pos;
        my $m_namespace = Perlito5::Grammar::optional_namespace_before_ident($str, $p);
        my $namespace = Perlito5::Match::flat($m_namespace);
        $p = $m_namespace->{"to"};
        my $m_name = Perlito5::Grammar::ident($str, $p);
        if (!$m_name) {
            if ($namespace) {
                $m_namespace->{"capture"} = ["term", Perlito5::AST::Var::->new("sigil", "::", "name", '', "namespace", $namespace)];
                return $m_namespace
            }
            return
        }
        my $name = Perlito5::Match::flat($m_name);
        if ($name eq "__PACKAGE__" && $namespace eq '') {
            $m_name->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", $name, "namespace", '', "arguments", [], "bareword", 1)];
            return $m_name
        }
        $p = $m_name->{"to"};
        if ($str->[$p] eq ":" && $str->[$p + 1] eq ":") {
            $m_name->{"to"} = $p + 2;
            $m_name->{"capture"} = ["term", Perlito5::AST::Var::->new("sigil", "::", "name", '', "namespace", $namespace . "::" . $name)];
            return $m_name
        }
        my $full_name = $name;
        $namespace && ($full_name = $namespace . "::" . $name);
        my $m = Perlito5::Grammar::Space::ws($str, $p);
        if ($m) {;
            $p = $m->{"to"}
        }
        my $invocant;
        my $is_subroutine_name;
        my $effective_name = ($namespace || $Perlito5::PKG_NAME) . "::" . $name;
        {
            my $p = eval {;
                prototype($effective_name)
            };
            $p && ($Perlito5::PROTO->{$effective_name} = $p)
        }
        if (exists($Perlito5::Grammar::Print::Print{$name})) {;
            $invocant = undef
        }
        elsif (exists($Perlito5::PROTO->{$effective_name}) || ((!$namespace || $namespace eq "CORE") && exists($Perlito5::CORE_PROTO->{"CORE::" . $name}))) {
            $is_subroutine_name = 1;
            $invocant = Perlito5::Grammar::full_ident($str, $p);
            if ($invocant) {
                my $package = Perlito5::Match::flat($invocant);
                if ($package) {
                    $invocant->{"capture"} = Perlito5::AST::Var::->new("sigil", "::", "name", '', "namespace", $package);
                    if ($str->[$invocant->{"to"}] eq ":" && $str->[$invocant->{"to"} + 1] eq ":") {;
                        $invocant->{"to"} = $invocant->{"to"} + 2
                    }
                    elsif (!$Perlito5::PACKAGES->{$package}) {;
                        $invocant = undef
                    }
                }
            }
        }
        else {;
            $invocant = Perlito5::Grammar::Bareword::the_object($str, $p)
        }
        if ($invocant) {
            $p = $invocant->{"to"};
            my $arg = [];
            $m = Perlito5::Grammar::Space::ws($str, $p);
            $m && ($p = $m->{"to"});
            if ($str->[$p] eq "-" && $str->[$p + 1] eq ">") {}
            elsif ($str->[$p] eq "(") {
                my $m = Perlito5::Grammar::Expression::term_paren($str, $p);
                if ($m) {
                    $arg = $m->{"capture"}->[2];
                    $p = $m->{"to"};
                    $arg = Perlito5::Grammar::Expression::expand_list($arg)
                }
            }
            else {
                my $m = Perlito5::Grammar::Expression::list_parse($str, $p);
                if ($m->{"capture"} ne "*undef*") {
                    $arg = Perlito5::Grammar::Expression::expand_list($m->{"capture"});
                    $p = $m->{"to"}
                }
            }
            $m_name->{"capture"} = ["term", Perlito5::AST::Call::->new("method", $full_name, "invocant", Perlito5::Match::flat($invocant), "arguments", $arg)];
            $m_name->{"to"} = $p;
            return $m_name
        }
        if ($str->[$p] eq "=" && $str->[$p + 1] eq ">") {
            $m_name->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", $name, "namespace", $namespace, "arguments", [], "bareword", 1)];
            $m_name->{"to"} = $p;
            return $m_name
        }
        if ($str->[$p] eq "-" && $str->[$p + 1] eq ">") {
            if ($is_subroutine_name) {;
                $m_name->{"capture"} = ["term", Perlito5::AST::Apply::->new("arguments", [], "code", $name, "namespace", $namespace)]
            }
            else {;
                $m_name->{"capture"} = ["term", Perlito5::AST::Var::->new("name", '', "namespace", $full_name, "sigil", "::")]
            }
            $m_name->{"to"} = $p;
            return $m_name
        }
        my $sig = undef;
        {
            my $op = $str->[$p] . $str->[$p + 1];
            if ($op eq "!=" || $op eq "!~" || $op eq "=~") {;
                $sig = ''
            }
        }
        if (exists($Perlito5::PROTO->{$effective_name})) {;
            $sig = $Perlito5::PROTO->{$effective_name}
        }
        elsif ((!$namespace || $namespace eq "CORE") && exists($Perlito5::CORE_PROTO->{"CORE::" . $name})) {
            $effective_name = "CORE::" . $name;
            $sig = $Perlito5::CORE_PROTO->{$effective_name}
        }
        else {
            my $m = Perlito5::Grammar::Number::val_version($str, $pos);
            if ($m) {
                $m->{"capture"} = ["term", $m->{"capture"}];
                return $m
            }
        }
        my $has_paren = 0;
        if (defined($sig)) {
            my $arg_index = 1;
            my $optional = 0;
            my @args;
            my $sig_part = substr($sig, 0, 1);
            my $m;
            my $capture;
            if ($sig_part eq "&") {
                $m = Perlito5::Grammar::Space::ws($str, $p);
                $m && ($p = $m->{"to"});
                if ($str->[$p] ne "(") {
                    $sig = substr($sig, 1);
                    $m = Perlito5::Grammar::Bareword::prototype_is_ampersand($str, $p);
                    $m && ($capture = $m->{"capture"});
                    if (!$m) {;
                        Perlito5::Compiler::error("Type of arg " . $arg_index . " to " . $name . " must be block or sub {}")
                    }
                    $p = $m->{"to"};
                    push(@args, $capture)
                }
            }
            if (substr($sig, 0, 1) eq ";" && $str->[$p] eq "/" && $str->[$p + 1] eq "/") {
                $m_name->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", $name, "namespace", $namespace, "arguments", [], "bareword", 1)];
                $m_name->{"to"} = $p;
                return $m_name
            }
            if ($sig eq '') {
                if ($str->[$p] eq "(") {
                    $p++;
                    $has_paren = 1;
                    my $m = Perlito5::Grammar::Space::ws($str, $p);
                    if ($m) {;
                        $p = $m->{"to"}
                    }
                    if ($str->[$p] ne ")") {;
                        Perlito5::Compiler::error("syntax error near ", join('', @{$str}[$pos .. $pos + 10]))
                    }
                    $p++
                }
                if ($name eq "__FILE__") {;
                    $m_name->{"capture"} = ["term", Perlito5::AST::Buf::->new("buf", $Perlito5::FILE_NAME)]
                }
                elsif ($name eq "__LINE__") {;
                    $m_name->{"capture"} = ["term", Perlito5::AST::Int::->new("int", $Perlito5::LINE_NUMBER)]
                }
                else {;
                    $m_name->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", $name, "namespace", $namespace, "arguments", \@args, "bareword", ($has_paren == 0))]
                }
                $m_name->{"to"} = $p;
                return $m_name
            }
            if ($sig eq "_" || $sig eq "\$" || $sig eq "+" || $sig eq ";\$") {
                my $m;
                my $arg;
                if ($str->[$p] eq "(") {
                    $m = Perlito5::Grammar::Expression::term_paren($str, $p);
                    if (!$m) {;
                        return $m
                    }
                    $p = $m->{"to"};
                    $has_paren = 1;
                    $arg = $m->{"capture"}->[2];
                    $arg = Perlito5::Grammar::Expression::expand_list($arg);
                    my $v = shift(@{$arg});
                    @{$arg} && Perlito5::Compiler::error("Too many arguments for " . $name);
                    $arg = $v
                }
                else {
                    $m = Perlito5::Grammar::Expression::argument_parse($str, $p);
                    $arg = $m->{"capture"};
                    if ($arg eq "*undef*") {;
                        $arg = undef
                    }
                    elsif (ref($arg) eq "Perlito5::AST::Apply" && $arg->{"code"} eq "circumfix:<( )>") {
                        my $v = shift(@{$arg->{"arguments"}});
                        @{$arg->{"arguments"}} && Perlito5::Compiler::error("Too many arguments for " . $name);
                        $arg = $v
                    }
                }
                if (defined($arg)) {
                    push(@args, $arg);
                    $has_paren = 1
                }
                else {
                    $sig eq "\$" && Perlito5::Compiler::error("Not enough arguments for " . $name);
                    $sig eq "_" && push(@args, Perlito5::AST::Var::->new("namespace", '', "name", "_", "sigil", "\$"))
                }
                my $ast = Perlito5::AST::Apply::->new("code", $name, "namespace", $namespace, "arguments", \@args, "bareword", ($has_paren == 0));
                if ($name eq "eval" && !$namespace) {
                    $ast->{"_scope"} = Perlito5::Grammar::Scope::get_snapshot($Perlito5::CLOSURE_SCOPE);
                    $ast->{"_scalar_hints"} = ${^H};
                    $ast->{"_hash_hints"} = {%{^H}, }
                }
                $m->{"capture"} = ["term", $ast];
                return $m
            }
            if ($sig eq ";\@" || $sig eq "\@") {
                if ($str->[$p] eq "(") {
                    $m = Perlito5::Grammar::Expression::term_paren($str, $p);
                    $has_paren = 1;
                    my $arg = $m->{"capture"}->[2];
                    $arg = Perlito5::Grammar::Expression::expand_list($arg);
                    push(@args, @{$arg})
                }
                else {
                    $m = Perlito5::Grammar::Expression::list_parse($str, $p);
                    my $arg = $m->{"capture"};
                    if ($arg ne "*undef*") {
                        $arg = Perlito5::Grammar::Expression::expand_list($arg);
                        push(@args, @{$arg})
                    }
                }
                my $ast = Perlito5::AST::Apply::->new("code", $name, "namespace", $namespace, "arguments", \@args, "bareword", ($has_paren == 0));
                $m->{"capture"} = ["term", $ast];
                return $m
            }
            if ($sig eq "*") {}
        }
        if ($str->[$p] eq "(") {
            $m = Perlito5::Grammar::Expression::term_paren($str, $p);
            if (!$m) {;
                return $m
            }
            my $arg = $m->{"capture"}->[2];
            $arg = Perlito5::Grammar::Expression::expand_list($arg);
            if ($namespace eq '' || $namespace eq "CORE") {
                if ($name eq "local" || $name eq "my" || $name eq "state" || $name eq "our") {
                    my $declarator = $name;
                    for my $var (@{$arg}) {
                        if (ref($var) eq "Perlito5::AST::Apply" && $var->{"code"} eq "undef") {}
                        else {
                            my $decl = Perlito5::AST::Decl::->new("decl", $declarator, "type", '', "var", $var, "attributes", []);
                            $var->{"_decl"} = $name;
                            $var->{"_id"} = $Perlito5::ID++;
                            $declarator eq "our" && ($var->{"_namespace"} = $Perlito5::PKG_NAME);
                            $declarator eq "local" && !$var->{"namespace"} && !$var->{"_namespace"} && ($var->{"_namespace"} = $Perlito5::PKG_NAME)
                        }
                    }
                }
                if ($name eq "print" || $name eq "say") {;
                    if (@{$arg} == 0) {;
                        push(@{$arg}, Perlito5::AST::Var::->new("namespace", '', "name", "_", "sigil", "\$"))
                    }
                }
                if ($name eq "split") {
                    if (@{$arg} == 0) {;
                        push(@{$arg}, Perlito5::AST::Buf::->new("buf", " "))
                    }
                    if (@{$arg} == 1) {;
                        push(@{$arg}, Perlito5::AST::Var::->new("namespace", '', "name", "_", "sigil", "\$"))
                    }
                }
            }
            $m->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", $name, "namespace", $namespace, "arguments", $arg, "proto", $sig)];
            return $m
        }
        my $m_list = Perlito5::Grammar::Expression::list_parse($str, $p);
        my $list = $m_list->{"capture"};
        if ($list ne "*undef*") {
            $m_name->{"capture"} = ["postfix_or_term", "funcall", $namespace, $name, $list];
            $m_name->{"to"} = $m_list->{"to"};
            return $m_name
        }
        if ($namespace eq '' || $namespace eq "CORE") {
            if ($name eq "print" || $name eq "say") {
                $m_name->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", $name, "namespace", $namespace, "arguments", [Perlito5::AST::Var::->new("namespace", '', "name", "_", "sigil", "\$")])];
                return $m_name
            }
            if ($name eq "split" && ($namespace eq '' || $namespace eq "CORE")) {
                $m_name->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", $name, "namespace", $namespace, "arguments", [Perlito5::AST::Buf::->new("buf", " "), Perlito5::AST::Var::->new("namespace", '', "name", "_", "sigil", "\$")])];
                return $m_name
            }
        }
        if (${^H} & $Perlito5::STRICT_SUBS) {
            my $m = Perlito5::Grammar::Space::opt_ws($str, $p);
            my $p = $m->{"to"};
            if ($str->[$p] eq ":") {}
            elsif (!(exists($Perlito5::PROTO->{$effective_name}) || ((!$namespace || $namespace eq "CORE") && exists($Perlito5::CORE_PROTO->{"CORE::" . $name})))) {}
        }
        $m_name->{"capture"} = ["postfix_or_term", "funcall_no_params", $namespace, $name];
        return $m_name
    }
    sub Perlito5::Grammar::Bareword::prototype_is_ampersand {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((("s" eq $str->[$MATCH->{"to"} + 0]) && ("u" eq $str->[$MATCH->{"to"} + 1]) && ("b" eq $str->[$MATCH->{"to"} + 2]) && ($MATCH->{"to"} += 3)) && (do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $m2 = Perlito5::Grammar::Block::anon_sub_def($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Block::anon_sub_def"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Block::anon_sub_def"});
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((do {
                    my $m2 = Perlito5::Grammar::block($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::block"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{"capture"} = Perlito5::AST::Sub::->new("attributes", [], "block", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::block"}), "name", undef, "namespace", undef, "sig", undef);
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((do {
                    my $tmp = $MATCH;
                    $MATCH = {"from", $tmp->{"to"}, "to", $tmp->{"to"}};
                    my $res = ((("\\" eq $str->[$MATCH->{"to"} + 0]) && ("\\" eq $str->[$MATCH->{"to"} + 1]) && ($MATCH->{"to"} += 2)) && (do {
                        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                        if ($m2) {
                            $MATCH->{"to"} = $m2->{"to"};
                            1
                        }
                        else {;
                            0
                        }
                    }) && (("&" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)));
                    $MATCH = $tmp;
                    $res ? 1 : 0
                }) && (do {
                    my $m2 = Perlito5::Grammar::Expression::argument_parse($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Expression::argument_parse"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::argument_parse"});
                    1
                }))
            })
        }));
        $tmp ? $MATCH : undef
    }
    1
}
{
    package main;
    package Perlito5::Grammar::Attribute;
    sub Perlito5::Grammar::Attribute::opt_attribute {
        my $str = $_[0];
        my $pos = $_[1];
        my @attributes;
        my $ws = Perlito5::Grammar::Space::opt_ws($str, $pos);
        if ($str->[$ws->{"to"}] ne ":") {;
            return {"to", $pos, "capture", []}
        }
        $ws = Perlito5::Grammar::Space::opt_ws($str, $ws->{"to"} + 1);
        my $p = $ws->{"to"};
        my $m = Perlito5::Grammar::ident($str, $p);
        !$m && Perlito5::Compiler::error("syntax error");
        my $to;
        while (1) {
            my $attr = [Perlito5::Match::flat($m), undef];
            $to = $m->{"to"};
            my $delimiter = $str->[$to];
            if ($delimiter eq "(") {
                my $params = Perlito5::Grammar::String::string_interpolation_parse($str, $m->{"to"} + 1, "(", ")", 0);
                !$params && Perlito5::Compiler::error("syntax error");
                $attr->[1] = Perlito5::Match::flat($params)->{"buf"};
                $to = $params->{"to"}
            }
            push(@attributes, $attr);
            $ws = Perlito5::Grammar::Space::opt_ws($str, $to);
            if ($str->[$ws->{"to"}] eq ":") {;
                $ws = Perlito5::Grammar::Space::opt_ws($str, $ws->{"to"} + 1)
            }
            $p = $ws->{"to"};
            $m = Perlito5::Grammar::ident($str, $p);
            !$m && return {"to", $to, "capture", \@attributes}
        }
    }
    1
}
{
    package main;
    package Perlito5::Dumper;
    sub Perlito5::Dumper::ast_dumper {
        my $seen = {};
        my $level = '';
        my $pos = "[TODO - recursive structure in AST is not supported]";
        return _dumper($_[0], $level, $seen, $pos)
    }
    sub Perlito5::Dumper::Dumper {
        my $seen = {};
        my $level = "    ";
        my @out;
        for my $i (0 .. $#_) {
            my $pos = "\$VAR" . ($i + 1);
            push(@out, $pos . " = " . _dumper($_[$i], $level, $seen, $pos) . ";
")
        }
        return join('', @out)
    }
    sub Perlito5::Dumper::_dumper {
        (my($obj), my($tab), my($seen), my($pos)) = @_;
        !defined($obj) && return "undef";
        my $ref = ref($obj);
        !$ref && return escape_string($obj);
        my $as_string = $obj;
        $seen->{$as_string} && return $seen->{$as_string};
        $seen->{$as_string} = $pos;
        my $tab1 = $tab . "    ";
        if ($ref eq "ARRAY") {
            @{$obj} || return "[]";
            my @out;
            for my $i (0 .. $#{$obj}) {
                my $here = $pos . "->[" . $i . "]";
                push(@out, $tab1, _dumper($obj->[$i], $tab1, $seen, $here), ",
")
            }
            return join('', "[
", @out, $tab, "]")
        }
        elsif ($ref eq "HASH") {
            keys(%{$obj}) || return "{}";
            my @out;
            for my $i (sort {;
                $a cmp $b
            } keys(%{$obj})) {
                my $here = $pos . "->{" . $i . "}";
                push(@out, $tab1, "'" . $i . "' => ", _dumper($obj->{$i}, $tab1, $seen, $here), ",
")
            }
            return join('', "{
", @out, $tab, "}")
        }
        elsif ($ref eq "SCALAR" || $ref eq "REF") {;
            return "\\" . _dumper(${$obj}, $tab1, $seen, $pos)
        }
        elsif ($ref eq "CODE") {;
            return "sub { \"DUMMY\" }"
        }
        my @out;
        my $res;
        local ${"\@"};
        $res = eval {
            for my $i (0 .. $#{$obj}) {
                my $here = $pos . "->[" . $i . "]";
                push(@out, $tab1, _dumper($obj->[$i], $tab1, $seen, $here), ",
")
            }
            join('', "bless([
", @out, $tab, "], '" . $ref . "')")
        };
        $res && return $res;
        for my $i (sort {;
            $a cmp $b
        } keys(%{$obj})) {
            my $here = $pos . "->{" . $i . "}";
            push(@out, $tab1, "'" . $i . "' => ", _dumper($obj->{$i}, $tab1, $seen, $here), ",
")
        }
        return join('', "bless({
", @out, $tab, "}, '" . $ref . "')")
    }
    our %safe_char = (" ", 1, "!", 1, "\"", 1, "'", 1, "#", 1, "\$", 1, "%", 1, "&", 1, "(", 1, ")", 1, "*", 1, "+", 1, ",", 1, "-", 1, ".", 1, "/", 1, ":", 1, ";", 1, "<", 1, "=", 1, ">", 1, "?", 1, "\@", 1, "[", 1, "]", 1, "^", 1, "_", 1, "`", 1, "{", 1, "|", 1, "}", 1, "~", 1, "
", 1);
    sub Perlito5::Dumper::escape_string {
        my $s = shift;
        my @out;
        my $tmp = '';
        $s eq '' && return "''";
        (0 + $s) eq $s && $s =~ m/[0-9]/ && return 0 + $s;
        for my $c (split('', $s)) {
            if ($c eq "\\" || $c eq "\$" || $c eq "\@" || $c eq "\"") {;
                $tmp = $tmp . "\\" . $c
            }
            elsif (($c ge "a" && $c le "z") || ($c ge "A" && $c le "Z") || ($c ge 0 && $c le 9) || exists($safe_char{$c})) {;
                $tmp = $tmp . $c
            }
            else {;
                $tmp = $tmp . "\\x{" . sprintf("%x", ord($c)) . "}"
            }
        }
        $tmp ne '' && push(@out, "\"" . $tmp . "\"");
        return join(" . ", @out)
    }
    sub Perlito5::Dumper::_identity {;
        $_[0] eq $_[1]
    }
    1
}
{
    package main;
    package Perlito5::TreeGrammar;
    my %dispatch = ("Ref", sub {;
        Ref(@_)
    }, "Lookup", sub {;
        Lookup(@_)
    }, "Index", sub {;
        Index(@_)
    }, "Value", sub {;
        Value(@_)
    }, "And", sub {;
        And(@_)
    }, "Or", sub {;
        Or(@_)
    }, "Not", sub {;
        Not(@_)
    }, "Action", sub {;
        Action(@_)
    }, "Progn", sub {;
        Progn(@_)
    }, "Star", sub {;
        Star(@_)
    });
    sub Perlito5::TreeGrammar::render {
        (my($rule), my($node)) = @_;
        return $dispatch{$rule->[0]}->($rule, $node)
    }
    sub Perlito5::TreeGrammar::scan {
        (my($rule), my($node)) = @_;
        $rule && render($rule, $node);
        if (ref($node) eq "ARRAY") {;
            scan($rule, $_)
                for @{$node}
        }
        elsif (ref($node)) {;
            scan($rule, $_)
                for values(%{$node})
        }
        return
    }
    sub Perlito5::TreeGrammar::Action {
        (my($rule), my($node)) = @_;
        $rule->[1]->($node);
        return 1
    }
    sub Perlito5::TreeGrammar::Not {
        (my($rule), my($node)) = @_;
        my $result;
        render($rule->[1], $node) && return;
        return 1
    }
    sub Perlito5::TreeGrammar::Star {
        (my($rule), my($node)) = @_;
        my $result;
        while (1) {;
            render($rule->[1], $node) || return
        }
    }
    sub Perlito5::TreeGrammar::Progn {
        (my($rule), my($node)) = @_;
        my $result;
        for $_ (@{$rule}[1 .. $#{$rule}]) {;
            $result = render($_, $node)
        }
        return $result
    }
    sub Perlito5::TreeGrammar::And {
        (my($rule), my($node)) = @_;
        my $result;
        for $_ (@{$rule}[1 .. $#{$rule}]) {;
            $result = render($_, $node) or return
        }
        return $result
    }
    sub Perlito5::TreeGrammar::Or {
        (my($rule), my($node)) = @_;
        my $result;
        for $_ (@{$rule}[1 .. $#{$rule}]) {;
            $result = render($_, $node) and return $result
        }
        return
    }
    sub Perlito5::TreeGrammar::Ref {
        (my($rule), my($node)) = @_;
        ref($node) ne $rule->[1] && return;
        !$rule->[2] && return 1;
        return render($rule->[2], $node)
    }
    sub Perlito5::TreeGrammar::Lookup {
        (my($rule), my($node)) = @_;
        (!ref($node) || ref($node) eq "ARRAY" || !exists($node->{$rule->[1]})) && return;
        !$rule->[2] && return 1;
        return render($rule->[2], $node->{$rule->[1]})
    }
    sub Perlito5::TreeGrammar::Index {
        (my($rule), my($node)) = @_;
        (!ref($node) || ref($node) ne "ARRAY" || !exists($node->[$rule->[1]])) && return;
        !$rule->[2] && return 1;
        return render($rule->[2], $node->[$rule->[1]])
    }
    sub Perlito5::TreeGrammar::Value {
        (my($rule), my($node)) = @_;
        (ref($node) || $node ne $rule->[1]) && return;
        !$rule->[2] && return 1;
        return render($rule->[2], $node)
    }
    1
}
{
    package main;
    package Perlito5::Macro;
    {
        package Perlito5::AST::Apply;
        my %op = ("infix:<+=>", "infix:<+>", "infix:<-=>", "infix:<->", "infix:<*=>", "infix:<*>", "infix:</=>", "infix:</>", "infix:<||=>", "infix:<||>", "infix:<&&=>", "infix:<&&>", "infix:<|=>", "infix:<|>", "infix:<&=>", "infix:<&>", "infix:<//=>", "infix:<//>", "infix:<.=>", "list:<.>", "infix:<x=>", "infix:<x>");
        sub Perlito5::AST::Apply::op_assign {
            my $self = $_[0];
            my $code = $self->{"code"};
            ref($code) && return 0;
            if (exists($op{$code})) {;
                return Perlito5::AST::Apply::->new("code", "infix:<=>", "arguments", [$self->{"arguments"}->[0], Perlito5::AST::Apply::->new("code", $op{$code}, "arguments", $self->{"arguments"})])
            }
            return 0
        }
        my %op_auto = ("prefix:<++>", 1, "prefix:<-->", 1, "postfix:<++>", 1, "postfix:<-->", 1);
        sub Perlito5::AST::Apply::op_auto {
            my $self = $_[0];
            my $code = $self->{"code"};
            ref($code) && return 0;
            if (exists($op_auto{$code})) {
                my $paren = $self->{"arguments"}->[0];
                if ($paren->{"code"} eq "circumfix:<( )>") {
                    my $arg = $paren->{"arguments"}->[-1];
                    if ($arg->{"code"} eq "infix:<=>") {
                        my $var = $arg->{"arguments"}->[0];
                        return Perlito5::AST::Apply::->new("code", "do", "arguments", [Perlito5::AST::Block::->new("stmts", [$paren, Perlito5::AST::Apply::->new("code", $code, "arguments", [$var])])])
                    }
                }
            }
            return 0
        }
    }
    {
        package Perlito5::AST::Sub;
        sub Perlito5::AST::Sub::maybe_rewrite_statevars {
            (my($self)) = @_;
            my $block = $self->{"block"} || return 0;
            my @init_flags;
            my @vars;
            my @base_rules = (["Lookup", "block"], ["Lookup", "stmts"]);
            for my $idx (0 .. $#{$block->{"stmts"}}) {
                my $stmt = $block->{"stmts"}->[$idx];
                (my($node), my(@rules)) = find_state_expr($stmt, @base_rules, ["Index", $idx]);
                if (defined($node)) {
                    (my($transformed), my($var), my($flagvar)) = rewrite_state_expr($node);
                    push(@vars, $var, $flagvar);
                    my $last_rule = pop(@rules);
                    push(@rules, ["Action", sub {
                        (my($parent)) = @_;
                        if ($last_rule->[0] eq "Lookup") {;
                            $parent->{$last_rule->[1]} = $transformed
                        }
                        else {;
                            $parent->[$last_rule->[1]] = $transformed
                        }
                    }]);
                    my $rule = nest(\@rules);
                    Perlito5::TreeGrammar::render($rule, $self)
                }
            }
            if (scalar(@vars)) {;
                return Perlito5::AST::Apply::->new("code", "do", "namespace", $block->{"namespace"}, "arguments", [Perlito5::AST::Block::->new("sig", undef, "stmts", [myvar_declaration_stmt(@vars), $self])])
            }
            return 0
        }
        sub Perlito5::AST::Sub::myvar_declaration_stmt {
            (grep {;
                ($_->{"decl"} // "my") ne "my"
            } @_) && die("Can only handle `my` variables");
            return Perlito5::AST::Apply::->new("code", "my", "arguments", [@_])
        }
        sub Perlito5::AST::Sub::rewrite_state_expr {
            (my($target)) = @_;
            (my($decl), my($rhs));
            if (ref($target) eq "Perlito5::AST::Apply") {
                $decl = $target->{"arguments"}->[0];
                $rhs = $target->{"arguments"}->[1]
            }
            elsif (ref($target) eq "Perlito5::AST::Decl") {;
                $decl = $target
            }
            else {;
                die("Invalid node type for state variable transformation: " . (ref($target)))
            }
            my $state_var = $decl->{"var"};
            my $var = Perlito5::AST::Var::->new("namespace", $state_var->{"namespace"}, "sigil", $state_var->{"sigil"}, "name", $state_var->{"name"}, "_id", $state_var->{"_id"}, "_decl", "my");
            my $label = Perlito5::get_label();
            my $flagvar = Perlito5::AST::Var::->new("name", $var->{"name"} . "_inited_" . $label, "sigil", "\$", "namespace", '', "_id", $Perlito5::ID++, "_decl", "my");
            my $init_block = Perlito5::AST::Apply::->new("code", "do", "namespace", $decl->{"namespace"}, "arguments", [Perlito5::AST::Block::->new("sig", undef, "stmts", [Perlito5::AST::Apply::->new("code", "infix:<=>", "namespace", $decl->{"namespace"}, "arguments", [$flagvar, Perlito5::AST::Int::->new("int", 1)]), ((ref($target) eq "Perlito5::AST::Apply") ? Perlito5::AST::Apply::->new("code", "infix:<=>", "namespace", $decl->{"namespace"}, "arguments", [$var, $rhs]) : $var)])]);
            my $transformed = Perlito5::AST::Apply::->new("code", "ternary:<? :>", "namespace", $decl->{"namespace"}, "arguments", [$flagvar, $var, $init_block]);
            return ($transformed, $var, $flagvar)
        }
        sub Perlito5::AST::Sub::nest {
            (my($xs)) = @_;
            if (scalar(@{$xs} == 0)) {;
                return
            }
            return [flatten($xs->[0]), nest([@{$xs}[1 .. $#{$xs}]])]
        }
        sub Perlito5::AST::Sub::flatten {
            (my($arg)) = @_;
            if (ref($arg) eq "ARRAY") {;
                return (@{$arg})
            }
            return $arg
        }
        sub Perlito5::AST::Sub::find_state_expr {
            (my($node), my(@rules)) = @_;
            if (is_node_state_decl($node) || is_node_state_assignment($node)) {;
                return ($node, @rules)
            }
            for my $branch ("stmts", "arguments") {;
                if (exists($node->{$branch}) && ref($node->{$branch}) eq "ARRAY") {;
                    for $_ (0 .. $#{$node->{$branch}}) {
                        (my($retnode), my(@retrules)) = find_state_expr($node->{$branch}->[$_], @rules, ["Lookup", $branch], ["Index", $_]);
                        if ($retnode) {;
                            return ($retnode, @retrules)
                        }
                    }
                }
            }
            return undef
        }
        sub Perlito5::AST::Sub::is_node_state_assignment {
            (my($node)) = @_;
            (ref($node) eq "Perlito5::AST::Apply" && $node->{"code"} eq "infix:<=>" && is_node_state_decl($node->{"arguments"}->[0]))
        }
        sub Perlito5::AST::Sub::is_node_state_decl {
            (my($node)) = @_;
            (ref($node) eq "Perlito5::AST::Decl" && $node->{"decl"} eq "state")
        }
    }
    sub Perlito5::Macro::while_file {
        my $self = $_[0];
        ref($self) ne "Perlito5::AST::While" && return 0;
        my $cond = $self->{"cond"};
        if ($cond->isa("Perlito5::AST::Apply") && ($cond->{"code"} eq "readline")) {
            $self->{"cond"} = bless({"arguments", [bless({"arguments", [Perlito5::AST::Var::SCALAR_ARG(), $cond], "code", "infix:<=>", "namespace", ''}, "Perlito5::AST::Apply")], "bareword", '', "code", "defined", "namespace", ''}, "Perlito5::AST::Apply");
            return $self
        }
        return 0
    }
    sub Perlito5::Macro::insert_return_in_block {
        (my($self)) = @_;
        if (@{$self->{"stmts"}} == 0) {;
            push(@{$self->{"stmts"}}, Perlito5::AST::Apply::->new("arguments", [], "code", "return", "namespace", '', "_return_from_block", 1))
        }
        else {
            my $last_statement = pop(@{$self->{"stmts"}});
            push(@{$self->{"stmts"}}, insert_return($last_statement))
        }
        return $self
    }
    sub Perlito5::Macro::insert_return_in_if {
        my $self = $_[0];
        $self->{"body"} = insert_return_in_block($self->{"body"} || Perlito5::AST::Block::->new("stmts", []));
        $self->{"otherwise"} = insert_return_in_block($self->{"otherwise"} || Perlito5::AST::Block::->new("stmts", []));
        return $self
    }
    sub Perlito5::Macro::insert_return {
        my $self = $_[0];
        if ($self->isa("Perlito5::AST::If")) {;
            return insert_return_in_if($self)
        }
        if ($self->isa("Perlito5::AST::Block")) {;
            return insert_return_in_block($self)
        }
        if ($self->isa("Perlito5::AST::For")) {;
            return ($self, Perlito5::AST::Apply::->new("arguments", [Perlito5::AST::Buf::->new("buf", '')], "code", "return", "namespace", '', "_return_from_block", 1))
        }
        if ($self->isa("Perlito5::AST::While")) {
            if ($self->{"cond"}->isa("Perlito5::AST::Int") && $self->{"cond"}->{"int"}) {;
                return $self
            }
            else {;
                return ($self, Perlito5::AST::Apply::->new("arguments", [Perlito5::AST::Int::->new("int", 0)], "code", "return", "namespace", '', "_return_from_block", 1))
            }
        }
        if ($self->isa("Perlito5::AST::Sub")) {
            if (!$self->{"name"}) {;
                return Perlito5::AST::Apply::->new("arguments", [$self], "code", "return", "namespace", '', "_return_from_block", 1)
            }
            else {;
                return ($self, Perlito5::AST::Apply::->new("arguments", [Perlito5::AST::Int::->new("int", 0)], "code", "return", "namespace", '', "_return_from_block", 1))
            }
        }
        if ($self->isa("Perlito5::AST::Int") || $self->isa("Perlito5::AST::Num") || $self->isa("Perlito5::AST::Buf") || $self->isa("Perlito5::AST::Index") || $self->isa("Perlito5::AST::Lookup") || $self->isa("Perlito5::AST::Call") || $self->isa("Perlito5::AST::Var") || $self->isa("Perlito5::AST::Decl")) {;
            return Perlito5::AST::Apply::->new("arguments", [$self], "code", "return", "namespace", '', "_return_from_block", 1)
        }
        if ($self->isa("Perlito5::AST::Apply")) {
            if ($self->code() eq "return") {;
                return $self
            }
            return Perlito5::AST::Apply::->new("arguments", [$self], "code", "return", "namespace", '', "_return_from_block", 1)
        }
        return $self
    }
    sub Perlito5::Macro::split_code_too_large {
        my @stmts = @_;
        while (@stmts > 20) {
            my @do = splice(@stmts, -15, 15);
            push(@stmts, Perlito5::AST::Apply::->new("arguments", [Perlito5::AST::Block::->new("stmts", \@do)], "code", "do"))
        }
        return @stmts
    }
    sub Perlito5::Macro::preprocess_regex {
        my $regex = shift;
        if ($regex->isa("Perlito5::AST::Apply") && $regex->{"code"} eq "circumfix:<( )>") {;
            ($regex) = @{$regex->{"arguments"}}
        }
        if ($regex->isa("Perlito5::AST::Buf") || $regex->isa("Perlito5::AST::Var") || ($regex->isa("Perlito5::AST::Apply") && $regex->{"code"} eq "list:<.>")) {;
            $regex = Perlito5::AST::Apply::->new("code", "p5:m", "arguments", [$regex, Perlito5::AST::Buf::->new("buf", '')])
        }
        return $regex
    }
    1
}
{
    package main;
    package Perlito5::Grammar::Statement;
    my @Statement_chars;
    my %Statement;
    sub Perlito5::Grammar::Statement::add_statement {
        my $name = shift;
        my $param = shift;
        $Statement{$name} = $param;
        unshift(@Statement_chars, scalar(@Statement_chars) + 1)
            while @Statement_chars < length($name)
    }
    sub Perlito5::Grammar::Statement::stmt_yadayada {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((("." eq $str->[$MATCH->{"to"} + 0]) && ("." eq $str->[$MATCH->{"to"} + 1]) && ("." eq $str->[$MATCH->{"to"} + 2]) && ($MATCH->{"to"} += 3)) && (do {
            $MATCH->{"capture"} = Perlito5::AST::Apply::->new("code", "die", "namespace", '', "arguments", [Perlito5::AST::Buf::->new("buf", "Unimplemented")]);
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Statement::stmt_format {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((("f" eq $str->[$MATCH->{"to"} + 0]) && ("o" eq $str->[$MATCH->{"to"} + 1]) && ("r" eq $str->[$MATCH->{"to"} + 2]) && ("m" eq $str->[$MATCH->{"to"} + 3]) && ("a" eq $str->[$MATCH->{"to"} + 4]) && ("t" eq $str->[$MATCH->{"to"} + 5]) && ($MATCH->{"to"} += 6)) && (do {
            my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                (do {
                    my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::full_ident"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                })
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (do {
                    $MATCH->{"Perlito5::Grammar::full_ident"} = "STDOUT";
                    1
                })
            })
        }) && (do {
            my $placeholder = Perlito5::AST::Apply::->new("code", "list:<.>", "namespace", '', "arguments", [Perlito5::AST::Apply::->new("code", "list:<.>", "namespace", '', "arguments", [])]);
            push(@Perlito5::Grammar::String::Here_doc, ["single_quote", $placeholder->{"arguments"}->[0]->{"arguments"}, "."]);
            $MATCH->{"capture"} = Perlito5::AST::Apply::->new("code", "p5:format", "namespace", '', "arguments", [Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::full_ident"}), $placeholder]);
            1
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (("=" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Statement::stmt_package {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((("p" eq $str->[$MATCH->{"to"} + 0]) && ("a" eq $str->[$MATCH->{"to"} + 1]) && ("c" eq $str->[$MATCH->{"to"} + 2]) && ("k" eq $str->[$MATCH->{"to"} + 3]) && ("a" eq $str->[$MATCH->{"to"} + 4]) && ("g" eq $str->[$MATCH->{"to"} + 5]) && ("e" eq $str->[$MATCH->{"to"} + 6]) && ($MATCH->{"to"} += 7)) && (do {
            my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::full_ident"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((do {
                    my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $m2 = Perlito5::Grammar::Use::version_string($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Use::version_string"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $version = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Use::version_string"});
                    $MATCH->{"_version"} = $version;
                    1
                }) && (do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                })
            })
        }) && (do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((do {
                    my $name = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::full_ident"});
                    $MATCH->{"_package"} = $Perlito5::PKG_NAME;
                    $Perlito5::PACKAGES->{$name} = 1;
                    $Perlito5::PKG_NAME = $name;
                    1
                }) && (do {
                    my $m2 = Perlito5::Grammar::block($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::block"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $namespace = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::full_ident"});
                    my @statements = @{$MATCH->{"Perlito5::Grammar::block"}->{"capture"}->{"stmts"}};
                    if (@statements == 1) {
                        my $stmt = $statements[0];
                        if ($stmt && ref($stmt) eq "Perlito5::AST::Apply" && ($stmt->{"code"} eq "infix:<=>>" || $stmt->{"code"} eq "list:<,>")) {;
                            push(@Perlito::ANNOTATION, [$namespace, Perlito5::AST::Apply::->new("arguments", [$stmt], "code", "circumfix:<{ }>")])
                        }
                    }
                    if ($MATCH->{"_version"}) {;
                        unshift(@statements, Perlito5::AST::Apply::->new("arguments", [Perlito5::AST::Var::->new("name", "VERSION", "namespace", $namespace, "sigil", "\$"), $MATCH->{"_version"}], "code", "infix:<=>"))
                    }
                    $MATCH->{"capture"} = Perlito5::AST::Block::->new("stmts", [Perlito5::AST::Apply::->new("code", "package", "arguments", [], "namespace", $namespace), @statements]);
                    $Perlito5::PKG_NAME = $MATCH->{"_package"};
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (do {
                    my $name = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::full_ident"});
                    $Perlito5::PACKAGES->{$name} = 1;
                    $Perlito5::PKG_NAME = $name;
                    $MATCH->{"capture"} = Perlito5::AST::Apply::->new("code", "package", "arguments", [], "namespace", $name);
                    1
                })
            })
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Statement::exp_stmt {
        my $str = $_[0];
        my $pos = $_[1];
        my $tok = join('', @{$str}[$pos .. $pos + 15]);
        for my $len (@Statement_chars) {
            my $term = substr($tok, 0, $len);
            if (exists($Statement{$term})) {
                my $m = $Statement{$term}->($_[0], $pos);
                $m && return $m
            }
        }
        return 0
    }
    my @Modifier_chars = (7, 6, 5, 4, 3, 2);
    my %Modifier = ("if", 1, "unless", 1, "when", 1, "for", 1, "foreach", 1, "while", 1, "until", 1, "given", 1);
    sub Perlito5::Grammar::Statement::statement_modifier {
        my $str = $_[0];
        my $pos = $_[1];
        my $tok = join('', @{$str}[$pos .. $pos + 15]);
        my $expression = $_[2];
        for my $len (@Modifier_chars) {
            my $term = substr($tok, 0, $len);
            if (exists($Modifier{$term})) {
                my $m = modifier($_[0], $pos + $len, $term, $expression);
                $m && return $m
            }
        }
        return 0
    }
    sub Perlito5::Grammar::Statement::modifier {
        my $str = $_[0];
        my $pos = $_[1];
        my $modifier = $_[2];
        my $expression = $_[3];
        my $modifier_exp = Perlito5::Grammar::Expression::exp_parse($str, $pos);
        if (!$modifier_exp) {;
            Perlito5::Compiler::error("Expected expression after '", Perlito5::Match::flat($modifier), "'")
        }
        if ($modifier eq "if") {;
            return {"str", $str, "from", $pos, "to", $modifier_exp->{"to"}, "capture", Perlito5::AST::Apply::->new("arguments", [Perlito5::Match::flat($modifier_exp), $expression], "code", "infix:<&&>", "namespace", '')}
        }
        if ($modifier eq "unless") {;
            return {"str", $str, "from", $pos, "to", $modifier_exp->{"to"}, "capture", Perlito5::AST::Apply::->new("arguments", [Perlito5::Match::flat($modifier_exp), $expression], "code", "infix:<||>", "namespace", '')}
        }
        if ($modifier eq "when") {;
            return {"str", $str, "from", $pos, "to", $modifier_exp->{"to"}, "capture", Perlito5::AST::When::->new("cond", Perlito5::Match::flat($modifier_exp), "body", $expression)}
        }
        if ($modifier eq "while") {
            my $stmt = Perlito5::AST::While::->new("cond", Perlito5::Match::flat($modifier_exp), "body", $expression);
            my $out = Perlito5::Macro::while_file($stmt);
            $out && ($stmt = $out);
            return {"str", $str, "from", $pos, "to", $modifier_exp->{"to"}, "capture", $stmt}
        }
        if ($modifier eq "until") {
            my $stmt = Perlito5::AST::While::->new("cond", Perlito5::AST::Apply::->new("arguments", [Perlito5::Match::flat($modifier_exp)], "code", "prefix:<!>", "namespace", ''), "body", $expression);
            return {"str", $str, "from", $pos, "to", $modifier_exp->{"to"}, "capture", $stmt}
        }
        if ($modifier eq "for" || $modifier eq "foreach") {;
            return {"str", $str, "from", $pos, "to", $modifier_exp->{"to"}, "capture", Perlito5::AST::For::->new("cond", Perlito5::Match::flat($modifier_exp), "body", $expression, "topic", Perlito5::AST::Var::SCALAR_ARG())}
        }
        Perlito5::Compiler::error("Unexpected statement modifier '" . $modifier . "'")
    }
    sub Perlito5::Grammar::Statement::statement_parse {
        my $m = statement_parse_inner(@_);
        !@Perlito5::SCOPE_STMT && return $m;
        Perlito5::Grammar::Scope::check_variable_declarations();
        return $m
    }
    sub Perlito5::Grammar::Statement::statement_parse_inner {
        my $str = $_[0];
        my $pos = $_[1];
        my $res = exp_stmt($str, $pos);
        if ($res) {
            if (ref($res->{"capture"}) eq "Perlito5::AST::Apply" && $res->{"capture"}->{"code"} eq "circumfix:<{ }>") {}
            else {;
                return $res
            }
        }
        $res = Perlito5::Grammar::Expression::exp_parse($str, $pos);
        if (!$res) {;
            return
        }
        if ($str->[$res->{"to"}] eq ":" && $res->{"capture"}->isa("Perlito5::AST::Apply") && $res->{"capture"}->{"bareword"}) {
            my $label = $res->{"capture"}->{"code"};
            my $ws = Perlito5::Grammar::Space::opt_ws($str, $res->{"to"} + 1);
            my $stmt = statement_parse($str, $ws->{"to"});
            if ($stmt) {
                $stmt->{"capture"}->{"label"} = $label;
                return $stmt
            }
            $res->{"to"} = $ws->{"to"};
            $res->{"capture"} = Perlito5::AST::Apply::->new("arguments", [], "code", "undef", "namespace", '', "label", $label);
            return $res
        }
        my $modifier = statement_modifier($str, $res->{"to"}, Perlito5::Match::flat($res));
        my $p = $modifier ? $modifier->{"to"} : $res->{"to"};
        my $terminator = $str->[$p];
        if ($terminator ne ";" && $terminator ne "}" && $terminator ne '') {
            my $type = "Number or Bareword";
            $terminator ge 0 && $terminator le 9 && ($type = "Number");
            ($terminator eq "\"" || $terminator eq "'") && ($type = "String");
            $terminator eq "\$" && ($type = "Scalar");
            $terminator eq "\@" && ($type = "Array");
            Perlito5::Compiler::error($type . " found where operator expected")
        }
        if (!$modifier) {;
            return $res
        }
        return $modifier
    }
    Perlito5::Grammar::Statement::add_statement("...", \&stmt_yadayada);
    Perlito5::Grammar::Statement::add_statement("package", \&stmt_package);
    Perlito5::Grammar::Statement::add_statement("format", \&stmt_format);
    1
}
{
    package main;
    package Perlito5::Grammar::Expression;
    sub Perlito5::Grammar::Expression::expand_list_fat_arrow {
        my $param_list = shift;
        if (ref($param_list) eq "Perlito5::AST::Apply" && $param_list->code() eq "infix:<=>>") {;
            return (Perlito5::AST::Lookup::->autoquote($param_list->{"arguments"}->[0]), expand_list_fat_arrow($param_list->{"arguments"}->[1]))
        }
        return $param_list
    }
    sub Perlito5::Grammar::Expression::expand_list {
        my $param_list = shift;
        if (ref($param_list) eq "Perlito5::AST::Apply" && $param_list->code() eq "list:<,>") {;
            return [map {;
                expand_list_fat_arrow($_)
            } grep {;
                defined($_)
            } @{$param_list->arguments()}]
        }
        if (ref($param_list) eq "Perlito5::AST::Apply" && $param_list->code() eq "infix:<=>>") {;
            return [expand_list_fat_arrow($param_list)]
        }
        elsif ($param_list eq "*undef*") {;
            return []
        }
        else {;
            return [$param_list]
        }
    }
    sub Perlito5::Grammar::Expression::block_or_hash {
        my $o = shift;
        if (defined($o->sig())) {;
            return $o
        }
        my $stmts = $o->stmts();
        if (!(defined($stmts)) || scalar(@{$stmts}) == 0) {;
            return Perlito5::AST::Apply::->new("code", "circumfix:<{ }>", "namespace", '', "arguments", [])
        }
        if (scalar(@{$stmts}) != 1) {;
            return $o
        }
        my $stmt = $stmts->[0];
        if (ref($stmt) eq "Perlito5::AST::Var") {;
            return Perlito5::AST::Apply::->new("code", "circumfix:<{ }>", "namespace", '', "arguments", [$stmt])
        }
        if (ref($stmt) ne "Perlito5::AST::Apply") {;
            return $o
        }
        if ($stmt->code() eq "infix:<=>>" || $stmt->code() eq "prefix:<%>" || $stmt->code() eq "prefix:<\@>") {;
            return Perlito5::AST::Apply::->new("code", "circumfix:<{ }>", "namespace", '', "arguments", [$stmt])
        }
        if ($stmt->code() ne "list:<,>") {}
        return Perlito5::AST::Apply::->new("code", "circumfix:<{ }>", "namespace", '', "arguments", expand_list($stmt))
    }
    sub Perlito5::Grammar::Expression::pop_term {
        my $num_stack = shift;
        my $v = pop(@{$num_stack});
        if (ref($v) eq "ARRAY") {
            ref($v->[1]) && return $v->[1];
            if ($v->[1] eq "methcall_no_params") {
                $v = Perlito5::AST::Call::->new("invocant", undef, "method", $v->[2], "arguments", []);
                return $v
            }
            if ($v->[1] eq "funcall_no_params") {
                $v = Perlito5::AST::Apply::->new("code", $v->[3], "namespace", $v->[2], "arguments", [], "bareword", 1);
                return $v
            }
            if ($v->[1] eq "methcall") {
                my $param_list = expand_list(($v->[3]));
                $v = Perlito5::AST::Call::->new("invocant", undef, "method", $v->[2], "arguments", $param_list);
                return $v
            }
            if ($v->[1] eq "funcall") {
                my $param_list = expand_list(($v->[4]));
                $v = Perlito5::AST::Apply::->new("code", $v->[3], "arguments", $param_list, "namespace", $v->[2]);
                return $v
            }
            if ($v->[1] eq "( )") {
                my $param_list = expand_list($v->[2]);
                $v = Perlito5::AST::Apply::->new("code", "circumfix:<( )>", "arguments", $param_list, "namespace", '');
                return $v
            }
            if ($v->[1] eq "[ ]") {
                my $param_list = expand_list($v->[2]);
                $v = Perlito5::AST::Apply::->new("code", "circumfix:<[ ]>", "arguments", $param_list, "namespace", '');
                return $v
            }
            if ($v->[1] eq "block") {
                $v = Perlito5::AST::Block::->new("stmts", $v->[2], "sig", $v->[3]);
                $v = block_or_hash($v);
                return $v
            }
            if ($v->[1] eq ".( )") {
                $v = Perlito5::AST::Call::->new("invocant", undef, "method", "postcircumfix:<( )>", "arguments", $v->[2]);
                return $v
            }
            if ($v->[1] eq ".[ ]") {
                $v = Perlito5::AST::Index::->new("obj", undef, "index_exp", $v->[2]);
                return $v
            }
            if ($v->[1] eq ".{ }") {
                $v = Perlito5::AST::Lookup::->new("obj", undef, "index_exp", $v->[2]);
                return $v
            }
            return $v->[1]
        }
        return $v
    }
    sub Perlito5::Grammar::Expression::reduce_postfix {
        my $op = shift;
        my $value = shift;
        my $v = $op;
        if ($v->[1] eq "methcall_no_params") {
            if ($v->[2] eq "\@*") {;
                return Perlito5::AST::Apply::->new("code", "prefix:<\@>", "arguments", [$value])
            }
            $v = Perlito5::AST::Call::->new("invocant", $value, "method", $v->[2], "arguments", [], (ref($v->[2]) ? () : ("_no_params", 1)));
            return $v
        }
        if ($v->[1] eq "funcall_no_params") {;
            Perlito5::Compiler::error("Bareword found where operator expected")
        }
        if ($v->[1] eq "methcall") {
            my $param_list = expand_list($v->[3]);
            $v = Perlito5::AST::Call::->new("invocant", $value, "method", $v->[2], "arguments", $param_list);
            return $v
        }
        if ($v->[1] eq "funcall") {;
            Perlito5::Compiler::error("unexpected function call")
        }
        if ($v->[1] eq "( )") {
            my $param_list = expand_list($v->[2]);
            if (ref($value) eq "Perlito5::AST::Apply" && !(defined($value->arguments()))) {
                $value->{"arguments"} = $param_list;
                return $value
            }
            if (ref($value) eq "Perlito5::AST::Call" && !(defined($value->arguments()))) {
                $value->{"arguments"} = $param_list;
                return $value
            }
            if (ref($value) eq "Perlito5::AST::Var" && $value->sigil() eq "&") {
                $v = Perlito5::AST::Apply::->new("ignore_proto", 1, "code", $value->{"name"}, "namespace", $value->{"namespace"}, "arguments", $param_list, "proto", undef);
                return $v
            }
            if (ref($value) eq "Perlito5::AST::Apply" && $value->code() eq "prefix:<&>") {
                $v = Perlito5::AST::Apply::->new("ignore_proto", 1, "code", $value, "namespace", '', "arguments", $param_list, "proto", undef);
                return $v
            }
            if (ref($value) eq "Perlito5::AST::Var") {;
                Perlito5::Compiler::error("syntax error")
            }
            $v = Perlito5::AST::Call::->new("invocant", $value, "method", "postcircumfix:<( )>", "arguments", $param_list);
            return $v
        }
        if ($v->[1] eq "[ ]") {
            if (ref($value) eq "Perlito5::AST::Var") {;
                $value->{"_real_sigil"} = "\@"
            }
            $v = Perlito5::AST::Index::->new("obj", $value, "index_exp", $v->[2]);
            return $v
        }
        if ($v->[1] eq "block") {
            if (ref($value) eq "Perlito5::AST::Var") {;
                $value->{"_real_sigil"} = "%"
            }
            $v = Perlito5::AST::Lookup::->new("obj", $value, "index_exp", $v->[2]->[0]);
            return $v
        }
        if ($v->[1] eq ".( )") {
            my $param_list = expand_list($v->[2]);
            $v = Perlito5::AST::Call::->new("invocant", $value, "method", "postcircumfix:<( )>", "arguments", $param_list);
            return $v
        }
        if ($v->[1] eq ".[ ]") {
            $v = Perlito5::AST::Call::->new("invocant", $value, "method", "postcircumfix:<[ ]>", "arguments", $v->[2]);
            return $v
        }
        if ($v->[1] eq ".{ }") {
            $v = Perlito5::AST::Call::->new("invocant", $value, "method", "postcircumfix:<{ }>", "arguments", $v->[2]);
            return $v
        }
        push(@{$op}, $value);
        return $op
    }
    my $reduce_to_ast = sub {
        my $op_stack = shift;
        my $num_stack = shift;
        my $last_op = shift(@{$op_stack});
        if ($last_op->[0] eq "prefix") {;
            push(@{$num_stack}, Perlito5::AST::Apply::->new("namespace", '', "code", "prefix:<" . $last_op->[1] . ">", "arguments", [pop_term($num_stack)]))
        }
        elsif ($last_op->[0] eq "postfix") {;
            push(@{$num_stack}, Perlito5::AST::Apply::->new("namespace", '', "code", "postfix:<" . $last_op->[1] . ">", "arguments", [pop_term($num_stack)]))
        }
        elsif ($last_op->[0] eq "postfix_or_term") {;
            push(@{$num_stack}, reduce_postfix($last_op, pop_term($num_stack)))
        }
        elsif (Perlito5::Grammar::Precedence::is_assoc_type("list", $last_op->[1])) {
            my $arg;
            if (scalar(@{$num_stack}) < 2) {
                my $v2 = pop_term($num_stack);
                if (ref($v2) eq "Perlito5::AST::Apply" && $v2->code() eq ("list:<" . $last_op->[1] . ">")) {;
                    push(@{$num_stack}, Perlito5::AST::Apply::->new("namespace", $v2->namespace(), "code", $v2->code(), "arguments", [@{$v2->arguments()}]))
                }
                else {;
                    push(@{$num_stack}, Perlito5::AST::Apply::->new("namespace", '', "code", "list:<" . $last_op->[1] . ">", "arguments", [$v2]))
                }
                return
            }
            else {
                my $v2 = pop_term($num_stack);
                $arg = [pop_term($num_stack), $v2]
            }
            if (ref($arg->[0]) eq "Perlito5::AST::Apply" && $last_op->[0] eq "infix" && ($arg->[0]->code() eq "list:<" . $last_op->[1] . ">")) {
                push(@{$num_stack}, Perlito5::AST::Apply::->new("namespace", '', "code", ($arg->[0])->code(), "arguments", [@{($arg->[0])->arguments()}, $arg->[1]]));
                return
            }
            push(@{$num_stack}, Perlito5::AST::Apply::->new("namespace", '', "code", "list:<" . $last_op->[1] . ">", "arguments", $arg))
        }
        elsif (Perlito5::Grammar::Precedence::is_assoc_type("chain", $last_op->[1])) {
            if (scalar(@{$num_stack}) < 2) {;
                Perlito5::Compiler::error("Missing value after operator " . $last_op->[1])
            }
            my $v2 = pop_term($num_stack);
            my $arg = [pop_term($num_stack), $v2];
            push(@{$num_stack}, Perlito5::AST::Apply::->new("namespace", '', "code", "infix:<" . $last_op->[1] . ">", "arguments", $arg))
        }
        elsif ($last_op->[0] eq "ternary") {
            if (scalar(@{$num_stack}) < 2) {;
                Perlito5::Compiler::error("Missing value after ternary operator")
            }
            my $v2 = pop_term($num_stack);
            push(@{$num_stack}, Perlito5::AST::Apply::->new("namespace", '', "code", "ternary:<" . $last_op->[1] . ">", "arguments", [pop_term($num_stack), $last_op->[2], $v2]))
        }
        else {
            if (scalar(@{$num_stack}) < 2) {;
                Perlito5::Compiler::error("missing value after operator '" . $last_op->[1] . "'")
            }
            my $v2 = pop_term($num_stack);
            push(@{$num_stack}, Perlito5::AST::Apply::->new("namespace", '', "code", "infix:<" . $last_op->[1] . ">", "arguments", [pop_term($num_stack), $v2]))
        }
    };
    sub Perlito5::Grammar::Expression::term_arrow {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((("-" eq $str->[$MATCH->{"to"} + 0]) && (">" eq $str->[$MATCH->{"to"} + 1]) && ($MATCH->{"to"} += 2)) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((("(" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $m2 = paren_parse($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"paren_parse"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && ((")" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    $MATCH->{"capture"} = ["postfix_or_term", ".( )", Perlito5::Match::flat($MATCH->{"paren_parse"})];
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((("[" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $m2 = square_parse($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"square_parse"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (("]" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    $MATCH->{"capture"} = ["postfix_or_term", ".[ ]", Perlito5::Match::flat($MATCH->{"square_parse"})];
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((("{" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $pos1 = $MATCH->{"to"};
                    (do {;
                        ((do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                1
                            }
                            else {;
                                0
                            }
                        }) && (do {
                            my $m2 = Perlito5::Grammar::ident($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                $MATCH->{"Perlito5::Grammar::ident"} = $m2;
                                1
                            }
                            else {;
                                0
                            }
                        }) && (do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                1
                            }
                            else {;
                                0
                            }
                        }) && (("}" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                            $MATCH->{"capture"} = ["postfix_or_term", ".{ }", Perlito5::AST::Buf::->new("buf", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::ident"}))];
                            1
                        }))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        ((do {
                            my $m2 = curly_parse($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                $MATCH->{"curly_parse"} = $m2;
                                1
                            }
                            else {;
                                0
                            }
                        }) && (do {
                            my $pos1 = $MATCH->{"to"};
                            (do {;
                                (("}" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                            }) || (do {
                                $MATCH->{"to"} = $pos1;
                                (do {
                                    Perlito5::Compiler::error("Missing right curly or square bracket");
                                    1
                                })
                            })
                        }) && (do {
                            $MATCH->{"capture"} = ["postfix_or_term", ".{ }", Perlito5::Match::flat($MATCH->{"curly_parse"})];
                            1
                        }))
                    })
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((("\$" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $m2 = Perlito5::Grammar::ident($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::ident"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $pos1 = $MATCH->{"to"};
                    (do {;
                        ((("(" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                            my $m2 = paren_parse($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                $MATCH->{"paren_parse"} = $m2;
                                1
                            }
                            else {;
                                0
                            }
                        }) && ((")" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                            $MATCH->{"capture"} = ["postfix_or_term", "methcall", Perlito5::AST::Var::->new("sigil", "\$", "namespace", '', "name", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::ident"})), Perlito5::Match::flat($MATCH->{"paren_parse"})];
                            1
                        }))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        (do {
                            $MATCH->{"capture"} = ["postfix_or_term", "methcall_no_params", Perlito5::AST::Var::->new("sigil", "\$", "namespace", '', "name", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::ident"}))];
                            1
                        })
                    })
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((do {
                    my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::full_ident"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $pos1 = $MATCH->{"to"};
                    (do {;
                        ((("(" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                            my $m2 = paren_parse($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                $MATCH->{"paren_parse"} = $m2;
                                1
                            }
                            else {;
                                0
                            }
                        }) && ((")" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                            $MATCH->{"capture"} = ["postfix_or_term", "methcall", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::full_ident"}), Perlito5::Match::flat($MATCH->{"paren_parse"})];
                            1
                        }))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        (do {
                            $MATCH->{"capture"} = ["postfix_or_term", "methcall_no_params", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::full_ident"})];
                            1
                        })
                    })
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((("\@" eq $str->[$MATCH->{"to"} + 0]) && ("*" eq $str->[$MATCH->{"to"} + 1]) && ($MATCH->{"to"} += 2)) && (do {
                    $MATCH->{"capture"} = ["postfix_or_term", "methcall_no_params", "\@*"];
                    1
                }))
            })
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Expression::term_ternary {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((("?" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $m2 = ternary5_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"ternary5_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && ((":" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
            $MATCH->{"capture"} = ["op", "? :", Perlito5::Match::flat($MATCH->{"ternary5_parse"})];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Expression::term_paren {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((("(" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $m2 = paren_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"paren_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && ((")" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
            $MATCH->{"capture"} = ["postfix_or_term", "( )", Perlito5::Match::flat($MATCH->{"paren_parse"})];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Expression::term_square {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((("[" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $m2 = square_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"square_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (("]" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
            $MATCH->{"capture"} = ["postfix_or_term", "[ ]", Perlito5::Match::flat($MATCH->{"square_parse"})];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Expression::term_curly {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((("{" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $m = $MATCH;
            if (!(do {
                my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            })) {;
                $MATCH = $m
            }
            1
        }) && (do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((do {
                    my $m2 = Perlito5::Grammar::ident($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::ident"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $m = $MATCH;
                    if (!(do {
                        my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
                        if ($m2) {
                            $MATCH->{"to"} = $m2->{"to"};
                            1
                        }
                        else {;
                            0
                        }
                    })) {;
                        $MATCH = $m
                    }
                    1
                }) && (("}" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    $MATCH->{"capture"} = ["postfix_or_term", "block", [Perlito5::AST::Apply::->new("arguments", [], "bareword", 1, "code", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::ident"}), "namespace", '')]];
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((do {
                    $MATCH->{"_save_scope"} = [@Perlito5::SCOPE_STMT];
                    @Perlito5::SCOPE_STMT = ();
                    1
                }) && (do {
                    my $m2 = Perlito5::Grammar::exp_stmts($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::exp_stmts"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    @Perlito5::SCOPE_STMT = @{$MATCH->{"_save_scope"}};
                    1
                }) && (do {
                    my $m = $MATCH;
                    if (!(do {
                        my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
                        if ($m2) {
                            $MATCH->{"to"} = $m2->{"to"};
                            1
                        }
                        else {;
                            0
                        }
                    })) {;
                        $MATCH = $m
                    }
                    1
                }) && (do {
                    my $pos1 = $MATCH->{"to"};
                    (do {;
                        (("}" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        (do {
                            Perlito5::Compiler::error("Missing right curly or square bracket");
                            1
                        })
                    })
                }) && (do {
                    $MATCH->{"capture"} = ["postfix_or_term", "block", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::exp_stmts"})];
                    1
                }))
            })
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Expression::term_pos {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((("p" eq $str->[$MATCH->{"to"} + 0]) && ("o" eq $str->[$MATCH->{"to"} + 1]) && ("s" eq $str->[$MATCH->{"to"} + 2]) && ($MATCH->{"to"} += 3)) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((do {
                    my $m2 = Perlito5::Grammar::var_ident($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::var_ident"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", "pos", "arguments", [$MATCH->{"Perlito5::Grammar::var_ident"}->{"capture"}])];
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((do {
                    my $tmp = $MATCH;
                    $MATCH = {"from", $tmp->{"to"}, "to", $tmp->{"to"}};
                    my $res = (("(" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1));
                    $MATCH = $tmp;
                    $res ? 0 : 1
                }) && (do {
                    $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", "pos", "arguments", [Perlito5::AST::Var::SCALAR_ARG()], "bareword", 1)];
                    1
                }))
            })
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Expression::declarator {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                (("m" eq $str->[$MATCH->{"to"} + 0]) && ("y" eq $str->[$MATCH->{"to"} + 1]) && ($MATCH->{"to"} += 2))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (("s" eq $str->[$MATCH->{"to"} + 0]) && ("t" eq $str->[$MATCH->{"to"} + 1]) && ("a" eq $str->[$MATCH->{"to"} + 2]) && ("t" eq $str->[$MATCH->{"to"} + 3]) && ("e" eq $str->[$MATCH->{"to"} + 4]) && ($MATCH->{"to"} += 5))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (("o" eq $str->[$MATCH->{"to"} + 0]) && ("u" eq $str->[$MATCH->{"to"} + 1]) && ("r" eq $str->[$MATCH->{"to"} + 2]) && ($MATCH->{"to"} += 3))
            })
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Expression::term_declarator {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((do {
            my $m2 = declarator($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"declarator"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((do {
                    my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $pos1 = $MATCH->{"to"};
                    (do {;
                        ((do {
                            my $m2 = Perlito5::Grammar::Block::named_sub($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                $MATCH->{"Perlito5::Grammar::Block::named_sub"} = $m2;
                                1
                            }
                            else {;
                                0
                            }
                        }) && (do {
                            my $sub = $MATCH->{"Perlito5::Grammar::Block::named_sub"}->{"capture"};
                            $sub->{"decl"} = Perlito5::Match::flat($MATCH->{"declarator"});
                            $MATCH->{"capture"} = ["term", $sub];
                            return $MATCH;
                            1
                        }))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        (do {
                            my $m2 = Perlito5::Grammar::opt_type($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                $MATCH->{"Perlito5::Grammar::opt_type"} = $m2;
                                1
                            }
                            else {;
                                0
                            }
                        })
                    })
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                1
            })
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::var_ident($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::var_ident"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Attribute::opt_attribute($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Attribute::opt_attribute"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $declarator = Perlito5::Match::flat($MATCH->{"declarator"});
            my $type = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::opt_type"});
            $type && !$Perlito5::PACKAGES->{$type} && Perlito5::Compiler::error("No such class " . $type);
            my $var = $MATCH->{"Perlito5::Grammar::var_ident"}->{"capture"};
            $var->{"namespace"} && Perlito5::Compiler::error("No package name allowed for variable " . $var->{"sigil"} . $var->{"name"} . " in \"" . $declarator . "\"");
            $var->{"_decl"} = $declarator;
            $var->{"_id"} = $Perlito5::ID++;
            $declarator eq "our" && ($var->{"_namespace"} = $Perlito5::PKG_NAME);
            my $decl = Perlito5::AST::Decl::->new("decl", $declarator, "type", $type, "var", $var, "attributes", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Attribute::opt_attribute"}));
            $MATCH->{"capture"} = ["term", $decl];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Expression::operator_with_paren {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                (("c" eq $str->[$MATCH->{"to"} + 0]) && ("h" eq $str->[$MATCH->{"to"} + 1]) && ("o" eq $str->[$MATCH->{"to"} + 2]) && ("m" eq $str->[$MATCH->{"to"} + 3]) && ("p" eq $str->[$MATCH->{"to"} + 4]) && ($MATCH->{"to"} += 5))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (("c" eq $str->[$MATCH->{"to"} + 0]) && ("h" eq $str->[$MATCH->{"to"} + 1]) && ("o" eq $str->[$MATCH->{"to"} + 2]) && ("p" eq $str->[$MATCH->{"to"} + 3]) && ($MATCH->{"to"} += 4))
            })
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Expression::term_operator_with_paren {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((do {
            my $m2 = operator_with_paren($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"operator_with_paren"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (("(" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $m2 = paren_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"paren_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && ((")" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
            $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", Perlito5::Match::flat($MATCH->{"operator_with_paren"}), "arguments", expand_list(Perlito5::Match::flat($MATCH->{"paren_parse"})), "namespace", '')];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Expression::term_not {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((("n" eq $str->[$MATCH->{"to"} + 0]) && ("o" eq $str->[$MATCH->{"to"} + 1]) && ("t" eq $str->[$MATCH->{"to"} + 2]) && ($MATCH->{"to"} += 3)) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (("(" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $m2 = paren_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"paren_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && ((")" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
            $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", "prefix:<not>", "arguments", expand_list(Perlito5::Match::flat($MATCH->{"paren_parse"})), "namespace", '')];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Expression::term_local {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((("l" eq $str->[$MATCH->{"to"} + 0]) && ("o" eq $str->[$MATCH->{"to"} + 1]) && ("c" eq $str->[$MATCH->{"to"} + 2]) && ("a" eq $str->[$MATCH->{"to"} + 3]) && ("l" eq $str->[$MATCH->{"to"} + 4]) && ($MATCH->{"to"} += 5)) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Sigil::term_sigil($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Sigil::term_sigil"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $declarator = "local";
            my $type = '';
            $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Sigil::term_sigil"})->[1];
            $MATCH = Perlito5::Grammar::String::double_quoted_var_with_subscript($MATCH);
            my $var = $MATCH->{"capture"};
            my $look = Perlito5::Grammar::Scope::lookup_variable($var);
            if ($look && ($look->{"_decl"} eq "my" || $look->{"_decl"} eq "state")) {;
                Perlito5::Compiler::error("Can't localize lexical variable " . $var->{"sigil"} . $var->{"name"})
            }
            $var->{"_id"} = $Perlito5::ID++;
            $var->{"_decl"} = $declarator;
            !$var->{"namespace"} && !$var->{"_namespace"} && ($var->{"_namespace"} = $Perlito5::PKG_NAME);
            my $decl = Perlito5::AST::Decl::->new("decl", $declarator, "type", $type, "var", $var);
            $MATCH->{"capture"} = ["term", $decl];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Expression::term_return {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((("r" eq $str->[$MATCH->{"to"} + 0]) && ("e" eq $str->[$MATCH->{"to"} + 1]) && ("t" eq $str->[$MATCH->{"to"} + 2]) && ("u" eq $str->[$MATCH->{"to"} + 3]) && ("r" eq $str->[$MATCH->{"to"} + 4]) && ("n" eq $str->[$MATCH->{"to"} + 5]) && ($MATCH->{"to"} += 6)) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = list_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"list_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $args = Perlito5::Match::flat($MATCH->{"list_parse"});
            $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", "return", "arguments", $args eq "*undef*" ? [] : [$args], "namespace", '', "bareword", $args eq "*undef*" ? 1 : 0)];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Expression::term_eval {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((("e" eq $str->[$MATCH->{"to"} + 0]) && ("v" eq $str->[$MATCH->{"to"} + 1]) && ("a" eq $str->[$MATCH->{"to"} + 2]) && ("l" eq $str->[$MATCH->{"to"} + 3]) && ($MATCH->{"to"} += 4)) && (do {
            my $m2 = Perlito5::Grammar::block($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::block"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", "eval", "arguments", [Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::block"})], "namespace", '')];
            1
        })));
        $tmp ? $MATCH : undef
    }
    my $Expr_end_token_chars = [7, 6, 5, 4, 3, 2, 1];
    my $Expr_end_token = {"]", 1, ")", 1, "}", 1, ";", 1, "if", 1, "for", 1, "else", 1, "when", 1, "while", 1, "until", 1, "elsif", 1, "unless", 1, "foreach", 1};
    my $List_end_token = {":", 1, "or", 1, "and", 1, "xor", 1, %{$Expr_end_token}};
    my $Argument_end_token = {",", 1, "<", 1, ">", 1, "=", 1, "|", 1, "^", 1, "?", 1, "=>", 1, "lt", 1, "le", 1, "gt", 1, "ge", 1, "<=", 1, ">=", 1, "==", 1, "!=", 1, "ne", 1, "eq", 1, "..", 1, "~~", 1, "&&", 1, "||", 1, "+=", 1, "-=", 1, "*=", 1, "/=", 1, "x=", 1, "|=", 1, "&=", 1, ".=", 1, "^=", 1, "%=", 1, "//", 1, "...", 1, "<=>", 1, "cmp", 1, "<<=", 1, ">>=", 1, "||=", 1, "&&=", 1, "//=", 1, "**=", 1, %{$List_end_token}};
    sub Perlito5::Grammar::Expression::list_parser {
        (my($str), my($pos), my($end_token)) = @_;
        my $expr;
        my $last_pos = $pos;
        my $is_first_token = 1;
        my $lexer_stack = [];
        my $last_token_was_space = 1;
        my $get_token = sub {
            my $last_is_term = $_[0];
            my $v;
            if (scalar(@{$lexer_stack})) {
                $v = pop(@{$lexer_stack});
                if ($is_first_token && ($v->[0] eq "op") && !(Perlito5::Grammar::Precedence::is_fixity_type("prefix", $v->[1]))) {;
                    $v->[0] = "end"
                }
            }
            else {
                my $m = Perlito5::Grammar::Precedence::op_parse($str, $last_pos, $last_is_term);
                if ($m) {
                    my $spc = Perlito5::Grammar::Space::ws($str, $m->{"to"});
                    if ($spc) {;
                        $m->{"to"} = $spc->{"to"}
                    }
                }
                if (!$m) {;
                    return ["end", "*end*"]
                }
                $v = $m->{"capture"};
                if ($is_first_token && ($v->[0] eq "op") && !(Perlito5::Grammar::Precedence::is_fixity_type("prefix", $v->[1]))) {;
                    $v->[0] = "end"
                }
                if ($v->[0] ne "end") {;
                    $last_pos = $m->{"to"}
                }
            }
            $last_token_was_space = ($v->[0] eq "space");
            $is_first_token = 0;
            return $v
        };
        my $prec = Perlito5::Grammar::Precedence::->new("get_token", $get_token, "reduce", $reduce_to_ast, "end_token", $end_token, "end_token_chars", $Expr_end_token_chars);
        my $res = $prec->precedence_parse();
        if (scalar(@{$res}) == 0) {;
            return {"str", $str, "from", $pos, "to", $last_pos, "capture", "*undef*"}
        }
        my $result = pop_term($res);
        return {"str", $str, "from", $pos, "to", $last_pos, "capture", $result}
    }
    sub Perlito5::Grammar::Expression::argument_parse {
        (my($str), my($pos)) = @_;
        return list_parser($str, $pos, $Argument_end_token)
    }
    sub Perlito5::Grammar::Expression::list_parse {
        (my($str), my($pos)) = @_;
        return list_parser($str, $pos, $List_end_token)
    }
    sub Perlito5::Grammar::Expression::circumfix_parse {
        (my($str), my($pos), my($delimiter)) = @_;
        my $expr;
        my $last_pos = $pos;
        my $get_token = sub {
            my $last_is_term = $_[0];
            my $m = Perlito5::Grammar::Precedence::op_parse($str, $last_pos, $last_is_term);
            if ($m) {
                my $spc = Perlito5::Grammar::Space::ws($str, $m->{"to"});
                if ($spc) {;
                    $m->{"to"} = $spc->{"to"}
                }
            }
            if (!$m) {
                my $msg = "Expected closing delimiter: " . $delimiter;
                ($delimiter eq "}" || $delimiter eq "]") && ($msg = "Missing right curly or square bracket");
                Perlito5::Compiler::error($msg . " near ", $last_pos)
            }
            my $v = $m->{"capture"};
            if ($v->[0] ne "end") {;
                $last_pos = $m->{"to"}
            }
            return $v
        };
        my %delim_token;
        $delim_token{$delimiter} = 1;
        my $prec = Perlito5::Grammar::Precedence::->new("get_token", $get_token, "reduce", $reduce_to_ast, "end_token", \%delim_token, "end_token_chars", [length($delimiter)]);
        my $res = $prec->precedence_parse();
        $res = pop_term($res);
        if (!(defined($res))) {;
            $res = "*undef*"
        }
        return {"str", $str, "from", $pos, "to", $last_pos, "capture", $res}
    }
    sub Perlito5::Grammar::Expression::ternary5_parse {;
        return circumfix_parse(@_, ":")
    }
    sub Perlito5::Grammar::Expression::curly_parse {;
        return circumfix_parse(@_, "}")
    }
    sub Perlito5::Grammar::Expression::square_parse {;
        return circumfix_parse(@_, "]")
    }
    sub Perlito5::Grammar::Expression::paren_parse {;
        return circumfix_parse(@_, ")")
    }
    sub Perlito5::Grammar::Expression::exp_parse {
        (my($str), my($pos)) = @_;
        my $expr;
        my $last_pos = $pos;
        my $lexer_stack = [];
        my $get_token = sub {
            my $last_is_term = $_[0];
            my $v;
            if (scalar(@{$lexer_stack})) {;
                $v = pop(@{$lexer_stack})
            }
            else {
                my $m = Perlito5::Grammar::Precedence::op_parse($str, $last_pos, $last_is_term);
                if ($m) {
                    my $spc = Perlito5::Grammar::Space::ws($str, $m->{"to"});
                    if ($spc) {;
                        $m->{"to"} = $spc->{"to"}
                    }
                }
                if (!$m) {;
                    return ["end", "*end*"]
                }
                $v = $m->{"capture"};
                if ($v->[0] ne "end") {;
                    $last_pos = $m->{"to"}
                }
            }
            return $v
        };
        my $prec = Perlito5::Grammar::Precedence::->new("get_token", $get_token, "reduce", $reduce_to_ast, "end_token", $Expr_end_token, "end_token_chars", $Expr_end_token_chars);
        my $res = $prec->precedence_parse();
        if (scalar(@{$res}) == 0) {;
            return 0
        }
        my $result = pop_term($res);
        return {"str", $str, "from", $pos, "to", $last_pos, "capture", $result}
    }
    Perlito5::Grammar::Precedence::add_term("my", \&term_declarator);
    Perlito5::Grammar::Precedence::add_term("our", \&term_declarator);
    Perlito5::Grammar::Precedence::add_term("eval", \&term_eval);
    Perlito5::Grammar::Precedence::add_term("state", \&term_declarator);
    Perlito5::Grammar::Precedence::add_term("local", \&term_local);
    Perlito5::Grammar::Precedence::add_term("return", \&term_return);
    Perlito5::Grammar::Precedence::add_term("not", \&term_not);
    Perlito5::Grammar::Precedence::add_term("pos", \&term_pos);
    Perlito5::Grammar::Precedence::add_term("chomp", \&term_operator_with_paren);
    Perlito5::Grammar::Precedence::add_term("chop", \&term_operator_with_paren);
    1
}
{
    package main;
    package Perlito5::Grammar;
    sub Perlito5::Grammar::unless {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((("u" eq $str->[$MATCH->{"to"} + 0]) && ("n" eq $str->[$MATCH->{"to"} + 1]) && ("l" eq $str->[$MATCH->{"to"} + 2]) && ("e" eq $str->[$MATCH->{"to"} + 3]) && ("s" eq $str->[$MATCH->{"to"} + 4]) && ("s" eq $str->[$MATCH->{"to"} + 5]) && ($MATCH->{"to"} += 6)) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            Perlito5::Grammar::Scope::create_new_compile_time_scope();
            1
        }) && (do {
            my $m2 = Perlito5::Grammar::Expression::term_paren($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Expression::term_paren"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = block($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"block"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (("e" eq $str->[$MATCH->{"to"} + 0]) && ("l" eq $str->[$MATCH->{"to"} + 1]) && ("s" eq $str->[$MATCH->{"to"} + 2]) && ("e" eq $str->[$MATCH->{"to"} + 3]) && ($MATCH->{"to"} += 4)) && (do {
                    my $m2 = block2($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"block2"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{"capture"} = Perlito5::AST::If::->new("cond", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::term_paren"})->[2], "body", Perlito5::Match::flat($MATCH->{"block2"}), "otherwise", Perlito5::Match::flat($MATCH->{"block"}));
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (("e" eq $str->[$MATCH->{"to"} + 0]) && ("l" eq $str->[$MATCH->{"to"} + 1]) && ("s" eq $str->[$MATCH->{"to"} + 2]) && ($MATCH->{"to"} += 3)) && (do {
                    my $m2 = if_($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"if_"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{"capture"} = Perlito5::AST::If::->new("cond", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::term_paren"})->[2], "body", Perlito5::AST::Block::->new("stmts", [Perlito5::Match::flat($MATCH->{"if_"})]), "otherwise", Perlito5::Match::flat($MATCH->{"block"}));
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (do {
                    $MATCH->{"capture"} = Perlito5::AST::If::->new("cond", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::term_paren"})->[2], "body", Perlito5::AST::Block::->new("stmts", []), "otherwise", Perlito5::Match::flat($MATCH->{"block"}));
                    1
                })
            })
        }) && (do {
            Perlito5::Grammar::Scope::end_compile_time_scope();
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::if_ {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((("i" eq $str->[$MATCH->{"to"} + 0]) && ("f" eq $str->[$MATCH->{"to"} + 1]) && ($MATCH->{"to"} += 2)) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            Perlito5::Grammar::Scope::create_new_compile_time_scope();
            1
        }) && (do {
            my $m2 = Perlito5::Grammar::Expression::term_paren($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Expression::term_paren"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = block($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"block"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (("e" eq $str->[$MATCH->{"to"} + 0]) && ("l" eq $str->[$MATCH->{"to"} + 1]) && ("s" eq $str->[$MATCH->{"to"} + 2]) && ("e" eq $str->[$MATCH->{"to"} + 3]) && ($MATCH->{"to"} += 4)) && (do {
                    my $m2 = block2($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"block2"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{"capture"} = Perlito5::AST::If::->new("cond", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::term_paren"})->[2], "body", Perlito5::Match::flat($MATCH->{"block"}), "otherwise", Perlito5::Match::flat($MATCH->{"block2"}));
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (("e" eq $str->[$MATCH->{"to"} + 0]) && ("l" eq $str->[$MATCH->{"to"} + 1]) && ("s" eq $str->[$MATCH->{"to"} + 2]) && ($MATCH->{"to"} += 3)) && (do {
                    my $m2 = if_($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"if_"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{"capture"} = Perlito5::AST::If::->new("cond", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::term_paren"})->[2], "body", Perlito5::Match::flat($MATCH->{"block"}), "otherwise", Perlito5::AST::Block::->new("stmts", [Perlito5::Match::flat($MATCH->{"if_"})]));
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (do {
                    $MATCH->{"capture"} = Perlito5::AST::If::->new("cond", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::term_paren"})->[2], "body", Perlito5::Match::flat($MATCH->{"block"}), "otherwise", Perlito5::AST::Block::->new("stmts", []));
                    1
                })
            })
        }) && (do {
            Perlito5::Grammar::Scope::end_compile_time_scope();
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::when {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((("w" eq $str->[$MATCH->{"to"} + 0]) && ("h" eq $str->[$MATCH->{"to"} + 1]) && ("e" eq $str->[$MATCH->{"to"} + 2]) && ("n" eq $str->[$MATCH->{"to"} + 3]) && ($MATCH->{"to"} += 4)) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            Perlito5::Grammar::Scope::create_new_compile_time_scope();
            1
        }) && (do {
            my $m2 = Perlito5::Grammar::Expression::term_paren($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Expression::term_paren"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = block($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"block"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = Perlito5::AST::When::->new("cond", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::term_paren"})->[2], "body", Perlito5::Match::flat($MATCH->{"block"}));
            1
        }) && (do {
            Perlito5::Grammar::Scope::end_compile_time_scope();
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::is_bareword {
        my $term = shift;
        $term->isa("Perlito5::AST::Apply") and $term->{"bareword"}
    }
    sub Perlito5::Grammar::for {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((("f" eq $str->[$MATCH->{"to"} + 0]) && ("o" eq $str->[$MATCH->{"to"} + 1]) && ("r" eq $str->[$MATCH->{"to"} + 2]) && ($MATCH->{"to"} += 3)) && (do {
            my $m = $MATCH;
            if (!(("e" eq $str->[$MATCH->{"to"} + 0]) && ("a" eq $str->[$MATCH->{"to"} + 1]) && ("c" eq $str->[$MATCH->{"to"} + 2]) && ("h" eq $str->[$MATCH->{"to"} + 3]) && ($MATCH->{"to"} += 4))) {;
                $MATCH = $m
            }
            1
        }) && (do {
            Perlito5::Grammar::Scope::create_new_compile_time_scope();
            1
        }) && (do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((do {
                    my $pos1 = $MATCH->{"to"};
                    (do {;
                        ((do {
                            my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                1
                            }
                            else {;
                                0
                            }
                        }) && (do {
                            my $m2 = Perlito5::Grammar::Expression::term_declarator($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                $MATCH->{"Perlito5::Grammar::Expression::term_declarator"} = $m2;
                                1
                            }
                            else {;
                                0
                            }
                        }) && (do {
                            $MATCH->{"_tmp"} = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::term_declarator"})->[1];
                            1
                        }))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        ((do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                1
                            }
                            else {;
                                0
                            }
                        }) && (do {
                            my $tmp = $MATCH;
                            $MATCH = {"from", $tmp->{"to"}, "to", $tmp->{"to"}};
                            my $res = (("\$" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1));
                            $MATCH = $tmp;
                            $res ? 1 : 0
                        }) && (do {
                            my $m2 = Perlito5::Grammar::Sigil::term_sigil($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                $MATCH->{"Perlito5::Grammar::Sigil::term_sigil"} = $m2;
                                1
                            }
                            else {;
                                0
                            }
                        }) && (do {
                            $MATCH->{"_tmp"} = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Sigil::term_sigil"})->[1];
                            my $v = $MATCH->{"_tmp"};
                            my $look = Perlito5::Grammar::Scope::lookup_variable($v);
                            my $decl = $look && $look->{"_decl"} ? $look->{"_decl"} : "global";
                            if ($decl ne "global") {
                                $v->{"_id"} = $Perlito5::ID++;
                                $v->{"_decl"} = $decl;
                                $MATCH->{"_tmp"} = Perlito5::AST::Decl::->new("decl", $decl, "var", $v)
                            }
                            1
                        }))
                    })
                }) && (do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (("(" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $m2 = Perlito5::Grammar::Expression::paren_parse($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Expression::paren_parse"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && ((")" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $m2 = block($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"block"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $m2 = opt_continue_block($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"opt_continue_block"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $body = Perlito5::Match::flat($MATCH->{"block"});
                    my $header = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::paren_parse"});
                    my $topic = $MATCH->{"_tmp"};
                    my $continue_block = $MATCH->{"opt_continue_block"}->{"capture"};
                    $MATCH->{"capture"} = Perlito5::AST::For::->new("cond", $header, "body", $body, "continue", $continue_block, "topic", $topic);
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (("(" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $pos1 = $MATCH->{"to"};
                    (do {;
                        ((do {
                            my $m2 = Perlito5::Grammar::Expression::exp_parse($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                $MATCH->{"Perlito5::Grammar::Expression::exp_parse"} = $m2;
                                1
                            }
                            else {;
                                0
                            }
                        }) && (do {
                            Perlito5::Grammar::Scope::check_variable_declarations();
                            1
                        }))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        ()
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        ((do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                1
                            }
                            else {;
                                0
                            }
                        }) && (do {
                            my $tmp = $MATCH;
                            $MATCH = {"from", $tmp->{"to"}, "to", $tmp->{"to"}};
                            my $res = ((";" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1));
                            $MATCH = $tmp;
                            $res ? 1 : 0
                        }))
                    })
                }) && (do {
                    my $pos1 = $MATCH->{"to"};
                    (do {;
                        (((";" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                            $MATCH->{"c_style_for"} = 1;
                            1
                        }) && (do {
                            my $pos1 = $MATCH->{"to"};
                            (do {;
                                ((do {
                                    my $m2 = Perlito5::Grammar::exp($str, $MATCH->{"to"});
                                    if ($m2) {
                                        $MATCH->{"to"} = $m2->{"to"};
                                        $MATCH->{"Perlito5::Grammar::exp"} = $m2;
                                        1
                                    }
                                    else {;
                                        0
                                    }
                                }) && (do {
                                    Perlito5::Grammar::Scope::check_variable_declarations();
                                    1
                                }))
                            }) || (do {
                                $MATCH->{"to"} = $pos1;
                                ()
                            }) || (do {
                                $MATCH->{"to"} = $pos1;
                                (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                                    if ($m2) {
                                        $MATCH->{"to"} = $m2->{"to"};
                                        1
                                    }
                                    else {;
                                        0
                                    }
                                })
                            })
                        }) && ((";" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                            my $pos1 = $MATCH->{"to"};
                            (do {;
                                (do {
                                    my $m2 = Perlito5::Grammar::exp2($str, $MATCH->{"to"});
                                    if ($m2) {
                                        $MATCH->{"to"} = $m2->{"to"};
                                        $MATCH->{"Perlito5::Grammar::exp2"} = $m2;
                                        1
                                    }
                                    else {;
                                        0
                                    }
                                })
                            }) || (do {
                                $MATCH->{"to"} = $pos1;
                                ()
                            }) || (do {
                                $MATCH->{"to"} = $pos1;
                                (do {
                                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                                    if ($m2) {
                                        $MATCH->{"to"} = $m2->{"to"};
                                        1
                                    }
                                    else {;
                                        0
                                    }
                                })
                            })
                        }))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        1
                    })
                }) && ((")" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $m2 = block($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"block"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $m2 = opt_continue_block($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"opt_continue_block"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $header;
                    my $body = Perlito5::Match::flat($MATCH->{"block"});
                    my $topic;
                    my $continue_block = $MATCH->{"opt_continue_block"}->{"capture"};
                    if ($MATCH->{"c_style_for"}) {;
                        $header = [$MATCH->{"Perlito5::Grammar::Expression::exp_parse"}->{"capture"}, $MATCH->{"Perlito5::Grammar::exp"}->{"capture"}, $MATCH->{"Perlito5::Grammar::exp2"}->{"capture"}]
                    }
                    else {
                        $header = $MATCH->{"Perlito5::Grammar::Expression::exp_parse"}->{"capture"};
                        $topic = Perlito5::AST::Var::SCALAR_ARG()
                    }
                    $MATCH->{"capture"} = Perlito5::AST::For::->new("cond", $header, "body", $body, "continue", $continue_block, "topic", $topic);
                    1
                }))
            })
        }) && (do {
            Perlito5::Grammar::Scope::end_compile_time_scope();
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::while {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((("w" eq $str->[$MATCH->{"to"} + 0]) && ("h" eq $str->[$MATCH->{"to"} + 1]) && ("i" eq $str->[$MATCH->{"to"} + 2]) && ("l" eq $str->[$MATCH->{"to"} + 3]) && ("e" eq $str->[$MATCH->{"to"} + 4]) && ($MATCH->{"to"} += 5)) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            Perlito5::Grammar::Scope::create_new_compile_time_scope();
            1
        }) && (("(" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $m2 = Perlito5::Grammar::Expression::paren_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Expression::paren_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && ((")" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $m2 = block($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"block"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = opt_continue_block($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"opt_continue_block"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $cond = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::paren_parse"});
            if ($cond eq "*undef*") {;
                $cond = Perlito5::AST::Int::->new("int", 1)
            }
            my $stmt = Perlito5::AST::While::->new("cond", $cond, "body", Perlito5::Match::flat($MATCH->{"block"}), "continue", $MATCH->{"opt_continue_block"}->{"capture"});
            my $out = Perlito5::Macro::while_file($stmt);
            $out && ($stmt = $out);
            $MATCH->{"capture"} = $stmt;
            1
        }) && (do {
            Perlito5::Grammar::Scope::end_compile_time_scope();
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::until {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((("u" eq $str->[$MATCH->{"to"} + 0]) && ("n" eq $str->[$MATCH->{"to"} + 1]) && ("t" eq $str->[$MATCH->{"to"} + 2]) && ("i" eq $str->[$MATCH->{"to"} + 3]) && ("l" eq $str->[$MATCH->{"to"} + 4]) && ($MATCH->{"to"} += 5)) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            Perlito5::Grammar::Scope::create_new_compile_time_scope();
            1
        }) && (("(" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $m2 = Perlito5::Grammar::Expression::paren_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Expression::paren_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && ((")" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $m2 = block($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"block"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = opt_continue_block($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"opt_continue_block"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $cond = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::paren_parse"});
            if ($cond eq "*undef*") {;
                $cond = Perlito5::AST::Int::->new("int", 1)
            }
            $MATCH->{"capture"} = Perlito5::AST::While::->new("cond", Perlito5::AST::Apply::->new("arguments", [$cond], "code", "prefix:<!>", "namespace", ''), "body", Perlito5::Match::flat($MATCH->{"block"}), "continue", $MATCH->{"opt_continue_block"}->{"capture"});
            1
        }) && (do {
            Perlito5::Grammar::Scope::end_compile_time_scope();
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::given {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((("g" eq $str->[$MATCH->{"to"} + 0]) && ("i" eq $str->[$MATCH->{"to"} + 1]) && ("v" eq $str->[$MATCH->{"to"} + 2]) && ("e" eq $str->[$MATCH->{"to"} + 3]) && ("n" eq $str->[$MATCH->{"to"} + 4]) && ($MATCH->{"to"} += 5)) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            Perlito5::Grammar::Scope::create_new_compile_time_scope();
            1
        }) && (("(" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $m2 = Perlito5::Grammar::Expression::paren_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Expression::paren_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && ((")" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $m2 = block($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"block"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $body = Perlito5::Match::flat($MATCH->{"block"});
            $body->{"sig"} = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::var_ident"});
            $MATCH->{"capture"} = Perlito5::AST::Given::->new("cond", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::paren_parse"}), "body", $body);
            1
        }) && (do {
            Perlito5::Grammar::Scope::end_compile_time_scope();
            1
        })));
        $tmp ? $MATCH : undef
    }
    Perlito5::Grammar::Statement::add_statement("if", \&if_);
    Perlito5::Grammar::Statement::add_statement("for", \&for);
    Perlito5::Grammar::Statement::add_statement("foreach", \&for);
    Perlito5::Grammar::Statement::add_statement("when", \&when);
    Perlito5::Grammar::Statement::add_statement("while", \&while);
    Perlito5::Grammar::Statement::add_statement("until", \&until);
    Perlito5::Grammar::Statement::add_statement("given", \&given);
    Perlito5::Grammar::Statement::add_statement("unless", \&unless)
}
{
    package main;
    package Perlito5::Grammar::String;
    sub Perlito5::Grammar::String::term_q_quote {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((("q" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $pos1 = $MATCH->{"to"};
                    (do {;
                        (("#" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        ((do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                1
                            }
                            else {;
                                0
                            }
                        }) && (do {
                            my $tmp = $MATCH;
                            $MATCH = {"from", $tmp->{"to"}, "to", $tmp->{"to"}};
                            my $res = (("=" eq $str->[$MATCH->{"to"} + 0]) && (">" eq $str->[$MATCH->{"to"} + 1]) && ($MATCH->{"to"} += 2));
                            $MATCH = $tmp;
                            $res ? 0 : 1
                        }) && ('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"}))
                    })
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (("'" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
            })
        }) && (do {
            my $m2 = q_quote_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"q_quote_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = ["term", Perlito5::Match::flat($MATCH->{"q_quote_parse"})];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::String::term_qq_quote {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((("q" eq $str->[$MATCH->{"to"} + 0]) && ("q" eq $str->[$MATCH->{"to"} + 1]) && ($MATCH->{"to"} += 2)) && (do {
                    my $pos1 = $MATCH->{"to"};
                    (do {;
                        (("#" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        ((do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                1
                            }
                            else {;
                                0
                            }
                        }) && (do {
                            my $tmp = $MATCH;
                            $MATCH = {"from", $tmp->{"to"}, "to", $tmp->{"to"}};
                            my $res = (("=" eq $str->[$MATCH->{"to"} + 0]) && (">" eq $str->[$MATCH->{"to"} + 1]) && ($MATCH->{"to"} += 2));
                            $MATCH = $tmp;
                            $res ? 0 : 1
                        }) && ('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"}))
                    })
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (("\"" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
            })
        }) && (do {
            my $m2 = qq_quote_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"qq_quote_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = ["term", Perlito5::Match::flat($MATCH->{"qq_quote_parse"})];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::String::term_qw_quote {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((("q" eq $str->[$MATCH->{"to"} + 0]) && ("w" eq $str->[$MATCH->{"to"} + 1]) && ($MATCH->{"to"} += 2)) && (do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                (("#" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $tmp = $MATCH;
                    $MATCH = {"from", $tmp->{"to"}, "to", $tmp->{"to"}};
                    my $res = (("=" eq $str->[$MATCH->{"to"} + 0]) && (">" eq $str->[$MATCH->{"to"} + 1]) && ($MATCH->{"to"} += 2));
                    $MATCH = $tmp;
                    $res ? 0 : 1
                }) && ('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"}))
            })
        }) && (do {
            my $m2 = qw_quote_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"qw_quote_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = ["term", Perlito5::Match::flat($MATCH->{"qw_quote_parse"})];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::String::term_m_quote {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((("m" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $pos1 = $MATCH->{"to"};
                    (do {;
                        (("#" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        ((do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                1
                            }
                            else {;
                                0
                            }
                        }) && (do {
                            my $tmp = $MATCH;
                            $MATCH = {"from", $tmp->{"to"}, "to", $tmp->{"to"}};
                            my $res = (("=" eq $str->[$MATCH->{"to"} + 0]) && (">" eq $str->[$MATCH->{"to"} + 1]) && ($MATCH->{"to"} += 2));
                            $MATCH = $tmp;
                            $res ? 0 : 1
                        }) && ('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"}))
                    })
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (("/" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
            })
        }) && (do {
            my $m2 = m_quote_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"m_quote_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = ["term", Perlito5::Match::flat($MATCH->{"m_quote_parse"})];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::String::term_s_quote {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((("s" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                (("#" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $tmp = $MATCH;
                    $MATCH = {"from", $tmp->{"to"}, "to", $tmp->{"to"}};
                    my $res = (("=" eq $str->[$MATCH->{"to"} + 0]) && (">" eq $str->[$MATCH->{"to"} + 1]) && ($MATCH->{"to"} += 2));
                    $MATCH = $tmp;
                    $res ? 0 : 1
                }) && ('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"}))
            })
        }) && (do {
            my $m2 = s_quote_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"s_quote_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = ["term", Perlito5::Match::flat($MATCH->{"s_quote_parse"})];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::String::term_qx {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((("q" eq $str->[$MATCH->{"to"} + 0]) && ("x" eq $str->[$MATCH->{"to"} + 1]) && ($MATCH->{"to"} += 2)) && (do {
                    my $pos1 = $MATCH->{"to"};
                    (do {;
                        (("#" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        ((do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                1
                            }
                            else {;
                                0
                            }
                        }) && (do {
                            my $tmp = $MATCH;
                            $MATCH = {"from", $tmp->{"to"}, "to", $tmp->{"to"}};
                            my $res = (("=" eq $str->[$MATCH->{"to"} + 0]) && (">" eq $str->[$MATCH->{"to"} + 1]) && ($MATCH->{"to"} += 2));
                            $MATCH = $tmp;
                            $res ? 0 : 1
                        }) && ('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"}))
                    })
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (("`" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
            })
        }) && (do {
            my $m2 = qx_quote_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"qx_quote_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = ["term", Perlito5::Match::flat($MATCH->{"qx_quote_parse"})];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::String::term_glob {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((("<" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $m2 = glob_quote_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"glob_quote_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = ["term", Perlito5::Match::flat($MATCH->{"glob_quote_parse"})];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::String::term_tr_quote {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                (("t" eq $str->[$MATCH->{"to"} + 0]) && ("r" eq $str->[$MATCH->{"to"} + 1]) && ($MATCH->{"to"} += 2))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (("y" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
            })
        }) && (do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                (("#" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $tmp = $MATCH;
                    $MATCH = {"from", $tmp->{"to"}, "to", $tmp->{"to"}};
                    my $res = (("=" eq $str->[$MATCH->{"to"} + 0]) && (">" eq $str->[$MATCH->{"to"} + 1]) && ($MATCH->{"to"} += 2));
                    $MATCH = $tmp;
                    $res ? 0 : 1
                }) && ('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"}))
            })
        }) && (do {
            my $m2 = tr_quote_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"tr_quote_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = ["term", Perlito5::Match::flat($MATCH->{"tr_quote_parse"})];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::String::term_qr_quote {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((("q" eq $str->[$MATCH->{"to"} + 0]) && ("r" eq $str->[$MATCH->{"to"} + 1]) && ($MATCH->{"to"} += 2)) && (do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                (("#" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $tmp = $MATCH;
                    $MATCH = {"from", $tmp->{"to"}, "to", $tmp->{"to"}};
                    my $res = (("=" eq $str->[$MATCH->{"to"} + 0]) && (">" eq $str->[$MATCH->{"to"} + 1]) && ($MATCH->{"to"} += 2));
                    $MATCH = $tmp;
                    $res ? 0 : 1
                }) && ('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"}))
            })
        }) && (do {
            my $m2 = qr_quote_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"qr_quote_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = ["term", Perlito5::Match::flat($MATCH->{"qr_quote_parse"})];
            1
        })));
        $tmp ? $MATCH : undef
    }
    my %pair = ("{", "}", "(", ")", "[", "]", "<", ">");
    my %escape_sequence = ("a", 7, "b", 8, "e", 27, "f", 12, "n", 10, "r", 13, "t", 9);
    my %hex = map(+($_, 1), 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "A", "B", "C", "D", "E", "F");
    my %octal = map(+($_, 1), 0, 1, 2, 3, 4, 5, 6, 7);
    sub Perlito5::Grammar::String::q_quote_parse {
        my $str = $_[0];
        my $pos = $_[1];
        my $delimiter = $str->[$pos - 1];
        my $open_delimiter = $delimiter;
        exists($pair{$delimiter}) && ($delimiter = $pair{$delimiter});
        return string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 0)
    }
    sub Perlito5::Grammar::String::qq_quote_parse {
        my $str = $_[0];
        my $pos = $_[1];
        my $delimiter = $str->[$pos - 1];
        my $open_delimiter = $delimiter;
        exists($pair{$delimiter}) && ($delimiter = $pair{$delimiter});
        return string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 1)
    }
    sub Perlito5::Grammar::String::qw_quote_parse {
        my $str = $_[0];
        my $pos = $_[1];
        my $delimiter = $str->[$pos - 1];
        my $open_delimiter = $delimiter;
        exists($pair{$delimiter}) && ($delimiter = $pair{$delimiter});
        my $m = string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 0);
        if ($m) {;
            $m->{"capture"} = Perlito5::AST::Apply::->new("code", "list:<,>", "arguments", [map(Perlito5::AST::Buf::->new("buf", $_), split(" ", Perlito5::Match::flat($m)->{"buf"}))], "namespace", '')
        }
        return $m
    }
    sub Perlito5::Grammar::String::m_quote_parse {
        my $str = $_[0];
        my $pos = $_[1];
        my $delimiter = $str->[$pos - 1];
        my $open_delimiter = $delimiter;
        my $closing_delimiter = $delimiter;
        exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
        my $interpolate = 2;
        $delimiter eq "'" && ($interpolate = 3);
        my $part1 = string_interpolation_parse($str, $pos, $open_delimiter, $closing_delimiter, $interpolate);
        $part1 || return $part1;
        my $str_regex = $part1->{"capture"};
        my $p = $part1->{"to"};
        my $modifiers = '';
        my $m = Perlito5::Grammar::ident($str, $p);
        if ($m) {
            $modifiers = Perlito5::Match::flat($m);
            $part1->{"to"} = $m->{"to"}
        }
        $part1->{"capture"} = Perlito5::AST::Apply::->new("code", "p5:m", "arguments", [$str_regex, Perlito5::AST::Buf::->new("buf", $modifiers), Perlito5::AST::Var::SCALAR_ARG()], "namespace", '');
        return $part1
    }
    sub Perlito5::Grammar::String::s_quote_parse {
        my $str = $_[0];
        my $pos = $_[1];
        my $delimiter = $str->[$pos - 1];
        my $open_delimiter = $delimiter;
        my $closing_delimiter = $delimiter;
        exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
        my $interpolate = 2;
        $delimiter eq "'" && ($interpolate = 3);
        my $part1 = string_interpolation_parse($str, $pos, $open_delimiter, $closing_delimiter, $interpolate);
        $part1 || return $part1;
        my $str_regex = Perlito5::Match::flat($part1);
        my $part2;
        my $m;
        my $p = $part1->{"to"};
        if (exists($pair{$delimiter})) {
            $m = Perlito5::Grammar::Space::opt_ws($str, $p);
            $p = $m->{"to"};
            $delimiter = $str->[$p];
            $open_delimiter = $delimiter;
            $p++;
            $closing_delimiter = $delimiter;
            exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter})
        }
        $part2 = string_interpolation_parse($str, $p, $open_delimiter, $closing_delimiter, 0);
        $part2 || return $part2;
        my @replace = @{$str}[$p .. $part2->{"to"} - 2];
        my $replace;
        $p = $part2->{"to"};
        my $modifiers = '';
        $m = Perlito5::Grammar::ident($str, $p);
        if ($m) {;
            $modifiers = Perlito5::Match::flat($m)
        }
        if ($modifiers =~ m/e/) {
            my $m = Perlito5::Grammar::block(["{", @replace, "}"], 0);
            if (!$m) {;
                Perlito5::Compiler::error("syntax error")
            }
            $replace = Perlito5::Match::flat($m);
            if ($modifiers =~ m/ee/) {;
                $replace = Perlito5::AST::Block::->new("sig", undef, "stmts", [Perlito5::AST::Apply::->new("code", "eval", "arguments", [Perlito5::AST::Apply::->new("code", "do", "arguments", [$replace])], "bareword", '', "namespace", '')])
            }
        }
        else {
            $interpolate = 1;
            $delimiter eq chr(39) && ($interpolate = 3);
            my $m = string_interpolation_parse([$open_delimiter, @replace, $closing_delimiter], 1, $open_delimiter, $closing_delimiter, $interpolate);
            if (!$m) {;
                Perlito5::Compiler::error("syntax error")
            }
            $replace = Perlito5::Match::flat($m)
        }
        if ($m) {;
            $part2->{"to"} = $m->{"to"}
        }
        $part2->{"capture"} = Perlito5::AST::Apply::->new("code", "p5:s", "arguments", [$str_regex, $replace, Perlito5::AST::Buf::->new("buf", $modifiers), Perlito5::AST::Var::SCALAR_ARG()], "namespace", '');
        return $part2
    }
    sub Perlito5::Grammar::String::qr_quote_parse {
        my $str = $_[0];
        my $pos = $_[1];
        my $delimiter = $str->[$pos - 1];
        my $open_delimiter = $delimiter;
        my $closing_delimiter = $delimiter;
        exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
        my $interpolate = 2;
        $delimiter eq "'" && ($interpolate = 3);
        my $part1 = string_interpolation_parse($str, $pos, $open_delimiter, $closing_delimiter, $interpolate);
        $part1 || return $part1;
        my $str_regex = $part1->{"capture"};
        my $p = $part1->{"to"};
        my $modifiers = '';
        my $m = Perlito5::Grammar::ident($str, $p);
        if ($m) {
            $modifiers = Perlito5::Match::flat($m);
            $part1->{"to"} = $m->{"to"}
        }
        $part1->{"capture"} = Perlito5::AST::Apply::->new("code", "p5:qr", "arguments", [$str_regex, Perlito5::AST::Buf::->new("buf", $modifiers)], "namespace", '');
        return $part1
    }
    sub Perlito5::Grammar::String::qx_quote_parse {
        my $str = $_[0];
        my $pos = $_[1];
        my $delimiter = $str->[$pos - 1];
        my $open_delimiter = $delimiter;
        exists($pair{$delimiter}) && ($delimiter = $pair{$delimiter});
        my $m = string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 0);
        if ($m) {;
            $m->{"capture"} = Perlito5::AST::Apply::->new("code", "qx", "arguments", [Perlito5::Match::flat($m)], "namespace", '')
        }
        return $m
    }
    sub Perlito5::Grammar::String::glob_quote_parse {
        my $str = $_[0];
        my $pos = $_[1];
        my $delimiter = $str->[$pos - 1];
        my $open_delimiter = $delimiter;
        exists($pair{$delimiter}) && ($delimiter = $pair{$delimiter});
        if ($str->[$pos] eq "<" && $str->[$pos + 1] eq ">" && $str->[$pos + 2] eq ">") {;
            return {"str", $str, "from", $pos, "to", $pos + 3, "capture", Perlito5::AST::Apply::->new("code", "readline", "arguments", [Perlito5::AST::Apply::->new("code", "<>", "arguments", [], "namespace", '', "bareword", 1)], "namespace", '')}
        }
        if ($str->[$pos] eq ">") {;
            return {"str", $str, "from", $pos, "to", $pos + 1, "capture", Perlito5::AST::Apply::->new("code", "readline", "arguments", [], "namespace", '')}
        }
        my $p = $pos;
        my $sigil = "::";
        if ($str->[$p] eq "\$") {
            $sigil = "\$";
            $p++
        }
        my $m_namespace = Perlito5::Grammar::optional_namespace_before_ident($str, $p);
        my $namespace = Perlito5::Match::flat($m_namespace);
        $p = $m_namespace->{"to"};
        my $m_name = Perlito5::Grammar::ident($str, $p);
        if ($m_name && $str->[$m_name->{"to"}] eq ">") {
            if ($sigil eq "::") {;
                return {"str", $str, "from", $pos, "to", $m_name->{"to"} + 1, "capture", Perlito5::AST::Apply::->new("code", "readline", "arguments", [Perlito5::AST::Apply::->new("code", Perlito5::Match::flat($m_name), "arguments", [], "namespace", $namespace, "bareword", 1)], "namespace", '')}
            }
            return {"str", $str, "from", $pos, "to", $m_name->{"to"} + 1, "capture", Perlito5::AST::Apply::->new("code", "readline", "arguments", [Perlito5::AST::Var::->new("sigil", $sigil, "name", Perlito5::Match::flat($m_name), "namespace", $namespace)], "namespace", '')}
        }
        my $m = string_interpolation_parse($str, $pos, $open_delimiter, $delimiter, 1);
        if ($m) {;
            $m->{"capture"} = Perlito5::AST::Apply::->new("code", "glob", "arguments", [Perlito5::Match::flat($m)], "namespace", '')
        }
        return $m
    }
    sub Perlito5::Grammar::String::tr_quote_parse {
        my $str = $_[0];
        my $pos = $_[1];
        my $delimiter = $str->[$pos - 1];
        my $open_delimiter = $delimiter;
        my $closing_delimiter = $delimiter;
        exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
        my $interpolate = 2;
        $delimiter eq "'" && ($interpolate = 3);
        my $part1 = string_interpolation_parse($str, $pos, $open_delimiter, $closing_delimiter, $interpolate);
        $part1 || return $part1;
        my $str_regex = Perlito5::Match::flat($part1);
        my $part2;
        my $m;
        my $p = $part1->{"to"};
        if (exists($pair{$delimiter})) {
            $m = Perlito5::Grammar::Space::opt_ws($str, $p);
            $p = $m->{"to"};
            $delimiter = $str->[$p];
            my $open_delimiter = $delimiter;
            $p++;
            $closing_delimiter = $delimiter;
            exists($pair{$delimiter}) && ($closing_delimiter = $pair{$delimiter});
            $interpolate = 2;
            $delimiter eq "'" && ($interpolate = 3);
            $part2 = string_interpolation_parse($str, $p, $open_delimiter, $closing_delimiter, $interpolate);
            $part2 || return $part2
        }
        else {
            $part2 = string_interpolation_parse($str, $p, $open_delimiter, $closing_delimiter, $interpolate);
            $part2 || return $part2
        }
        $p = $part2->{"to"};
        my $modifiers = '';
        $m = Perlito5::Grammar::ident($str, $p);
        if ($m) {
            $modifiers = Perlito5::Match::flat($m);
            $part2->{"to"} = $m->{"to"}
        }
        $part2->{"capture"} = Perlito5::AST::Apply::->new("code", "p5:tr", "arguments", [$str_regex, Perlito5::Match::flat($part2), Perlito5::AST::Buf::->new("buf", $modifiers), Perlito5::AST::Var::SCALAR_ARG()], "namespace", '');
        return $part2
    }
    sub Perlito5::Grammar::String::apply_quote_flags {
        (my($c), my($quote_flags)) = @_;
        length($c) || return $c;
        if ($quote_flags->{"l"}) {
            $c = lcfirst($c);
            delete($quote_flags->{"l"})
        }
        if ($quote_flags->{"u"}) {
            $c = ucfirst($c);
            delete($quote_flags->{"u"})
        }
        $quote_flags->{"L"} && ($c = lc($c));
        $quote_flags->{"U"} && ($c = uc($c));
        $quote_flags->{"Q"} && ($c = quotemeta($c));
        return $c
    }
    sub Perlito5::Grammar::String::string_interpolation_parse {
        my $str = $_[0];
        my $pos = $_[1];
        my $open_delimiter = $_[2];
        my $delimiter = $_[3];
        my $interpolate = $_[4];
        my $quote_flags = $_[5] || {};
        my $interpolate_vars = ($interpolate == 1 || $interpolate == 2);
        my $p = $pos;
        my $balanced = $open_delimiter && exists($pair{$open_delimiter});
        my @args;
        my $buf = '';
        my $d1 = substr($delimiter, 0, 1);
        while ($p < @{$str} && !($str->[$p] eq $d1 && join('', @{$str}[$p .. $p + length($delimiter) - 1]) eq $delimiter)) {
            my $c = $str->[$p];
            my $c2 = $str->[$p + 1];
            my $m;
            my $more = '';
            if ($balanced && $c eq "\\" && ($c2 eq $open_delimiter || $c2 eq $delimiter)) {
                $p++;
                $c = $c2
            }
            elsif ($balanced && $c eq $open_delimiter) {
                $buf .= $c;
                $p++;
                $m = string_interpolation_parse($str, $p, $open_delimiter, $delimiter, $interpolate, $quote_flags);
                $more = $delimiter
            }
            elsif ($interpolate_vars && ($c eq "\$" || $c eq "\@")) {
                my $match = Perlito5::Grammar::String::double_quoted_var($str, $p, $delimiter, $interpolate);
                if ($match) {
                    my $ast = $match->{"capture"};
                    if ($quote_flags->{"l"}) {
                        $ast = Perlito5::AST::Apply::->new("namespace", '', "code", "lcfirst", "arguments", [$ast]);
                        delete($quote_flags->{"l"})
                    }
                    if ($quote_flags->{"u"}) {
                        $ast = Perlito5::AST::Apply::->new("namespace", '', "code", "ucfirst", "arguments", [$ast]);
                        delete($quote_flags->{"u"})
                    }
                    $quote_flags->{"L"} && ($ast = Perlito5::AST::Apply::->new("namespace", '', "code", "lc", "arguments", [$ast]));
                    $quote_flags->{"U"} && ($ast = Perlito5::AST::Apply::->new("namespace", '', "code", "uc", "arguments", [$ast]));
                    $quote_flags->{"Q"} && ($ast = Perlito5::AST::Apply::->new("namespace", '', "code", "quotemeta", "arguments", [$ast]));
                    $match->{"capture"} = $ast
                }
                $m = $match
            }
            elsif ($c eq "\\") {
                if ($interpolate) {
                    if ($c2 eq "E") {
                        my $flag_to_reset = $quote_flags->{"last_flag"};
                        if ($flag_to_reset) {
                            delete($quote_flags->{$flag_to_reset});
                            delete($quote_flags->{"last_flag"})
                        }
                        else {;
                            $quote_flags = {}
                        }
                        $p += 1;
                        $c = ''
                    }
                    elsif ($c2 eq "L") {
                        $quote_flags->{$c2} = 1;
                        delete($quote_flags->{"U"});
                        $quote_flags->{"last_flag"} = $c2;
                        $p += 1;
                        $c = ''
                    }
                    elsif ($c2 eq "U") {
                        $quote_flags->{$c2} = 1;
                        delete($quote_flags->{"L"});
                        $quote_flags->{"last_flag"} = $c2;
                        $p += 1;
                        $c = ''
                    }
                    elsif ($c2 eq "Q") {
                        $quote_flags->{$c2} = 1;
                        $quote_flags->{"last_flag"} = $c2;
                        $p += 1;
                        $c = ''
                    }
                    elsif ($c2 eq "l") {
                        $quote_flags->{"u"} || ($quote_flags->{$c2} = 1);
                        $p += 1;
                        $c = ''
                    }
                    elsif ($c2 eq "u") {
                        $quote_flags->{"l"} || ($quote_flags->{$c2} = 1);
                        $p += 1;
                        $c = ''
                    }
                }
                if ($c) {
                    if ($interpolate == 2) {;
                        $m = {"str", $str, "from", $p, "to", $p + 2, "capture", Perlito5::AST::Buf::->new("buf", $str->[$p] . $str->[$p + 1])}
                    }
                    elsif ($interpolate == 1) {;
                        $m = Perlito5::Grammar::String::double_quoted_unescape($str, $p)
                    }
                    else {;
                        $m = $c2 eq "\\" ? {"str", $str, "from", $p, "to", $p + 2, "capture", Perlito5::AST::Buf::->new("buf", "\\")} : $c2 eq "'" ? {"str", $str, "from", $p, "to", $p + 2, "capture", Perlito5::AST::Buf::->new("buf", "'")} : 0
                    }
                }
            }
            if ($m) {
                my $obj = Perlito5::Match::flat($m);
                if (ref($obj) eq "Perlito5::AST::Buf") {
                    $buf .= apply_quote_flags($obj->{"buf"}, $quote_flags);
                    $obj = undef
                }
                if ($obj) {
                    if (length($buf)) {
                        push(@args, Perlito5::AST::Buf::->new("buf", $buf));
                        $buf = ''
                    }
                    push(@args, $obj)
                }
                $p = $m->{"to"};
                $buf .= $more
            }
            else {
                $p++;
                if ($c eq chr(10) || $c eq chr(13)) {
                    my $m = here_doc($str, $p);
                    if ($p != $m->{"to"}) {;
                        $p = $m->{"to"}
                    }
                    else {;
                        $buf .= apply_quote_flags($c, $quote_flags)
                    }
                }
                else {;
                    $buf .= apply_quote_flags($c, $quote_flags)
                }
            }
        }
        if (length($buf)) {;
            push(@args, Perlito5::AST::Buf::->new("buf", $buf))
        }
        join('', @{$str}[$p .. $p + length($delimiter) - 1]) ne $delimiter && Perlito5::Compiler::error("Can't find string terminator '" . $delimiter . "' anywhere before EOF");
        $p += length($delimiter);
        my $ast;
        if (!@args) {;
            $ast = Perlito5::AST::Buf::->new("buf", '')
        }
        elsif (@args == 1) {;
            $ast = $args[0]
        }
        else {;
            $ast = Perlito5::AST::Apply::->new("namespace", '', "code", "list:<.>", "arguments", \@args)
        }
        return {"str", $str, "from", $pos, "to", $p, "capture", $ast}
    }
    our @Here_doc;
    sub Perlito5::Grammar::String::here_doc_wanted {
        my $str = $_[0];
        my $pos = $_[1];
        my $delimiter;
        my $type = "double_quote";
        my $indented = 0;
        my $p = $pos;
        if ($str->[$p] eq "<" && $str->[$p + 1] eq "<") {
            $p += 2;
            my $quote = $str->[$p];
            if ($quote eq "~") {
                $indented = 1;
                $p++;
                $quote = $str->[$p]
            }
            if ($quote eq "'" || $quote eq "\"") {
                $p += 1;
                my $m = string_interpolation_parse($_[0], $p, $quote, $quote, 0);
                if ($m) {
                    $p = $m->{"to"};
                    $delimiter = Perlito5::Match::flat($m)->{"buf"};
                    $type = $quote eq "'" ? "single_quote" : "double_quote"
                }
            }
            else {
                $quote eq "\\" && ($p += 1);
                my $m = Perlito5::Grammar::ident($str, $p);
                if ($m) {
                    $p = $m->{"to"};
                    $delimiter = Perlito5::Match::flat($m);
                    $type = $quote eq "\\" ? "single_quote" : "double_quote"
                }
                else {
                    $Perlito5::WARNINGS && warn("Use of bare << to mean <<\"\" is deprecated");
                    $delimiter = '';
                    $type = "double_quote"
                }
            }
        }
        if (!defined($delimiter)) {;
            return 0
        }
        my $placeholder = Perlito5::AST::Apply::->new("code", "list:<.>", "namespace", '', "arguments", [Perlito5::AST::Apply::->new("code", "list:<.>", "namespace", '', "arguments", [])]);
        push(@Here_doc, [$type, $placeholder->{"arguments"}->[0]->{"arguments"}, $delimiter, $indented]);
        return {"str", $str, "from", $pos, "to", $p, "capture", ["term", $placeholder]}
    }
    sub Perlito5::Grammar::String::newline {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((("
" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $m = $MATCH;
                    if (!(("\x{d}" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))) {;
                        $MATCH = $m
                    }
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((("\x{d}" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $m = $MATCH;
                    if (!(("
" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))) {;
                        $MATCH = $m
                    }
                    1
                }))
            })
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::String::here_doc {
        my $str = $_[0];
        my $pos = $_[1];
        if (!@Here_doc) {;
            return {"str", $str, "from", $pos, "to", $pos}
        }
        my $p = $pos;
        my $here = shift(@Here_doc);
        my $type = $here->[0];
        my $result = $here->[1];
        my $delimiter = $here->[2];
        my $indented = $here->[3];
        while ($p < @{$str}) {
            my $spaces = '';
            my $p0 = $p;
            if ($indented) {
                while ($p < @{$str}) {
                    $str->[$p] ne " " && $str->[$p] ne "\x{9}" && last;
                    $p++
                }
                $spaces = join('', @{$str}[$p0 .. $p - 1])
            }
            if (join('', @{$str}[$p .. $p + length($delimiter) - 1]) eq $delimiter) {
                my $c = $str->[$p + length($delimiter)];
                if ($c eq '' || $c eq " " || $c eq "\x{9}" || $c eq chr(10) || $c eq chr(13)) {
                    my @here_string = split("
", join('', @{$str}[$pos .. $p - 1]), -1);
                    if (length($spaces)) {
                        my $l = length($spaces);
                        for my $i (0 .. $#here_string) {
                            if (substr($here_string[$i], 0, $l) eq $spaces) {;
                                $here_string[$i] = substr($here_string[$i], $l)
                            }
                            else {;
                                Perlito5::Compiler::error("Indentation on line " . $i . " of here-doc doesn't match delimiter")
                            }
                        }
                    }
                    if ($type eq "single_quote") {;
                        push(@{$result}, Perlito5::AST::Buf::->new("buf", join("
", @here_string)))
                    }
                    else {
                        my $m;
                        my $str = [split('', join("
", @here_string, $delimiter . "
"))];
                        $m = string_interpolation_parse($str, 0, '', "
" . $delimiter . "
", 1);
                        if ($m) {;
                            push(@{$result}, Perlito5::Match::flat($m))
                        }
                        else {;
                            Perlito5::Compiler::error("Can't find string terminator \"" . $delimiter . "\" anywhere before EOF")
                        }
                    }
                    $p += length($delimiter);
                    my $m = newline($str, $p);
                    if ($p >= @{$str} || $m) {
                        $m && ($p = $m->{"to"});
                        return {"str", $str, "from", $pos, "to", $p - 1}
                    }
                }
            }
            while ($p < @{$str} && ($str->[$p] ne chr(10) && $str->[$p] ne chr(13))) {;
                $p++
            }
            while ($p < @{$str} && ($str->[$p] eq chr(10) || $str->[$p] eq chr(13))) {;
                $p++
            }
        }
        Perlito5::Compiler::error("Can't find string terminator \"" . $delimiter . "\" anywhere before EOF")
    }
    sub Perlito5::Grammar::String::double_quoted_unescape {
        my $str = $_[0];
        my $pos = $_[1];
        my $c2 = $str->[$pos + 1];
        my $m;
        if (exists($escape_sequence{$c2})) {;
            $m = {"str", $str, "from", $pos, "to", $pos + 2, "capture", Perlito5::AST::Buf::->new("buf", chr($escape_sequence{$c2}))}
        }
        elsif ($c2 eq "c") {
            my $c3 = ord(uc($str->[$pos + 2])) - ord("A") + 1;
            $c3 < 0 && ($c3 = 128 + $c3);
            $m = {"str", $str, "from", $pos, "to", $pos + 3, "capture", Perlito5::AST::Buf::->new("buf", chr($c3))}
        }
        elsif ($c2 eq "x") {
            if ($str->[$pos + 2] eq "{") {
                my $p = $pos + 3;
                $p++
                    while $p < @{$str} && $str->[$p] ne "}";
                my $hex_code = join('', @{$str}[$pos + 3 .. $p - 1]);
                $hex_code || ($hex_code = 0);
                my $tmp = oct("0x" . $hex_code);
                $m = {"str", $str, "from", $pos, "to", $p + 1, "capture", Perlito5::AST::Buf::->new("buf", chr($tmp))}
            }
            else {
                my $p = $pos + 2;
                $hex{uc($str->[$p])} && $p++;
                $hex{uc($str->[$p])} && $p++;
                my $hex_code = join('', @{$str}[$pos + 2 .. $p - 1]);
                $hex_code || ($hex_code = 0);
                my $tmp = oct("0x" . $hex_code);
                $m = {"str", $str, "from", $pos, "to", $p, "capture", Perlito5::AST::Buf::->new("buf", chr($tmp))}
            }
        }
        elsif (exists($octal{$c2})) {
            my $p = $pos + 1;
            $octal{$str->[$p]} && $p++;
            $octal{$str->[$p]} && $p++;
            $octal{$str->[$p]} && $p++;
            my $oct_code = join('', @{$str}[$pos + 1 .. $p - 1]);
            my $tmp = oct($oct_code);
            $m = {"str", $str, "from", $pos, "to", $p, "capture", Perlito5::AST::Buf::->new("buf", chr($tmp))}
        }
        elsif ($c2 eq "N") {;
            Perlito5::Compiler::error("TODO - \\N{charname} not implemented; requires 'use charnames'")
        }
        else {;
            $m = {"str", $str, "from", $pos, "to", $pos + 2, "capture", Perlito5::AST::Buf::->new("buf", $c2)}
        }
        return $m
    }
    sub Perlito5::Grammar::String::double_quoted_var_with_subscript {
        my $m_var = $_[0];
        my $interpolate = $_[1];
        my $str = $m_var->{"str"};
        my $pos = $m_var->{"to"};
        my $p = $pos;
        my $m_index;
        if ($str->[$p] eq "-" && $str->[$p + 1] eq ">" && $str->[$p + 2] eq "[") {
            $p += 3;
            $m_index = Perlito5::Grammar::Expression::list_parse($str, $p);
            $m_index || Perlito5::Compiler::error("syntax error");
            my $exp = $m_index->{"capture"};
            $p = $m_index->{"to"};
            ($exp eq "*undef*" || $str->[$p] ne "]") && Perlito5::Compiler::error("syntax error");
            $p++;
            $m_index->{"capture"} = Perlito5::AST::Call::->new("method", "postcircumfix:<[ ]>", "invocant", $m_var->{"capture"}, "arguments", $exp);
            $m_index->{"to"} = $p;
            return double_quoted_var_with_subscript($m_index, $interpolate)
        }
        if ($str->[$p] eq "-" && $str->[$p + 1] eq ">" && $str->[$p + 2] eq "{") {
            $pos += 2;
            $m_index = Perlito5::Grammar::Expression::term_curly($str, $pos);
            $m_index || Perlito5::Compiler::error("syntax error");
            $m_index->{"capture"} = Perlito5::AST::Call::->new("method", "postcircumfix:<{ }>", "invocant", $m_var->{"capture"}, "arguments", Perlito5::Match::flat($m_index)->[2]->[0]);
            return double_quoted_var_with_subscript($m_index, $interpolate)
        }
        if ($str->[$p] eq "[") {
            if ($interpolate == 2) {
                my $m = Perlito5::Grammar::Number::term_digit($str, $p + 1) || ($str->[$p + 1] eq "-" && Perlito5::Grammar::Number::term_digit($str, $p + 2)) || Perlito5::Grammar::Sigil::term_sigil($str, $p + 1);
                $m || return $m_var;
                $str->[$m->{"to"}] eq "]" || return $m_var
            }
            $p++;
            $m_index = Perlito5::Grammar::Expression::list_parse($str, $p);
            if ($m_index) {
                my $exp = $m_index->{"capture"};
                $p = $m_index->{"to"};
                if ($exp ne "*undef*" && $str->[$p] eq "]") {
                    $p++;
                    my $value = $m_var->{"capture"};
                    if (ref($value) eq "Perlito5::AST::Var") {;
                        $value->{"_real_sigil"} = "\@"
                    }
                    $m_index->{"capture"} = Perlito5::AST::Index::->new("obj", $value, "index_exp", $exp);
                    $m_index->{"to"} = $p;
                    return double_quoted_var_with_subscript($m_index, $interpolate)
                }
            }
        }
        $m_index = Perlito5::Grammar::Expression::term_curly($str, $pos);
        if ($m_index) {
            my $value = $m_var->{"capture"};
            if (ref($value) eq "Perlito5::AST::Var") {;
                $value->{"_real_sigil"} = "%"
            }
            $m_index->{"capture"} = Perlito5::AST::Lookup::->new("obj", $value, "index_exp", Perlito5::Match::flat($m_index)->[2]->[0]);
            return double_quoted_var_with_subscript($m_index, $interpolate)
        }
        return $m_var
    }
    sub Perlito5::Grammar::String::double_quoted_var {
        my $str = $_[0];
        my $pos = $_[1];
        my $delimiter = $_[2];
        my $interpolate = $_[3];
        my $c = $str->[$pos];
        my $c2 = $str->[$pos + 1];
        if ($c eq "\$" && $c2 eq ")") {;
            return 0
        }
        elsif ($c eq "\$" && $c2 eq "{") {
            my $m = Perlito5::Grammar::Sigil::term_sigil($str, $pos);
            $m || return $m;
            my $var = Perlito5::Match::flat($m)->[1];
            $m->{"capture"} = $var;
            return $m
        }
        elsif ($c eq "\$" && $c2 eq "\$" && !Perlito5::Grammar::word($str, $pos + 2)) {;
            return {"str", $str, "capture", Perlito5::AST::Var::->new("name", "\$", "sigil", "\$", "namespace", ''), "from", $pos, "to", $pos + 2}
        }
        elsif ($c eq "\$" && join('', @{$str}[$pos + 1 .. $pos + length($delimiter)]) ne $delimiter) {
            my $m = Perlito5::Grammar::Sigil::term_sigil($str, $pos);
            $m || return $m;
            $m->{"capture"} = $m->{"capture"}->[1];
            return double_quoted_var_with_subscript($m, $interpolate)
        }
        elsif ($c eq "\@" && join('', @{$str}[$pos + 1 .. $pos + length($delimiter)]) ne $delimiter && ($c2 lt 0 || $c2 gt 9)) {
            my $m = Perlito5::Grammar::Sigil::term_sigil($str, $pos);
            $m || return $m;
            $m->{"capture"} = $m->{"capture"}->[1];
            $m = double_quoted_var_with_subscript($m, $interpolate);
            $m->{"capture"} = Perlito5::AST::Apply::->new("code", "join", "arguments", [Perlito5::AST::Var::->new("name", "\"", "sigil", "\$", "namespace", ''), $m->{"capture"}], "namespace", '');
            return $m
        }
        return 0
    }
    Perlito5::Grammar::Precedence::add_term("'", \&term_q_quote);
    Perlito5::Grammar::Precedence::add_term("\"", \&term_qq_quote);
    Perlito5::Grammar::Precedence::add_term("/", \&term_m_quote);
    Perlito5::Grammar::Precedence::add_term("<", \&term_glob);
    Perlito5::Grammar::Precedence::add_term("<<>>", \&term_glob);
    Perlito5::Grammar::Precedence::add_term("<<", \&here_doc_wanted);
    Perlito5::Grammar::Precedence::add_term("`", \&term_qx);
    Perlito5::Grammar::Precedence::add_term("m", \&term_m_quote);
    Perlito5::Grammar::Precedence::add_term("q", \&term_q_quote);
    Perlito5::Grammar::Precedence::add_term("qq", \&term_qq_quote);
    Perlito5::Grammar::Precedence::add_term("qw", \&term_qw_quote);
    Perlito5::Grammar::Precedence::add_term("qx", \&term_qx);
    Perlito5::Grammar::Precedence::add_term("qr", \&term_qr_quote);
    Perlito5::Grammar::Precedence::add_term("s", \&term_s_quote);
    Perlito5::Grammar::Precedence::add_term("tr", \&term_tr_quote);
    Perlito5::Grammar::Precedence::add_term("y", \&term_tr_quote);
    1
}
{
    package main;
    package Perlito5::Grammar::Sigil;
    my %special_var = ("\$_", '', "\$&", '', "\$`", '', "\$'", '', "\$+", '', "\@+", '', "%+", '', "\$.", '', "\$/", '', "\$|", '', "\$,", '', "\$\\", '', "\$\"", '', "\$;", '', "\$%", '', "\$=", '', "\$-", '', "\@-", '', "%-", '', "\$~", '', "\$^", '', "\$:", '', "\$?", '', "\$!", '', "%!", '', "\$\@", '', "\$\$", '', "\$<", '', "\$>", '', "\$(", '', "\$)", '', "\$[", '', "\$]", '', "\$}", '', "\@_", '', "*_", '', "*&", '', "*`", '', "*'", '', "*+", '', "*.", '', "*/", '', "*|", '', "*,", '', "*\\", '', "*\"", '', "*;", '', "*%", '', "*=", '', "*-", '', "*~", '', "*^", '', "*:", '', "*?", '', "*!", '', "*\@", '', "*\$", '', "*<", '', "*>", '', "*(", '', "*)", '', "*[", '', "*]", '', "*_", '', "**", '', "*#", '', "\$#+", '', "\$#-", '', "\$#_", '');
    sub Perlito5::Grammar::Sigil::term_special_var {
        my $str = $_[0];
        my $pos = $_[1];
        my $len = 0;
        my $s = $str->[$pos] . $str->[$pos + 1] . $str->[$pos + 2];
        if ($s eq "\$#[") {;
            $len = 2
        }
        elsif (exists($special_var{$s})) {;
            $len = length($s)
        }
        else {
            $s = $str->[$pos] . $str->[$pos + 1];
            if (exists($special_var{$s})) {;
                $len = 2
            }
        }
        if ($len) {
            my $c0 = $str->[$pos + $len - 1];
            my $c1 = $str->[$pos + $len];
            if (($c0 eq "\$" || $c0 eq "\@" || $c0 eq "%" || $c0 eq "*" || $c0 eq "&") && ($c1 eq "\$" || $c1 eq "\@" || $c1 eq "%" || $c1 eq "*" || $c1 eq "&" || ($c1 ge "a" && $c1 le "z") || ($c1 ge "A" && $c1 le "Z") || ($c1 ge 0 && $c1 le 9))) {}
            else {;
                return {"str", $str, "from", $pos, "to", $pos + $len, "capture", ["term", Perlito5::AST::Var::->new("sigil", substr($s, 0, $len - 1), "namespace", $special_var{$s}, "name", substr($s, $len - 1, 1), "_namespace", "main")]}
            }
        }
        return 0
    }
    my %sigil = ("\$", 1, "%", 1, "\@", 1, "&", 1, "*", 1);
    sub Perlito5::Grammar::Sigil::term_sigil {
        my $str = $_[0];
        my $pos = $_[1];
        my $c1 = $str->[$pos];
        exists($sigil{$c1}) || return;
        my $p = $pos + 1;
        my $sigil = $c1;
        if ($c1 eq "\$" && $str->[$pos + 1] eq "#") {
            $sigil = "\$#";
            $p++
        }
        my $m = Perlito5::Grammar::Space::opt_ws($str, $p);
        $p = $m->{"to"};
        my $p0 = $p;
        $c1 = $str->[$p];
        my $q = $p + 1;
        if ($c1 eq "{") {
            my $p = $q;
            $m = Perlito5::Grammar::Space::opt_ws($str, $p);
            $p = $m->{"to"};
            $m = Perlito5::Grammar::optional_namespace_before_ident($str, $p);
            if ($m) {
                my $namespace = Perlito5::Match::flat($m);
                my $pos = $m->{"to"};
                my $n = Perlito5::Grammar::var_name($str, $m->{"to"});
                my $name;
                if ($n) {
                    $name = Perlito5::Match::flat($n);
                    $pos = $n->{"to"}
                }
                if ($namespace || $name) {
                    my $spc = Perlito5::Grammar::Space::opt_ws($str, $pos);
                    my $pos = $spc->{"to"};
                    if ($str->[$pos] eq "{" || $str->[$pos] eq "[" || $str->[$pos] eq "}") {
                        $m->{"capture"} = Perlito5::AST::Var::->new("sigil", $sigil, "namespace", $namespace, "name", $name);
                        $m->{"to"} = $spc->{"to"};
                        $m = Perlito5::Grammar::String::double_quoted_var_with_subscript($m);
                        $m->{"capture"} = ["term", $m->{"capture"}];
                        $spc = Perlito5::Grammar::Space::opt_ws($str, $m->{"to"});
                        my $p = $spc->{"to"};
                        if ($str->[$p] eq "}") {
                            $m->{"to"} = $p + 1;
                            return $m
                        }
                    }
                    elsif ($str->[$pos] eq "-" && $str->[$pos + 1] eq ">") {
                        my $spc = Perlito5::Grammar::Space::opt_ws($str, $pos + 2);
                        my $pos = $spc->{"to"};
                        if ($str->[$pos] eq "{" || $str->[$pos] eq "[") {
                            $m->{"capture"} = Perlito5::AST::Var::->new("sigil", $sigil, "namespace", ($namespace || $Perlito5::PKG_NAME), "name", $name);
                            $m->{"to"} = $spc->{"to"};
                            $m = Perlito5::Grammar::String::double_quoted_var_with_subscript($m);
                            $m->{"capture"} = ["term", $m->{"capture"}];
                            $spc = Perlito5::Grammar::Space::opt_ws($str, $m->{"to"});
                            my $p = $spc->{"to"};
                            if ($str->[$p] eq "}") {
                                $m->{"to"} = $p + 1;
                                return $m
                            }
                        }
                    }
                }
            }
            my $caret = Perlito5::Grammar::caret_char($str, $p);
            if ($caret) {
                my $p = $caret->{"to"};
                my $name = Perlito5::Match::flat($caret);
                $m = Perlito5::Grammar::var_name($str, $p);
                if ($m) {
                    $name = $name . Perlito5::Match::flat($m);
                    $p = $m->{"to"}
                }
                if ($str->[$p] eq "}") {
                    $caret->{"capture"} = ["term", Perlito5::AST::Var::->new("name", $name, "namespace", '', "sigil", $sigil)];
                    $caret->{"to"} = $p + 1;
                    return $caret
                }
            }
            my $special = $sigil . $str->[$p];
            if (exists($special_var{$special})) {
                my $m = Perlito5::Grammar::Space::opt_ws($str, $p + 1);
                my $p2 = $m->{"to"};
                my $c2 = $str->[$p2];
                if ($c2 eq "}") {
                    $m->{"to"} = $p2 + 1;
                    $m->{"capture"} = ["term", Perlito5::AST::Var::->new("sigil", $sigil, "namespace", '', "name", $str->[$p], ($sigil eq "\$#" ? ("_real_sigil", "\@") : ()), "_namespace", "main")];
                    return $m
                }
            }
            if ($str->[$p] eq "}") {;
                Perlito5::Compiler::error("syntax error")
            }
            $m = Perlito5::Grammar::block($str, $p0);
            if ($m) {
                my $ast = Perlito5::Match::flat($m);
                if (@{$ast->{"stmts"}} == 1 && (ref($ast->{"stmts"}->[0]) eq "Perlito5::AST::Apply" || ref($ast->{"stmts"}->[0]) eq "Perlito5::AST::Call" || ref($ast->{"stmts"}->[0]) eq "Perlito5::AST::Var" || ref($ast->{"stmts"}->[0]) eq "Perlito5::AST::Buf" || ref($ast->{"stmts"}->[0]) eq "Perlito5::AST::Index" || ref($ast->{"stmts"}->[0]) eq "Perlito5::AST::Lookup")) {
                    $m->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", "prefix:<" . $sigil . ">", "namespace", '', "arguments", [$ast->{"stmts"}->[0]], "_strict_refs", (${^H} & $Perlito5::STRICT_REFS))];
                    return $m
                }
                $m->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", "prefix:<" . $sigil . ">", "arguments", [Perlito5::AST::Apply::->new("code", "do", "namespace", '', "arguments", [$ast])], "_strict_refs", (${^H} & $Perlito5::STRICT_REFS))];
                return $m
            }
        }
        my $caret = Perlito5::Grammar::caret_char($str, $p);
        if ($caret) {
            my $name = Perlito5::Match::flat($caret);
            $caret->{"capture"} = ["term", Perlito5::AST::Var::->new("name", $name, "namespace", '', "sigil", $sigil)];
            return $caret
        }
        if ($c1 eq "\$") {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $p + 1);
            my $p2 = $m2->{"to"};
            my $c2 = $str->[$p2];
            if ($c2 ne "," && $c2 ne ";") {
                $m = term_sigil($str, $p);
                if ($m) {
                    $m->{"capture"} = ["term", Perlito5::AST::Apply::->new("arguments", [$m->{"capture"}->[1]], "code", "prefix:<" . $sigil . ">", "namespace", '', "_strict_refs", (${^H} & $Perlito5::STRICT_REFS))];
                    return $m
                }
            }
        }
        $m = Perlito5::Grammar::optional_namespace_before_ident($str, $p);
        if ($m) {
            my $namespace = Perlito5::Match::flat($m);
            my $n = Perlito5::Grammar::var_name($str, $m->{"to"});
            if ($n) {
                $n->{"capture"} = ["term", Perlito5::AST::Var::->new("sigil", $sigil, "namespace", $namespace, "name", Perlito5::Match::flat($n), ($sigil eq "\$#" ? ("_real_sigil", "\@") : ()))];
                return $n
            }
            if ($namespace) {
                $m->{"capture"} = ["term", Perlito5::AST::Var::->new("sigil", $sigil, "namespace", $namespace, "name", undef, ($sigil eq "\$#" ? ("_real_sigil", "\@") : ()))];
                return $m
            }
        }
        return term_special_var($str, $pos)
    }
    Perlito5::Grammar::Precedence::add_term("\$", \&term_sigil);
    Perlito5::Grammar::Precedence::add_term("\@", \&term_sigil);
    Perlito5::Grammar::Precedence::add_term("%", \&term_sigil);
    Perlito5::Grammar::Precedence::add_term("&", \&term_sigil);
    Perlito5::Grammar::Precedence::add_term("*", \&term_sigil);
    1
}
{
    package main;
    package Perlito5::Grammar::Use;
    my %Perlito_internal_module = ("strict", "Perlito5X::strict", "warnings", "Perlito5X::warnings", "warnings::register", "Perlito5X::warnings::register", "feature", "Perlito5X::feature", "utf8", "Perlito5X::utf8", "bytes", "Perlito5X::bytes", "re", "Perlito5X::re", "encoding", "Perlito5X::encoding", "Carp", "Perlito5X::Carp", "Config", "Perlito5X::Config", "Exporter", "Perlito5X::Exporter", "Data::Dumper", "Perlito5X::Dumper", "UNIVERSAL", "Perlito5X::UNIVERSAL", "JSON", "Perlito5X::JSON", "Tie::Hash", "Perlito5X::Tie::Hash", "Tie::Array", "Perlito5X::Tie::Array", "Tie::Scalar", "Perlito5X::Tie::Scalar");
    sub Perlito5::Grammar::Use::register_internal_module {
        (my($module), my($real_name)) = @_;
        $Perlito_internal_module{$module} = $real_name
    }
    sub Perlito5::Grammar::Use::use_decl {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                (("u" eq $str->[$MATCH->{"to"} + 0]) && ("s" eq $str->[$MATCH->{"to"} + 1]) && ("e" eq $str->[$MATCH->{"to"} + 2]) && ($MATCH->{"to"} += 3))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (("n" eq $str->[$MATCH->{"to"} + 0]) && ("o" eq $str->[$MATCH->{"to"} + 1]) && ($MATCH->{"to"} += 2))
            })
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Use::version_string {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((do {
                    my $m2 = Perlito5::Grammar::Number::val_version($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Number::val_version"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{"capture"} = $MATCH->{"Perlito5::Grammar::Number::val_version"}->{"capture"};
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((do {
                    my $m2 = Perlito5::Grammar::Number::term_digit($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Number::term_digit"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $version = $MATCH->{"Perlito5::Grammar::Number::term_digit"}->{"capture"}->[1]->{"buf"} || $MATCH->{"Perlito5::Grammar::Number::term_digit"}->{"capture"}->[1]->{"int"} || $MATCH->{"Perlito5::Grammar::Number::term_digit"}->{"capture"}->[1]->{"num"};
                    $MATCH->{"capture"} = Perlito5::AST::Buf::->new("buf", $version);
                    1
                }))
            })
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Use::term_require {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((("r" eq $str->[$MATCH->{"to"} + 0]) && ("e" eq $str->[$MATCH->{"to"} + 1]) && ("q" eq $str->[$MATCH->{"to"} + 2]) && ("u" eq $str->[$MATCH->{"to"} + 3]) && ("i" eq $str->[$MATCH->{"to"} + 4]) && ("r" eq $str->[$MATCH->{"to"} + 5]) && ("e" eq $str->[$MATCH->{"to"} + 6]) && ($MATCH->{"to"} += 7)) && (do {
            my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((do {
                    my $m2 = version_string($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"version_string"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $version = $MATCH->{"version_string"}->{"capture"};
                    $version->{"is_version_string"} = 1;
                    $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", "require", "namespace", '', "arguments", [$version])];
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((do {
                    my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::full_ident"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $module_name = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::full_ident"});
                    my $filename = modulename_to_filename($module_name);
                    $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", "require", "namespace", '', "arguments", [Perlito5::AST::Buf::->new("buf", $filename)])];
                    1
                }))
            })
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Use::stmt_use {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((do {
            my $m2 = use_decl($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"use_decl"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((do {
                    my $m2 = version_string($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"version_string"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $version = $MATCH->{"version_string"}->{"capture"}->{"buf"};
                    Perlito5::test_perl_version($version);
                    $MATCH->{"capture"} = Perlito5::Grammar::Block::ast_nop();
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((do {
                    my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::full_ident"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $m = $MATCH;
                    if (!((("-" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                        my $m2 = Perlito5::Grammar::ident($str, $MATCH->{"to"});
                        if ($m2) {
                            $MATCH->{"to"} = $m2->{"to"};
                            if (exists($MATCH->{"Perlito5::Grammar::ident"})) {;
                                push(@{$MATCH->{"Perlito5::Grammar::ident"}}, $m2)
                            }
                            else {;
                                $MATCH->{"Perlito5::Grammar::ident"} = [$m2]
                            }
                            1
                        }
                        else {;
                            0
                        }
                    }))) {;
                        $MATCH = $m
                    }
                    1
                }) && (do {
                    my $m = $MATCH;
                    if (!((do {
                        my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
                        if ($m2) {
                            $MATCH->{"to"} = $m2->{"to"};
                            1
                        }
                        else {;
                            0
                        }
                    }) && (do {
                        my $m2 = version_string($str, $MATCH->{"to"});
                        if ($m2) {
                            $MATCH->{"to"} = $m2->{"to"};
                            if (exists($MATCH->{"version_string"})) {;
                                push(@{$MATCH->{"version_string"}}, $m2)
                            }
                            else {;
                                $MATCH->{"version_string"} = [$m2]
                            }
                            1
                        }
                        else {;
                            0
                        }
                    }) && (do {
                        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                        if ($m2) {
                            $MATCH->{"to"} = $m2->{"to"};
                            1
                        }
                        else {;
                            0
                        }
                    }) && (do {
                        my $tmp = $MATCH;
                        $MATCH = {"from", $tmp->{"to"}, "to", $tmp->{"to"}};
                        my $res = (("," eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1));
                        $MATCH = $tmp;
                        $res ? 0 : 1
                    }))) {;
                        $MATCH = $m
                    }
                    1
                }) && (do {
                    my $pos1 = $MATCH->{"to"};
                    (do {;
                        (do {
                            my $m2 = Perlito5::Grammar::Expression::exp_parse($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                $MATCH->{"Perlito5::Grammar::Expression::exp_parse"} = $m2;
                                1
                            }
                            else {;
                                0
                            }
                        })
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        (do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                1
                            }
                            else {;
                                0
                            }
                        })
                    })
                }) && (do {
                    my $version = $MATCH->{"version_string"}->[0]->{"capture"}->{"buf"};
                    my $list = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::exp_parse"});
                    if (ref($list) eq "Perlito5::AST::Buf") {;
                        $list = [$list->{"buf"}]
                    }
                    elsif ($list) {
                        Perlito5::Grammar::Scope::check_variable_declarations();
                        my $ast = Perlito5::AST::Block::->new("stmts", [Perlito5::AST::Apply::->new("code", "circumfix:<[ ]>", "arguments", [$list])]);
                        $list = Perlito5::Grammar::Block::eval_begin_block($ast)
                    }
                    else {;
                        $list = undef
                    }
                    my $full_ident = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::full_ident"});
                    $Perlito5::PACKAGES->{$full_ident} = 1;
                    my $use_decl = Perlito5::Match::flat($MATCH->{"use_decl"});
                    if ($use_decl eq "use" && $full_ident eq "vars" && $list) {
                        my $code = "our (" . join(", ", @{$list}) . ")";
                        my $m = Perlito5::Grammar::Statement::statement_parse([split('', $code)], 0);
                        !$m && Perlito5::Compiler::error("not a valid variable name: " . join(${"\""}, @{$list}));
                        $MATCH->{"capture"} = $m->{"capture"}
                    }
                    elsif ($use_decl eq "use" && $full_ident eq "constant") {
                        my @ast;
                        if ($list) {
                            my $name = shift(@{$list});
                            if (ref($name) eq "HASH") {;
                                for my $key (sort {;
                                    $a cmp $b
                                } keys(%{$name})) {
                                    my $code = "sub " . $key . " () { " . Perlito5::Dumper::_dumper($name->{$key}) . " }";
                                    my $m = Perlito5::Grammar::Statement::statement_parse([split('', $code)], 0);
                                    !$m && Perlito5::Compiler::error("not a valid constant: " . join(${"\""}, @{$list}));
                                    push(@ast, $m->{"capture"})
                                }
                            }
                            else {
                                my $code = "sub " . $name . " () { (" . join(", ", map {;
                                    Perlito5::Dumper::_dumper($_)
                                } @{$list}) . ") }";
                                my $m = Perlito5::Grammar::Statement::statement_parse([split('', $code)], 0);
                                !$m && Perlito5::Compiler::error("not a valid constant: " . join(${"\""}, @{$list}));
                                push(@ast, $m->{"capture"})
                            }
                        }
                        $MATCH->{"capture"} = Perlito5::AST::Block::->new("stmts", \@ast)
                    }
                    elsif ($Perlito5::EMIT_USE) {;
                        $MATCH->{"capture"} = Perlito5::AST::Apply::->new("code", "use", "special_arg", Perlito5::AST::Apply::->new("code", $full_ident, "bareword", 1, "arguments", []), "arguments", $list)
                    }
                    else {;
                        $MATCH->{"capture"} = parse_time_eval({"mod", $full_ident, "code", $use_decl, "arguments", $list})
                    }
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (do {
                    Perlito5::Compiler::error("Syntax error");
                    1
                })
            })
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Use::parse_time_eval {
        my $ast = shift;
        my $module_name = $ast->{"mod"};
        my $use_or_not = $ast->{"code"};
        my $arguments = $ast->{"arguments"};
        my $skip_import = defined($arguments) && @{$arguments} == 0;
        defined($arguments) || ($arguments = []);
        if ($Perlito5::EXPAND_USE) {
            my $current_module_name = $Perlito5::PKG_NAME;
            my $filename = modulename_to_filename($module_name);
            Perlito5::Grammar::Use::require($filename);
            if (!$skip_import) {
                if ($use_or_not eq "use") {
                    my $code = $module_name->can("import");
                    if (defined($code)) {
                        unshift(@Perlito5::CALLER, [$current_module_name]);
                        eval {
                            $module_name->import(@{$arguments});
                            1
                        } or ${"\@"}->Perlito5::Compiler::error();
                        shift(@Perlito5::CALLER)
                    }
                }
                elsif ($use_or_not eq "no") {
                    my $code = $module_name->can("unimport");
                    if (defined($code)) {
                        unshift(@Perlito5::CALLER, [$current_module_name]);
                        eval {
                            $module_name->unimport(@{$arguments});
                            1
                        } or ${"\@"}->Perlito5::Compiler::error();
                        shift(@Perlito5::CALLER)
                    }
                }
            }
        }
        else {;
            bootstrapping_use($ast)
        }
        return Perlito5::Grammar::Block::ast_nop()
    }
    sub Perlito5::Grammar::Use::emit_time_eval {
        my $ast = shift;
        if ($ast->{"mod"} eq "strict") {
            if ($ast->{"code"} eq "use") {;
                strict::->import()
            }
            elsif ($ast->{"code"} eq "no") {;
                strict::->unimport()
            }
        }
    }
    sub Perlito5::Grammar::Use::modulename_to_filename {
        my $s = shift;
        exists($Perlito_internal_module{$s}) && ($s = $Perlito_internal_module{$s});
        $s =~ s!::!/!g;
        return $s . ".pm"
    }
    sub Perlito5::Grammar::Use::filename_lookup {
        my $filename = shift;
        if (exists($INC{$filename})) {
            $INC{$filename} && return "done";
            Perlito5::Compiler::error("Compilation failed in require")
        }
        for my $prefix (@INC, ".") {
            my $realfilename = $prefix . "/" . $filename;
            if (-f $realfilename) {
                $INC{$filename} = $realfilename;
                return "todo"
            }
        }
        Perlito5::Compiler::error("Can't locate " . $filename . " in \@INC " . "(\@INC contains " . join(" ", @INC) . ").")
    }
    sub Perlito5::Grammar::Use::bootstrapping_use {
        my $stmt = shift;
        my $module_name = $stmt->{"mod"};
        my $filename = modulename_to_filename($module_name);
        filename_lookup($filename) eq "done" && return;
        local $Perlito5::FILE_NAME = $filename;
        local $Perlito5::LINE_NUMBER = 1;
        my $realfilename = $INC{$filename};
        open(FILE, "<", $realfilename) or Perlito5::Compiler::error("Cannot read " . $realfilename . ": " . ${"!"} . "
");
        local $/ = undef;
        my $source = <FILE>;
        close(FILE);
        my $m = Perlito5::Grammar::exp_stmts($source, 0);
        $m->{"to"} != length($source) && Perlito5::Compiler::error("Syntax Error near ", $m->{"to"});
        if ($m->{"to"} != length($source)) {
            my $pos = $m->{"to"} - 10;
            $pos < 0 && ($pos = 0);
            print("* near: ", substr($source, $pos, 20), "
");
            print("* filename: " . $realfilename . "
");
            Perlito5::Compiler::error("Syntax Error")
        }
        push(@Perlito5::COMP_UNIT, Perlito5::AST::CompUnit::->new("name", "main", "body", Perlito5::Match::flat($m)));
        return
    }
    sub Perlito5::Grammar::Use::require {
        my $filename = shift;
        my $m2 = version_string([split('', $filename)], 0);
        if ($m2) {
            my $version = $m2->{"version_string"}->{"capture"}->{"buf"};
            Perlito5::test_perl_version($version);
            return 1
        }
        filename_lookup($filename) eq "done" && return;
        my $source = slurp_file($filename);
        local $Perlito5::FILE_NAME = $filename;
        Perlito5::Grammar::Scope::check_variable_declarations();
        Perlito5::Grammar::Scope::create_new_compile_time_scope();
        local ${^H} = 0;
        local %{^H} = ();
        my $m = Perlito5::Grammar::exp_stmts($source, 0);
        my $ast = Perlito5::AST::Block::->new("stmts", Perlito5::Match::flat($m));
        my $result = Perlito5::Grammar::Block::eval_begin_block($ast);
        Perlito5::Grammar::Scope::end_compile_time_scope();
        if (${"\@"}) {
            $INC{$filename} = undef;
            ${"\@"}->Perlito5::Compiler::error()
        }
        elsif (!$result) {
            delete($INC{$filename});
            ${"\@"} && warn(${"\@"});
            Perlito5::Compiler::error($filename . " did not return true value")
        }
        else {;
            return $result
        }
    }
    sub Perlito5::Grammar::Use::slurp_file {
        my $filename = shift;
        eval {
            filename_lookup($filename);
            1
        } or do {
            $INC{$filename} = undef;
            ${"\@"} = '';
            ${"!"} = "No such file or directory";
            return "undef"
        };
        my $realfilename = $INC{$filename};
        open(FILE, "<", $realfilename) or Perlito5::Compiler::error("Cannot read " . $realfilename . ": " . ${"!"} . "
");
        local $/ = undef;
        my $source = <FILE>;
        close(FILE);
        return $source
    }
    Perlito5::Grammar::Statement::add_statement("no", \&stmt_use);
    Perlito5::Grammar::Statement::add_statement("use", \&stmt_use);
    Perlito5::Grammar::Precedence::add_term("require", \&term_require);
    1
}
{
    package main;
    package Perlito5::AST::CompUnit;
    sub Perlito5::AST::CompUnit::new {
        my $class = shift;
        my %args = @_;
        if ($args{"body"}) {
            my @body;
            for my $stmt (@{$args{"body"}}) {
                !defined($stmt) && next;
                ref($stmt) eq "Perlito5::AST::Apply" && $stmt->{"namespace"} eq "Perlito5" && $stmt->{"code"} eq "nop" && next;
                push(@body, $stmt)
            }
            $Perlito5::CODE_TOO_LARGE && (@body = Perlito5::Macro::split_code_too_large(@body));
            $args{"body"} = \@body
        }
        bless(\%args, $class)
    }
    sub Perlito5::AST::CompUnit::name {;
        $_[0]->{"name"}
    }
    sub Perlito5::AST::CompUnit::body {;
        $_[0]->{"body"}
    }
    package Perlito5::AST::Block;
    sub Perlito5::AST::Block::new {
        my $class = shift;
        my %args = @_;
        if ($args{"stmts"}) {
            my @stmts;
            for my $stmt (@{$args{"stmts"}}) {
                !defined($stmt) && next;
                ref($stmt) eq "Perlito5::AST::Apply" && $stmt->{"namespace"} eq "Perlito5" && $stmt->{"code"} eq "nop" && next;
                push(@stmts, $stmt)
            }
            $Perlito5::CODE_TOO_LARGE && (@stmts = Perlito5::Macro::split_code_too_large(@stmts));
            $args{"stmts"} = \@stmts
        }
        bless(\%args, $class)
    }
    sub Perlito5::AST::Block::sig {;
        $_[0]->{"sig"}
    }
    sub Perlito5::AST::Block::stmts {;
        $_[0]->{"stmts"}
    }
    package Perlito5::AST::Int;
    sub Perlito5::AST::Int::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::AST::Int::int {;
        $_[0]->{"int"}
    }
    package Perlito5::AST::Num;
    sub Perlito5::AST::Num::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::AST::Num::num {;
        $_[0]->{"num"}
    }
    package Perlito5::AST::Buf;
    sub Perlito5::AST::Buf::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::AST::Buf::buf {;
        $_[0]->{"buf"}
    }
    package Perlito5::AST::Index;
    sub Perlito5::AST::Index::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::AST::Index::obj {;
        $_[0]->{"obj"}
    }
    sub Perlito5::AST::Index::index_exp {;
        $_[0]->{"index_exp"}
    }
    sub Perlito5::AST::Index::INDEX {
        (my($term), my($index)) = @_;
        if (ref($term) eq "Perlito5::AST::Var" && $term->{"sigil"} eq "\@") {;
            return Perlito5::AST::Index::->new("obj", Perlito5::AST::Var::->new(%{$term}, "_real_sigil", $term->{"sigil"}, "sigil", "\$"), "index_exp", $index)
        }
        return Perlito5::AST::Call::->new("method", "postcircumfix:<[ ]>", "invocant", $term, "arguments", $index)
    }
    package Perlito5::AST::Lookup;
    sub Perlito5::AST::Lookup::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::AST::Lookup::obj {;
        $_[0]->{"obj"}
    }
    sub Perlito5::AST::Lookup::index_exp {;
        $_[0]->{"index_exp"}
    }
    sub Perlito5::AST::Lookup::autoquote {
        my $self = shift;
        my $index = shift;
        if ($index->isa("Perlito5::AST::Apply") && $index->{"bareword"}) {
            my $full_name = ($index->{"namespace"} ? $index->{"namespace"} . "::" : '') . $index->{"code"};
            if (!exists($Perlito5::PROTO->{$full_name})) {;
                return Perlito5::AST::Buf::->new("buf", $full_name)
            }
        }
        elsif ($index->isa("Perlito5::AST::Apply") && ($index->code() eq "prefix:<->" || $index->code() eq "prefix:<+>")) {
            my $arg = $index->arguments()->[0];
            $arg && return Perlito5::AST::Apply::->new("code", $index->code(), "namespace", $index->namespace(), "arguments", [$self->autoquote($arg)])
        }
        elsif ($index->isa("Perlito5::AST::Apply") && ($index->code() eq "list:<,>")) {
            my $obj = $self->obj();
            if ($obj->sigil() eq "\@") {;
                return $index
            }
            my $args = $index->arguments();
            return Perlito5::AST::Apply::->new("code", "join", "namespace", '', "arguments", [Perlito5::AST::Var::->new("name", ";", "namespace", '', "sigil", "\$"), map {;
                defined($_) ? $_ : Perlito5::AST::Buf::->new("buf", '')
            } @{$args}])
        }
        $index
    }
    sub Perlito5::AST::Lookup::LOOKUP {
        (my($term), my($index)) = @_;
        if (ref($term) eq "Perlito5::AST::Var" && $term->{"sigil"} eq "%") {;
            return Perlito5::AST::Lookup::->new("obj", Perlito5::AST::Var::->new(%{$term}, "_real_sigil", $term->{"sigil"}, "sigil", "\$"), "index_exp", $index)
        }
        return Perlito5::AST::Call::->new("method", "postcircumfix:<{ }>", "invocant", $term, "arguments", $index)
    }
    package Perlito5::AST::Var;
    sub Perlito5::AST::Var::new {
        (my($class), my(%args)) = @_;
        my $var = bless(\%args, $class);
        push(@Perlito5::SCOPE_STMT, $var);
        return $var
    }
    sub Perlito5::AST::Var::sigil {;
        $_[0]->{"sigil"}
    }
    sub Perlito5::AST::Var::namespace {;
        $_[0]->{"namespace"}
    }
    sub Perlito5::AST::Var::name {;
        $_[0]->{"name"}
    }
    sub Perlito5::AST::Var::plain_name {
        my $self = shift;
        if ($self->namespace()) {;
            return $self->namespace() . "::" . $self->name()
        }
        return $self->name()
    }
    our %Special_var = ("ARGV", 1, "INC", 1, "ENV", 1, "SIG", 1, "_", 1);
    our %NonSpecial_var = map {;
        $_ => 1
    } ("A" .. "Z", "_", "a" .. "z");
    sub Perlito5::AST::Var::is_special_var {
        my $self = shift;
        my $c = substr($self->{"name"}, 0, 1);
        if ($Special_var{$self->{"name"}} || !$NonSpecial_var{$c}) {;
            return 1
        }
        0
    }
    sub Perlito5::AST::Var::SCALAR_ARG {;
        Perlito5::AST::Var::->new("sigil", "\$", "namespace", '', "name", "_", "_decl", "global", "_namespace", "main")
    }
    sub Perlito5::AST::Var::LIST_ARG {;
        Perlito5::AST::Var::->new("sigil", "\@", "namespace", '', "name", "_", "_decl", "global", "_namespace", "main")
    }
    sub Perlito5::AST::Var::LIST_ARG_INDEX {
        my $index = shift;
        Perlito5::AST::Index::INDEX(LIST_ARG(), Perlito5::AST::Int::->new("int", $index))
    }
    package Perlito5::AST::Call;
    sub Perlito5::AST::Call::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::AST::Call::invocant {;
        $_[0]->{"invocant"}
    }
    sub Perlito5::AST::Call::method {;
        $_[0]->{"method"}
    }
    sub Perlito5::AST::Call::arguments {;
        $_[0]->{"arguments"}
    }
    package Perlito5::AST::Apply;
    sub Perlito5::AST::Apply::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::AST::Apply::code {;
        $_[0]->{"code"}
    }
    sub Perlito5::AST::Apply::special_arg {;
        $_[0]->{"special_arg"}
    }
    sub Perlito5::AST::Apply::arguments {;
        $_[0]->{"arguments"}
    }
    sub Perlito5::AST::Apply::namespace {;
        $_[0]->{"namespace"}
    }
    sub Perlito5::AST::Apply::PUSH {
        (my($var), my($value)) = @_;
        if (ref($var) eq "Perlito5::AST::Var" && $var->{"sigil"} eq "\@") {;
            return Perlito5::AST::Apply::->new("code", "push", "arguments", [$var, $value])
        }
        return Perlito5::AST::Apply::->new("code", "push", "arguments", [Perlito5::AST::Apply::->new("code", "prefix:<\@>", "arguments", [$var]), $value])
    }
    package Perlito5::AST::If;
    sub Perlito5::AST::If::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::AST::If::cond {;
        $_[0]->{"cond"}
    }
    sub Perlito5::AST::If::body {;
        $_[0]->{"body"}
    }
    sub Perlito5::AST::If::otherwise {;
        $_[0]->{"otherwise"}
    }
    package Perlito5::AST::When;
    sub Perlito5::AST::When::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::AST::When::cond {;
        $_[0]->{"cond"}
    }
    sub Perlito5::AST::When::body {;
        $_[0]->{"body"}
    }
    package Perlito5::AST::While;
    sub Perlito5::AST::While::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::AST::While::init {;
        $_[0]->{"init"}
    }
    sub Perlito5::AST::While::cond {;
        $_[0]->{"cond"}
    }
    sub Perlito5::AST::While::continue {;
        $_[0]->{"continue"}
    }
    sub Perlito5::AST::While::body {;
        $_[0]->{"body"}
    }
    package Perlito5::AST::For;
    sub Perlito5::AST::For::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::AST::For::cond {;
        $_[0]->{"cond"}
    }
    sub Perlito5::AST::For::continue {;
        $_[0]->{"continue"}
    }
    sub Perlito5::AST::For::body {;
        $_[0]->{"body"}
    }
    sub Perlito5::AST::For::topic {;
        $_[0]->{"topic"}
    }
    package Perlito5::AST::Given;
    sub Perlito5::AST::Given::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::AST::Given::cond {;
        $_[0]->{"cond"}
    }
    sub Perlito5::AST::Given::body {;
        $_[0]->{"body"}
    }
    package Perlito5::AST::Decl;
    sub Perlito5::AST::Decl::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::AST::Decl::decl {;
        $_[0]->{"decl"}
    }
    sub Perlito5::AST::Decl::type {;
        $_[0]->{"type"}
    }
    sub Perlito5::AST::Decl::var {;
        $_[0]->{"var"}
    }
    sub Perlito5::AST::Decl::attributes {;
        $_[0]->{"attributes"}
    }
    package Perlito5::AST::Sub;
    sub Perlito5::AST::Sub::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::AST::Sub::name {;
        $_[0]->{"name"}
    }
    sub Perlito5::AST::Sub::sig {;
        $_[0]->{"sig"}
    }
    sub Perlito5::AST::Sub::block {;
        $_[0]->{"block"}
    }
    sub Perlito5::AST::Sub::attributes {;
        $_[0]->{"attributes"}
    }
    sub Perlito5::AST::Sub::is_named_sub {
        my $self = shift;
        $self->isa("Perlito5::AST::Sub") && $self->{"name"}
    }
    sub Perlito5::AST::Sub::is_anon_sub {
        my $self = shift;
        $self->isa("Perlito5::AST::Sub") && !$self->{"name"}
    }
    1
}
{
    package main;
    package Perlito5::Grammar::Scope;
    sub Perlito5::Grammar::Scope::new {;
        return {"block" => [], }
    }
    sub Perlito5::Grammar::Scope::new_base_scope {;
        return {"block" => [], }
    }
    sub Perlito5::Grammar::Scope::create_new_compile_time_scope {
        my $new_scope = {"block" => [], };
        push(@{$Perlito5::SCOPE->{"block"}}, $new_scope);
        $Perlito5::SCOPE_DEPTH++;
        $Perlito5::SCOPE = $new_scope;
        $Perlito5::SCOPE->{"hint_scalar"} = ${^H};
        $Perlito5::SCOPE->{"hint_hash"} = {%{^H}, }
    }
    sub Perlito5::Grammar::Scope::end_compile_time_scope {
        ${^H} = $Perlito5::SCOPE->{"hint_scalar"};
        %{^H} = %{$Perlito5::SCOPE->{"hint_hash"} || {}};
        my $pos = 0;
        $Perlito5::SCOPE_DEPTH--;
        $Perlito5::SCOPE = $Perlito5::BASE_SCOPE;
        while ($Perlito5::SCOPE_DEPTH > $pos) {
            $pos++;
            $Perlito5::SCOPE = $Perlito5::SCOPE->{"block"}->[-1]
        }
    }
    sub Perlito5::Grammar::Scope::compile_time_glob_set {
        (my($glob), my($value), my($namespace)) = @_;
        if (!ref($glob)) {
            if ($glob !~ m/::/) {;
                $glob = $namespace . "::" . $glob
            }
            my @parts = split("::", $glob);
            my $name = pop(@parts);
            Perlito5::AST::Var::->new("name", $name, "namespace", join("::", @parts), "sigil", "*", "_decl", "global")
        }
        *{$glob} = $value
    }
    sub Perlito5::Grammar::Scope::lookup_variable {
        my $var = shift;
        my $scope = shift() // $Perlito5::BASE_SCOPE;
        $var->{"namespace"} && return $var;
        $var->{"_decl"} && return $var;
        my $look = lookup_variable_inner($var, $scope, 0);
        $look && return $look;
        ref($var) ne "Perlito5::AST::Var" && return;
        my $c = substr($var->{"name"}, 0, 1);
        if ($var->is_special_var()) {
            $var->{"_decl"} = "global";
            $var->{"_namespace"} = "main";
            return $var
        }
        if ($var->{"sigil"} eq "\$" && ($var->{"name"} eq "a" || $var->{"name"} eq "b")) {;
            if (!$var->{"_real_sigil"}) {
                $var->{"_decl"} = "global";
                $var->{"_namespace"} = $Perlito5::PKG_NAME;
                return $var
            }
        }
        return
    }
    sub Perlito5::Grammar::Scope::lookup_variable_inner {
        (my($var), my($scope), my($depth)) = @_;
        $depth > $Perlito5::SCOPE_DEPTH && return;
        my $block = $scope->{"block"};
        if (@{$block} && ref($block->[-1]) eq "HASH" && $block->[-1]->{"block"}) {
            my $look = lookup_variable_inner($var, $block->[-1], $depth + 1);
            $look && return $look
        }
        if (($scope->{"compacted"} + 100) < @{$block}) {
            my %seen;
            my @out;
            my $start = $#{$block} - 500;
            $start < 1 && ($start = 1);
            for my $i ($start .. $#{$block}) {
                my $item = $block->[$i];
                my $s = join(":", map {;
                    $_ . "=" . $item->{$_}
                } sort {;
                    $a cmp $b
                } keys(%{$item}));
                $seen{$s}++ || push(@out, $item)
            }
            $scope->{"block"} = [@{$block}[0 .. $start - 1], @out];
            $scope->{"compacted"} += 100
        }
        for my $item (reverse(@{$block})) {;
            if (ref($item) eq "Perlito5::AST::Var" && $item->{"_decl"} && $item->{"_decl"} ne "global" && $item->{"name"} eq $var->{"name"}) {
                my $sigil = $var->{"_real_sigil"} || $var->{"sigil"};
                my $item_sigil = $item->{"_real_sigil"} || $item->{"sigil"};
                if ($sigil eq $item_sigil) {;
                    return $item
                }
            }
        }
        return
    }
    sub Perlito5::Grammar::Scope::check_variable_declarations {
        for my $item (@Perlito5::SCOPE_STMT) {;
            if (ref($item) eq "Perlito5::AST::Var") {
                my $var = $item;
                my $look = lookup_variable($var);
                if ($look) {
                    $look->{"_id"} && ($var->{"_id"} = $look->{"_id"});
                    $look->{"_decl"} && ($var->{"_decl"} = $look->{"_decl"});
                    $look->{"_namespace"} && ($var->{"_namespace"} = $look->{"_namespace"})
                }
                else {
                    if (${^H} & $Perlito5::STRICT_VARS) {
                        my $sigil = $var->{"_real_sigil"} || $var->{"sigil"};
                        if ($sigil ne "*" && $sigil ne "&") {;
                            Perlito5::Compiler::error("Global symbol \"" . $sigil . $var->{"name"} . "\"" . " requires explicit package name")
                        }
                    }
                    $var->{"_decl"} = "global";
                    $var->{"_namespace"} = $Perlito5::PKG_NAME
                }
                if ($var->{"name"} && ($var->{"namespace"} || $var->{"_namespace"})) {
                    my $compiletime_name;
                    if ($var->{"name"} lt "A" || $var->{"name"} eq "\\") {;
                        $compiletime_name = ($var->{"_real_sigil"} || $var->{"sigil"}) . $var->{"name"}
                    }
                    else {;
                        $compiletime_name = ($var->{"_real_sigil"} || $var->{"sigil"}) . ($var->{"namespace"} || $var->{"_namespace"}) . "::" . $var->{"name"} . ($var->{"_decl"} eq "global" ? '' : $var->{"_id"} ? "_" . $var->{"_id"} : '')
                    }
                    $Perlito5::GLOBAL->{$compiletime_name} = {"value", undef, "ast", $var}
                }
            }
        }
        push(@{$Perlito5::SCOPE->{"block"}}, @Perlito5::SCOPE_STMT);
        @Perlito5::SCOPE_STMT = ()
    }
    sub Perlito5::Grammar::Scope::get_snapshot {
        my @result;
        my $scope = shift() // $Perlito5::BASE_SCOPE;
        my $block = $scope->{"block"};
        if (@{$block} && ref($block->[-1]) eq "HASH" && $block->[-1]->{"block"}) {
            my $look = get_snapshot($block->[-1]);
            unshift(@result, @{$look->{"block"}})
        }
        for my $item (@{$block}) {;
            if (ref($item) eq "Perlito5::AST::Var" && $item->{"_decl"} && $item->{"_decl"} ne "global" && $item->{"_decl"} ne "local") {;
                unshift(@result, $item)
            }
        }
        return {"block" => \@result, }
    }
    1
}
{
    package main;
    package Perlito5::AST::CompUnit;
    {;
        sub Perlito5::AST::CompUnit::emit_begin_scratchpad {
            my $self = $_[0];
            return __PACKAGE__->new(%{$self}, "body", [map {;
                defined($_) && $_->emit_begin_scratchpad()
            } @{$self->{"body"}}])
        }
    }
    package Perlito5::AST::Int;
    {;
        sub Perlito5::AST::Int::emit_begin_scratchpad {;
            return $_[0]
        }
    }
    package Perlito5::AST::Num;
    {;
        sub Perlito5::AST::Num::emit_begin_scratchpad {;
            return $_[0]
        }
    }
    package Perlito5::AST::Buf;
    {;
        sub Perlito5::AST::Buf::emit_begin_scratchpad {;
            return $_[0]
        }
    }
    package Perlito5::AST::Block;
    {;
        sub Perlito5::AST::Block::emit_begin_scratchpad {
            my $self = $_[0];
            return __PACKAGE__->new(%{$self}, "stmts", [map {;
                defined($_) && $_->emit_begin_scratchpad()
            } @{$self->{"stmts"}}], ($self->{"continue"} ? ("continue", $self->{"continue"}->emit_begin_scratchpad()) : ()))
        }
    }
    package Perlito5::AST::Index;
    {;
        sub Perlito5::AST::Index::emit_begin_scratchpad {
            my $self = $_[0];
            return __PACKAGE__->new(%{$self}, "obj", $self->{"obj"}->emit_begin_scratchpad(), "index_exp", $self->{"index_exp"}->emit_begin_scratchpad())
        }
    }
    package Perlito5::AST::Lookup;
    {;
        sub Perlito5::AST::Lookup::emit_begin_scratchpad {
            my $self = $_[0];
            return __PACKAGE__->new(%{$self}, "obj", $self->{"obj"}->emit_begin_scratchpad(), "index_exp", $self->{"index_exp"}->emit_begin_scratchpad())
        }
    }
    package Perlito5::AST::Var;
    {;
        sub Perlito5::AST::Var::emit_begin_scratchpad {
            my $self = $_[0];
            if (!$self->{"namespace"} && $Perlito5::BEGIN_SCRATCHPAD{$self->{"_id"} || ''}) {;
                return __PACKAGE__->new(%{$self}, "_decl", "global", "namespace", "Perlito5::BEGIN", "name", "_" . $self->{"_id"} . "_" . $self->{"name"})
            }
            return $self
        }
    }
    package Perlito5::AST::Call;
    {;
        sub Perlito5::AST::Call::emit_begin_scratchpad {
            my $self = $_[0];
            my $invocant = $self->{"invocant"}->emit_begin_scratchpad();
            my $arguments;
            if ($self->{"method"} eq "postcircumfix:<[ ]>") {;
                $arguments = $self->{"arguments"}->emit_begin_scratchpad()
            }
            elsif ($self->{"method"} eq "postcircumfix:<{ }>") {;
                $arguments = $self->{"arguments"}->emit_begin_scratchpad()
            }
            else {;
                $arguments = [map {;
                    $_->emit_begin_scratchpad()
                } @{$self->{"arguments"}}]
            }
            my $meth = $self->{"method"};
            if (ref($meth) eq "Perlito5::AST::Var") {;
                $meth = $meth->emit_begin_scratchpad()
            }
            return __PACKAGE__->new(%{$self}, "method", $meth, "invocant", $invocant, "arguments", $arguments)
        }
    }
    package Perlito5::AST::Apply;
    {
        sub Perlito5::AST::Apply::emit_begin_scratchpad_args {
            my $self = $_[0];
            !$self->{"arguments"} && return ();
            return map {;
                $_->emit_begin_scratchpad()
            } @{$self->{"arguments"}}
        }
        sub Perlito5::AST::Apply::emit_begin_scratchpad {
            my $self = $_[0];
            my $code;
            if (ref($self->{"code"})) {;
                $code = $self->{"code"}->emit_begin_scratchpad()
            }
            else {;
                $code = $self->{"code"}
            }
            my $arguments;
            if (ref($self->{"arguments"})) {;
                $arguments = [map {;
                    $_->emit_begin_scratchpad()
                } @{$self->{"arguments"}}]
            }
            else {;
                $arguments = $self->{"arguments"}
            }
            if ($code eq "eval" && $self->{"_scope"}) {;
                $self->{"_scope"}->{"block"} = [grep {;
                    $_->{"_decl"} ne "global"
                } map {;
                    $_->emit_begin_scratchpad()
                } @{$self->{"_scope"}->{"block"}}]
            }
            if ($code eq "my") {
                my @arg;
                for my $var (@{$arguments}) {
                    if ($var->{"namespace"} && $var->{"namespace"} eq "Perlito5::BEGIN") {;
                        push(@arg, $var)
                    }
                    else {;
                        push(@arg, __PACKAGE__->new("code", $code, "arguments", [$var]))
                    }
                }
                return __PACKAGE__->new("code", "circumfix:<( )>", "arguments", \@arg)
            }
            return __PACKAGE__->new(%{$self}, "code", $code, "arguments", $arguments)
        }
    }
    package Perlito5::AST::If;
    {;
        sub Perlito5::AST::If::emit_begin_scratchpad {
            my $self = $_[0];
            return __PACKAGE__->new(%{$self}, "cond", $self->{"cond"}->emit_begin_scratchpad(), "body", $self->{"body"}->emit_begin_scratchpad(), "otherwise", $self->{"otherwise"}->emit_begin_scratchpad())
        }
    }
    package Perlito5::AST::When;
    {;
        sub Perlito5::AST::When::emit_begin_scratchpad {
            my $self = $_[0];
            return __PACKAGE__->new(%{$self}, "cond", $self->{"cond"}->emit_begin_scratchpad(), "body", $self->{"body"}->emit_begin_scratchpad())
        }
    }
    package Perlito5::AST::While;
    {;
        sub Perlito5::AST::While::emit_begin_scratchpad {
            my $self = $_[0];
            return __PACKAGE__->new(%{$self}, "cond", $self->{"cond"}->emit_begin_scratchpad(), "body", $self->{"body"}->emit_begin_scratchpad())
        }
    }
    package Perlito5::AST::For;
    {;
        sub Perlito5::AST::For::emit_begin_scratchpad {
            my $self = $_[0];
            my $cond;
            if (ref($self->{"cond"}) eq "ARRAY") {;
                $cond = [map {;
                    defined($_) ? $_->emit_begin_scratchpad() : $_
                } @{$self->{"cond"}}]
            }
            else {;
                $cond = $self->{"cond"}->emit_begin_scratchpad()
            }
            return __PACKAGE__->new(%{$self}, "cond", $cond, "body", $self->{"body"}->emit_begin_scratchpad(), ($self->{"continue"} ? ("continue", $self->{"continue"}->emit_begin_scratchpad()) : ()))
        }
    }
    package Perlito5::AST::Decl;
    {;
        sub Perlito5::AST::Decl::emit_begin_scratchpad {
            my $self = $_[0];
            my $var = $self->{"var"}->emit_begin_scratchpad();
            if ($var->{"namespace"} && $var->{"namespace"} eq "Perlito5::BEGIN") {;
                return $var
            }
            return __PACKAGE__->new(%{$self}, "var", $var)
        }
    }
    package Perlito5::AST::Sub;
    {;
        sub Perlito5::AST::Sub::emit_begin_scratchpad {
            my $self = $_[0];
            my @stmts;
            if (defined($self->{"block"})) {
                @stmts = @{$self->{"block"}->{"stmts"}};
                @stmts = map {;
                    $_->emit_begin_scratchpad()
                } @stmts;
                $self = __PACKAGE__->new(%{$self}, ($self->{"block"} ? ("block", Perlito5::AST::Block::->new(%{$self->{"block"}}, "stmts", [@stmts])) : ()))
            }
            return $self
        }
    }
    1
}
{
    package main;
    package Perlito5::AST::CompUnit;
    {;
        sub Perlito5::AST::CompUnit::get_captures {;
            ()
        }
    }
    package Perlito5::AST::Int;
    {;
        sub Perlito5::AST::Int::get_captures {;
            ()
        }
    }
    package Perlito5::AST::Num;
    {;
        sub Perlito5::AST::Num::get_captures {;
            ()
        }
    }
    package Perlito5::AST::Buf;
    {;
        sub Perlito5::AST::Buf::get_captures {;
            ()
        }
    }
    package Perlito5::AST::Block;
    {;
        sub Perlito5::AST::Block::get_captures {
            (my($self)) = @_;
            my @var;
            for my $stmt (@{$self->{"stmts"}}) {;
                push(@var, $stmt->get_captures())
            }
            return @var
        }
    }
    package Perlito5::AST::Index;
    {;
        sub Perlito5::AST::Index::get_captures {
            my $self = shift;
            my @var;
            push(@var, $self->{"obj"}->get_captures());
            push(@var, $self->{"index_exp"}->get_captures());
            return @var
        }
    }
    package Perlito5::AST::Lookup;
    {;
        sub Perlito5::AST::Lookup::get_captures {
            my $self = shift;
            my @var;
            push(@var, $self->{"obj"}->get_captures());
            push(@var, $self->{"index_exp"}->get_captures());
            return @var
        }
    }
    package Perlito5::AST::Var;
    {;
        sub Perlito5::AST::Var::get_captures {
            my $self = shift;
            return ($self)
        }
    }
    package Perlito5::AST::Decl;
    {;
        sub Perlito5::AST::Decl::get_captures {;
            return {"dont" => $_[0]->{"var"}->{"_id"}, }
        }
    }
    package Perlito5::AST::Call;
    {;
        sub Perlito5::AST::Call::get_captures {
            my $self = shift;
            my @var;
            ref($self->{"method"}) && push(@var, $self->{"method"}->get_captures());
            push(@var, $self->{"invocant"}->get_captures());
            my $args = $self->{"arguments"};
            if ($args) {
                if (ref($args) eq "ARRAY") {;
                    push(@var, map {;
                        $_->get_captures()
                    } @{$args})
                }
                else {;
                    push(@var, $args->get_captures())
                }
            }
            return @var
        }
    }
    package Perlito5::AST::Apply;
    {;
        sub Perlito5::AST::Apply::get_captures {
            my $self = shift;
            my $code = $self->{"code"};
            my @var;
            ref($code) && push(@var, $code->get_captures());
            $self->{"arguments"} && push(@var, map {;
                $_->get_captures()
            } @{$self->{"arguments"}});
            ref($self->{"special_arg"}) && push(@var, $self->{"special_arg"}->get_captures());
            if ($code eq "eval" && $self->{"_scope"}) {;
                push(@var, @{$self->{"_scope"}->{"block"}})
            }
            if ($code eq "my" || $code eq "our" || $code eq "state") {;
                push(@var, (map {;
                    ref($_) eq "Perlito5::AST::Var" ? ({"dont" => $_->{"_id"}, }) : ()
                } @{$self->{"arguments"}}))
            }
            return @var
        }
    }
    package Perlito5::AST::If;
    {;
        sub Perlito5::AST::If::get_captures {
            my $self = shift;
            my @var;
            push(@var, $self->{"cond"}->get_captures());
            push(@var, $self->{"body"}->get_captures());
            push(@var, $self->{"otherwise"}->get_captures());
            return @var
        }
    }
    package Perlito5::AST::When;
    {;
        sub Perlito5::AST::When::get_captures {
            my $self = shift;
            my @var;
            push(@var, $self->{"cond"}->get_captures());
            push(@var, $self->{"body"}->get_captures());
            return @var
        }
    }
    package Perlito5::AST::While;
    {;
        sub Perlito5::AST::While::get_captures {
            my $self = shift;
            my @var;
            push(@var, $self->{"cond"}->get_captures());
            push(@var, $self->{"body"}->get_captures());
            return @var
        }
    }
    package Perlito5::AST::For;
    {;
        sub Perlito5::AST::For::get_captures {
            my $self = shift;
            my @var;
            my $body = ref($self->{"body"}) ne "Perlito5::AST::Block" ? [$self->{"body"}] : $self->{"body"}->{"stmts"};
            push(@var, map {;
                $_->get_captures()
            } grep {;
                defined($_)
            } @{$body}, $self->{"topic"}, (ref($self->{"cond"}) eq "ARRAY" ? @{$self->{"cond"}} : $self->{"cond"}));
            return @var
        }
    }
    package Perlito5::AST::Sub;
    {;
        sub Perlito5::AST::Sub::get_captures {
            my $self = shift;
            !$self->{"block"} && return;
            return $self->{"block"}->get_captures()
        }
    }
    1
}
{
    package main;
    package Perlito5::Grammar::Block;
    our %Named_block = ("BEGIN", 1, "UNITCHECK", 1, "CHECK", 1, "INIT", 1, "END", 1, "AUTOLOAD", 1, "DESTROY", 1);
    sub Perlito5::Grammar::Block::block {
        my $str = $_[0];
        my $pos = $_[1];
        my $m = Perlito5::Grammar::Space::opt_ws($str, $pos);
        $pos = $m->{"to"};
        if ($str->[$pos] ne "{") {;
            return
        }
        $pos++;
        Perlito5::Grammar::Scope::check_variable_declarations();
        Perlito5::Grammar::Scope::create_new_compile_time_scope();
        $m = Perlito5::Grammar::exp_stmts($str, $pos);
        if (!$m) {;
            Perlito5::Compiler::error("syntax error")
        }
        $pos = $m->{"to"};
        my $capture = Perlito5::Match::flat($m);
        $m = Perlito5::Grammar::Space::opt_ws($str, $pos);
        $pos = $m->{"to"};
        if ($str->[$pos] ne "}") {;
            Perlito5::Compiler::error("syntax error")
        }
        $m->{"to"} = $pos + 1;
        $m->{"capture"} = Perlito5::AST::Block::->new("stmts", $capture, "sig", undef);
        Perlito5::Grammar::Scope::end_compile_time_scope();
        return $m
    }
    sub Perlito5::Grammar::Block::closure_block {
        my $str = $_[0];
        my $pos = $_[1];
        my $m = Perlito5::Grammar::Space::opt_ws($str, $pos);
        $pos = $m->{"to"};
        if ($str->[$pos] ne "{") {;
            return
        }
        $pos++;
        Perlito5::Grammar::Scope::check_variable_declarations();
        Perlito5::Grammar::Scope::create_new_compile_time_scope();
        local $Perlito5::CLOSURE_SCOPE = $Perlito5::SCOPE;
        $m = Perlito5::Grammar::exp_stmts($str, $pos);
        if (!$m) {;
            Perlito5::Compiler::error("syntax error")
        }
        $pos = $m->{"to"};
        my $capture = Perlito5::Match::flat($m);
        $m = Perlito5::Grammar::Space::opt_ws($str, $pos);
        $pos = $m->{"to"};
        if ($str->[$pos] ne "}") {;
            Perlito5::Compiler::error("syntax error")
        }
        $m->{"to"} = $pos + 1;
        $m->{"capture"} = Perlito5::AST::Block::->new("stmts", $capture, "sig", undef);
        Perlito5::Grammar::Scope::end_compile_time_scope();
        return $m
    }
    sub Perlito5::Grammar::Block::eval_end_block {
        (my($block), my($phase)) = @_;
        $block = Perlito5::AST::Block::->new("stmts", [Perlito5::AST::Sub::->new("attributes", [], "block", $block, "name", undef, "namespace", $Perlito5::PKG_NAME, "sig", undef)]);
        return Perlito5::Grammar::Block::eval_begin_block($block, "BEGIN")
    }
    sub Perlito5::Grammar::Block::eval_begin_block {
        my $block = shift;
        local ${^GLOBAL_PHASE};
        Perlito5::set_global_phase("BEGIN");
        my @captured = $block->get_captures();
        my %dont_capture = map {;
            $_->{"dont"} ? ($_->{"dont"}, 1) : ()
        } @captured;
        my %capture = map {;
            $_->{"dont"} ? () : $dont_capture{$_->{"_id"}} ? () : ($_->{"_decl"} eq "local" || $_->{"_decl"} eq "global" || $_->{"_decl"} eq "our" || $_->{"_decl"} eq '') ? () : ($_->{"_id"}, $_)
        } @captured;
        %Perlito5::BEGIN_SCRATCHPAD = (%Perlito5::BEGIN_SCRATCHPAD, %capture);
        $block = $block->emit_begin_scratchpad();
        $block = $block->emit_compile_time();
        local ${"\@"};
        my $result = Perlito5::Perl5::Runtime::eval_ast($block);
        if (${"\@"}) {;
            Perlito5::Compiler::error("Error in BEGIN block: " . ${"\@"})
        }
        return $result
    }
    sub Perlito5::Grammar::Block::opt_continue_block {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (("c" eq $str->[$MATCH->{"to"} + 0]) && ("o" eq $str->[$MATCH->{"to"} + 1]) && ("n" eq $str->[$MATCH->{"to"} + 2]) && ("t" eq $str->[$MATCH->{"to"} + 3]) && ("i" eq $str->[$MATCH->{"to"} + 4]) && ("n" eq $str->[$MATCH->{"to"} + 5]) && ("u" eq $str->[$MATCH->{"to"} + 6]) && ("e" eq $str->[$MATCH->{"to"} + 7]) && ($MATCH->{"to"} += 8)) && (do {
                    my $m2 = block($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"block"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"block"});
                    $MATCH->{"capture"}->{"is_continue"} = 1;
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (do {
                    $MATCH->{"capture"} = Perlito5::AST::Block::->new("stmts", [], "sig", undef);
                    1
                })
            })
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Block::anon_block {
        my $str = $_[0];
        my $pos = $_[1];
        my $p = $pos;
        local $Perlito5::BLOCK_HAS_SEMICOLON;
        my $m = Perlito5::Grammar::block($str, $p);
        !$m && return;
        $p = $m->{"to"};
        my $block = Perlito5::Match::flat($m);
        $m = Perlito5::Grammar::opt_continue_block($str, $p);
        $p = $m->{"to"};
        my $continue = Perlito5::Match::flat($m);
        my $v = $block;
        !$continue->{"is_continue"} && !$Perlito5::BLOCK_HAS_SEMICOLON && ($v = Perlito5::Grammar::Expression::block_or_hash($v));
        $m->{"capture"} = $v;
        if ($continue->{"is_continue"}) {;
            $m->{"capture"}->{"continue"} = $continue
        }
        return $m
    }
    sub Perlito5::Grammar::Block::ast_nop {;
        Perlito5::AST::Apply::->new("code", "nop", "namespace", "Perlito5", "arguments", [])
    }
    sub Perlito5::Grammar::Block::special_named_block {
        my $str = $_[0];
        my $pos = $_[1];
        my $p = $pos;
        my $block_name;
        my $m_name = Perlito5::Grammar::ident($str, $p);
        !$m_name && return;
        $p = $m_name->{"to"};
        $block_name = Perlito5::Match::flat($m_name);
        my $ws = Perlito5::Grammar::Space::opt_ws($str, $p);
        $p = $ws->{"to"};
        my $block_start = $p;
        my $m = Perlito5::Grammar::Block::closure_block($str, $p);
        !$m && return;
        $p = $m->{"to"};
        my $block = Perlito5::Match::flat($m);
        my $compile_block = $Perlito5::SCOPE->{"block"}->[-1];
        $compile_block->{"type"} = "sub";
        $compile_block->{"name"} = $block_name;
        if ($block_name eq "INIT") {
            push(@Perlito5::INIT_BLOCK, eval_end_block($block, "INIT"));
            $m->{"capture"} = ast_nop()
        }
        elsif ($block_name eq "END") {
            unshift(@Perlito5::END_BLOCK, eval_end_block($block, "END"));
            $m->{"capture"} = ast_nop()
        }
        elsif ($block_name eq "CHECK") {
            unshift(@Perlito5::CHECK_BLOCK, eval_end_block($block, "CHECK"));
            $m->{"capture"} = ast_nop()
        }
        elsif ($block_name eq "UNITCHECK") {
            unshift(@Perlito5::UNITCHECK_BLOCK, eval_end_block($block, "UNITCHECK"));
            $m->{"capture"} = ast_nop()
        }
        elsif ($block_name eq "BEGIN") {
            local $Perlito5::PHASE = "BEGIN";
            eval_begin_block($block);
            $m->{"capture"} = ast_nop()
        }
        elsif ($block_name eq "AUTOLOAD" || $block_name eq "DESTROY") {
            my $sub = Perlito5::AST::Sub::->new("attributes", [], "block", $block, "name", $block_name, "namespace", $Perlito5::PKG_NAME, "sig", undef);
            my $full_name = $sub->{"namespace"} . "::" . $sub->{"name"};
            $Perlito5::PROTO->{$full_name} = undef;
            $Perlito5::GLOBAL->{$full_name} = $sub;
            $block = Perlito5::AST::Block::->new("stmts", [$sub]);
            Perlito5::Grammar::Block::eval_begin_block($block, "BEGIN");
            $m->{"capture"} = ast_nop()
        }
        else {
            $m->{"capture"} = $block;
            $m->{"capture"}->{"name"} = $block_name
        }
        return $m
    }
    sub Perlito5::Grammar::Block::named_sub_def {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((do {
            my $m2 = Perlito5::Grammar::optional_namespace_before_ident($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::optional_namespace_before_ident"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::ident($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::ident"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Block::prototype_($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Block::prototype_"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Attribute::opt_attribute($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Attribute::opt_attribute"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((do {
                    my $m2 = Perlito5::Grammar::Block::closure_block($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Block::closure_block"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{"_tmp"} = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Block::closure_block"});
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((do {
                    my $m2 = Perlito5::Grammar::Statement::statement_parse($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    Perlito5::Compiler::error("Illegal declaration of subroutine '", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::ident"}), "'");
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (do {
                    $MATCH->{"_tmp"} = undef;
                    1
                })
            })
        }) && (do {
            my $name = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::ident"});
            my $sig = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Block::prototype_"});
            $sig eq "*undef*" && ($sig = undef);
            my $attributes = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Attribute::opt_attribute"});
            (my($proto)) = grep {;
                $_->[0] eq "prototype"
            } @{$attributes};
            if ($proto) {
                $attributes = [grep {;
                    $_->[0] ne "prototype"
                } @{$attributes}];
                $sig = $proto->[1]
            }
            my $namespace = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::optional_namespace_before_ident"});
            if ($name) {
                if (!$namespace) {;
                    $namespace = $name eq "_" ? "main" : $Perlito5::PKG_NAME
                }
                my $full_name = $namespace . "::" . $name;
                $Perlito5::PROTO->{$full_name} = $sig;
                if ($MATCH->{"_tmp"}) {
                    my $block = $Perlito5::SCOPE->{"block"}->[-1];
                    $block->{"type"} = "sub";
                    $block->{"name"} = $full_name
                }
            }
            my $sub = Perlito5::AST::Sub::->new("name", $name, "namespace", $namespace, "sig", $sig, "block", $MATCH->{"_tmp"}, "attributes", $attributes);
            if ($Perlito5::EXPAND_USE) {
                my $block = Perlito5::AST::Block::->new("stmts", [$sub]);
                Perlito5::Grammar::Block::eval_begin_block($block, "BEGIN");
                if ($name) {
                    my $full_name = $namespace . "::" . $name;
                    $Perlito5::GLOBAL->{$full_name} = $sub;
                    $sub = ast_nop()
                }
                $MATCH->{"capture"} = $sub
            }
            else {;
                $MATCH->{"capture"} = $sub
            }
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Block::named_sub {
        my $str = $_[0];
        my $pos = $_[1];
        $str->[$pos] eq "s" && $str->[$pos + 1] eq "u" && $str->[$pos + 2] eq "b" || return;
        my $ws = Perlito5::Grammar::Space::ws($str, $pos + 3);
        $ws || return;
        my $p = $ws->{"to"};
        my $m_name = Perlito5::Grammar::ident($str, $p);
        $m_name || return;
        my $block_name = Perlito5::Match::flat($m_name);
        if (exists($Named_block{$block_name})) {;
            return Perlito5::Grammar::Block::special_named_block($str, $p)
        }
        return Perlito5::Grammar::Block::named_sub_def($str, $p)
    }
    sub Perlito5::Grammar::Block::term_anon_sub {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((("s" eq $str->[$MATCH->{"to"} + 0]) && ("u" eq $str->[$MATCH->{"to"} + 1]) && ("b" eq $str->[$MATCH->{"to"} + 2]) && ($MATCH->{"to"} += 3)) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Block::anon_sub_def($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Block::anon_sub_def"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = ["term", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Block::anon_sub_def"})];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Block::term_do {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((("d" eq $str->[$MATCH->{"to"} + 0]) && ("o" eq $str->[$MATCH->{"to"} + 1]) && ($MATCH->{"to"} += 2)) && (do {
            my $m2 = Perlito5::Grammar::block($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::block"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", "do", "arguments", [Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::block"})])];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Block::args_sig {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = ((do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{"to"};
            while ((do {
                my $pos1 = $MATCH->{"to"};
                (do {;
                    ((";" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                }) || (do {
                    $MATCH->{"to"} = $pos1;
                    (("\\" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                }) || (do {
                    $MATCH->{"to"} = $pos1;
                    (("[" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                }) || (do {
                    $MATCH->{"to"} = $pos1;
                    (("]" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                }) || (do {
                    $MATCH->{"to"} = $pos1;
                    (("*" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                }) || (do {
                    $MATCH->{"to"} = $pos1;
                    (("+" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                }) || (do {
                    $MATCH->{"to"} = $pos1;
                    (("\@" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                }) || (do {
                    $MATCH->{"to"} = $pos1;
                    (("%" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                }) || (do {
                    $MATCH->{"to"} = $pos1;
                    (("\$" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                }) || (do {
                    $MATCH->{"to"} = $pos1;
                    (("&" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                })
            }) && ($last_match_null < 2)) {
                if ($to == $MATCH->{"to"}) {;
                    $last_match_null = $last_match_null + 1
                }
                else {;
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{"to"}
            }
            $MATCH = $m;
            $MATCH->{"to"} = $to;
            1
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Block::prototype_ {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (("(" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (("_" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && ((")" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    $MATCH->{"capture"} = "_";
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (("(" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $m2 = args_sig($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"args_sig"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && ((")" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    $MATCH->{"capture"} = '' . Perlito5::Match::flat($MATCH->{"args_sig"});
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (do {
                    $MATCH->{"capture"} = "*undef*";
                    1
                })
            })
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Block::anon_sub_def {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((do {
            my $m2 = prototype_($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"prototype_"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Attribute::opt_attribute($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Attribute::opt_attribute"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Block::closure_block($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Block::closure_block"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $sig = Perlito5::Match::flat($MATCH->{"prototype_"});
            $sig eq "*undef*" && ($sig = undef);
            my $attributes = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Attribute::opt_attribute"});
            (my($proto)) = grep {;
                $_->[0] eq "prototype"
            } @{$attributes};
            if ($proto) {
                $attributes = [grep {;
                    $_->[0] ne "prototype"
                } @{$attributes}];
                $sig = $proto->[1]
            }
            $MATCH->{"capture"} = Perlito5::AST::Sub::->new("name", undef, "namespace", undef, "sig", $sig, "block", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Block::closure_block"}), "attributes", $attributes);
            1
        })));
        $tmp ? $MATCH : undef
    }
    Perlito5::Grammar::Precedence::add_term("do", \&term_do);
    Perlito5::Grammar::Precedence::add_term("sub", \&term_anon_sub);
    Perlito5::Grammar::Statement::add_statement("{", \&anon_block);
    Perlito5::Grammar::Statement::add_statement("sub", \&named_sub);
    Perlito5::Grammar::Statement::add_statement($_, \&special_named_block)
        for keys(%Named_block);
    1
}
{
    package main;
    package Perlito5::Grammar::Space;
    my %line_index;
    sub Perlito5::Grammar::Space::count_line {
        my $pos = $_[0];
        $pos < $line_index{$Perlito5::FILE_NAME} && return;
        $line_index{$Perlito5::FILE_NAME} = $pos + 1;
        $Perlito5::LINE_NUMBER++
    }
    my %space = ("#", sub {
        my $m = Perlito5::Grammar::Space::to_eol($_[0], $_[1]);
        $m->{"to"}
    }, chr(9), sub {;
        $_[1]
    }, chr(10), sub {
        my $str = $_[0];
        my $pos = $_[1];
        count_line($pos);
        $str->[$pos] eq chr(13) && $pos++;
        my $m = Perlito5::Grammar::Space::start_of_line($_[0], $pos);
        $m->{"to"}
    }, chr(12), sub {;
        $_[1]
    }, chr(13), sub {
        my $str = $_[0];
        my $pos = $_[1];
        if ($str->[$pos] eq chr(10)) {
            count_line($pos);
            $pos++
        }
        my $m = Perlito5::Grammar::Space::start_of_line($_[0], $pos);
        $m->{"to"}
    }, chr(32), sub {;
        $_[1]
    });
    sub Perlito5::Grammar::Space::term_space {
        my $str = $_[0];
        my $pos = $_[1];
        my $p = $pos;
        while ($p <= @{$str} && $space{$str->[$p]}) {;
            $p = $space{$str->[$p]}->($str, $p + 1)
        }
        if ($str->[$p] eq "_") {
            my $s = join('', @{$str}[$p .. $p + 6]);
            ($s eq "__END__" || $s . $str->[$p + 7] eq "__DATA__") && return term_end($str, $p)
        }
        return {"str", $str, "from", $pos, "to", $p, "capture", ["space", " "]}
    }
    sub Perlito5::Grammar::Space::term_end {
        my $str = $_[0];
        my $p = $_[1];
        my $is_data = 0;
        my $s = join('', @{$str}[$p .. $p + 6]);
        if ($s eq "__END__" && $Perlito5::PKG_NAME eq "main") {
            $p = $p + 7;
            $is_data = 1
        }
        elsif ($s . $str->[$p + 7] eq "__DATA__") {
            $p = $p + 8;
            $is_data = 1
        }
        my $m = Perlito5::Grammar::Space::to_eol($str, $p);
        $p = $m->{"to"};
        if ($str->[$p] eq chr(10)) {
            count_line($p);
            $p++;
            $str->[$p] eq chr(13) && $p++
        }
        elsif ($str->[$p] eq chr(13)) {
            $p++;
            if ($str->[$p] eq chr(10)) {
                count_line($p);
                $p++
            }
        }
        if ($is_data) {
            my $source = join('', @{$str});
            my $len = length($source);
            $source =~ s/^.*\n#--START--\n# line 1//s;
            my $pos = $p - $len + length($source);
            $Perlito5::DATA_SECTION{$Perlito5::PKG_NAME} = {"pos", $pos, "data", $source};
            my $pkg = $Perlito5::PKG_NAME;
            open(*{$pkg . "::DATA"}, "<", \$Perlito5::DATA_SECTION{$pkg}->{"data"});
            seek(*{$pkg . "::DATA"}, $Perlito5::DATA_SECTION{$pkg}->{"pos"}, 0)
        }
        return {"str", $str, "from", $_[1], "to", scalar(@{$str}), "capture", ["space", " "]}
    }
    Perlito5::Grammar::Precedence::add_term("#", \&term_space);
    Perlito5::Grammar::Precedence::add_term(chr(9), \&term_space);
    Perlito5::Grammar::Precedence::add_term(chr(10), \&term_space);
    Perlito5::Grammar::Precedence::add_term(chr(12), \&term_space);
    Perlito5::Grammar::Precedence::add_term(chr(13), \&term_space);
    Perlito5::Grammar::Precedence::add_term(chr(32), \&term_space);
    Perlito5::Grammar::Precedence::add_term("__END__", \&term_end);
    Perlito5::Grammar::Precedence::add_term("__DATA__", \&term_end);
    sub Perlito5::Grammar::Space::to_eol {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = ((do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{"to"};
            while (((do {
                my $tmp = $MATCH;
                $MATCH = {"from", $tmp->{"to"}, "to", $tmp->{"to"}};
                my $res = (do {
                    my $pos1 = $MATCH->{"to"};
                    (do {;
                        (("
" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        (("\x{d}" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                    })
                });
                $MATCH = $tmp;
                $res ? 0 : 1
            }) && ('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"})) && ($last_match_null < 2)) {
                if ($to == $MATCH->{"to"}) {;
                    $last_match_null = $last_match_null + 1
                }
                else {;
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{"to"}
            }
            $MATCH = $m;
            $MATCH->{"to"} = $to;
            1
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Space::pod_pod_begin {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((do {
                    my $pos1 = $MATCH->{"to"};
                    (do {;
                        (("
" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        (("\x{d}" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                    })
                }) && (("=" eq $str->[$MATCH->{"to"} + 0]) && ("c" eq $str->[$MATCH->{"to"} + 1]) && ("u" eq $str->[$MATCH->{"to"} + 2]) && ("t" eq $str->[$MATCH->{"to"} + 3]) && ($MATCH->{"to"} += 4)) && (do {
                    my $m2 = to_eol($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"}) && (do {
                    my $m2 = to_eol($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $m2 = pod_pod_begin($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }))
            })
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Space::pod_begin {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((do {
                    my $pos1 = $MATCH->{"to"};
                    (do {;
                        (("
" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        (("\x{d}" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                    })
                }) && (("=" eq $str->[$MATCH->{"to"} + 0]) && ("e" eq $str->[$MATCH->{"to"} + 1]) && ("n" eq $str->[$MATCH->{"to"} + 2]) && ("d" eq $str->[$MATCH->{"to"} + 3]) && ($MATCH->{"to"} += 4)) && (do {
                    my $m2 = to_eol($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"}) && (do {
                    my $m2 = to_eol($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $m2 = pod_begin($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }))
            })
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Space::start_of_line {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((do {
            my $m2 = Perlito5::Grammar::String::here_doc($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((("=" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $pos1 = $MATCH->{"to"};
                    (do {;
                        ((("p" eq $str->[$MATCH->{"to"} + 0]) && ("o" eq $str->[$MATCH->{"to"} + 1]) && ("d" eq $str->[$MATCH->{"to"} + 2]) && ($MATCH->{"to"} += 3)) && (do {
                            my $m2 = pod_pod_begin($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                1
                            }
                            else {;
                                0
                            }
                        }))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        ((("h" eq $str->[$MATCH->{"to"} + 0]) && ("e" eq $str->[$MATCH->{"to"} + 1]) && ("a" eq $str->[$MATCH->{"to"} + 2]) && ("d" eq $str->[$MATCH->{"to"} + 3]) && ($MATCH->{"to"} += 4)) && (do {
                            my $m2 = pod_pod_begin($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                1
                            }
                            else {;
                                0
                            }
                        }))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        ((("i" eq $str->[$MATCH->{"to"} + 0]) && ("t" eq $str->[$MATCH->{"to"} + 1]) && ("e" eq $str->[$MATCH->{"to"} + 2]) && ("m" eq $str->[$MATCH->{"to"} + 3]) && ($MATCH->{"to"} += 4)) && (do {
                            my $m2 = pod_pod_begin($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                1
                            }
                            else {;
                                0
                            }
                        }))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        ((("o" eq $str->[$MATCH->{"to"} + 0]) && ("v" eq $str->[$MATCH->{"to"} + 1]) && ("e" eq $str->[$MATCH->{"to"} + 2]) && ("r" eq $str->[$MATCH->{"to"} + 3]) && ($MATCH->{"to"} += 4)) && (do {
                            my $m2 = pod_pod_begin($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                1
                            }
                            else {;
                                0
                            }
                        }))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        ((("b" eq $str->[$MATCH->{"to"} + 0]) && ("e" eq $str->[$MATCH->{"to"} + 1]) && ("g" eq $str->[$MATCH->{"to"} + 2]) && ("i" eq $str->[$MATCH->{"to"} + 3]) && ("n" eq $str->[$MATCH->{"to"} + 4]) && ($MATCH->{"to"} += 5)) && (do {
                            my $m2 = pod_begin($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                1
                            }
                            else {;
                                0
                            }
                        }))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        ((("f" eq $str->[$MATCH->{"to"} + 0]) && ("o" eq $str->[$MATCH->{"to"} + 1]) && ("r" eq $str->[$MATCH->{"to"} + 2]) && ($MATCH->{"to"} += 3)) && (do {
                            my $m2 = pod_begin($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                1
                            }
                            else {;
                                0
                            }
                        }))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        ((("e" eq $str->[$MATCH->{"to"} + 0]) && ("n" eq $str->[$MATCH->{"to"} + 1]) && ("c" eq $str->[$MATCH->{"to"} + 2]) && ("o" eq $str->[$MATCH->{"to"} + 3]) && ("d" eq $str->[$MATCH->{"to"} + 4]) && ("i" eq $str->[$MATCH->{"to"} + 5]) && ("n" eq $str->[$MATCH->{"to"} + 6]) && ("g" eq $str->[$MATCH->{"to"} + 7]) && ($MATCH->{"to"} += 8)) && (do {
                            my $m2 = to_eol($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                1
                            }
                            else {;
                                0
                            }
                        }))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        ((("c" eq $str->[$MATCH->{"to"} + 0]) && ("u" eq $str->[$MATCH->{"to"} + 1]) && ("t" eq $str->[$MATCH->{"to"} + 2]) && ($MATCH->{"to"} += 3)) && (do {
                            my $m2 = to_eol($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                1
                            }
                            else {;
                                0
                            }
                        }))
                    })
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((("#" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $last_match_null = 0;
                    my $m = $MATCH;
                    my $to = $MATCH->{"to"};
                    while ((do {
                        my $pos1 = $MATCH->{"to"};
                        (do {;
                            ((" " eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                        }) || (do {
                            $MATCH->{"to"} = $pos1;
                            (("\x{9}" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                        })
                    }) && ($last_match_null < 2)) {
                        if ($to == $MATCH->{"to"}) {;
                            $last_match_null = $last_match_null + 1
                        }
                        else {;
                            $last_match_null = 0
                        }
                        $m = $MATCH;
                        $to = $MATCH->{"to"}
                    }
                    $MATCH = $m;
                    $MATCH->{"to"} = $to;
                    1
                }) && (("l" eq $str->[$MATCH->{"to"} + 0]) && ("i" eq $str->[$MATCH->{"to"} + 1]) && ("n" eq $str->[$MATCH->{"to"} + 2]) && ("e" eq $str->[$MATCH->{"to"} + 3]) && ($MATCH->{"to"} += 4)) && (do {
                    my $last_match_null = 0;
                    my $m = $MATCH;
                    my $to = $MATCH->{"to"};
                    my $count = 0;
                    while ((do {
                        my $pos1 = $MATCH->{"to"};
                        (do {;
                            ((" " eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                        }) || (do {
                            $MATCH->{"to"} = $pos1;
                            (("\x{9}" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                        })
                    }) && ($last_match_null < 2)) {
                        if ($to == $MATCH->{"to"}) {;
                            $last_match_null = $last_match_null + 1
                        }
                        else {;
                            $last_match_null = 0
                        }
                        $m = $MATCH;
                        $to = $MATCH->{"to"};
                        $count = $count + 1
                    }
                    $MATCH = $m;
                    $MATCH->{"to"} = $to;
                    $count > 0
                }) && (do {
                    my $m2 = Perlito5::Grammar::Number::digits($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Number::digits"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $last_match_null = 0;
                    my $m = $MATCH;
                    my $to = $MATCH->{"to"};
                    while ((do {
                        my $pos1 = $MATCH->{"to"};
                        (do {;
                            ((" " eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                        }) || (do {
                            $MATCH->{"to"} = $pos1;
                            (("\x{9}" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                        })
                    }) && ($last_match_null < 2)) {
                        if ($to == $MATCH->{"to"}) {;
                            $last_match_null = $last_match_null + 1
                        }
                        else {;
                            $last_match_null = 0
                        }
                        $m = $MATCH;
                        $to = $MATCH->{"to"}
                    }
                    $MATCH = $m;
                    $MATCH->{"to"} = $to;
                    1
                }) && (do {
                    my $m2 = to_eol($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $Perlito5::LINE_NUMBER = 0 + Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Number::digits"});
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                1
            })
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Space::ws {
        my $str = $_[0];
        my $pos = $_[1];
        my $p = $pos;
        while ($p <= @{$str} && $space{$str->[$p]}) {;
            $p = $space{$str->[$p]}->($str, $p + 1)
        }
        if ($str->[$p] eq "_") {
            my $s = join('', @{$str}[$p .. $p + 6]);
            ($s eq "__END__" || $s . $str->[$p + 7] eq "__DATA__") && return term_end($str, $p)
        }
        if ($p == $pos) {;
            return
        }
        return {"str", $str, "from", $pos, "to", $p}
    }
    sub Perlito5::Grammar::Space::opt_ws {
        my $str = $_[0];
        my $pos = $_[1];
        my $p = $pos;
        while ($p <= @{$str} && $space{$str->[$p]}) {;
            $p = $space{$str->[$p]}->($str, $p + 1)
        }
        if ($str->[$p] eq "_") {
            my $s = join('', @{$str}[$p .. $p + 6]);
            ($s eq "__END__" || $s . $str->[$p + 7] eq "__DATA__") && return term_end($_[0], $p)
        }
        return {"str", $_[0], "from", $pos, "to", $p}
    }
    1
}
{
    package main;
    package Perlito5::Grammar::Print;
    our %Print = ("print", 1, "printf", 1, "say", 1, "exec", 1, "system", 1);
    sub Perlito5::Grammar::Print::print_decl {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                (("p" eq $str->[$MATCH->{"to"} + 0]) && ("r" eq $str->[$MATCH->{"to"} + 1]) && ("i" eq $str->[$MATCH->{"to"} + 2]) && ("n" eq $str->[$MATCH->{"to"} + 3]) && ("t" eq $str->[$MATCH->{"to"} + 4]) && ("f" eq $str->[$MATCH->{"to"} + 5]) && ($MATCH->{"to"} += 6))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (("p" eq $str->[$MATCH->{"to"} + 0]) && ("r" eq $str->[$MATCH->{"to"} + 1]) && ("i" eq $str->[$MATCH->{"to"} + 2]) && ("n" eq $str->[$MATCH->{"to"} + 3]) && ("t" eq $str->[$MATCH->{"to"} + 4]) && ($MATCH->{"to"} += 5))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (("s" eq $str->[$MATCH->{"to"} + 0]) && ("a" eq $str->[$MATCH->{"to"} + 1]) && ("y" eq $str->[$MATCH->{"to"} + 2]) && ($MATCH->{"to"} += 3))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (("e" eq $str->[$MATCH->{"to"} + 0]) && ("x" eq $str->[$MATCH->{"to"} + 1]) && ("e" eq $str->[$MATCH->{"to"} + 2]) && ("c" eq $str->[$MATCH->{"to"} + 3]) && ($MATCH->{"to"} += 4))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (("s" eq $str->[$MATCH->{"to"} + 0]) && ("y" eq $str->[$MATCH->{"to"} + 1]) && ("s" eq $str->[$MATCH->{"to"} + 2]) && ("t" eq $str->[$MATCH->{"to"} + 3]) && ("e" eq $str->[$MATCH->{"to"} + 4]) && ("m" eq $str->[$MATCH->{"to"} + 5]) && ($MATCH->{"to"} += 6))
            })
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Print::the_object {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((do {
                    my $tmp = $MATCH;
                    $MATCH = {"from", $tmp->{"to"}, "to", $tmp->{"to"}};
                    my $res = (("\$" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1));
                    $MATCH = $tmp;
                    $res ? 1 : 0
                }) && (do {
                    my $m2 = Perlito5::Grammar::Sigil::term_sigil($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Sigil::term_sigil"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $tmp = $MATCH;
                    $MATCH = {"from", $tmp->{"to"}, "to", $tmp->{"to"}};
                    my $res = (("+" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1));
                    $MATCH = $tmp;
                    $res ? 0 : 1
                }) && (do {
                    $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Sigil::term_sigil"})->[1];
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((do {
                    my $tmp = $MATCH;
                    $MATCH = {"from", $tmp->{"to"}, "to", $tmp->{"to"}};
                    my $res = (("{" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1));
                    $MATCH = $tmp;
                    $res ? 1 : 0
                }) && (do {
                    my $m2 = Perlito5::Grammar::Block::block($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Block::block"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Block::block"});
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((do {
                    my $m2 = typeglob($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"typeglob"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"typeglob"});
                    1
                }))
            })
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $tmp = $MATCH;
            $MATCH = {"from", $tmp->{"to"}, "to", $tmp->{"to"}};
            my $res = (do {
                my $pos1 = $MATCH->{"to"};
                (do {;
                    (("," eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                }) || (do {
                    $MATCH->{"to"} = $pos1;
                    (("?" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                }) || (do {
                    $MATCH->{"to"} = $pos1;
                    (("-" eq $str->[$MATCH->{"to"} + 0]) && (">" eq $str->[$MATCH->{"to"} + 1]) && ($MATCH->{"to"} += 2))
                }) || (do {
                    $MATCH->{"to"} = $pos1;
                    (("[" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                }) || (do {
                    $MATCH->{"to"} = $pos1;
                    (("{" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                })
            });
            $MATCH = $tmp;
            $res ? 0 : 1
        }) && (do {
            my $pos = $MATCH->{"to"};
            my $s = $str->[$pos];
            if ($s eq "+") {
                my $m = Perlito5::Grammar::Space::ws($MATCH->{"str"}, $pos + 1);
                if ($m) {;
                    return
                }
            }
            else {
                my $m = Perlito5::Grammar::Precedence::op_parse($MATCH->{"str"}, $pos, 1);
                my $next_op = $m ? Perlito5::Match::flat($m)->[1] : '';
                my $is_infix = Perlito5::Grammar::Precedence::is_fixity_type("infix", $next_op);
                $is_infix && $next_op ne "<<" && return
            }
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Print::typeglob {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((do {
            my $m2 = typeglob_bareword($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"typeglob_bareword"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $tmp = $MATCH;
            $MATCH = {"from", $tmp->{"to"}, "to", $tmp->{"to"}};
            my $res = (("(" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1));
            $MATCH = $tmp;
            $res ? 0 : 1
        }) && (do {
            $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"typeglob_bareword"});
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Print::typeglob_bareword {
        my $str = $_[0];
        my $pos = $_[1];
        my $p = $pos;
        my $m_namespace = Perlito5::Grammar::optional_namespace_before_ident($str, $p);
        my $namespace = Perlito5::Match::flat($m_namespace);
        $p = $m_namespace->{"to"};
        my $m_name = Perlito5::Grammar::ident($str, $p);
        if (!$m_name) {
            if ($namespace) {
                $m_namespace->{"capture"} = Perlito5::AST::Var::->new("sigil", "::", "name", '', "namespace", $namespace);
                return $m_namespace
            }
            return
        }
        my $name = Perlito5::Match::flat($m_name);
        $p = $m_name->{"to"};
        my $s = $str->[$p];
        my $s2 = $s . $str->[$p + 1];
        if ($s2 eq "::") {
            $m_name->{"to"} = $p + 2;
            $m_name->{"capture"} = Perlito5::AST::Var::->new("sigil", "::", "name", '', "namespace", $namespace . "::" . $name);
            return $m_name
        }
        my $effective_name = ($namespace || $Perlito5::PKG_NAME) . "::" . $name;
        if (exists($Perlito5::PROTO->{$effective_name}) || exists(&{$effective_name})) {;
            return
        }
        if ((!$namespace || $namespace eq "CORE") && exists($Perlito5::CORE_PROTO->{"CORE::" . $name})) {;
            return
        }
        my $full_name = $name;
        $namespace && ($full_name = $namespace . "::" . $name);
        $m_name->{"capture"} = Perlito5::AST::Var::->new("sigil", "::", "name", '', "namespace", $full_name);
        return $m_name
    }
    sub Perlito5::Grammar::Print::print_ast {
        (my($decl), my($the_object), my($expr)) = @_;
        Perlito5::AST::Apply::->new("namespace", '', "code", $decl, "special_arg", $the_object, "arguments", $expr)
    }
    sub Perlito5::Grammar::Print::term_print {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((do {
            my $m2 = print_decl($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"print_decl"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((("(" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{"_scope"} = $#Perlito5::SCOPE_STMT;
                    1
                }) && (do {
                    my $pos1 = $MATCH->{"to"};
                    (do {;
                        ((do {
                            my $m2 = the_object($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                $MATCH->{"the_object"} = $m2;
                                1
                            }
                            else {;
                                0
                            }
                        }) && (do {
                            my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                $MATCH->{"Perlito5::Grammar::Expression::list_parse"} = $m2;
                                1
                            }
                            else {;
                                0
                            }
                        }))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        (do {
                            $#Perlito5::SCOPE_STMT = $MATCH->{"_scope"};
                            return;
                            1
                        })
                    })
                }) && ((")" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $list = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::list_parse"});
                    !ref($list) && return;
                    $MATCH->{"capture"} = ["term", print_ast(Perlito5::Match::flat($MATCH->{"print_decl"}), Perlito5::Match::flat($MATCH->{"the_object"}), Perlito5::Grammar::Expression::expand_list($list))];
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((do {
                    $MATCH->{"_scope"} = $#Perlito5::SCOPE_STMT;
                    1
                }) && (do {
                    my $pos1 = $MATCH->{"to"};
                    (do {;
                        ((do {
                            my $m2 = the_object($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                $MATCH->{"the_object"} = $m2;
                                1
                            }
                            else {;
                                0
                            }
                        }) && (do {
                            my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                $MATCH->{"Perlito5::Grammar::Expression::list_parse"} = $m2;
                                1
                            }
                            else {;
                                0
                            }
                        }))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        (do {
                            $#Perlito5::SCOPE_STMT = $MATCH->{"_scope"};
                            return;
                            1
                        })
                    })
                }) && (do {
                    my $list = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::list_parse"});
                    !ref($list) && return;
                    $MATCH->{"capture"} = ["term", print_ast(Perlito5::Match::flat($MATCH->{"print_decl"}), Perlito5::Match::flat($MATCH->{"the_object"}), Perlito5::Grammar::Expression::expand_list($list))];
                    1
                }))
            })
        })));
        $tmp ? $MATCH : undef
    }
    Perlito5::Grammar::Precedence::add_term("print", \&term_print);
    Perlito5::Grammar::Precedence::add_term("printf", \&term_print);
    Perlito5::Grammar::Precedence::add_term("say", \&term_print);
    Perlito5::Grammar::Precedence::add_term("exec", \&term_print);
    Perlito5::Grammar::Precedence::add_term("system", \&term_print);
    1
}
{
    package main;
    package Perlito5::Grammar::Map;
    sub Perlito5::Grammar::Map::map_or_grep {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                (("m" eq $str->[$MATCH->{"to"} + 0]) && ("a" eq $str->[$MATCH->{"to"} + 1]) && ("p" eq $str->[$MATCH->{"to"} + 2]) && ($MATCH->{"to"} += 3))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (("g" eq $str->[$MATCH->{"to"} + 0]) && ("r" eq $str->[$MATCH->{"to"} + 1]) && ("e" eq $str->[$MATCH->{"to"} + 2]) && ("p" eq $str->[$MATCH->{"to"} + 3]) && ($MATCH->{"to"} += 4))
            })
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Map::term_map_or_grep {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((do {
            my $m2 = map_or_grep($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"map_or_grep"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((do {
                    my $m2 = Perlito5::Grammar::block($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::block"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Expression::list_parse"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", Perlito5::Match::flat($MATCH->{"map_or_grep"}), "special_arg", $MATCH->{"Perlito5::Grammar::block"}->{"capture"}, "arguments", Perlito5::Grammar::Expression::expand_list($MATCH->{"Perlito5::Grammar::Expression::list_parse"}->{"capture"}), "namespace", '')];
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((("(" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $m2 = Perlito5::Grammar::block($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::block"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Expression::list_parse"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && ((")" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", Perlito5::Match::flat($MATCH->{"map_or_grep"}), "special_arg", $MATCH->{"Perlito5::Grammar::block"}->{"capture"}, "arguments", Perlito5::Grammar::Expression::expand_list($MATCH->{"Perlito5::Grammar::Expression::list_parse"}->{"capture"}), "namespace", '')];
                    1
                }))
            })
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Map::non_core_ident {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((do {
            my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::full_ident"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $name = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::full_ident"});
            (exists($Perlito5::CORE_PROTO->{$name}) || exists($Perlito5::CORE_PROTO->{"CORE::" . $name})) && return;
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Map::term_sort {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((("s" eq $str->[$MATCH->{"to"} + 0]) && ("o" eq $str->[$MATCH->{"to"} + 1]) && ("r" eq $str->[$MATCH->{"to"} + 2]) && ("t" eq $str->[$MATCH->{"to"} + 3]) && ($MATCH->{"to"} += 4)) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((("(" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $pos1 = $MATCH->{"to"};
                    (do {;
                        ((do {
                            my $m2 = Perlito5::Grammar::Map::non_core_ident($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                $MATCH->{"Perlito5::Grammar::Map::non_core_ident"} = $m2;
                                1
                            }
                            else {;
                                0
                            }
                        }) && (do {
                            my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                1
                            }
                            else {;
                                0
                            }
                        }) && (do {
                            my $name = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Map::non_core_ident"});
                            $MATCH->{"_tmp"} = $name;
                            1
                        }))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        ((do {
                            my $m2 = Perlito5::Grammar::block($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                $MATCH->{"Perlito5::Grammar::block"} = $m2;
                                1
                            }
                            else {;
                                0
                            }
                        }) && (do {
                            $MATCH->{"_tmp"} = $MATCH->{"Perlito5::Grammar::block"}->{"capture"};
                            1
                        }))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        ((do {
                            my $tmp = $MATCH;
                            $MATCH = {"from", $tmp->{"to"}, "to", $tmp->{"to"}};
                            my $res = (("\$" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1));
                            $MATCH = $tmp;
                            $res ? 1 : 0
                        }) && (do {
                            my $m2 = Perlito5::Grammar::Sigil::term_sigil($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                $MATCH->{"Perlito5::Grammar::Sigil::term_sigil"} = $m2;
                                1
                            }
                            else {;
                                0
                            }
                        }) && (do {
                            my $var = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Sigil::term_sigil"})->[1];
                            ref($var) ne "Perlito5::AST::Var" && return;
                            $MATCH->{"_tmp"} = $var;
                            1
                        }))
                    })
                }) && (do {
                    my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Expression::list_parse"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && ((")" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", "sort", "special_arg", $MATCH->{"_tmp"}, "arguments", Perlito5::Grammar::Expression::expand_list($MATCH->{"Perlito5::Grammar::Expression::list_parse"}->{"capture"}), "namespace", '')];
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((do {
                    my $pos1 = $MATCH->{"to"};
                    (do {;
                        ((do {
                            my $m2 = Perlito5::Grammar::block($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                $MATCH->{"Perlito5::Grammar::block"} = $m2;
                                1
                            }
                            else {;
                                0
                            }
                        }) && (do {
                            $MATCH->{"_tmp"} = $MATCH->{"Perlito5::Grammar::block"}->{"capture"};
                            1
                        }))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        ((do {
                            my $m2 = Perlito5::Grammar::Map::non_core_ident($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                $MATCH->{"Perlito5::Grammar::Map::non_core_ident"} = $m2;
                                1
                            }
                            else {;
                                0
                            }
                        }) && (do {
                            my $name = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Map::non_core_ident"});
                            $MATCH->{"_tmp"} = $name;
                            1
                        }))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        ((do {
                            my $tmp = $MATCH;
                            $MATCH = {"from", $tmp->{"to"}, "to", $tmp->{"to"}};
                            my $res = (("\$" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1));
                            $MATCH = $tmp;
                            $res ? 1 : 0
                        }) && (do {
                            my $m2 = Perlito5::Grammar::Sigil::term_sigil($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                $MATCH->{"Perlito5::Grammar::Sigil::term_sigil"} = $m2;
                                1
                            }
                            else {;
                                0
                            }
                        }) && (do {
                            my $var = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Sigil::term_sigil"})->[1];
                            ref($var) ne "Perlito5::AST::Var" && return;
                            $MATCH->{"_tmp"} = $var;
                            1
                        }))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        (do {
                            $MATCH->{"_tmp"} = Perlito5::AST::Block::->new("stmts", [Perlito5::AST::Apply::->new("code", "infix:<cmp>", "arguments", [Perlito5::AST::Var::->new("name", "a", "namespace", $Perlito5::PKG, "sigil", "\$"), Perlito5::AST::Var::->new("name", "b", "namespace", $Perlito5::PKG, "sigil", "\$")])]);
                            1
                        })
                    })
                }) && (do {
                    my $m2 = Perlito5::Grammar::Expression::list_parse($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Expression::list_parse"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", "sort", "special_arg", $MATCH->{"_tmp"}, "arguments", Perlito5::Grammar::Expression::expand_list($MATCH->{"Perlito5::Grammar::Expression::list_parse"}->{"capture"}), "namespace", '')];
                    1
                }))
            })
        })));
        $tmp ? $MATCH : undef
    }
    Perlito5::Grammar::Precedence::add_term("map", \&term_map_or_grep);
    Perlito5::Grammar::Precedence::add_term("grep", \&term_map_or_grep);
    Perlito5::Grammar::Precedence::add_term("sort", \&term_sort);
    1
}
{
    package main;
    package Perlito5::Grammar::Number;
    sub Perlito5::Grammar::Number::term_digit {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((do {
                    my $m2 = Perlito5::Grammar::Number::val_octal($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Number::val_octal"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{"capture"} = ["term", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Number::val_octal"})];
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((do {
                    my $m2 = Perlito5::Grammar::Number::val_vstring($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Number::val_vstring"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{"capture"} = ["term", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Number::val_vstring"})];
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((do {
                    my $m2 = Perlito5::Grammar::Number::val_num($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Number::val_num"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{"capture"} = ["term", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Number::val_num"})];
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((do {
                    my $m2 = Perlito5::Grammar::Number::val_int($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Number::val_int"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{"capture"} = ["term", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Number::val_int"})];
                    1
                }))
            })
        }));
        $tmp ? $MATCH : undef
    }
    Perlito5::Grammar::Precedence::add_term($_, \&term_digit)
        for ".", 0 .. 9;
    sub Perlito5::Grammar::Number::digit {
        my $str = $_[0];
        my $pos = $_[1];
        $str->[$pos] ge 0 && $str->[$pos] le 9 ? {"str", $str, "from", $pos, "to", $pos + 1} : 0
    }
    sub Perlito5::Grammar::Number::exponent {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                (("e" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (("E" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
            })
        }) && (do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                (("+" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (("-" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                1
            })
        }) && (do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{"to"};
            my $count = 0;
            while ((do {
                my $pos1 = $MATCH->{"to"};
                (do {;
                    (("_" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                }) || (do {
                    $MATCH->{"to"} = $pos1;
                    (do {
                        my $m2 = digit($str, $MATCH->{"to"});
                        if ($m2) {
                            $MATCH->{"to"} = $m2->{"to"};
                            1
                        }
                        else {;
                            0
                        }
                    })
                })
            }) && ($last_match_null < 2)) {
                if ($to == $MATCH->{"to"}) {;
                    $last_match_null = $last_match_null + 1
                }
                else {;
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{"to"};
                $count = $count + 1
            }
            $MATCH = $m;
            $MATCH->{"to"} = $to;
            $count > 0
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Number::val_num {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((("." eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $m2 = digit($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $last_match_null = 0;
                    my $m = $MATCH;
                    my $to = $MATCH->{"to"};
                    while ((do {
                        my $pos1 = $MATCH->{"to"};
                        (do {;
                            (("_" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                        }) || (do {
                            $MATCH->{"to"} = $pos1;
                            (do {
                                my $m2 = digit($str, $MATCH->{"to"});
                                if ($m2) {
                                    $MATCH->{"to"} = $m2->{"to"};
                                    1
                                }
                                else {;
                                    0
                                }
                            })
                        })
                    }) && ($last_match_null < 2)) {
                        if ($to == $MATCH->{"to"}) {;
                            $last_match_null = $last_match_null + 1
                        }
                        else {;
                            $last_match_null = 0
                        }
                        $m = $MATCH;
                        $to = $MATCH->{"to"}
                    }
                    $MATCH = $m;
                    $MATCH->{"to"} = $to;
                    1
                }) && (do {
                    my $m = $MATCH;
                    if (!(do {
                        my $m2 = exponent($str, $MATCH->{"to"});
                        if ($m2) {
                            $MATCH->{"to"} = $m2->{"to"};
                            1
                        }
                        else {;
                            0
                        }
                    })) {;
                        $MATCH = $m
                    }
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((do {
                    my $m2 = digit($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $last_match_null = 0;
                    my $m = $MATCH;
                    my $to = $MATCH->{"to"};
                    while ((do {
                        my $pos1 = $MATCH->{"to"};
                        (do {;
                            (("_" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                        }) || (do {
                            $MATCH->{"to"} = $pos1;
                            (do {
                                my $m2 = digit($str, $MATCH->{"to"});
                                if ($m2) {
                                    $MATCH->{"to"} = $m2->{"to"};
                                    1
                                }
                                else {;
                                    0
                                }
                            })
                        })
                    }) && ($last_match_null < 2)) {
                        if ($to == $MATCH->{"to"}) {;
                            $last_match_null = $last_match_null + 1
                        }
                        else {;
                            $last_match_null = 0
                        }
                        $m = $MATCH;
                        $to = $MATCH->{"to"}
                    }
                    $MATCH = $m;
                    $MATCH->{"to"} = $to;
                    1
                }) && (do {
                    my $pos1 = $MATCH->{"to"};
                    (do {;
                        (do {
                            my $m2 = exponent($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                1
                            }
                            else {;
                                0
                            }
                        })
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        ((("." eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                            my $tmp = $MATCH;
                            $MATCH = {"from", $tmp->{"to"}, "to", $tmp->{"to"}};
                            my $res = (("." eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1));
                            $MATCH = $tmp;
                            $res ? 0 : 1
                        }) && (do {
                            my $last_match_null = 0;
                            my $m = $MATCH;
                            my $to = $MATCH->{"to"};
                            while ((do {
                                my $pos1 = $MATCH->{"to"};
                                (do {;
                                    (("_" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                                }) || (do {
                                    $MATCH->{"to"} = $pos1;
                                    (do {
                                        my $m2 = digit($str, $MATCH->{"to"});
                                        if ($m2) {
                                            $MATCH->{"to"} = $m2->{"to"};
                                            1
                                        }
                                        else {;
                                            0
                                        }
                                    })
                                })
                            }) && ($last_match_null < 2)) {
                                if ($to == $MATCH->{"to"}) {;
                                    $last_match_null = $last_match_null + 1
                                }
                                else {;
                                    $last_match_null = 0
                                }
                                $m = $MATCH;
                                $to = $MATCH->{"to"}
                            }
                            $MATCH = $m;
                            $MATCH->{"to"} = $to;
                            1
                        }) && (do {
                            my $m = $MATCH;
                            if (!(do {
                                my $m2 = exponent($str, $MATCH->{"to"});
                                if ($m2) {
                                    $MATCH->{"to"} = $m2->{"to"};
                                    1
                                }
                                else {;
                                    0
                                }
                            })) {;
                                $MATCH = $m
                            }
                            1
                        }))
                    })
                }))
            })
        }) && (do {
            my $s = Perlito5::Match::flat($MATCH);
            $s =~ s/_//g;
            $MATCH->{"capture"} = Perlito5::AST::Num::->new("num", $s);
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Number::digits {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = ((do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{"to"};
            my $count = 0;
            while ((do {
                my $m2 = digit($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && ($last_match_null < 2)) {
                if ($to == $MATCH->{"to"}) {;
                    $last_match_null = $last_match_null + 1
                }
                else {;
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{"to"};
                $count = $count + 1
            }
            $MATCH = $m;
            $MATCH->{"to"} = $to;
            $count > 0
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Number::digits_underscore {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((do {
            my $m2 = digit($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{"to"};
            while ((do {
                my $pos1 = $MATCH->{"to"};
                (do {;
                    (("_" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                }) || (do {
                    $MATCH->{"to"} = $pos1;
                    (do {
                        my $m2 = digit($str, $MATCH->{"to"});
                        if ($m2) {
                            $MATCH->{"to"} = $m2->{"to"};
                            1
                        }
                        else {;
                            0
                        }
                    })
                })
            }) && ($last_match_null < 2)) {
                if ($to == $MATCH->{"to"}) {;
                    $last_match_null = $last_match_null + 1
                }
                else {;
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{"to"}
            }
            $MATCH = $m;
            $MATCH->{"to"} = $to;
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Number::val_octal {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = ((((0 eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((do {
                    my $pos1 = $MATCH->{"to"};
                    (do {;
                        (("x" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        (("X" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                    })
                }) && (do {
                    my $last_match_null = 0;
                    my $m = $MATCH;
                    my $to = $MATCH->{"to"};
                    my $count = 0;
                    while ((do {
                        my $m2 = Perlito5::Grammar::word($str, $MATCH->{"to"});
                        if ($m2) {
                            $MATCH->{"to"} = $m2->{"to"};
                            1
                        }
                        else {;
                            0
                        }
                    }) && ($last_match_null < 2)) {
                        if ($to == $MATCH->{"to"}) {;
                            $last_match_null = $last_match_null + 1
                        }
                        else {;
                            $last_match_null = 0
                        }
                        $m = $MATCH;
                        $to = $MATCH->{"to"};
                        $count = $count + 1
                    }
                    $MATCH = $m;
                    $MATCH->{"to"} = $to;
                    $count > 0
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((do {
                    my $pos1 = $MATCH->{"to"};
                    (do {;
                        (("b" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        (("B" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                    })
                }) && (do {
                    my $last_match_null = 0;
                    my $m = $MATCH;
                    my $to = $MATCH->{"to"};
                    my $count = 0;
                    while ((do {
                        my $pos1 = $MATCH->{"to"};
                        (do {;
                            (("_" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                        }) || (do {
                            $MATCH->{"to"} = $pos1;
                            ((0 eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                        }) || (do {
                            $MATCH->{"to"} = $pos1;
                            ((1 eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                        })
                    }) && ($last_match_null < 2)) {
                        if ($to == $MATCH->{"to"}) {;
                            $last_match_null = $last_match_null + 1
                        }
                        else {;
                            $last_match_null = 0
                        }
                        $m = $MATCH;
                        $to = $MATCH->{"to"};
                        $count = $count + 1
                    }
                    $MATCH = $m;
                    $MATCH->{"to"} = $to;
                    $count > 0
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (do {
                    my $last_match_null = 0;
                    my $m = $MATCH;
                    my $to = $MATCH->{"to"};
                    my $count = 0;
                    while ((do {
                        my $pos1 = $MATCH->{"to"};
                        (do {;
                            (("_" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
                        }) || (do {
                            $MATCH->{"to"} = $pos1;
                            (do {
                                my $m2 = digit($str, $MATCH->{"to"});
                                if ($m2) {
                                    $MATCH->{"to"} = $m2->{"to"};
                                    1
                                }
                                else {;
                                    0
                                }
                            })
                        })
                    }) && ($last_match_null < 2)) {
                        if ($to == $MATCH->{"to"}) {;
                            $last_match_null = $last_match_null + 1
                        }
                        else {;
                            $last_match_null = 0
                        }
                        $m = $MATCH;
                        $to = $MATCH->{"to"};
                        $count = $count + 1
                    }
                    $MATCH = $m;
                    $MATCH->{"to"} = $to;
                    $count > 0
                })
            })
        }) && (do {
            $MATCH->{"capture"} = Perlito5::AST::Int::->new("int", oct(lc(Perlito5::Match::flat($MATCH))));
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Number::val_int {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((do {
            my $m2 = digits_underscore($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $s = Perlito5::Match::flat($MATCH);
            $s =~ s/_//g;
            $MATCH->{"capture"} = Perlito5::AST::Int::->new("int", $s);
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Number::val_vstring {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((do {
            my $m2 = val_int($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"val_int"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{"to"};
            my $count = 0;
            while (((("." eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $m2 = digits_underscore($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    if (exists($MATCH->{"digits_underscore"})) {;
                        push(@{$MATCH->{"digits_underscore"}}, $m2)
                    }
                    else {;
                        $MATCH->{"digits_underscore"} = [$m2]
                    }
                    1
                }
                else {;
                    0
                }
            })) && ($last_match_null < 2)) {
                if ($to == $MATCH->{"to"}) {;
                    $last_match_null = $last_match_null + 1
                }
                else {;
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{"to"};
                $count = $count + 1
            }
            $MATCH = $m;
            $MATCH->{"to"} = $to;
            $count > 0
        }) && (do {
            my @parts = map {;
                Perlito5::Match::flat($_)
            } @{$MATCH->{"digits_underscore"}};
            @parts < 2 && return;
            $MATCH->{"capture"} = Perlito5::AST::Buf::->new("is_vstring", 1, "buf", join('', map {;
                chr($_)
            } $MATCH->{"val_int"}->{"capture"}->{"int"}, @parts));
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Number::val_version {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((("v" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $m2 = val_int($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"val_int"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $tmp = $MATCH;
            $MATCH = {"from", $tmp->{"to"}, "to", $tmp->{"to"}};
            my $res = ((do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (("(" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)));
            $MATCH = $tmp;
            $res ? 0 : 1
        }) && (do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{"to"};
            while (((("." eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $m2 = digits_underscore($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    if (exists($MATCH->{"digits_underscore"})) {;
                        push(@{$MATCH->{"digits_underscore"}}, $m2)
                    }
                    else {;
                        $MATCH->{"digits_underscore"} = [$m2]
                    }
                    1
                }
                else {;
                    0
                }
            })) && ($last_match_null < 2)) {
                if ($to == $MATCH->{"to"}) {;
                    $last_match_null = $last_match_null + 1
                }
                else {;
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{"to"}
            }
            $MATCH = $m;
            $MATCH->{"to"} = $to;
            1
        }) && (do {
            my @parts = map {;
                Perlito5::Match::flat($_)
            } @{$MATCH->{"digits_underscore"}};
            $MATCH->{"capture"} = Perlito5::AST::Buf::->new("buf", join('', map {;
                chr($_)
            } $MATCH->{"val_int"}->{"capture"}->{"int"}, @parts));
            1
        })));
        $tmp ? $MATCH : undef
    }
    1
}
{
    package main;
    package Perlito5::Grammar;
    sub Perlito5::Grammar::word {
        my $str = $_[0];
        my $pos = $_[1];
        ($str->[$pos] ge "a" && $str->[$pos] le "z") || ($str->[$pos] ge "A" && $str->[$pos] le "Z") || ($str->[$pos] ge 0 && $str->[$pos] le 9) || ($str->[$pos] eq "_") || return;
        $pos++;
        return {"str", $_[0], "from", $_[1], "to", $pos}
    }
    sub Perlito5::Grammar::ident {
        my $str = $_[0];
        my $pos = $_[1];
        ($str->[$pos] ge "a" && $str->[$pos] le "z") || ($str->[$pos] ge "A" && $str->[$pos] le "Z") || ($str->[$pos] eq "_") || return;
        $pos++;
        while (($str->[$pos] ge "a" && $str->[$pos] le "z") || ($str->[$pos] ge "A" && $str->[$pos] le "Z") || ($str->[$pos] ge 0 && $str->[$pos] le 9) || ($str->[$pos] eq "_")) {;
            $pos++
        }
        ($pos - $_[1]) > 251 && die("Identifier too long");
        return {"str", $_[0], "from", $_[1], "to", $pos}
    }
    sub Perlito5::Grammar::caret_char {
        my $str = $_[0];
        my $pos = $_[1];
        my $c = $str->[$pos];
        if ($c eq "^") {
            $pos++;
            $c = $str->[$pos];
            ($c lt "A" || $c gt "Z") && return 0;
            $c = chr(ord($c) - ord("A") + 1)
        }
        elsif (Perlito5::Grammar::Space::ws($_[0], $pos)) {;
            return
        }
        ($c lt "\x{1}" || $c gt "\x{1a}") && return;
        return {"str", $_[0], "from", $_[1], "to", $pos + 1, "capture", $c}
    }
    sub Perlito5::Grammar::full_ident {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((do {
            my $m2 = ident($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{"to"};
            while ((((":" eq $str->[$MATCH->{"to"} + 0]) && (":" eq $str->[$MATCH->{"to"} + 1]) && ($MATCH->{"to"} += 2)) && (do {
                my $m2 = ident($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            })) && ($last_match_null < 2)) {
                if ($to == $MATCH->{"to"}) {;
                    $last_match_null = $last_match_null + 1
                }
                else {;
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{"to"}
            }
            $MATCH = $m;
            $MATCH->{"to"} = $to;
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::namespace_before_ident {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((do {
            my $m2 = ident($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $tmp = $MATCH;
            $MATCH = {"from", $tmp->{"to"}, "to", $tmp->{"to"}};
            my $res = ((":" eq $str->[$MATCH->{"to"} + 0]) && (":" eq $str->[$MATCH->{"to"} + 1]) && ($MATCH->{"to"} += 2));
            $MATCH = $tmp;
            $res ? 1 : 0
        }) && (do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{"to"};
            while ((((":" eq $str->[$MATCH->{"to"} + 0]) && (":" eq $str->[$MATCH->{"to"} + 1]) && ($MATCH->{"to"} += 2)) && (do {
                my $m2 = ident($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $tmp = $MATCH;
                $MATCH = {"from", $tmp->{"to"}, "to", $tmp->{"to"}};
                my $res = ((":" eq $str->[$MATCH->{"to"} + 0]) && (":" eq $str->[$MATCH->{"to"} + 1]) && ($MATCH->{"to"} += 2));
                $MATCH = $tmp;
                $res ? 1 : 0
            })) && ($last_match_null < 2)) {
                if ($to == $MATCH->{"to"}) {;
                    $last_match_null = $last_match_null + 1
                }
                else {;
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{"to"}
            }
            $MATCH = $m;
            $MATCH->{"to"} = $to;
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::optional_namespace_before_ident {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((do {
                    my $m2 = namespace_before_ident($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"namespace_before_ident"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $last_match_null = 0;
                    my $m = $MATCH;
                    my $to = $MATCH->{"to"};
                    while (((":" eq $str->[$MATCH->{"to"} + 0]) && (":" eq $str->[$MATCH->{"to"} + 1]) && ($MATCH->{"to"} += 2)) && ($last_match_null < 2)) {
                        if ($to == $MATCH->{"to"}) {;
                            $last_match_null = $last_match_null + 1
                        }
                        else {;
                            $last_match_null = 0
                        }
                        $m = $MATCH;
                        $to = $MATCH->{"to"}
                    }
                    $MATCH = $m;
                    $MATCH->{"to"} = $to;
                    1
                }) && (do {
                    $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"namespace_before_ident"});
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (((":" eq $str->[$MATCH->{"to"} + 0]) && (":" eq $str->[$MATCH->{"to"} + 1]) && ($MATCH->{"to"} += 2)) && (do {
                    my $m2 = optional_namespace_before_ident($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"optional_namespace_before_ident"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $name = Perlito5::Match::flat($MATCH->{"optional_namespace_before_ident"});
                    $MATCH->{"capture"} = "main";
                    $name ne '' && ($MATCH->{"capture"} .= "::" . $name);
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (1 && (do {
                    $MATCH->{"capture"} = '';
                    1
                }))
            })
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::exp_stmts2 {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((do {
            my $m2 = exp_stmts($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"exp_stmts"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"exp_stmts"});
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::exp {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((do {
            my $m2 = Perlito5::Grammar::Expression::exp_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Expression::exp_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::exp_parse"});
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::exp2 {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((do {
            my $m2 = Perlito5::Grammar::Expression::exp_parse($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Expression::exp_parse"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Expression::exp_parse"});
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::opt_type {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((do {
                    my $m = $MATCH;
                    if (!((":" eq $str->[$MATCH->{"to"} + 0]) && (":" eq $str->[$MATCH->{"to"} + 1]) && ($MATCH->{"to"} += 2))) {;
                        $MATCH = $m
                    }
                    1
                }) && (do {
                    my $m2 = full_ident($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"full_ident"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"full_ident"});
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (1 && (do {
                    $MATCH->{"capture"} = '';
                    1
                }))
            })
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::var_sigil {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                (("\$" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (("%" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (("\@" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (("&" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (("*" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
            })
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::var_name {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                (do {
                    my $m2 = full_ident($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"full_ident"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                })
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (do {
                    my $m2 = Perlito5::Grammar::Number::digits($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Number::digits"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                })
            })
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::var_ident {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((do {
            my $m2 = var_sigil($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"var_sigil"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = optional_namespace_before_ident($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"optional_namespace_before_ident"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = var_name($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"var_name"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = Perlito5::AST::Var::->new("sigil", Perlito5::Match::flat($MATCH->{"var_sigil"}), "namespace", Perlito5::Match::flat($MATCH->{"optional_namespace_before_ident"}), "name", Perlito5::Match::flat($MATCH->{"var_name"}));
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::block {;
        Perlito5::Grammar::Block::block(@_)
    }
    sub Perlito5::Grammar::block2 {;
        Perlito5::Grammar::Block::block(@_)
    }
    sub Perlito5::Grammar::opt_continue_block {;
        Perlito5::Grammar::Block::opt_continue_block(@_)
    }
    my @PKG;
    sub Perlito5::Grammar::exp_stmts {
        my $str = $_[0];
        my $pos = $_[1] // 0;
        if (!ref($str)) {;
            $str = [split('', $str)]
        }
        push(@PKG, $Perlito5::PKG_NAME);
        if ($pos == 0) {
            my $m = Perlito5::Grammar::Space::start_of_line($str, $pos);
            $pos = $m->{"to"}
        }
        my $has_semicolon;
        my @stmts;
        my $m = Perlito5::Grammar::Space::opt_ws($str, $pos);
        $pos = $m->{"to"};
        while ($m) {
            if ($str->[$pos] eq ";") {
                $has_semicolon = 1;
                $m = Perlito5::Grammar::Space::opt_ws($str, $pos + 1);
                $pos = $m->{"to"}
            }
            else {
                $m = Perlito5::Grammar::Statement::statement_parse($str, $pos);
                if ($m) {
                    push(@stmts, $m->{"capture"});
                    $pos = $m->{"to"};
                    if ($str->[$pos] eq ";") {
                        $has_semicolon = 1;
                        $pos = $pos + 1
                    }
                    $m = Perlito5::Grammar::Space::opt_ws($str, $pos);
                    $pos = $m->{"to"}
                }
            }
        }
        $Perlito5::PKG_NAME = pop(@PKG);
        $Perlito5::BLOCK_HAS_SEMICOLON ||= $has_semicolon;
        return {"str", $str, "to", $pos, "capture", \@stmts}
    }
}
{
    package main;
    package Perlito5;
    defined(${^O}) || (${^O} = "perlito5");
    defined($/) || ($/ = chr(10));
    defined(${"\""}) || (${"\""} = " ");
    defined(${","}) || (${","} = undef);
    defined(${"!"}) || (${"!"} = '');
    defined(${";"}) || (${";"} = chr(28));
    defined(${"?"}) || (${"?"} = 0);
    ${"]"} || (${"]"} = "5.026000");
    defined(${^V}) || (${^V} = bless({"original", "v5.26.0", "qv", 1, "version", [5, 26, 0]}, "version"));
    ${^H} = 0;
    %{^H} = ();
    our $EXPAND_USE = 1;
    our $EMIT_USE = 0;
    our $WARNINGS = 0;
    our $UTF8 = 0;
    our $BYTES = 0;
    our @CALLER = ();
    our %DATA_SECTION = ();
    our $PKG_NAME = '';
    our $LINE_NUMBER = 0;
    our $FILE_NAME = '';
    our $GLOBAL = {};
    our $BASE_SCOPE = Perlito5::Grammar::Scope::->new_base_scope();
    our $CLOSURE_SCOPE = $BASE_SCOPE;
    our $SCOPE = $BASE_SCOPE;
    our $SCOPE_DEPTH = 0;
    our @SCOPE_STMT = ();
    our @END_BLOCK = ();
    our @INIT_BLOCK = ();
    our @CHECK_BLOCK = ();
    our @UNITCHECK_BLOCK = ();
    our %BEGIN_SCRATCHPAD = ();
    our $PROTO = {};
    our @ANNOTATION;
    sub Perlito5::set_global_phase {
        my $phase = shift;
        local ${"\@"};
        eval {;
            ${^GLOBAL_PHASE} = $phase
        }
    }
    our $ID = 100;
    our $PACKAGES = {"STDERR", 1, "STDOUT", 1, "STDIN", 1, "main", 1, "strict", 1, "warnings", 1, "utf8", 1, "bytes", 1, "encoding", 1, "UNIVERSAL", 1, "CORE", 1, "CORE::GLOBAL", 1, "Perlito5::IO", 1};
    push(@INC, $_)
        for split(":", ($ENV{"PERL5LIB"} || ''));
    our $SPECIAL_VAR = {"\$_", "ARG", "\$&", "\$MATCH", "\$`", "\$PREMATCH", "\$'", "\$POSTMATCH", "\$+", "\$LAST_PAREN_MATCH", "\@+", "\@LAST_MATCH_END", "%+", "%LAST_PAREN_MATCH", "\@-", "\@LAST_MATCH_START", "\$|", "autoflush", "\$/", "\$RS", "\@_", "\@ARG", "< \$", "\$EUID", "\$.", "\$NR", "< \$< ", "\$UID", "\$(", "\$GID", "\$#", undef, "\$\@", "\$EVAL_ERROR", "\$=", "\$FORMAT_LINES_PER_PAGE", "\$,", "\$OFS", "\$?", "\$CHILD_ERROR", "\$*", undef, "\$[", undef, "\$\$", "\$PID", "%-", undef, "\$~", "\$FORMAT_NAME", "\$-", "\$FORMAT_LINES_LEFT", "\$&", "\$MATCH", "\$%", "\$FORMAT_PAGE_NUMBER", "\$)", "\$EGID", "\$]", undef, "\$!", "\$ERRNO", "\$;", "\$SUBSEP", "\$\\", "\$ORS", "%!", undef, "\$\"", "\$LIST_SEPARATOR", "\$_", "\$ARG", "\$:", "FORMAT_LINE_BREAK_CHARACTERS"};
    our $CORE_OVERRIDABLE = {"say", 1, "break", 1, "given", 1, "when", 1, "default", 1, "state", 1, "lock", 1};
    our $CORE_PROTO = {"CORE::shutdown", "*\$", "CORE::chop", "_", "CORE::lstat", "*", "CORE::rename", "\$\$", "CORE::lock", "\\\$", "CORE::rand", ";\$", "CORE::gmtime", ";\$", "CORE::gethostbyname", "\$", "CORE::each", "+", "CORE::ref", "_", "CORE::syswrite", "*\$;\$\$", "CORE::msgctl", "\$\$\$", "CORE::getnetbyname", "\$", "CORE::write", ";*", "CORE::alarm", "_", "CORE::print", undef, "CORE::getnetent", '', "CORE::semget", "\$\$\$", "CORE::use", undef, "CORE::abs", "_", "CORE::break", '', "CORE::undef", ";\$", "CORE::no", undef, "CORE::eval", "_", "CORE::split", undef, "CORE::localtime", ";\$", "CORE::sort", undef, "CORE::chown", "\@", "CORE::endpwent", '', "CORE::getpwent", '', "CORE::pos", undef, "CORE::lcfirst", "_", "CORE::kill", "\@", "CORE::send", "*\$\$;\$", "CORE::endprotoent", '', "CORE::semctl", "\$\$\$\$", "CORE::waitpid", "\$\$", "CORE::utime", "\@", "CORE::dbmclose", "\\%", "CORE::getpwnam", "\$", "CORE::substr", "\$\$;\$\$", "CORE::listen", "*\$", "CORE::getprotoent", '', "CORE::shmget", "\$\$\$", "CORE::our", undef, "CORE::readlink", "_", "CORE::shmwrite", "\$\$\$\$", "CORE::times", '', "CORE::package", undef, "CORE::map", undef, "CORE::join", "\$\@", "CORE::rmdir", "_", "CORE::shmread", "\$\$\$\$", "CORE::uc", "_", "CORE::bless", "\$;\$", "CORE::closedir", "*", "CORE::getppid", '', "CORE::tie", "\\[\$\@%]\$;\@", "CORE::readdir", "*", "CORE::gethostent", '', "CORE::getlogin", '', "CORE::last", undef, "CORE::gethostbyaddr", "\$\$", "CORE::accept", "**", "CORE::log", "_", "CORE::tell", ";*", "CORE::readline", ";*", "CORE::tied", undef, "CORE::socket", "*\$\$\$", "CORE::umask", ";\$", "CORE::sysread", "*\\\$\$;\$", "CORE::syscall", "\$\@", "CORE::quotemeta", "_", "CORE::dump", '', "CORE::opendir", "*\$", "CORE::untie", undef, "CORE::truncate", "\$\$", "CORE::select", ";*", "CORE::sleep", ";\$", "CORE::seek", "*\$\$", "CORE::read", "*\\\$\$;\$", "CORE::rewinddir", "*", "CORE::scalar", undef, "CORE::wantarray", '', "CORE::oct", "_", "CORE::bind", "*\$", "CORE::stat", "*", "CORE::sqrt", "_", "CORE::getc", ";*", "CORE::fileno", "*", "CORE::getpeername", "*", "CORE::sin", "_", "CORE::getnetbyaddr", "\$\$", "CORE::grep", undef, "CORE::setservent", "\$", "CORE::sub", undef, "CORE::shmctl", "\$\$\$", "CORE::study", undef, "CORE::msgrcv", "\$\$\$\$\$", "CORE::setsockopt", "*\$\$\$", "CORE::int", "_", "CORE::pop", ";+", "CORE::link", "\$\$", "CORE::exec", undef, "CORE::setpwent", '', "CORE::mkdir", "_;\$", "CORE::sysseek", "*\$\$", "CORE::endservent", '', "CORE::chr", "_", "CORE::when", undef, "CORE::getpwuid", "\$", "CORE::setprotoent", "\$", "CORE::reverse", "\@", "CORE::say", undef, "CORE::goto", undef, "CORE::getgrent", '', "CORE::endnetent", '', "CORE::hex", "_", "CORE::binmode", "*;\$", "CORE::formline", "\$\@", "CORE::getgrnam", "\$", "CORE::ucfirst", "_", "CORE::chdir", ";\$", "CORE::setnetent", "\$", "CORE::splice", "+;\$\$\@", "CORE::unlink", "\@", "CORE::time", '', "CORE::push", "+\@", "CORE::exit", ";\$", "CORE::endgrent", '', "CORE::unshift", "+\@", "CORE::local", undef, "CORE::my", undef, "CORE::cos", "_", "CORE::redo", undef, "CORE::warn", "\@", "CORE::getsockname", "*", "CORE::pipe", "**", "CORE::sprintf", "\$\@", "CORE::open", "*;\$\@", "CORE::setpgrp", ";\$\$", "CORE::exp", "_", "CORE::seekdir", "*\$", "CORE::getservbyport", "\$\$", "CORE::given", undef, "CORE::pack", "\$\@", "CORE::msgget", "\$\$", "CORE::rindex", "\$\$;\$", "CORE::srand", ";\$", "CORE::telldir", "*", "CORE::connect", "*\$", "CORE::getprotobyname", "\$", "CORE::msgsnd", "\$\$\$", "CORE::length", "_", "CORE::state", undef, "CORE::die", "\@", "CORE::delete", "\$", "CORE::getservent", '', "CORE::getservbyname", "\$\$", "CORE::setpriority", "\$\$\$", "CORE::lc", "_", "CORE::fc", "_", "CORE::pack", "\$\@", "CORE::fcntl", "*\$\$", "CORE::chroot", "_", "CORE::recv", "*\\\$\$\$", "CORE::dbmopen", "\\%\$\$", "CORE::socketpair", "**\$\$\$", "CORE::vec", "\$\$\$", "CORE::system", undef, "CORE::defined", "_", "CORE::index", "\$\$;\$", "CORE::caller", ";\$", "CORE::close", ";*", "CORE::atan2", "\$\$", "CORE::semop", "\$\$", "CORE::unpack", "\$;\$", "CORE::ord", "_", "CORE::chmod", "\@", "CORE::prototype", undef, "CORE::getprotobynumber", "\$", "CORE::values", "+", "CORE::chomp", "_", "CORE::ioctl", "*\$\$", "CORE::eof", ";*", "CORE::crypt", "\$\$", "CORE::do", undef, "CORE::flock", "*\$", "CORE::wait", '', "CORE::sethostent", "\$", "CORE::return", undef, "CORE::getsockopt", "*\$\$", "CORE::fork", '', "CORE::require", undef, "CORE::format", undef, "CORE::readpipe", "_", "CORE::endhostent", '', "CORE::getpgrp", ";\$", "CORE::setgrent", '', "CORE::keys", "+", "CORE::glob", undef, "CORE::getpriority", "\$\$", "CORE::reset", ";\$", "CORE::sysopen", "*\$\$;\$", "CORE::continue", '', "CORE::next", undef, "CORE::getgrgid", "\$", "CORE::default", undef, "CORE::shift", ";+", "CORE::symlink", "\$\$", "CORE::exists", "\$", "CORE::printf", "\$\@", "CORE::m", undef, "CORE::q", undef, "CORE::qq", undef, "CORE::qw", undef, "CORE::qx", undef, "CORE::qr", undef, "CORE::s", undef, "CORE::tr", undef, "CORE::y", undef, "CORE::if", undef, "CORE::unless", undef, "CORE::when", undef, "CORE::for", undef, "CORE::foreach", undef, "CORE::while", undef, "CORE::given", undef, "CORE::and", undef, "CORE::or", undef, "CORE::xor", undef, "CORE::not", undef, "CORE::cmp", undef, "CORE::__FILE__", '', "CORE::__LINE__", ''};
    sub Perlito5::test_perl_version {
        my $version = shift;
        $version =~ s/^v//;
        if ($version && ord(substr($version, 0, 1)) < 10) {
            my @v = split(m//, $version);
            push(@v, chr(0))
                while @v < 3;
            $version = sprintf("%d.%03d%03d", map {;
                ord($_)
            } @v)
        }
        else {
            my @v = split(m/\./, $version);
            $v[1] = $v[1] . 0
                while length($v[1]) < 3;
            $version = join(".", @v)
        }
        if ($version gt ${"]"}) {;
            die("Perl v" . $version . " required--this is only v" . ${"]"})
        }
    }
    sub Perlito5::get_label {;
        "tmp" . $Perlito5::ID++
    }
    1
}
{
    package main;
    package Perlito5::AST::CompUnit;
    {;
        sub Perlito5::AST::CompUnit::emit_compile_time {
            my $self = $_[0];
            return __PACKAGE__->new(%{$self}, "body", [map {;
                defined($_) && $_->emit_compile_time()
            } @{$self->{"body"}}])
        }
    }
    package Perlito5::AST::Int;
    {;
        sub Perlito5::AST::Int::emit_compile_time {;
            return $_[0]
        }
    }
    package Perlito5::AST::Num;
    {;
        sub Perlito5::AST::Num::emit_compile_time {;
            return $_[0]
        }
    }
    package Perlito5::AST::Buf;
    {;
        sub Perlito5::AST::Buf::emit_compile_time {;
            return $_[0]
        }
    }
    package Perlito5::AST::Block;
    {;
        sub Perlito5::AST::Block::emit_compile_time {
            my $self = $_[0];
            return __PACKAGE__->new(%{$self}, "stmts", [map {;
                defined($_) && $_->emit_compile_time()
            } @{$self->{"stmts"}}], ($self->{"continue"} ? ("continue", $self->{"continue"}->emit_compile_time()) : ()))
        }
    }
    package Perlito5::AST::Index;
    {;
        sub Perlito5::AST::Index::emit_compile_time {
            my $self = $_[0];
            return __PACKAGE__->new(%{$self}, "obj", $self->{"obj"}->emit_compile_time(), "index_exp", $self->{"index_exp"}->emit_compile_time())
        }
    }
    package Perlito5::AST::Lookup;
    {;
        sub Perlito5::AST::Lookup::emit_compile_time {
            my $self = $_[0];
            return __PACKAGE__->new(%{$self}, "obj", $self->{"obj"}->emit_compile_time(), "index_exp", $self->{"index_exp"}->emit_compile_time())
        }
    }
    package Perlito5::AST::Var;
    {;
        sub Perlito5::AST::Var::emit_compile_time {
            my $self = $_[0];
            return $self
        }
    }
    package Perlito5::AST::Call;
    {;
        sub Perlito5::AST::Call::emit_compile_time {
            my $self = $_[0];
            my $invocant = $self->{"invocant"}->emit_compile_time();
            my $arguments;
            if ($self->{"method"} eq "postcircumfix:<[ ]>") {;
                $arguments = $self->{"arguments"}->emit_compile_time()
            }
            elsif ($self->{"method"} eq "postcircumfix:<{ }>") {;
                $arguments = $self->{"arguments"}->emit_compile_time()
            }
            else {;
                $arguments = [map {;
                    $_->emit_compile_time()
                } @{$self->{"arguments"}}]
            }
            my $meth = $self->{"method"};
            if (ref($meth) eq "Perlito5::AST::Var") {;
                $meth = $meth->emit_compile_time()
            }
            return __PACKAGE__->new(%{$self}, "method", $meth, "invocant", $invocant, "arguments", $arguments)
        }
    }
    package Perlito5::AST::Apply;
    {
        sub Perlito5::AST::Apply::emit_compile_time_args {
            my $self = $_[0];
            !$self->{"arguments"} && return ();
            return map {;
                $_->emit_compile_time()
            } @{$self->{"arguments"}}
        }
        sub Perlito5::AST::Apply::emit_compile_time {
            my $self = $_[0];
            my $code;
            if (ref($self->{"code"})) {;
                $code = $self->{"code"}->emit_compile_time()
            }
            else {;
                $code = $self->{"code"}
            }
            my $arguments;
            if (ref($self->{"arguments"})) {;
                $arguments = [map {;
                    $_->emit_compile_time()
                } @{$self->{"arguments"}}]
            }
            else {;
                $arguments = $self->{"arguments"}
            }
            my $special_arg;
            if (ref($self->{"special_arg"})) {;
                $special_arg = $self->{"special_arg"}->emit_compile_time()
            }
            else {;
                $special_arg = $self->{"special_arg"}
            }
            if ($self->{"code"} eq "infix:<=>") {
                my $arg = $self->{"arguments"}->[0];
                if (ref($arg) eq "Perlito5::AST::Apply" && $arg->{"code"} eq "prefix:<*>") {;
                    return Perlito5::AST::Apply::->new("code", "compile_time_glob_set", "namespace", "Perlito5::Grammar::Scope", "arguments", [$arg->{"arguments"}->[0]->emit_compile_time(), $self->{"arguments"}->[1]->emit_compile_time(), Perlito5::AST::Buf::->new("buf", $Perlito5::PKG_NAME)])
                }
                elsif (ref($arg) eq "Perlito5::AST::Var" && $arg->{"sigil"} eq "*") {;
                    return Perlito5::AST::Apply::->new("code", "compile_time_glob_set", "namespace", "Perlito5::Grammar::Scope", "arguments", [Perlito5::AST::Buf::->new("buf", ($arg->{"namespace"} || $arg->{"_namespace"}) . "::" . $arg->{"name"}), $self->{"arguments"}->[1]->emit_compile_time(), Perlito5::AST::Buf::->new("buf", $Perlito5::PKG_NAME)])
                }
            }
            if ($self->{"code"} eq "eval") {
                my $args = $self->{"arguments"};
                if (@{$args} && !$args->[0]->isa("Perlito5::AST::Block")) {;
                    return $self
                }
            }
            if ($self->{"code"} eq "require" && !$self->{"namespace"}) {;
                return Perlito5::AST::Apply::->new(%{$self}, "namespace", "Perlito5::Grammar::Use")
            }
            return __PACKAGE__->new(%{$self}, "code", $code, "arguments", $arguments, ($special_arg ? ("special_arg", $special_arg) : ()))
        }
    }
    package Perlito5::AST::If;
    {;
        sub Perlito5::AST::If::emit_compile_time {
            my $self = $_[0];
            return __PACKAGE__->new(%{$self}, "cond", $self->{"cond"}->emit_compile_time(), "body", $self->{"body"}->emit_compile_time(), "otherwise", $self->{"otherwise"}->emit_compile_time())
        }
    }
    package Perlito5::AST::When;
    {;
        sub Perlito5::AST::When::emit_compile_time {
            my $self = $_[0];
            return __PACKAGE__->new(%{$self}, "cond", $self->{"cond"}->emit_compile_time(), "body", $self->{"body"}->emit_compile_time())
        }
    }
    package Perlito5::AST::While;
    {;
        sub Perlito5::AST::While::emit_compile_time {
            my $self = $_[0];
            return __PACKAGE__->new(%{$self}, "cond", $self->{"cond"}->emit_compile_time(), "body", $self->{"body"}->emit_compile_time())
        }
    }
    package Perlito5::AST::For;
    {;
        sub Perlito5::AST::For::emit_compile_time {
            my $self = $_[0];
            my $cond;
            if (ref($self->{"cond"}) eq "ARRAY") {;
                $cond = [map {;
                    defined($_) ? $_->emit_compile_time() : $_
                } @{$self->{"cond"}}]
            }
            else {;
                $cond = $self->{"cond"}->emit_compile_time()
            }
            return __PACKAGE__->new(%{$self}, "cond", $cond, "body", $self->{"body"}->emit_compile_time(), ($self->{"continue"} ? ("continue", $self->{"continue"}->emit_compile_time()) : ()))
        }
    }
    package Perlito5::AST::Decl;
    {;
        sub Perlito5::AST::Decl::emit_compile_time {
            my $self = $_[0];
            return __PACKAGE__->new(%{$self}, "var", $self->{"var"}->emit_compile_time())
        }
    }
    package Perlito5::AST::Sub;
    {;
        sub Perlito5::AST::Sub::emit_compile_time {
            my $self = $_[0];
            my @stmts;
            if (defined($self->{"block"})) {
                if ($self->{"name"}) {
                    local $Perlito5::PKG_NAME = $self->{"namespace"};
                    return Perlito5::AST::Apply::->new("code", "infix:<=>", "namespace", '', "arguments", [Perlito5::AST::Var::->new("sigil", "*", "_decl", "global", "namespace", $self->{"namespace"}, "name", $self->{"name"}), Perlito5::AST::Sub::->new(%{$self}, "namespace", undef, "name", undef)->emit_compile_time()])
                }
                @stmts = @{$self->{"block"}->{"stmts"}};
                @stmts = map {;
                    $_->emit_compile_time()
                } @stmts;
                {
                    my @captured;
                    for my $stmt (@{$self->{"block"}->{"stmts"}}) {;
                        push(@captured, $stmt->get_captures())
                    }
                    my %dont_capture = map {;
                        $_->{"dont"} ? ($_->{"dont"}, 1) : ()
                    } @captured;
                    my %capture = map {;
                        $_->{"dont"} ? () : $dont_capture{$_->{"_id"}} ? () : ($_->{"_decl"} eq "local" || $_->{"_decl"} eq "global" || $_->{"_decl"} eq '') ? () : ($_->{"_id"}, $_)
                    } @captured;
                    my $code = __PACKAGE__->new(%{$self});
                    my $id = Perlito5::get_label();
                    $Perlito5::BEGIN_SUBS{$id} = $code;
                    $Perlito5::BEGIN_LEXICALS{$_} = $capture{$_}
                        for keys(%capture);
                    if (!@stmts) {;
                        unshift(@stmts, Perlito5::AST::Apply::->new("code", "return", "arguments", []))
                    }
                    unshift(@stmts, Perlito5::AST::Apply::->new("code", "infix:<&&>", "arguments", [Perlito5::AST::Var::LIST_ARG(), Perlito5::AST::Apply::->new("code", "infix:<&&>", "arguments", [Perlito5::AST::Apply::->new("code", "infix:<eq>", "arguments", [Perlito5::AST::Apply::->new("arguments", [Perlito5::AST::Var::LIST_ARG_INDEX(0)], "code", "ref"), Perlito5::AST::Buf::->new("buf", "Perlito5::dump")]), Perlito5::AST::Apply::->new("code", "return", "arguments", [Perlito5::AST::Apply::->new("code", "circumfix:<{ }>", "arguments", [Perlito5::AST::Buf::->new("buf", "__SUB__"), Perlito5::AST::Buf::->new("buf", $id), Perlito5::AST::Buf::->new("buf", "__PKG__"), Perlito5::AST::Buf::->new("buf", $Perlito5::PKG_NAME), map {;
                        (Perlito5::AST::Buf::->new("buf", $_), Perlito5::AST::Apply::->new("code", "prefix:<\\>", "arguments", [$capture{$_}]))
                    } sort {;
                        $a cmp $b
                    } keys(%capture)])])])]))
                }
                $self = __PACKAGE__->new(%{$self}, ($self->{"block"} ? ("block", Perlito5::AST::Block::->new(%{$self->{"block"}}, "stmts", [@stmts])) : ()))
            }
            return $self
        }
    }
    1
}
{
    package main;
    package Perlito5::DumpToAST;
    sub Perlito5::DumpToAST::dump_to_ast {
        (my($obj), my($seen), my($pos)) = @_;
        !defined($obj) && return Perlito5::AST::Apply::->new("code", "undef", "arguments", []);
        my $ref = ref($obj);
        if (!$ref) {
            if (0 + $obj eq $obj) {
                int($obj) == $obj && return Perlito5::AST::Int::->new("int", $obj);
                return Perlito5::AST::Num::->new("num", $obj)
            }
            return Perlito5::AST::Buf::->new("buf", $obj)
        }
        my $as_string = $obj;
        $seen->{$as_string} && return $seen->{$as_string};
        $seen->{$as_string} = $pos;
        if ($ref eq "ARRAY") {
            my @out;
            for my $i (0 .. $#{$obj}) {
                my $here = Perlito5::AST::Index::INDEX($pos, Perlito5::AST::Int::->new("int", $i));
                push(@out, dump_to_ast($obj->[$i], $seen, $here))
            }
            return Perlito5::AST::Apply::->new("code", "circumfix:<[ ]>", "arguments", \@out)
        }
        elsif ($ref eq "HASH") {
            my @out;
            for my $i (sort {;
                $a cmp $b
            } keys(%{$obj})) {
                my $here = Perlito5::AST::Lookup::LOOKUP($pos, Perlito5::AST::Buf::->new("buf", $i));
                push(@out, Perlito5::AST::Apply::->new("code", "infix:<=>>", "arguments", [Perlito5::AST::Buf::->new("buf", $i), dump_to_ast($obj->{$i}, $seen, $here)]))
            }
            return Perlito5::AST::Apply::->new("code", "circumfix:<{ }>", "arguments", \@out)
        }
        elsif ($ref eq "SCALAR" || $ref eq "REF") {
            my $here = Perlito5::AST::Apply::->new("code", "prefix:<\$>", "arguments", [$pos]);
            return Perlito5::AST::Apply::->new("code", "prefix:<\\>", "arguments", [dump_to_ast(${$obj}, $seen, $here)])
        }
        elsif ($ref eq "CODE") {
            my $closure_flag = bless({}, "Perlito5::dump");
            my $captures = $obj->($closure_flag) // {};
            my @vars;
            my $ast;
            my $source;
            my $sub_name;
            my $package = $captures->{"__PKG__"};
            my $current_package = "main";
            for my $var_id (sort {;
                $a cmp $b
            } keys(%{$captures})) {
                $var_id eq "__PKG__" && next;
                if ($var_id eq "__SUB__") {
                    my $sub_id = $captures->{$var_id};
                    $ast = $Perlito5::BEGIN_SUBS{$sub_id};
                    $ast->{"name"} && ($sub_name = $ast->{"namespace"} . "::" . $ast->{"name"});
                    $source = $ast
                }
                else {
                    my $var = $Perlito5::BEGIN_LEXICALS{$var_id};
                    $var = Perlito5::AST::Var::->new(%{$var}, "sigil", $var->{"_real_sigil"} || $var->{"sigil"});
                    my $decl = $var->{"_decl"} || "my";
                    if ($decl eq "our") {
                        my $var_namespace = $var->{"_namespace"} || $var->{"namespace"};
                        if ($var_namespace ne $current_package) {
                            push(@vars, Perlito5::AST::Apply::->new("code", "package", "namespace", $var_namespace, "arguments", []));
                            $current_package = $var_namespace
                        }
                        push(@vars, Perlito5::AST::Decl::->new("attributes", [], "decl", $decl, "type", '', "var", $var))
                    }
                    else {;
                        push(@vars, Perlito5::AST::Apply::->new("code", "infix:<=>", "arguments", [Perlito5::AST::Decl::->new("attributes", [], "decl", $decl, "type", '', "var", $var), dump_to_ast_deref($captures->{$var_id}, $seen, $pos)]))
                    }
                }
            }
            if ($package ne $current_package) {
                push(@vars, Perlito5::AST::Apply::->new("code", "package", "namespace", $package, "arguments", []));
                $current_package = $package
            }
            return Perlito5::AST::Apply::->new("code", "do", "arguments", [Perlito5::AST::Block::->new("stmts", [@vars, $source])])
        }
        elsif ($ref eq "Regexp") {
            my $regex = $ref;
            return Perlito5::AST::Apply::->new("code", "p5:qr", "arguments", [Perlito5::AST::Buf::->new("buf", $regex), Perlito5::AST::Buf::->new("buf", '')])
        }
        my @out;
        for my $i (sort {;
            $a cmp $b
        } keys(%{$obj})) {
            my $here = Perlito5::AST::Lookup::LOOKUP($pos, Perlito5::AST::Buf::->new("buf", $i));
            push(@out, Perlito5::AST::Apply::->new("code", "infix:<=>>", "arguments", [Perlito5::AST::Buf::->new("buf", $i), dump_to_ast($obj->{$i}, $seen, $here)]))
        }
        return Perlito5::AST::Apply::->new("code", "bless", "arguments", [Perlito5::AST::Apply::->new("code", "circumfix:<{ }>", "arguments", \@out), Perlito5::AST::Buf::->new("buf", $ref)])
    }
    sub Perlito5::DumpToAST::dump_to_ast_deref {
        (my($obj), my($seen), my($pos)) = @_;
        my $ref = ref($obj);
        !$ref && return dump_to_ast(@_);
        if ($ref eq "ARRAY") {
            @{$obj} || return "()";
            my @out;
            for my $i (0 .. $#{$obj}) {
                my $here = Perlito5::AST::Index::INDEX($pos, Perlito5::AST::Int::->new("int", $i));
                push(@out, dump_to_ast($obj->[$i], $seen, $here))
            }
            return Perlito5::AST::Apply::->new("code", "circumfix:<( )>", "arguments", \@out)
        }
        elsif ($ref eq "HASH") {
            keys(%{$obj}) || return "()";
            my @out;
            for my $i (sort {;
                $a cmp $b
            } keys(%{$obj})) {
                my $here = Perlito5::AST::Lookup::LOOKUP($pos, Perlito5::AST::Buf::->new("buf", $i));
                push(@out, Perlito5::AST::Apply::->new("code", "infix:<=>>", "arguments", [Perlito5::AST::Buf::->new("buf", $i), dump_to_ast($obj->{$i}, $seen, $here)]))
            }
            return Perlito5::AST::Apply::->new("code", "circumfix:<( )>", "arguments", \@out)
        }
        elsif ($ref eq "SCALAR" || $ref eq "REF") {
            my $here = Perlito5::AST::Apply::->new("code", "prefix:<\$>", "arguments", [$pos]);
            return dump_to_ast(${$obj}, $seen, $here)
        }
        return dump_to_ast($obj, $seen, $pos)
    }
    1
}
{
    package main;
    package Perlito5::CompileTime::Dumper;
    sub Perlito5::CompileTime::Dumper::_dump_AST_from_scope {
        (my($name), my($item), my($vars), my($dumper_seen)) = @_;
        my $sigil = substr($name, 0, 1);
        if (ref($item) eq "Perlito5::AST::Sub" && $item->{"name"}) {;
            return
        }
        if (substr($name, 7, 1) lt "A") {;
            $name = $sigil . "{" . Perlito5::Dumper::escape_string(substr($name, 1)) . "}"
        }
        my $ast = $item->{"ast"};
        if (ref($ast) eq "Perlito5::AST::Var" && $ast->{"_decl"} eq "our") {
            $ast = Perlito5::AST::Var::->new(%{$ast}, "sigil", $ast->{"_real_sigil"} || $ast->{"sigil"}, "namespace", $ast->{"namespace"} || $ast->{"_namespace"}, "decl", "global");
            $name = $ast->{"sigil"} . $ast->{"namespace"} . "::" . $ast->{"name"}
        }
        my $bareword = substr($name, 1);
        if (ref($ast) eq "Perlito5::AST::Var" && $sigil eq "\$") {
            my $value = ${$bareword};
            !defined($value) && return;
            push(@{$vars}, Perlito5::AST::Apply::->new("code", "infix:<=>", "arguments", [$ast, Perlito5::DumpToAST::dump_to_ast($value, $dumper_seen, $ast)]))
        }
        elsif (ref($ast) eq "Perlito5::AST::Var" && $sigil eq "\@") {
            substr($bareword, 0, 2) eq "{'" && ($bareword = substr($bareword, 2, -2));
            my $value = \@{$bareword};
            push(@{$vars}, Perlito5::AST::Apply::->new("code", "infix:<=>", "arguments", [Perlito5::AST::Var::->new(%{$ast}, "sigil", "*"), Perlito5::DumpToAST::dump_to_ast($value, $dumper_seen, $ast)]))
        }
        elsif (ref($ast) eq "Perlito5::AST::Var" && $sigil eq "%") {
            my $value = \%{$bareword};
            push(@{$vars}, Perlito5::AST::Apply::->new("code", "infix:<=>", "arguments", [Perlito5::AST::Var::->new(%{$ast}, "sigil", "*"), Perlito5::DumpToAST::dump_to_ast($value, $dumper_seen, $ast)]))
        }
        elsif (ref($ast) eq "Perlito5::AST::Var" && $sigil eq "*") {
            substr($bareword, 0, 2) eq "{'" && ($bareword = substr($bareword, 2, -2));
            if (exists(&{$bareword})) {
                my $value = \&{$bareword};
                push(@{$vars}, Perlito5::AST::Apply::->new("code", "infix:<=>", "arguments", [Perlito5::AST::Var::->new(%{$ast}, "sigil", "*"), Perlito5::DumpToAST::dump_to_ast($value, $dumper_seen, $ast)]))
            }
            if (defined(${$bareword})) {
                my $value = \${$bareword};
                push(@{$vars}, Perlito5::AST::Apply::->new("code", "infix:<=>", "arguments", [Perlito5::AST::Var::->new(%{$ast}, "sigil", "*"), Perlito5::DumpToAST::dump_to_ast($value, $dumper_seen, $ast)]))
            }
            if (@{$bareword}) {
                my $value = \@{$bareword};
                push(@{$vars}, Perlito5::AST::Apply::->new("code", "infix:<=>", "arguments", [Perlito5::AST::Var::->new(%{$ast}, "sigil", "*"), Perlito5::DumpToAST::dump_to_ast($value, $dumper_seen, $ast)]))
            }
            if (keys(%{$bareword})) {
                my $value = \%{$bareword};
                push(@{$vars}, Perlito5::AST::Apply::->new("code", "infix:<=>", "arguments", [Perlito5::AST::Var::->new(%{$ast}, "sigil", "*"), Perlito5::DumpToAST::dump_to_ast($value, $dumper_seen, $ast)]))
            }
        }
    }
    sub Perlito5::CompileTime::Dumper::emit_globals_after_BEGIN {
        my $scope = shift() // $Perlito5::GLOBAL;
        my $vars = [];
        my $seen = {};
        my $dumper_seen = {};
        my $tab = '';
        delete($scope->{"%main::ENV"});
        delete($scope->{"\$main::]"});
        delete($scope->{"\$main::ARGV"});
        delete($scope->{"\@main::_"});
        local $_;
        for my $v ("\$main::0", "\$main::a", "\$main::b", "\$main::_") {
            (my($sigil), my($namespace), my($name)) = $v =~ m/^([$@%])(\w+)::(.*)$/;
            $scope->{$v} //= {"ast", Perlito5::AST::Var::->new("name", $name, "sigil", $sigil, "_decl", "global", "namespace", $namespace)}
        }
        for my $pkg (keys(%{$Perlito5::PACKAGES})) {;
            if (@{$pkg . "::ISA"}) {;
                $scope->{"\@" . $pkg . "::ISA"} //= {"ast", Perlito5::AST::Var::->new("name", "ISA", "sigil", "\@", "_decl", "global", "namespace", $pkg), "value", \@{$pkg . "::ISA"}}
            }
        }
        $scope->{"\@Perlito5::END_BLOCK"} //= {"ast", Perlito5::AST::Var::->new("namespace", "Perlito5", "name", "END_BLOCK", "sigil", "\@", "_decl", "global"), "value", \@Perlito5::END_BLOCK};
        $scope->{"\@Perlito5::INIT_BLOCK"} //= {"ast", Perlito5::AST::Var::->new("namespace", "Perlito5", "name", "INIT_BLOCK", "sigil", "\@", "_decl", "global"), "value", \@Perlito5::INIT_BLOCK};
        $scope->{"%Perlito5::DATA_SECTION"} //= {"ast", Perlito5::AST::Var::->new("namespace", "Perlito5", "name", "DATA_SECTION", "sigil", "%", "_decl", "global"), "value", \%Perlito5::DATA_SECTION};
        for my $id (keys(%Perlito5::BEGIN_SCRATCHPAD)) {
            my $ast = $Perlito5::BEGIN_SCRATCHPAD{$id};
            my $sigil = $ast->{"_real_sigil"} || $ast->{"sigil"};
            if (!$ast->{"namespace"}) {
                $ast->{"namespace"} = "Perlito5::BEGIN";
                $ast->{"name"} = "_" . $id . "_" . $ast->{"name"}
            }
            my $fullname = $ast->{"namespace"} . "::" . $ast->{"name"};
            if ($sigil eq "\$") {;
                $scope->{$sigil . $fullname} //= {"ast", $ast, "value", \${$fullname}}
            }
            elsif ($sigil eq "\@") {;
                $scope->{$sigil . $fullname} //= {"ast", $ast, "value", \@{$fullname}}
            }
            elsif ($sigil eq "%") {;
                $scope->{$sigil . $fullname} //= {"ast", $ast, "value", \%{$fullname}}
            }
        }
        my $vars = [];
        my $dumper_seen = {};
        for my $fullname (sort {;
            $a cmp $b
        } keys(%{$Perlito5::PROTO})) {
            my $proto = $Perlito5::PROTO->{$fullname};
            my @parts = split("::", $fullname);
            my $name = pop(@parts);
            push(@{$vars}, Perlito5::AST::Sub::->new("namespace", join("::", @parts), "sig", $proto, "name", $name, "block", undef, "attributes", []))
        }
        for my $name (sort {;
            $a cmp $b
        } keys(%{$scope})) {
            my $item = $scope->{$name};
            _dump_AST_from_scope($name, $item, $vars, $dumper_seen)
        }
        return $vars
    }
    1
}
{
    package main;
    package Perlito5::Compiler;
    sub Perlito5::Compiler::compiler_name {;
        "Perlito5"
    }
    sub Perlito5::Compiler::do_not_edit {
        my $prefix = shift;
        return $prefix . " Do not edit this file - Generated by " . compiler_name() . " " . $Perlito5::VERSION . "
"
    }
    sub Perlito5::Compiler::error {;
        die(join('', @_) . " at " . $Perlito5::FILE_NAME . " line " . $Perlito5::LINE_NUMBER . "
")
    }
    1
}
{
    package main;
    package Perlito5::Grammar::Regex6;
    sub Perlito5::Grammar::Regex6::term_token {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((("t" eq $str->[$MATCH->{"to"} + 0]) && ("o" eq $str->[$MATCH->{"to"} + 1]) && ("k" eq $str->[$MATCH->{"to"} + 2]) && ("e" eq $str->[$MATCH->{"to"} + 3]) && ("n" eq $str->[$MATCH->{"to"} + 4]) && ($MATCH->{"to"} += 5)) && (do {
            my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::ident($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::ident"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (("{" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $m2 = Perlito5::Grammar::Regex6::rule($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Regex6::rule"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (("}" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
            my $source = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::ident"}) . "{ " . "my \$str     = \$_[0]; " . "my \$pos     = \$_[1]; " . "my \$MATCH = { str => \$str, from => \$pos, to => \$pos }; " . "my \$tmp = ( " . Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Regex6::rule"})->emit_perl5() . "); " . "\$tmp ? \$MATCH : undef; " . "}";
            $source = [split(m//, $source)];
            my $ast = Perlito5::Grammar::Block::named_sub_def($source, 0);
            $MATCH->{"capture"} = ["term", Perlito5::Match::flat($ast)];
            1
        })));
        $tmp ? $MATCH : undef
    }
    Perlito5::Grammar::Precedence::add_term("token", \&term_token);
    sub Perlito5::Grammar::Regex6::any {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"}));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Regex6::literal {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = ((do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{"to"};
            while ((do {
                my $pos1 = $MATCH->{"to"};
                (do {;
                    ((("\\" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && ('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"}))
                }) || (do {
                    $MATCH->{"to"} = $pos1;
                    ((do {
                        my $tmp = $MATCH;
                        $MATCH = {"from", $tmp->{"to"}, "to", $tmp->{"to"}};
                        my $res = (("'" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1));
                        $MATCH = $tmp;
                        $res ? 0 : 1
                    }) && ('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"}))
                })
            }) && ($last_match_null < 2)) {
                if ($to == $MATCH->{"to"}) {;
                    $last_match_null = $last_match_null + 1
                }
                else {;
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{"to"}
            }
            $MATCH = $m;
            $MATCH->{"to"} = $to;
            1
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Regex6::metasyntax_exp {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = ((do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{"to"};
            my $count = 0;
            while (((do {
                my $tmp = $MATCH;
                $MATCH = {"from", $tmp->{"to"}, "to", $tmp->{"to"}};
                my $res = ((">" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1));
                $MATCH = $tmp;
                $res ? 0 : 1
            }) && ('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"})) && ($last_match_null < 2)) {
                if ($to == $MATCH->{"to"}) {;
                    $last_match_null = $last_match_null + 1
                }
                else {;
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{"to"};
                $count = $count + 1
            }
            $MATCH = $m;
            $MATCH->{"to"} = $to;
            $count > 0
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Regex6::string_code {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = ((do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{"to"};
            my $count = 0;
            while ((do {
                my $pos1 = $MATCH->{"to"};
                (do {;
                    ((("\\" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && ('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"}))
                }) || (do {
                    $MATCH->{"to"} = $pos1;
                    ((("'" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                        my $m2 = literal($str, $MATCH->{"to"});
                        if ($m2) {
                            $MATCH->{"to"} = $m2->{"to"};
                            1
                        }
                        else {;
                            0
                        }
                    }) && (("'" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)))
                }) || (do {
                    $MATCH->{"to"} = $pos1;
                    ((("{" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                        my $m2 = string_code($str, $MATCH->{"to"});
                        if ($m2) {
                            $MATCH->{"to"} = $m2->{"to"};
                            1
                        }
                        else {;
                            0
                        }
                    }) && (("}" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)))
                }) || (do {
                    $MATCH->{"to"} = $pos1;
                    ((do {
                        my $tmp = $MATCH;
                        $MATCH = {"from", $tmp->{"to"}, "to", $tmp->{"to"}};
                        my $res = (("}" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1));
                        $MATCH = $tmp;
                        $res ? 0 : 1
                    }) && ('' ne $str->[$MATCH->{"to"}] && ++$MATCH->{"to"}))
                })
            }) && ($last_match_null < 2)) {
                if ($to == $MATCH->{"to"}) {;
                    $last_match_null = $last_match_null + 1
                }
                else {;
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{"to"};
                $count = $count + 1
            }
            $MATCH = $m;
            $MATCH->{"to"} = $to;
            $count > 0
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Regex6::parsed_code {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((do {
            my $m2 = string_code($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = Perlito5::Match::flat($MATCH);
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Regex6::rule_term {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((("<" eq $str->[$MATCH->{"to"} + 0]) && ("b" eq $str->[$MATCH->{"to"} + 1]) && ("e" eq $str->[$MATCH->{"to"} + 2]) && ("f" eq $str->[$MATCH->{"to"} + 3]) && ("o" eq $str->[$MATCH->{"to"} + 4]) && ("r" eq $str->[$MATCH->{"to"} + 5]) && ("e" eq $str->[$MATCH->{"to"} + 6]) && ($MATCH->{"to"} += 7)) && (do {
                    my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $m2 = rule($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"rule"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && ((">" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    $MATCH->{"capture"} = Perlito5::Rul::Before::->new("rule_exp", Perlito5::Match::flat($MATCH->{"rule"}));
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((("<" eq $str->[$MATCH->{"to"} + 0]) && ("!" eq $str->[$MATCH->{"to"} + 1]) && ("b" eq $str->[$MATCH->{"to"} + 2]) && ("e" eq $str->[$MATCH->{"to"} + 3]) && ("f" eq $str->[$MATCH->{"to"} + 4]) && ("o" eq $str->[$MATCH->{"to"} + 5]) && ("r" eq $str->[$MATCH->{"to"} + 6]) && ("e" eq $str->[$MATCH->{"to"} + 7]) && ($MATCH->{"to"} += 8)) && (do {
                    my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $m2 = rule($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"rule"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && ((">" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    $MATCH->{"capture"} = Perlito5::Rul::NotBefore::->new("rule_exp", Perlito5::Match::flat($MATCH->{"rule"}));
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((("'" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $m2 = literal($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"literal"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (("'" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    $MATCH->{"capture"} = Perlito5::Rul::Constant::->new("constant", Perlito5::Match::flat($MATCH->{"literal"}));
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((("<" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $pos1 = $MATCH->{"to"};
                    (do {;
                        ((("." eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                            my $m2 = metasyntax_exp($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                $MATCH->{"metasyntax_exp"} = $m2;
                                1
                            }
                            else {;
                                0
                            }
                        }) && ((">" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                            $MATCH->{"capture"} = Perlito5::Rul::Subrule::->new("metasyntax", Perlito5::Match::flat($MATCH->{"metasyntax_exp"}), "captures", 0);
                            1
                        }))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        ((do {
                            my $m2 = metasyntax_exp($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                $MATCH->{"metasyntax_exp"} = $m2;
                                1
                            }
                            else {;
                                0
                            }
                        }) && ((">" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                            $MATCH->{"capture"} = Perlito5::Rul::Subrule::->new("metasyntax", Perlito5::Match::flat($MATCH->{"metasyntax_exp"}), "captures", 1);
                            1
                        }))
                    })
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((("{" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $m2 = parsed_code($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"parsed_code"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (("}" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    $MATCH->{"capture"} = Perlito5::Rul::Block::->new("closure", Perlito5::Match::flat($MATCH->{"parsed_code"}));
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((("\\" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $pos1 = $MATCH->{"to"};
                    (do {;
                        ((("c" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                            my $m2 = Perlito5::Grammar::Number::digits($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                $MATCH->{"Perlito5::Grammar::Number::digits"} = $m2;
                                1
                            }
                            else {;
                                0
                            }
                        }) && (do {
                            $MATCH->{"capture"} = Perlito5::Rul::Constant::->new("constant", chr(Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Number::digits"})));
                            1
                        }))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        ((do {
                            my $m2 = any($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                $MATCH->{"any"} = $m2;
                                1
                            }
                            else {;
                                0
                            }
                        }) && (do {
                            $MATCH->{"capture"} = Perlito5::Rul::SpecialChar::->new("char", Perlito5::Match::flat($MATCH->{"any"}));
                            1
                        }))
                    })
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((("." eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    $MATCH->{"capture"} = Perlito5::Rul::Dot::->new();
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                ((("[" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    my $m2 = rule($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"rule"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (("]" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                    $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"rule"});
                    1
                }))
            })
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Regex6::quant_exp {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                (("?" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (("*" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (("+" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1))
            })
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Regex6::quantifier {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Space::opt_ws"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = rule_term($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"rule_term"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Space::opt_ws"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((do {
                    my $m2 = quant_exp($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"quant_exp"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"Perlito5::Grammar::Space::opt_ws"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{"capture"} = Perlito5::Rul::Quantifier::->new("term", Perlito5::Match::flat($MATCH->{"rule_term"}), "quant", Perlito5::Match::flat($MATCH->{"quant_exp"}));
                    1
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (do {
                    $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"rule_term"});
                    1
                })
            })
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Regex6::concat_list {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((do {
                    my $m2 = quantifier($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"quantifier"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $pos1 = $MATCH->{"to"};
                    (do {;
                        ((do {
                            my $m2 = concat_list($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                $MATCH->{"concat_list"} = $m2;
                                1
                            }
                            else {;
                                0
                            }
                        }) && (do {
                            $MATCH->{"capture"} = [Perlito5::Match::flat($MATCH->{"quantifier"}), @{Perlito5::Match::flat($MATCH->{"concat_list"})}];
                            1
                        }))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        (do {
                            $MATCH->{"capture"} = [Perlito5::Match::flat($MATCH->{"quantifier"})];
                            1
                        })
                    })
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (do {
                    $MATCH->{"capture"} = [];
                    1
                })
            })
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Regex6::concat_exp {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((do {
            my $m2 = concat_list($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"concat_list"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = Perlito5::Rul::Concat::->new("concat", Perlito5::Match::flat($MATCH->{"concat_list"}));
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Regex6::or_list_exp {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((do {
                    my $m2 = concat_exp($str, $MATCH->{"to"});
                    if ($m2) {
                        $MATCH->{"to"} = $m2->{"to"};
                        $MATCH->{"concat_exp"} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $pos1 = $MATCH->{"to"};
                    (do {;
                        ((("|" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)) && (do {
                            my $m2 = or_list_exp($str, $MATCH->{"to"});
                            if ($m2) {
                                $MATCH->{"to"} = $m2->{"to"};
                                $MATCH->{"or_list_exp"} = $m2;
                                1
                            }
                            else {;
                                0
                            }
                        }) && (do {
                            $MATCH->{"capture"} = [Perlito5::Match::flat($MATCH->{"concat_exp"}), @{Perlito5::Match::flat($MATCH->{"or_list_exp"})}];
                            1
                        }))
                    }) || (do {
                        $MATCH->{"to"} = $pos1;
                        (do {
                            $MATCH->{"capture"} = [Perlito5::Match::flat($MATCH->{"concat_exp"})];
                            1
                        })
                    })
                }))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                (do {
                    $MATCH->{"capture"} = [];
                    1
                })
            })
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Regex6::rule {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str", $str, "from", $pos, "to", $pos};
        my $tmp = (((do {
            my $pos1 = $MATCH->{"to"};
            (do {;
                ((do {
                    my $m = $MATCH;
                    if (!(do {
                        my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{"to"});
                        if ($m2) {
                            $MATCH->{"to"} = $m2->{"to"};
                            1
                        }
                        else {;
                            0
                        }
                    })) {;
                        $MATCH = $m
                    }
                    1
                }) && (("|" eq $str->[$MATCH->{"to"} + 0]) && ($MATCH->{"to"} += 1)))
            }) || (do {
                $MATCH->{"to"} = $pos1;
                1
            })
        }) && (do {
            my $m2 = or_list_exp($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"or_list_exp"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = Perlito5::Rul::Or::->new("or_list", Perlito5::Match::flat($MATCH->{"or_list_exp"}));
            1
        })));
        $tmp ? $MATCH : undef
    }
}
{
    package main;
    package Perlito5::Rul;
    sub Perlito5::Rul::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::Rul::constant {
        my $str = shift;
        my $len = length($str);
        if ($len) {
            my @cond;
            my $i = 0;
            for my $char (split(m//, $str)) {
                if ($char eq "\\") {;
                    $char = "\\\\"
                }
                if ($char eq "'") {;
                    $char = "\\'"
                }
                push(@cond, "('" . $char . "' eq \$str->[\$MATCH->{to} + " . $i . "])");
                $i++
            }
            return "(" . join(" && ", @cond, "(\$MATCH->{to} += " . $len . ")") . ")"
        }
        else {;
            return 1
        }
    }
    package Perlito5::Rul::Quantifier;
    sub Perlito5::Rul::Quantifier::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::Rul::Quantifier::term {;
        $_[0]->{"term"}
    }
    sub Perlito5::Rul::Quantifier::quant {;
        $_[0]->{"quant"}
    }
    sub Perlito5::Rul::Quantifier::emit_perl5 {
        my $self = $_[0];
        if ($self->{"quant"} eq '') {;
            return $self->{"term"}->emit_perl5()
        }
        if ($self->{"quant"} eq "+") {
            $self->{"term"}->set_captures_to_array();
            return "(do { " . "my \$last_match_null = 0; " . "my \$m = \$MATCH; " . "my \$to = \$MATCH->{to}; " . "my \$count = 0; " . "while (" . $self->{"term"}->emit_perl5() . " && (\$last_match_null < 2)) " . "{ " . "if (\$to == \$MATCH->{to}) { " . "\$last_match_null = \$last_match_null + 1; " . "} " . "else { " . "\$last_match_null = 0; " . "}; " . "\$m = \$MATCH; " . "\$to = \$MATCH->{to}; " . "\$count = \$count + 1; " . "}; " . "\$MATCH = \$m; " . "\$MATCH->{to} = \$to; " . "\$count > 0; " . "})"
        }
        if ($self->{"quant"} eq "*") {
            $self->{"term"}->set_captures_to_array();
            return "(do { " . "my \$last_match_null = 0; " . "my \$m = \$MATCH; " . "my \$to = \$MATCH->{to}; " . "while (" . $self->{"term"}->emit_perl5() . " && (\$last_match_null < 2)) " . "{ " . "if (\$to == \$MATCH->{to}) { " . "\$last_match_null = \$last_match_null + 1; " . "} " . "else { " . "\$last_match_null = 0; " . "}; " . "\$m = \$MATCH; " . "\$to = \$MATCH->{to}; " . "}; " . "\$MATCH = \$m; " . "\$MATCH->{to} = \$to; " . "1 " . "})"
        }
        if ($self->{"quant"} eq "?") {
            $self->{"term"}->set_captures_to_array();
            return "(do { " . "my \$m = \$MATCH; " . "if (!" . $self->{"term"}->emit_perl5() . ") " . "{ " . "\$MATCH = \$m; " . "}; " . "1 " . "})"
        }
        die("Perlito5::Rul::Quantifier:  not implemented")
    }
    sub Perlito5::Rul::Quantifier::set_captures_to_array {
        my $self = $_[0];
        $self->{"term"}->set_captures_to_array()
    }
    package Perlito5::Rul::Or;
    sub Perlito5::Rul::Or::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::Rul::Or::or_list {;
        $_[0]->{"or_list"}
    }
    sub Perlito5::Rul::Or::emit_perl5 {
        my $self = $_[0];
        if (scalar(@{$self->{"or_list"}}) == 1) {;
            return $self->{"or_list"}->[0]->emit_perl5()
        }
        "(do { " . "my \$pos1 = \$MATCH->{to}; (do { " . join("}) || (do { \$MATCH->{to} = \$pos1; ", map($_->emit_perl5(), @{$self->{"or_list"}})) . "}) })"
    }
    sub Perlito5::Rul::Or::set_captures_to_array {
        my $self = $_[0];
        map($_->set_captures_to_array(), @{$self->{"or_list"}})
    }
    package Perlito5::Rul::Concat;
    sub Perlito5::Rul::Concat::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::Rul::Concat::concat {;
        $_[0]->{"concat"}
    }
    sub Perlito5::Rul::Concat::emit_perl5 {
        my $self = $_[0];
        if (scalar(@{$self->{"concat"}}) == 1) {;
            return $self->{"concat"}->[0]->emit_perl5()
        }
        "(" . join(" && ", map($_->emit_perl5(), @{$self->{"concat"}})) . ")"
    }
    sub Perlito5::Rul::Concat::set_captures_to_array {
        my $self = $_[0];
        map($_->set_captures_to_array(), @{$self->{"concat"}})
    }
    package Perlito5::Rul::Subrule;
    sub Perlito5::Rul::Subrule::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::Rul::Subrule::metasyntax {;
        $_[0]->{"metasyntax"}
    }
    sub Perlito5::Rul::Subrule::captures {;
        $_[0]->{"captures"}
    }
    sub Perlito5::Rul::Subrule::emit_perl5 {
        my $self = $_[0];
        my $meth = $self->{"metasyntax"};
        my $code;
        if ($self->{"captures"} == 1) {;
            $code = "if (\$m2) { \$MATCH->{to} = \$m2->{to}; \$MATCH->{'" . $self->{"metasyntax"} . "'} = \$m2; 1 } else { 0 }; "
        }
        elsif ($self->{"captures"} > 1) {;
            $code = "if (\$m2) { " . "\$MATCH->{to} = \$m2->{to}; " . "if (exists \$MATCH->{'" . $self->{"metasyntax"} . "'}) { " . "push \@{ \$MATCH->{'" . $self->{"metasyntax"} . "'} }, \$m2; " . "} " . "else { " . "\$MATCH->{'" . $self->{"metasyntax"} . "'} = [ \$m2 ]; " . "}; " . "1 " . "} else { 0 }; "
        }
        else {;
            $code = "if (\$m2) { \$MATCH->{to} = \$m2->{to}; 1 } else { 0 }; "
        }
        "(do { " . "my \$m2 = " . $meth . "(\$str, \$MATCH->{to}); " . $code . "})"
    }
    sub Perlito5::Rul::Subrule::set_captures_to_array {
        my $self = $_[0];
        if ($self->{"captures"} > 0) {;
            $self->{"captures"} = $self->{"captures"} + 1
        }
    }
    package Perlito5::Rul::Constant;
    sub Perlito5::Rul::Constant::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::Rul::Constant::constant {;
        $_[0]->{"constant"}
    }
    sub Perlito5::Rul::Constant::emit_perl5 {
        my $self = $_[0];
        my $str = $self->{"constant"};
        Perlito5::Rul::constant($str)
    }
    sub Perlito5::Rul::Constant::set_captures_to_array {;
        my $self = $_[0]
    }
    package Perlito5::Rul::Dot;
    sub Perlito5::Rul::Dot::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::Rul::Dot::emit_perl5 {
        my $self = $_[0];
        "('' ne \$str->[\$MATCH->{to}] " . "&& ++\$MATCH->{to}" . ")"
    }
    sub Perlito5::Rul::Dot::set_captures_to_array {;
        my $self = $_[0]
    }
    package Perlito5::Rul::SpecialChar;
    sub Perlito5::Rul::SpecialChar::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::Rul::SpecialChar::char {;
        $_[0]->{"char"}
    }
    sub Perlito5::Rul::SpecialChar::emit_perl5 {
        my $self = $_[0];
        my $char = $self->{"char"};
        if ($char eq "n") {;
            return Perlito5::Rul::Subrule::->new("metasyntax", "is_newline", "captures", 0)->emit_perl5()
        }
        if ($char eq "N") {;
            return Perlito5::Rul::Subrule::->new("metasyntax", "not_newline", "captures", 0)->emit_perl5()
        }
        if ($char eq "d") {;
            return Perlito5::Rul::Subrule::->new("metasyntax", "digit", "captures", 0)->emit_perl5()
        }
        if ($char eq "s") {;
            return Perlito5::Rul::Subrule::->new("metasyntax", "space", "captures", 0)->emit_perl5()
        }
        if ($char eq "t") {;
            return Perlito5::Rul::constant(chr(9))
        }
        return Perlito5::Rul::constant($char)
    }
    sub Perlito5::Rul::SpecialChar::set_captures_to_array {;
        my $self = $_[0]
    }
    package Perlito5::Rul::Block;
    sub Perlito5::Rul::Block::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::Rul::Block::closure {;
        $_[0]->{"closure"}
    }
    sub Perlito5::Rul::Block::emit_perl5 {
        my $self = $_[0];
        "(do { " . $self->{"closure"} . "; 1 })"
    }
    sub Perlito5::Rul::Block::set_captures_to_array {;
        my $self = $_[0]
    }
    package Perlito5::Rul::Before;
    sub Perlito5::Rul::Before::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::Rul::Before::rule_exp {;
        $_[0]->{"rule_exp"}
    }
    sub Perlito5::Rul::Before::emit_perl5 {
        my $self = $_[0];
        "(do { " . "my \$tmp = \$MATCH; " . "\$MATCH = { 'from' => \$tmp->{to}, 'to' => \$tmp->{to} }; " . "my \$res = " . $self->{"rule_exp"}->emit_perl5() . "; " . "\$MATCH = \$tmp; " . "\$res ? 1 : 0 " . "})"
    }
    sub Perlito5::Rul::Before::set_captures_to_array {;
        my $self = $_[0]
    }
    package Perlito5::Rul::NotBefore;
    sub Perlito5::Rul::NotBefore::new {
        my $class = shift;
        bless({@_, }, $class)
    }
    sub Perlito5::Rul::NotBefore::rule_exp {;
        $_[0]->{"rule_exp"}
    }
    sub Perlito5::Rul::NotBefore::emit_perl5 {
        my $self = $_[0];
        "(do { " . "my \$tmp = \$MATCH; " . "\$MATCH = { 'from' => \$tmp->{to}, 'to' => \$tmp->{to} }; " . "my \$res = " . $self->{"rule_exp"}->emit_perl5() . "; " . "\$MATCH = \$tmp; " . "\$res ? 0 : 1 " . "})"
    }
    sub Perlito5::Rul::NotBefore::set_captures_to_array {;
        my $self = $_[0]
    }
    1
}
{
    package main;
    package Perlito5::JSON;
    sub Perlito5::JSON::ast_dumper {
        my $seen = {};
        my $level = '';
        my $pos = "[TODO - recursive structure is not supported]";
        return _dumper($_[0], $level, $seen, $pos)
    }
    sub Perlito5::JSON::_dumper {
        (my($obj), my($tab), my($seen), my($pos)) = @_;
        !defined($obj) && return "null";
        my $ref = ref($obj);
        !$ref && return escape_string($obj);
        my $as_string = $obj;
        $seen->{$as_string} && return $seen->{$as_string};
        $seen->{$as_string} = $pos;
        my $tab1 = $tab . "  ";
        if ($ref eq "ARRAY") {
            @{$obj} || return "[]";
            my @out;
            for my $i (0 .. $#{$obj}) {
                my $here = $pos . "[" . $i . "]";
                push(@out, $tab1 . _dumper($obj->[$i], $tab1, $seen, $here))
            }
            return "[
" . join(",
", @out) . "
" . $tab . "]"
        }
        elsif ($ref eq "SCALAR") {;
            return "{ \"_type\": \"SCALAR\", \"value\": " . _dumper(${$obj}, $tab1, $seen, $pos) . " }"
        }
        elsif ($ref eq "CODE") {;
            return "{ \"_type\": \"CODE\", \"value\": \"DUMMY\" }"
        }
        $ref =~ s/^Perlito5::AST:://;
        my @out;
        $ref ne "HASH" && push(@out, "\"_type\": \"" . $ref . "\"");
        for my $i (sort {;
            $a cmp $b
        } keys(%{$obj})) {
            my $here = $pos . "{" . $i . "}";
            push(@out, $tab1 . "\"" . $i . "\": " . _dumper($obj->{$i}, $tab1, $seen, $here))
        }
        return "{
" . join(",
", @out) . "
" . $tab . "}"
    }
    sub Perlito5::JSON::escape_string {
        my $s = shift;
        my @out;
        $s eq '' && return "\"\"";
        (0 + $s) eq $s && $s =~ m/[0-9]/ && return 0 + $s;
        for my $i (0 .. length($s) - 1) {
            my $c = substr($s, $i, 1);
            if ($c eq "\\" || $c eq "\"") {;
                push(@out, "\\" . $c)
            }
            elsif ($c eq "
") {;
                push(@out, "\\n")
            }
            elsif ($c eq "\x{d}") {;
                push(@out, "\\r")
            }
            elsif ($c eq "\x{9}") {;
                push(@out, "\\t")
            }
            elsif ($c eq "\x{8}") {;
                push(@out, "\\b")
            }
            elsif ($c eq "\x{c}") {;
                push(@out, "\\f")
            }
            elsif ($c le chr(31)) {;
                push(@out, sprintf("\\u%04x", ord($c)))
            }
            else {;
                push(@out, $c)
            }
        }
        return join('', "\"", @out, "\"")
    }
    1
}
{
    package main;
    package Perlito5::AST::Apply;
    {
        sub Perlito5::AST::Apply::_emit_assignment_javascript2 {
            (my($parameters), my($arguments), my($level), my($wantarray)) = @_;
            if ($parameters->isa("Perlito5::AST::Apply") && ($parameters->code() eq "my" || $parameters->code() eq "local" || $parameters->code() eq "circumfix:<( )>")) {
                my $tmp = Perlito5::JavaScript2::get_label();
                my $tmp2 = Perlito5::JavaScript2::get_label();
                return Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, "var " . $tmp . " = " . Perlito5::JavaScript2::to_list([$arguments], $level + 1) . ";", "var " . $tmp2 . " = " . $tmp . ".slice(0);", (map($_->emit_javascript2_set_list($level + 1, $tmp) . ";", @{$parameters->arguments()})), "return " . $tmp2)
            }
            return $parameters->emit_javascript2_set($arguments, $level + 1, $wantarray)
        }
        sub Perlito5::AST::Apply::emit_regex_javascript2 {
            my $op = shift;
            my $var = shift;
            my $regex = shift;
            my $level = shift;
            my $wantarray = shift;
            $regex = Perlito5::Macro::preprocess_regex($regex);
            my $str;
            my $code = $regex->{"code"};
            my $regex_args = $regex->{"arguments"};
            if ($code eq "p5:s") {
                my $replace = $regex_args->[1];
                my $modifier = $regex_args->[2]->{"buf"};
                my $fun;
                if (ref($replace) eq "Perlito5::AST::Block") {
                    $replace = Perlito5::AST::Sub::->new("block", $replace);
                    $fun = $replace->emit_javascript2($level + 2, $wantarray);
                    $modifier =~ s/e//g
                }
                else {;
                    $fun = Perlito5::JavaScript2::emit_function_javascript2($level + 2, $wantarray, $replace)
                }
                $str = Perlito5::JavaScript2::emit_wrap_javascript2($level + 1, $wantarray, "var tmp = p5s(" . $var->emit_javascript2() . ", " . $regex_args->[0]->emit_javascript2() . ", " . $fun . ", " . Perlito5::JavaScript2::escape_string($modifier) . ", " . ($wantarray eq "runtime" ? "p5want" : $wantarray eq "list" ? 1 : 0) . ");", $var->emit_javascript2() . " = tmp[0];", "return tmp[1];")
            }
            elsif ($code eq "p5:m") {;
                $str = "p5m(" . $var->emit_javascript2() . ", " . $regex_args->[0]->emit_javascript2() . ", " . Perlito5::JavaScript2::escape_string($regex_args->[1]->{"buf"}) . ", " . ($wantarray eq "runtime" ? "p5want" : $wantarray eq "list" ? 1 : 0) . ")"
            }
            elsif ($code eq "p5:tr") {;
                $str = Perlito5::JavaScript2::emit_wrap_javascript2($level + 1, $wantarray, "var tmp = p5tr(" . $var->emit_javascript2() . ", " . $regex_args->[0]->emit_javascript2() . ", " . $regex_args->[1]->emit_javascript2() . ", " . Perlito5::JavaScript2::escape_string($regex_args->[2]->{"buf"}) . ", " . ($wantarray eq "runtime" ? "p5want" : $wantarray eq "list" ? 1 : 0) . ");", $var->emit_javascript2() . " = tmp[0];", "return tmp[1];")
            }
            else {;
                die("Error: regex emitter - unknown operator " . $code)
            }
            if ($op eq "=~") {;
                return $str
            }
            if ($op eq "!~") {;
                return "!(" . $str . ")"
            }
            die("Error: regex emitter")
        }
        sub Perlito5::AST::Apply::emit_javascript2_set {
            (my($self), my($arguments), my($level), my($wantarray)) = @_;
            my $code = $self->{"code"};
            if ($code eq "prefix:<\$>") {;
                return "p5scalar_deref_set(" . Perlito5::JavaScript2::emit_javascript2_autovivify($self->{"arguments"}->[0], $level + 1, "scalar") . ", " . Perlito5::JavaScript2::to_scalar([$arguments], $level + 1) . ", " . Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME) . ")"
            }
            if ($code eq "prefix:<*>") {;
                return "p5typeglob_deref_set(" . Perlito5::JavaScript2::to_scalar($self->{"arguments"}, $level + 1) . ", " . Perlito5::JavaScript2::to_scalar([$arguments], $level + 1) . ", " . Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME) . ")"
            }
            my $open = $wantarray eq "void" ? '' : "(";
            my $close = $wantarray eq "void" ? '' : ")";
            $open . $self->emit_javascript2($level + 1) . " = " . $arguments->emit_javascript2($level + 1) . $close
        }
        my %emit_js = ("infix:<=~>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            emit_regex_javascript2("=~", $self->{"arguments"}->[0], $self->{"arguments"}->[1], $level, $wantarray)
        }, "infix:<!~>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            emit_regex_javascript2("!~", $self->{"arguments"}->[0], $self->{"arguments"}->[1], $level, $wantarray)
        }, "p5:s", sub {
            (my($self), my($level), my($wantarray)) = @_;
            emit_regex_javascript2("=~", $self->{"arguments"}->[3], $self, $level, $wantarray)
        }, "p5:m", sub {
            (my($self), my($level), my($wantarray)) = @_;
            emit_regex_javascript2("=~", $self->{"arguments"}->[2], $self, $level, $wantarray)
        }, "p5:tr", sub {
            (my($self), my($level), my($wantarray)) = @_;
            emit_regex_javascript2("=~", $self->{"arguments"}->[3], $self, $level, $wantarray)
        }, "p5:qr", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "p5qr(" . Perlito5::JavaScript2::to_str($self->{"arguments"}->[0]) . ", " . Perlito5::JavaScript2::to_str($self->{"arguments"}->[1]) . ")"
        }, "__PACKAGE__", sub {
            my $self = $_[0];
            Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME)
        }, "__SUB__", sub {
            my $self = $_[0];
            $Perlito5::AST::Sub::SUB_REF // "__SUB__"
        }, "wantarray", sub {
            my $self = $_[0];
            "p5want"
        }, "package", sub {
            my $self = $_[0];
            "p5make_package(" . Perlito5::JavaScript2::escape_string($self->{"namespace"}) . ")"
        }, "bless", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $class;
            if ($self->{"arguments"}->[1]) {;
                $class = Perlito5::JavaScript2::to_str($self->{"arguments"}->[1])
            }
            else {;
                $class = Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME)
            }
            "CORE.bless(p5list_to_a([" . $self->{"arguments"}->[0]->emit_javascript2($level, "scalar") . ", " . $class . "]))"
        }, "infix:<~~>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg0 = $self->{"arguments"}->[0];
            my $arg1 = $self->{"arguments"}->[1];
            "p5smrt_scalar(" . $arg0->emit_javascript2($level, "scalar") . ", " . $arg1->emit_javascript2($level, "scalar") . ")"
        }, "infix:<&&>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "p5and(" . $self->{"arguments"}->[0]->emit_javascript2($level, "scalar") . ", " . Perlito5::JavaScript2::emit_function_javascript2($level, $wantarray, $self->{"arguments"}->[1]) . ")"
        }, "infix:<and>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "p5and(" . $self->{"arguments"}->[0]->emit_javascript2($level, "scalar") . ", " . Perlito5::JavaScript2::emit_function_javascript2($level, $wantarray, $self->{"arguments"}->[1]) . ")"
        }, "infix:<||>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "p5or(" . $self->{"arguments"}->[0]->emit_javascript2($level, "scalar") . ", " . Perlito5::JavaScript2::emit_function_javascript2($level, $wantarray, $self->{"arguments"}->[1]) . ")"
        }, "infix:<or>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "p5or(" . $self->{"arguments"}->[0]->emit_javascript2($level, "scalar") . ", " . Perlito5::JavaScript2::emit_function_javascript2($level, $wantarray, $self->{"arguments"}->[1]) . ")"
        }, "infix:<xor>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "p5xor(" . $self->{"arguments"}->[0]->emit_javascript2($level, "scalar") . ", " . Perlito5::JavaScript2::emit_function_javascript2($level, $wantarray, $self->{"arguments"}->[1]) . ")"
        }, "infix:<=>>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            return "p5list_to_a([" . Perlito5::AST::Lookup::->autoquote($self->{"arguments"}->[0])->emit_javascript2($level) . ", " . $self->{"arguments"}->[1]->emit_javascript2($level) . "])"
        }, "infix:<cmp>", sub {
            my $self = $_[0];
            "p5cmp(" . join(", ", map(Perlito5::JavaScript2::to_str($_), @{$self->{"arguments"}})) . ")"
        }, "infix:<<=>>", sub {
            my $self = $_[0];
            "p5cmp(" . join(", ", map(Perlito5::JavaScript2::to_num($_), @{$self->{"arguments"}})) . ")"
        }, "infix:<**>", sub {
            my $self = $_[0];
            "Math.pow(" . join(", ", map(Perlito5::JavaScript2::to_num($_), @{$self->{"arguments"}})) . ")"
        }, "infix:<<<>", sub {
            my $self = $_[0];
            "p5shift_left(" . join(", ", map(Perlito5::JavaScript2::to_num($_), @{$self->{"arguments"}})) . ")"
        }, "infix:<%>", sub {
            my $self = $_[0];
            "p5modulo(" . join(", ", map(Perlito5::JavaScript2::to_num($_), @{$self->{"arguments"}})) . ")"
        }, "prefix:<!>", sub {
            my $self = shift;
            my $level = shift;
            "!( " . Perlito5::JavaScript2::to_bool($self->{"arguments"}->[0], $level) . ")"
        }, "prefix:<not>", sub {
            my $self = shift;
            my $level = shift;
            my $arg = pop(@{$self->{"arguments"}});
            if (!$arg) {;
                return "true"
            }
            "!( " . Perlito5::JavaScript2::to_bool($arg, $level) . ")"
        }, "prefix:<~>", sub {
            my $self = $_[0];
            "p5complement( " . Perlito5::JavaScript2::to_num($self->{"arguments"}->[0]) . ")"
        }, "prefix:<->", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "p5negative( " . $self->{"arguments"}->[0]->emit_javascript2($level, "scalar") . ")"
        }, "prefix:<+>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "(" . $self->{"arguments"}->[0]->emit_javascript2($level, $wantarray) . ")"
        }, "require", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ($arg->{"is_version_string"}) {;
                return "p5pkg[\"Perlito5\"][\"test_perl_version\"]([" . Perlito5::JavaScript2::to_str($self->{"arguments"}->[0]) . "], " . Perlito5::JavaScript2::to_context($wantarray) . ")"
            }
            "p5pkg[\"Perlito5::Grammar::Use\"][\"require\"]([" . Perlito5::JavaScript2::to_str($self->{"arguments"}->[0]) . ", " . ($self->{"arguments"}->[0]->{"bareword"} ? 1 : 0) . "], " . Perlito5::JavaScript2::to_context($wantarray) . ")"
        }, "select", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "p5pkg[\"CORE\"][\"select\"]([" . ($self->{"arguments"}->[0]->{"bareword"} ? Perlito5::JavaScript2::to_str($self->{"arguments"}->[0]) : $self->{"arguments"}->[0]->emit_javascript2($level, "scalar")) . "])"
        }, "prefix:<\$>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0];
            return "p5scalar_deref(" . $arg->emit_javascript2($level) . ", " . Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME) . ", " . "\"\"" . ")"
        }, "prefix:<\@>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0];
            my $s = "p5array_deref(" . Perlito5::JavaScript2::emit_javascript2_autovivify($arg, $level, "array") . ", " . Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME) . ")";
            return $wantarray eq "scalar" ? "p5num(" . $s . ")" : $s
        }, "prefix:<\$#>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0];
            return "(p5array_deref(" . Perlito5::JavaScript2::emit_javascript2_autovivify($arg, $level, "array") . ", " . Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME) . ").length - 1)"
        }, "prefix:<%>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0];
            return "p5hash_deref(" . Perlito5::JavaScript2::emit_javascript2_autovivify($arg, $level, "hash") . ", " . Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME) . ")"
        }, "prefix:<&>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0];
            "p5cget_by_name(" . Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME) . ", " . $arg->emit_javascript2($level) . ")([])"
        }, "circumfix:<[ ]>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "(new p5ArrayRef(" . Perlito5::JavaScript2::to_list($self->{"arguments"}) . "))"
        }, "circumfix:<{ }>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "(new p5HashRef(" . Perlito5::JavaScript2::to_list($self->{"arguments"}, $level, "hash") . "))"
        }, "prefix:<\\>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ($arg->isa("Perlito5::AST::Apply")) {
                if ($arg->{"code"} eq "prefix:<\@>") {;
                    return "(new p5ArrayRef(" . $arg->emit_javascript2($level) . "))"
                }
                if ($arg->{"code"} eq "prefix:<%>") {;
                    return "(new p5HashRef(" . $arg->emit_javascript2($level) . "))"
                }
                if ($arg->{"code"} eq "circumfix:<( )>") {;
                    return "p5_list_of_refs(" . Perlito5::JavaScript2::to_list($arg->{"arguments"}) . ")"
                }
                if ($arg->{"code"} eq "prefix:<&>") {;
                    return "p5code_lookup_by_name(" . Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME) . ", " . $arg->{"arguments"}->[0]->emit_javascript2($level) . ")"
                }
            }
            if ($arg->isa("Perlito5::AST::Var")) {
                if ($arg->sigil() eq "\@") {;
                    return "(new p5ArrayRef(" . $arg->emit_javascript2($level) . "))"
                }
                if ($arg->sigil() eq "%") {;
                    return "(new p5HashRef(" . $arg->emit_javascript2($level) . "))"
                }
                if ($arg->sigil() eq "*") {;
                    return "(new p5GlobRef(" . $arg->emit_javascript2($level) . "))"
                }
                if ($arg->sigil() eq "&") {
                    if ($arg->{"namespace"}) {;
                        return "p5pkg[" . Perlito5::JavaScript2::escape_string($arg->{"namespace"}) . "]." . $arg->{"name"}
                    }
                    else {;
                        return Perlito5::JavaScript2::pkg() . "." . $arg->{"name"}
                    }
                }
            }
            return "(new p5ScalarRef(" . $arg->emit_javascript2($level) . "))"
        }, "postfix:<++>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ($arg->isa("Perlito5::AST::Index") || $arg->isa("Perlito5::AST::Lookup") || $arg->isa("Perlito5::AST::Call")) {;
                return $arg->emit_javascript2($level + 1, 0, "p5postincr")
            }
            if ($arg->isa("Perlito5::AST::Var") && $arg->{"sigil"} eq "\$") {
                my $tmp = Perlito5::JavaScript2::get_label();
                return Perlito5::JavaScript2::emit_wrap_javascript2($level, "scalar", "var " . $tmp . " = " . $arg->emit_javascript2($level) . ";", $arg->emit_javascript2($level) . " = p5incr_(" . $tmp . ");", "return " . $tmp)
            }
            "(" . join(" ", map($_->emit_javascript2(), @{$self->{"arguments"}})) . ")++"
        }, "postfix:<-->", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ($arg->isa("Perlito5::AST::Index") || $arg->isa("Perlito5::AST::Lookup") || $arg->isa("Perlito5::AST::Call")) {;
                return $arg->emit_javascript2($level + 1, 0, "p5postdecr")
            }
            if ($arg->isa("Perlito5::AST::Var") && $arg->{"sigil"} eq "\$") {
                my $tmp = Perlito5::JavaScript2::get_label();
                return Perlito5::JavaScript2::emit_wrap_javascript2($level, "scalar", "var " . $tmp . " = " . $arg->emit_javascript2($level) . ";", $arg->emit_javascript2($level) . " = p5decr_(" . $tmp . ");", "return " . $tmp)
            }
            "(" . join(" ", map($_->emit_javascript2(), @{$self->{"arguments"}})) . ")--"
        }, "prefix:<++>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ($arg->isa("Perlito5::AST::Index") || $arg->isa("Perlito5::AST::Lookup") || $arg->isa("Perlito5::AST::Call")) {;
                return $arg->emit_javascript2($level + 1, 0, "p5incr")
            }
            if ($arg->isa("Perlito5::AST::Var") && $arg->{"sigil"} eq "\$") {
                my $tmp = Perlito5::JavaScript2::get_label();
                return Perlito5::JavaScript2::emit_wrap_javascript2($level, "scalar", "var " . $tmp . " = " . $arg->emit_javascript2($level) . ";", $arg->emit_javascript2($level) . " = p5incr_(" . $tmp . ");", "return " . $arg->emit_javascript2($level + 1))
            }
            "++(" . join(" ", map($_->emit_javascript2(), @{$self->{"arguments"}})) . ")"
        }, "prefix:<-->", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ($arg->isa("Perlito5::AST::Index") || $arg->isa("Perlito5::AST::Lookup") || $arg->isa("Perlito5::AST::Call")) {;
                return $arg->emit_javascript2($level + 1, 0, "p5decr")
            }
            if ($arg->isa("Perlito5::AST::Var") && $arg->{"sigil"} eq "\$") {
                my $tmp = Perlito5::JavaScript2::get_label();
                return Perlito5::JavaScript2::emit_wrap_javascript2($level, "scalar", "var " . $tmp . " = " . $arg->emit_javascript2($level) . ";", $arg->emit_javascript2($level) . " = p5decr_(" . $tmp . ");", "return " . $arg->emit_javascript2($level + 1))
            }
            "--(" . join(" ", map($_->emit_javascript2(), @{$self->{"arguments"}})) . ")"
        }, "infix:<x>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0];
            if (ref($arg) eq "Perlito5::AST::Apply" && ($arg->{"code"} eq "circumfix:<( )>" || $arg->{"code"} eq "list:<,>")) {;
                return "p5list_replicate(" . $self->{"arguments"}->[0]->emit_javascript2($level, "list") . "," . Perlito5::JavaScript2::to_num($self->{"arguments"}->[1], $level) . ", " . ($wantarray eq "runtime" ? "p5want" : $wantarray eq "list" ? 1 : 0) . ")"
            }
            "p5str_replicate(" . Perlito5::JavaScript2::to_str($self->{"arguments"}->[0], $level) . "," . Perlito5::JavaScript2::to_num($self->{"arguments"}->[1], $level) . ")"
        }, "list:<.>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "(" . join(" + ", map(Perlito5::JavaScript2::to_str($_), @{$self->{"arguments"}})) . ")"
        }, "list:<,>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            Perlito5::JavaScript2::to_list($self->{"arguments"})
        }, "infix:<..>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            return "p5range(" . $self->{"arguments"}->[0]->emit_javascript2($level) . ", " . $self->{"arguments"}->[1]->emit_javascript2($level) . ", " . ($wantarray eq "runtime" ? "p5want" : $wantarray eq "list" ? 1 : 0) . ", " . "\"" . Perlito5::JavaScript2::get_label() . "\"" . ", " . 0 . ")"
        }, "infix:<...>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            return "p5range(" . $self->{"arguments"}->[0]->emit_javascript2($level) . ", " . $self->{"arguments"}->[1]->emit_javascript2($level) . ", " . ($wantarray eq "runtime" ? "p5want" : $wantarray eq "list" ? 1 : 0) . ", " . "\"" . Perlito5::JavaScript2::get_label() . "\"" . ", " . 1 . ")"
        }, "delete", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ($arg->isa("Perlito5::AST::Lookup")) {
                my $v = $arg->obj();
                my $v_js = $v->emit_javascript2();
                my $key_js = $arg->autoquote($arg->{"index_exp"})->emit_javascript2($level);
                my $suffix = (($v->isa("Perlito5::AST::Var") && $v->sigil() eq "\$") ? '' : "._hash_");
                return "((function (v,k) { var ret = v[k]; delete (v[k]); return ret;})(" . $v_js . $suffix . "," . $key_js . "))"
            }
            if ($arg->isa("Perlito5::AST::Index")) {
                my $v = $arg->obj();
                if ($v->isa("Perlito5::AST::Var") && $v->sigil() eq "\$") {;
                    return "(delete " . $v->emit_javascript2() . "[" . $arg->{"index_exp"}->emit_javascript2($level) . "])"
                }
                return "(delete " . $v->emit_javascript2() . "._array_[" . $arg->{"index_exp"}->emit_javascript2($level) . "])"
            }
            if ($arg->isa("Perlito5::AST::Call")) {
                if ($arg->method() eq "postcircumfix:<{ }>") {;
                    return "(delete " . $arg->invocant()->emit_javascript2() . "._hash_[" . Perlito5::AST::Lookup::->autoquote($arg->{"arguments"})->emit_javascript2($level) . "])"
                }
                if ($arg->method() eq "postcircumfix:<[ ]>") {;
                    return "(delete " . $arg->invocant()->emit_javascript2() . "._array_[" . $arg->{"arguments"}->emit_javascript2($level) . "])"
                }
            }
            if ($arg->isa("Perlito5::AST::Var") && $arg->sigil() eq "&") {;
                die("TODO delete &code")
            }
            if ($arg->isa("Perlito5::AST::Apply") && $arg->{"code"} eq "prefix:<&>") {;
                die("TODO delete &\$code")
            }
        }, "scalar", sub {
            (my($self), my($level), my($wantarray)) = @_;
            Perlito5::JavaScript2::to_scalar($self->{"arguments"}, $level + 1)
        }, "ternary:<? :>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "( " . Perlito5::JavaScript2::to_bool($self->{"arguments"}->[0]) . " ? " . ($self->{"arguments"}->[1])->emit_javascript2($level, $wantarray) . " : " . ($self->{"arguments"}->[2])->emit_javascript2($level, $wantarray) . ")"
        }, "my", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "p5context(" . "[" . join(", ", map($_->emit_javascript2($level, $wantarray), @{$self->{"arguments"}})) . "], " . ($wantarray eq "runtime" ? "p5want" : $wantarray eq "list" ? 1 : 0) . ")"
        }, "state", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "p5context(" . "[" . join(", ", map($_->emit_javascript2($level, $wantarray), @{$self->{"arguments"}})) . "], " . ($wantarray eq "runtime" ? "p5want" : $wantarray eq "list" ? 1 : 0) . ")"
        }, "our", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "p5context(" . "[" . join(", ", map($_->emit_javascript2($level, $wantarray), @{$self->{"arguments"}})) . "], " . ($wantarray eq "runtime" ? "p5want" : $wantarray eq "list" ? 1 : 0) . ")"
        }, "local", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "p5context(" . "[" . join(", ", map($_->emit_javascript2($level, $wantarray), @{$self->{"arguments"}})) . "], " . ($wantarray eq "runtime" ? "p5want" : $wantarray eq "list" ? 1 : 0) . ")"
        }, "circumfix:<( )>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "p5context(" . "[" . join(", ", map($_->emit_javascript2($level, $wantarray), @{$self->{"arguments"}})) . "], " . ($wantarray eq "runtime" ? "p5want" : $wantarray eq "list" ? 1 : 0) . ")"
        }, "infix:<=>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $parameters = $self->{"arguments"}->[0];
            my $arguments = $self->{"arguments"}->[1];
            return _emit_assignment_javascript2($parameters, $arguments, $level, $wantarray)
        }, "break", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $Perlito5::THROW = 1;
            Perlito5::JavaScript2::emit_wrap_statement_javascript2($level, $wantarray, "throw(new p5_error(\"break\", \"\"))")
        }, "next", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $Perlito5::THROW = 1;
            my $label = '';
            @{$self->{"arguments"}} && ($label = $self->{"arguments"}->[0]->{"code"} || '');
            Perlito5::JavaScript2::emit_wrap_statement_javascript2($level, $wantarray, "throw(new p5_error(\"next\", " . Perlito5::JavaScript2::escape_string($label) . "))")
        }, "last", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $Perlito5::THROW = 1;
            my $label = '';
            @{$self->{"arguments"}} && ($label = $self->{"arguments"}->[0]->{"code"} || '');
            Perlito5::JavaScript2::emit_wrap_statement_javascript2($level, $wantarray, "throw(new p5_error(\"last\", " . Perlito5::JavaScript2::escape_string($label) . "))")
        }, "redo", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $Perlito5::THROW = 1;
            my $label = '';
            @{$self->{"arguments"}} && ($label = $self->{"arguments"}->[0]->{"code"} || '');
            Perlito5::JavaScript2::emit_wrap_statement_javascript2($level, $wantarray, "throw(new p5_error(\"redo\", " . Perlito5::JavaScript2::escape_string($label) . "))")
        }, "return", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $Perlito5::THROW = 1;
            Perlito5::JavaScript2::emit_wrap_statement_javascript2($level, $wantarray, "throw(" . Perlito5::JavaScript2::to_runtime_context($self->{"arguments"}, $level + 1) . ")")
        }, "goto", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $Perlito5::THROW = 1;
            Perlito5::JavaScript2::emit_wrap_statement_javascript2($level, $wantarray, "throw(" . $self->{"arguments"}->[0]->emit_javascript2($level) . ")")
        }, "do", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ($arg->isa("Perlito5::AST::Block")) {
                my $block = $arg->{"stmts"};
                return Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, (Perlito5::JavaScript2::LexicalBlock::->new("block", $block))->emit_javascript2($level + 1, $wantarray))
            }
            my $ast = Perlito5::AST::Apply::->new("code", "eval", "namespace", '', "arguments", [Perlito5::AST::Apply::->new("code", "slurp_file", "namespace", "Perlito5::Grammar::Use", "arguments", $self->{"arguments"})], "_scope", Perlito5::Grammar::Scope::->new_base_scope(), "_hash_hints", {}, "_scalar_hints", 0);
            my $js = $ast->emit_javascript2($level, $wantarray);
            return $js
        }, "eval", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $Perlito5::THROW = 1;
            my $arg = $self->{"arguments"}->[0];
            my $eval;
            if ($arg->isa("Perlito5::AST::Block")) {;
                $eval = Perlito5::AST::Apply::->new("code", "do", "arguments", [$arg])->emit_javascript2($level + 1, $wantarray)
            }
            else {
                my %vars;
                for my $var (@{$self->{"_scope"}->{"block"}}, @Perlito5::CAPTURES) {;
                    if ($var->{"_decl"} && $var->{"_decl"} ne "global") {;
                        $vars{$var->{"_id"}} = $var
                    }
                }
                my $scope = Perlito5::DumpToAST::dump_to_ast({"block", [values(%vars)]}, {}, "s");
                my $scope_js = "(new p5ArrayRef(" . Perlito5::JavaScript2::to_list([$scope]) . "))";
                my $hash_hints = Perlito5::DumpToAST::dump_to_ast($self->{"_hash_hints"}, {}, "s");
                my $hash_hints_js = $hash_hints->emit_javascript2($level);
                $eval = "eval(p5pkg[\"Perlito5::JavaScript2::Runtime\"].perl5_to_js([" . Perlito5::JavaScript2::to_str($arg) . ", " . Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME) . ", " . Perlito5::JavaScript2::escape_string($wantarray) . ", " . (0 + $self->{"_scalar_hints"}) . ", " . $hash_hints_js . ", " . $scope_js . "]))"
            }
            my $context = Perlito5::JavaScript2::to_context($wantarray);
            Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, ($context eq "p5want" ? () : "var p5want = " . $context . ";"), "var r;", "p5pkg[\"main\"][\"v_\@\"] = \"\";", "try {", ["r = " . $eval . ''], "}", "catch(err) {", ["if (err instanceof p5_error && (err.type == 'last' || err.type == 'redo' || err.type == 'next')) {", ["throw(err)"], "}", "else if ( err instanceof p5_error || err instanceof Error ) {", ["p5pkg[\"main\"][\"v_\@\"] = err;", "if (p5str(p5pkg[\"main\"][\"v_\@\"]).substr(-1, 1) != \"\\n\") {", ["try {" . '', ["p5pkg[\"main\"][\"v_\@\"] = p5pkg[\"main\"][\"v_\@\"] + \"\\n\" + err.stack + \"\\n\";"], "}", "catch(err) { }"], "}"], "}", "else {", ["return(err);"], "}"], "}", "return r;")
        }, "substr", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $length = $self->{"arguments"}->[2];
            if ($length && $length->isa("Perlito5::AST::Int") && $length->{"int"} > 0) {;
                return Perlito5::JavaScript2::to_str($self->{"arguments"}->[0]) . ".substr(" . Perlito5::JavaScript2::to_num($self->{"arguments"}->[1]) . ", " . Perlito5::JavaScript2::to_num($self->{"arguments"}->[2]) . ")"
            }
            my $arg_list = Perlito5::JavaScript2::to_list_preprocess($self->{"arguments"});
            my $arg_code = Perlito5::JavaScript2::to_list($arg_list);
            return "CORE.substr(" . $arg_code . ", " . Perlito5::JavaScript2::to_context($wantarray) . ")"
        }, "undef", sub {
            (my($self), my($level), my($wantarray)) = @_;
            if ($self->{"arguments"} && @{$self->{"arguments"}}) {
                my $arg = $self->{"arguments"}->[0];
                if (ref($arg) eq "Perlito5::AST::Var" && $arg->{"sigil"} eq "&") {;
                    return "(delete p5pkg[" . Perlito5::JavaScript2::escape_string(($arg->{"namespace"} || $Perlito5::PKG_NAME)) . "][" . Perlito5::JavaScript2::escape_string($arg->{"name"}) . "])"
                }
                return "(" . _emit_assignment_javascript2($arg, Perlito5::AST::Apply::->new("arguments", [], "bareword", 1, "code", "undef"), $level + 1, $wantarray) . ")"
            }
            return "null"
        }, "defined", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0];
            my $invocant;
            if (ref($arg) eq "Perlito5::AST::Apply" && $arg->{"code"} eq "prefix:<&>") {
                my $arg2 = $arg->{"arguments"}->[0];
                $invocant = "p5code_lookup_by_name(" . Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME) . ", " . $arg2->emit_javascript2($level) . ")"
            }
            elsif (ref($arg) eq "Perlito5::AST::Var" && $arg->{"sigil"} eq "&") {;
                $invocant = "p5pkg[" . Perlito5::JavaScript2::escape_string(($arg->{"namespace"} || $Perlito5::PKG_NAME)) . "][" . Perlito5::JavaScript2::escape_string($arg->{"name"}) . "]"
            }
            else {;
                $invocant = $arg->emit_javascript2($level, "scalar")
            }
            "(" . $invocant . " != null)"
        }, "shift", sub {
            (my($self), my($level), my($wantarray)) = @_;
            if ($self->{"arguments"} && @{$self->{"arguments"}}) {;
                return $self->{"arguments"}->[0]->emit_javascript2($level) . ".shift()"
            }
            if ($Perlito5::JavaScript2::is_inside_subroutine) {;
                return "List__.shift()"
            }
            return "p5pkg.main.List_ARGV.shift()"
        }, "pop", sub {
            (my($self), my($level), my($wantarray)) = @_;
            if ($self->{"arguments"} && @{$self->{"arguments"}}) {;
                return $self->{"arguments"}->[0]->emit_javascript2($level) . ".pop()"
            }
            if ($Perlito5::JavaScript2::is_inside_subroutine) {;
                return "List__.pop()"
            }
            return "p5pkg.main.List_ARGV.pop()"
        }, "unshift", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @arguments = @{$self->{"arguments"}};
            my $v = shift(@arguments);
            return $v->emit_javascript2($level) . ".p5unshift(" . Perlito5::JavaScript2::to_list(\@arguments) . ")"
        }, "push", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @arguments = @{$self->{"arguments"}};
            my $v = shift(@arguments);
            return $v->emit_javascript2($level) . ".p5push(" . Perlito5::JavaScript2::to_list(\@arguments) . ")"
        }, "tie", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @arguments = @{$self->{"arguments"}};
            my $v = shift(@arguments);
            my $meth;
            if ($v->isa("Perlito5::AST::Var") && $v->sigil() eq "%") {;
                $meth = "hash"
            }
            elsif ($v->isa("Perlito5::AST::Var") && $v->sigil() eq "\@") {;
                $meth = "array"
            }
            elsif ($v->isa("Perlito5::AST::Var") && $v->sigil() eq "\$") {;
                $meth = "scalar"
            }
            else {;
                die("tie '", ref($v), "' not implemented")
            }
            return "p5tie_" . $meth . "(" . $v->emit_javascript2($level) . ", " . Perlito5::JavaScript2::to_list(\@arguments) . ")"
        }, "untie", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @arguments = @{$self->{"arguments"}};
            my $v = shift(@arguments);
            my $meth;
            if ($v->isa("Perlito5::AST::Var") && $v->sigil() eq "%") {;
                $meth = "hash"
            }
            elsif ($v->isa("Perlito5::AST::Var") && $v->sigil() eq "\@") {;
                $meth = "array"
            }
            elsif ($v->isa("Perlito5::AST::Var") && $v->sigil() eq "\$") {;
                $meth = "scalar"
            }
            else {;
                die("tie '", ref($v), "' not implemented")
            }
            return "p5untie_" . $meth . "(" . $v->emit_javascript2($level) . ")"
        }, "print", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun;
            if ($self->{"special_arg"}) {;
                $fun = $self->{"special_arg"}->emit_javascript2($level)
            }
            else {;
                $fun = "\"STDOUT\""
            }
            my $list = Perlito5::JavaScript2::to_list(\@in, $level);
            "p5pkg[\"Perlito5::IO\"].print(" . $fun . ", " . $list . ")"
        }, "say", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun;
            if ($self->{"special_arg"}) {;
                $fun = $self->{"special_arg"}->emit_javascript2($level)
            }
            else {;
                $fun = "\"STDOUT\""
            }
            my $list = Perlito5::JavaScript2::to_list(\@in, $level);
            "p5pkg[\"Perlito5::IO\"].say(" . $fun . ", " . $list . ")"
        }, "printf", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun;
            if ($self->{"special_arg"}) {;
                $fun = $self->{"special_arg"}->emit_javascript2($level)
            }
            else {;
                $fun = "\"STDOUT\""
            }
            my $list = Perlito5::JavaScript2::to_list(\@in, $level);
            "p5pkg[\"Perlito5::IO\"].printf(" . $fun . ", " . $list . ")"
        }, "close", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun = shift(@in);
            "p5pkg[\"Perlito5::IO\"].close(" . $fun->emit_javascript2($level) . ", [])"
        }, "open", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun = shift(@in);
            if (ref($fun) ne "Perlito5::AST::Apply") {;
                return Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, $fun->emit_javascript2($level) . " = CORE.bless([ {file_handle : {id : null}}, \"GLOB\" ]);", "return CORE.open(" . Perlito5::JavaScript2::to_list($self->{"arguments"}, $level) . ")")
            }
            else {;
                return "CORE.open(" . Perlito5::JavaScript2::to_list($self->{"arguments"}, $level) . ")"
            }
        }, "chomp", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $v = $self->{"arguments"}->[0];
            return Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, "var r = p5chomp(" . $v->emit_javascript2($level) . ");", $v->emit_javascript2($level) . " = r[1];", "return r[0]")
        }, "chop", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $v = $self->{"arguments"}->[0];
            return Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, "var r = p5chop(" . $v->emit_javascript2($level) . ");", $v->emit_javascript2($level) . " = r[1];", "return r[0]")
        }, "read", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun = shift(@in);
            my $scalar = shift(@in);
            my $length = shift(@in);
            return Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, "var r = p5pkg[\"Perlito5::IO\"].read(" . $fun->emit_javascript2($level) . ", [" . $length->emit_javascript2($level) . "]);", $scalar->emit_javascript2($level) . " = r[1];", "return r[0]")
        }, "readline", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun = shift(@in) || bless({"arguments", [], "bareword", 1, "code", "ARGV", "namespace", ''}, "Perlito5::AST::Apply");
            return "CORE.readline([" . $fun->emit_javascript2($level) . "], " . Perlito5::JavaScript2::to_context($wantarray) . ")"
        }, "map", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun;
            if ($self->{"special_arg"}) {;
                $fun = $self->{"special_arg"}
            }
            else {;
                $fun = shift(@in)
            }
            my $list = Perlito5::JavaScript2::to_list(\@in, $level);
            if (ref($fun) eq "Perlito5::AST::Block") {;
                $fun = $fun->{"stmts"}
            }
            else {;
                $fun = [$fun]
            }
            "p5map(" . Perlito5::JavaScript2::pkg() . ", " . "function (p5want) {" . "
" . Perlito5::JavaScript2::tab($level + 1) . (Perlito5::JavaScript2::LexicalBlock::->new("block", $fun))->emit_javascript2($level + 1, $wantarray) . "
" . Perlito5::JavaScript2::tab($level) . "}, " . $list . ")"
        }, "grep", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun;
            if ($self->{"special_arg"}) {;
                $fun = $self->{"special_arg"}
            }
            else {;
                $fun = shift(@in)
            }
            my $list = Perlito5::JavaScript2::to_list(\@in, $level);
            if (ref($fun) eq "Perlito5::AST::Block") {;
                $fun = $fun->{"stmts"}
            }
            else {;
                $fun = [$fun]
            }
            "p5grep(" . Perlito5::JavaScript2::pkg() . ", " . "function (p5want) {" . "
" . Perlito5::JavaScript2::tab($level + 1) . (Perlito5::JavaScript2::LexicalBlock::->new("block", $fun))->emit_javascript2($level + 1, $wantarray) . "
" . Perlito5::JavaScript2::tab($level) . "}, " . $list . ")"
        }, "sort", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun;
            my $list;
            if ($self->{"special_arg"}) {;
                $fun = $self->{"special_arg"}
            }
            elsif (ref($in[0]) eq "Perlito5::AST::Block") {;
                $fun = shift(@in)
            }
            if (ref($fun) eq "Perlito5::AST::Block") {;
                $fun = "function (p5want) {" . "
" . Perlito5::JavaScript2::tab($level + 1) . (Perlito5::JavaScript2::LexicalBlock::->new("block", $fun->{"stmts"}))->emit_javascript2($level + 1, $wantarray) . "
" . Perlito5::JavaScript2::tab($level) . "}"
            }
            else {;
                $fun = "null"
            }
            $list = Perlito5::JavaScript2::to_list(\@in, $level);
            "p5sort(" . Perlito5::JavaScript2::pkg() . ", " . $fun . ", " . $list . ")"
        }, "infix:<//>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "p5defined_or" . "(" . $self->{"arguments"}->[0]->emit_javascript2($level, "scalar") . ", " . Perlito5::JavaScript2::emit_function_javascript2($level, $wantarray, $self->{"arguments"}->[1]) . ")"
        }, "exists", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ($arg->isa("Perlito5::AST::Lookup")) {
                my $v = $arg->obj();
                if ($v->isa("Perlito5::AST::Var") && $v->sigil() eq "\$") {
                    $v->{"sigil"} = "%";
                    return "(" . $v->emit_javascript2() . ").hasOwnProperty(" . $arg->autoquote($arg->{"index_exp"})->emit_javascript2($level) . ")"
                }
                return "(" . $v->emit_javascript2() . ")._hash_.hasOwnProperty(" . $arg->autoquote($arg->{"index_exp"})->emit_javascript2($level) . ")"
            }
            if ($arg->isa("Perlito5::AST::Index")) {
                my $v = $arg->obj();
                if ($v->isa("Perlito5::AST::Var") && $v->sigil() eq "\$") {;
                    return "(" . $v->emit_javascript2() . ").hasOwnProperty(" . $arg->{"index_exp"}->emit_javascript2($level) . ")"
                }
                return "(" . $v->emit_javascript2() . ")._array_.hasOwnProperty(" . $arg->{"index_exp"}->emit_javascript2($level) . ")"
            }
            if ($arg->isa("Perlito5::AST::Call")) {
                if ($arg->method() eq "postcircumfix:<{ }>") {;
                    return Perlito5::JavaScript2::emit_javascript2_autovivify($arg->invocant(), $level, "hash") . "._hash_.hasOwnProperty(" . Perlito5::AST::Lookup::->autoquote($arg->{"arguments"})->emit_javascript2($level) . ")"
                }
                if ($arg->method() eq "postcircumfix:<[ ]>") {;
                    return Perlito5::JavaScript2::emit_javascript2_autovivify($arg->invocant(), $level, "array") . "._array_.hasOwnProperty(" . $arg->{"arguments"}->emit_javascript2($level) . ")"
                }
            }
            if ($arg->isa("Perlito5::AST::Var") && $arg->sigil() eq "&") {
                my $name = $arg->{"name"};
                my $namespace = $arg->{"namespace"} || $Perlito5::PKG_NAME;
                return "p5pkg[" . Perlito5::JavaScript2::escape_string($namespace) . "].hasOwnProperty(" . Perlito5::JavaScript2::escape_string($name) . ")"
            }
            if ($arg->isa("Perlito5::AST::Apply") && $arg->{"code"} eq "prefix:<&>") {
                my $arg2 = $arg->{"arguments"}->[0];
                return "p5sub_exists(" . Perlito5::JavaScript2::to_str($arg2) . ", " . Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME) . ")"
            }
        }, "prototype", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0];
            return "p5sub_prototype(" . $arg->emit_javascript2() . ", " . Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME) . ")"
        }, "split", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @js;
            my $arg = $self->{"arguments"}->[0];
            if ($arg && $arg->isa("Perlito5::AST::Apply") && $arg->{"code"} eq "p5:m") {
                push(@js, "new RegExp(" . $arg->{"arguments"}->[0]->emit_javascript2() . ", " . Perlito5::JavaScript2::escape_string($arg->{"arguments"}->[1]->{"buf"}) . ")");
                shift(@{$self->{"arguments"}})
            }
            return "CORE.split(" . "[" . join(", ", @js, map($_->emit_javascript2(), @{$self->{"arguments"}})) . "], " . Perlito5::JavaScript2::to_context($wantarray) . ")"
        });
        sub Perlito5::AST::Apply::emit_javascript2 {
            (my($self), my($level), my($wantarray)) = @_;
            my $apply = $self->op_assign();
            if ($apply) {;
                return $apply->emit_javascript2($level)
            }
            my $apply = $self->op_auto();
            if ($apply) {;
                return $apply->emit_javascript2($level)
            }
            my $code = $self->{"code"};
            if (ref($code) ne '') {
                my @args = ();
                push(@args, $_->emit_javascript2())
                    for @{$self->{"arguments"}};
                if (ref($code) eq "Perlito5::AST::Apply" && $code->code() eq "prefix:<&>") {
                    my $arg = $self->{"code"}->{"arguments"}->[0];
                    $code = "p5code_lookup_by_name(" . Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME) . ", " . $arg->emit_javascript2($level) . ")";
                    return $code . "([" . join(",", @args) . "])"
                }
                return "(" . $self->{"code"}->emit_javascript2($level) . ")([" . join(",", @args) . "])"
            }
            exists($emit_js{$code}) && return $emit_js{$code}->($self, $level, $wantarray);
            if (exists($Perlito5::JavaScript2::op_infix_js_str{$code})) {;
                return "(" . join($Perlito5::JavaScript2::op_infix_js_str{$code}, map {;
                    Perlito5::JavaScript2::to_str($_, $level)
                } @{$self->{"arguments"}}) . ")"
            }
            if (exists($Perlito5::JavaScript2::op_infix_js_num{$code})) {;
                return "(" . join($Perlito5::JavaScript2::op_infix_js_num{$code}, map {;
                    Perlito5::JavaScript2::to_num($_, $level)
                } @{$self->{"arguments"}}) . ")"
            }
            if (exists($Perlito5::JavaScript2::op_prefix_js_str{$code})) {;
                return $Perlito5::JavaScript2::op_prefix_js_str{$code} . "(" . Perlito5::JavaScript2::to_str($self->{"arguments"}->[0]) . ")"
            }
            if ($self->{"namespace"}) {
                if ($self->{"namespace"} eq "JS") {;
                    if ($code eq "inline") {
                        if ($self->{"arguments"}->[0]->isa("Perlito5::AST::Buf")) {;
                            return $self->{"arguments"}->[0]->{"buf"}
                        }
                        else {;
                            die("JS::inline needs a string constant")
                        }
                    }
                }
                if ($self->{"namespace"} eq "Perlito5") {;
                    if ($code eq "eval_ast") {;
                        $self->{"namespace"} = "Perlito5::JavaScript2::Runtime"
                    }
                }
                $code = "p5pkg[" . Perlito5::JavaScript2::escape_string($self->{"namespace"}) . "]." . $code
            }
            else {;
                $code = Perlito5::JavaScript2::pkg() . "." . $code
            }
            my $sig;
            my $may_need_autoload;
            {
                my $name = $self->{"code"};
                my $namespace = $self->{"namespace"} || $Perlito5::PKG_NAME;
                my $effective_name = $namespace . "::" . $self->{"code"};
                if (exists($Perlito5::PROTO->{$effective_name})) {;
                    $sig = $Perlito5::PROTO->{$effective_name}
                }
                elsif ((!$self->{"namespace"} || $namespace eq "CORE") && exists($Perlito5::CORE_PROTO->{"CORE::" . $name})) {
                    $effective_name = "CORE::" . $name;
                    $sig = $Perlito5::CORE_PROTO->{$effective_name}
                }
                elsif (exists($Perlito5::PACKAGES->{$name})) {;
                    return Perlito5::JavaScript2::escape_string($name)
                }
                else {
                    if ($self->{"bareword"}) {;
                        return Perlito5::JavaScript2::escape_string(($self->{"namespace"} ? $self->{"namespace"} . "::" : '') . $name)
                    }
                    $may_need_autoload = 1
                }
                (exists($self->{"proto"})) && ($sig = $self->{"proto"})
            }
            $self->{"ignore_proto"} && ($sig = '');
            if ($sig) {
                my @out = ();
                my @in = @{$self->{"arguments"} || []};
                my $close = "]";
                my $optional = 0;
                while (length($sig)) {
                    my $c = substr($sig, 0, 1);
                    if ($c eq ";") {;
                        $optional = 1
                    }
                    elsif ($c eq "\$" || $c eq "_") {;
                        (@in || !$optional) && push(@out, shift(@in)->emit_javascript2($level + 1, "scalar"))
                    }
                    elsif ($c eq "+") {;
                        if (@in || !$optional) {
                            my $in = shift(@in);
                            if (($in->isa("Perlito5::AST::Apply") && $in->{"code"} eq "prefix:<\@>") || ($in->isa("Perlito5::AST::Var") && $in->sigil() eq "\@") || ($in->isa("Perlito5::AST::Apply") && $in->{"code"} eq "prefix:<%>") || ($in->isa("Perlito5::AST::Var") && $in->sigil() eq "%")) {;
                                push(@out, $in->emit_javascript2($level + 1, "list"))
                            }
                            else {;
                                push(@out, $in->emit_javascript2($level + 1, "scalar"))
                            }
                        }
                    }
                    elsif ($c eq "\@") {
                        (@in || !$optional) && ($close = "].concat(" . Perlito5::JavaScript2::to_list(\@in, $level + 1) . ")");
                        @in = ()
                    }
                    elsif ($c eq "&") {;
                        push(@out, shift(@in)->emit_javascript2($level + 1, "scalar"))
                    }
                    elsif ($c eq "*") {;
                        if (@in || !$optional) {
                            my $arg = shift(@in);
                            if ($arg->{"bareword"}) {;
                                push(@out, Perlito5::JavaScript2::escape_string($arg->{"code"}))
                            }
                            else {;
                                push(@out, $arg->emit_javascript2($level + 1, "scalar"))
                            }
                        }
                    }
                    elsif ($c eq "\\") {
                        if (substr($sig, 0, 2) eq "\\\$") {
                            $sig = substr($sig, 1);
                            (@in || !$optional) && push(@out, shift(@in)->emit_javascript2($level + 1, "scalar"))
                        }
                        elsif (substr($sig, 0, 2) eq "\\\@" || substr($sig, 0, 2) eq "\\%") {
                            $sig = substr($sig, 1);
                            (@in || !$optional) && push(@out, shift(@in)->emit_javascript2($level + 1, "list"))
                        }
                        elsif (substr($sig, 0, 5) eq "\\[\@%]") {
                            $sig = substr($sig, 4);
                            (@in || !$optional) && push(@out, shift(@in)->emit_javascript2($level + 1, "list"))
                        }
                        elsif (substr($sig, 0, 6) eq "\\[\$\@%]") {
                            $sig = substr($sig, 5);
                            (@in || !$optional) && push(@out, shift(@in)->emit_javascript2($level + 1, "list"))
                        }
                    }
                    $sig = substr($sig, 1)
                }
                return $code . "([" . join(", ", @out) . $close . ", " . Perlito5::JavaScript2::to_context($wantarray) . ")"
            }
            my $arg_list = Perlito5::JavaScript2::to_list_preprocess($self->{"arguments"});
            my $arg_code = $self->{"code"} eq "scalar" ? "[" . join(", ", map($_->emit_javascript2($level), @{$arg_list})) . "]" : Perlito5::JavaScript2::to_list($arg_list, $level);
            if ($may_need_autoload) {
                my $name = $self->{"code"};
                my $namespace = $self->{"namespace"} || $Perlito5::PKG_NAME;
                return "p5cget(" . Perlito5::JavaScript2::escape_string($namespace) . ", " . Perlito5::JavaScript2::escape_string($name) . ")(" . $arg_code . ", " . Perlito5::JavaScript2::to_context($wantarray) . ")"
            }
            $code . "(" . $arg_code . ", " . Perlito5::JavaScript2::to_context($wantarray) . ")"
        }
        sub Perlito5::AST::Apply::emit_javascript2_set_list {
            (my($self), my($level), my($list)) = @_;
            my $code = $self->{"code"};
            if ($self->code() eq "undef") {;
                return $list . ".shift()"
            }
            if ($self->code() eq "prefix:<\$>") {;
                return "p5scalar_deref_set(" . Perlito5::JavaScript2::emit_javascript2_autovivify($self->{"arguments"}->[0], $level + 1, "scalar") . ", " . $list . ".shift()" . ", " . Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME) . ")"
            }
            if ($code eq "my" || $code eq "our" || $code eq "state" || $code eq "local") {;
                return join("; ", map {;
                    $_->emit_javascript2_set_list($level, $list)
                } @{$self->{"arguments"}})
            }
            die("not implemented: assign to ", $self->code())
        }
        sub Perlito5::AST::Apply::emit_javascript2_get_decl {
            my $self = shift;
            my $code = $self->{"code"};
            if ($code eq "my" || $code eq "our" || $code eq "state" || $code eq "local") {;
                return (map {;
                    ref($_) eq "Perlito5::AST::Var" ? Perlito5::AST::Decl::->new("decl", $code, "type", '', "var", $_) : ()
                } @{$self->{"arguments"}})
            }
            if ($code ne "do" && $code ne "eval") {;
                $self->{"arguments"} && return (map(+($_->emit_javascript2_get_decl()), @{$self->{"arguments"}}))
            }
            return ()
        }
        sub Perlito5::AST::Apply::emit_javascript2_has_regex {
            my $self = shift;
            my $code = $self->{"code"};
            if ($code eq "p5:m" || $code eq "p5:s" || $code eq "infix:<=~>" || $code eq "infix:<!~>") {;
                return 1
            }
            return ()
        }
    }
    1
}
{
    package main;
    package Perlito5::JavaScript2;
    {
        my %label;
        sub Perlito5::JavaScript2::pkg {;
            "p5pkg[" . Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME) . "]"
        }
        sub Perlito5::JavaScript2::get_label {;
            "tmp" . $Perlito5::ID++
        }
        sub Perlito5::JavaScript2::tab {
            my $level = shift;
            "\x{9}" x $level
        }
        our $is_inside_subroutine;
        our %op_prefix_js_str = ("prefix:<-A>", "p5atime", "prefix:<-C>", "p5ctime", "prefix:<-M>", "p5mtime", "prefix:<-d>", "p5is_directory", "prefix:<-e>", "p5file_exists", "prefix:<-f>", "p5is_file", "prefix:<-s>", "p5size", "prefix:<-p>", "p5is_pipe");
        our %op_infix_js_str = ("infix:<eq>", " == ", "infix:<ne>", " != ", "infix:<le>", " <= ", "infix:<ge>", " >= ", "infix:<lt>", " < ", "infix:<gt>", " > ");
        our %op_infix_js_num = ("infix:<==>", " == ", "infix:<!=>", " != ", "infix:<+>", " + ", "infix:<->", " - ", "infix:<*>", " * ", "infix:</>", " / ", "infix:<>>", " > ", "infix:<<>", " < ", "infix:<>=>", " >= ", "infix:<<=>", " <= ", "infix:<&>", " & ", "infix:<|>", " | ", "infix:<^>", " ^ ", "infix:<>>>", " >>> ");
        our %op_to_bool = map(+($_, 1), "prefix:<!>", "infix:<!=>", "infix:<==>", "infix:<<=>", "infix:<>=>", "infix:<>>", "infix:<<>", "infix:<eq>", "infix:<ne>", "infix:<ge>", "infix:<le>", "infix:<gt>", "infix:<lt>", "infix:<~~>", "prefix:<not>", "exists", "defined");
        our %op_to_str = map(+($_, 1), "substr", "join", "list:<.>", "chr", "lc", "uc", "lcfirst", "ucfirst", "ref");
        our %op_to_num = map(+($_, 1), "length", "index", "ord", "oct", "infix:<->", "infix:<+>", "infix:<*>", "infix:</>", "infix:<%>", "infix:<**>");
        my %safe_char = (" ", 1, "!", 1, "\"", 1, "#", 1, "\$", 1, "%", 1, "&", 1, "(", 1, ")", 1, "*", 1, "+", 1, ",", 1, "-", 1, ".", 1, "/", 1, ":", 1, ";", 1, "<", 1, "=", 1, ">", 1, "?", 1, "\@", 1, "[", 1, "]", 1, "^", 1, "_", 1, "`", 1, "{", 1, "|", 1, "}", 1, "~", 1);
        sub Perlito5::JavaScript2::escape_string {
            my $s = shift;
            my @out;
            my $tmp = '';
            $s eq '' && return "''";
            for my $i (0 .. length($s) - 1) {
                my $c = substr($s, $i, 1);
                if (($c ge "a" && $c le "z") || ($c ge "A" && $c le "Z") || ($c ge 0 && $c le 9) || exists($safe_char{$c})) {;
                    $tmp = $tmp . $c
                }
                else {
                    $tmp ne '' && push(@out, "'" . $tmp . "'");
                    push(@out, "String.fromCharCode(" . ord($c) . ")");
                    $tmp = ''
                }
            }
            $tmp ne '' && push(@out, "'" . $tmp . "'");
            return join(" + ", @out)
        }
        sub Perlito5::JavaScript2::to_str {
            my $cond = shift;
            my $level = shift;
            my $wantarray = "scalar";
            if ($cond->isa("Perlito5::AST::Apply") && $cond->code() eq "circumfix:<( )>" && $cond->{"arguments"} && @{$cond->{"arguments"}}) {;
                return to_str($cond->{"arguments"}->[0], $level)
            }
            if (($cond->isa("Perlito5::AST::Buf")) || ($cond->isa("Perlito5::AST::Apply") && exists($op_to_str{$cond->code()}))) {;
                return $cond->emit_javascript2($level, $wantarray)
            }
            else {;
                return "p5str(" . $cond->emit_javascript2($level, $wantarray) . ")"
            }
        }
        sub Perlito5::JavaScript2::is_num {
            my $cond = shift;
            ($cond->isa("Perlito5::AST::Int") || $cond->isa("Perlito5::AST::Num") || ($cond->isa("Perlito5::AST::Apply") && exists($op_to_num{$cond->code()}))) && return 1;
            return 0
        }
        sub Perlito5::JavaScript2::to_num {
            my $cond = shift;
            my $level = shift;
            my $wantarray = "scalar";
            if (is_num($cond)) {;
                return $cond->emit_javascript2($level, $wantarray)
            }
            else {;
                return "p5num(" . $cond->emit_javascript2($level, $wantarray) . ")"
            }
        }
        sub Perlito5::JavaScript2::to_bool {
            my $cond = shift;
            my $level = shift;
            my $wantarray = "scalar";
            if ($cond->isa("Perlito5::AST::Apply") && $cond->code() eq "circumfix:<( )>" && $cond->{"arguments"} && @{$cond->{"arguments"}}) {;
                return to_bool($cond->{"arguments"}->[0], $level)
            }
            if ($cond->isa("Perlito5::AST::Apply") && ($cond->code() eq "infix:<&&>" || $cond->code() eq "infix:<and>")) {;
                return "(" . to_bool($cond->{"arguments"}->[0], $level) . " && " . to_bool($cond->{"arguments"}->[1], $level) . ")"
            }
            if ($cond->isa("Perlito5::AST::Apply") && ($cond->code() eq "infix:<||>" || $cond->code() eq "infix:<or>")) {;
                return "(" . to_bool($cond->{"arguments"}->[0], $level) . " || " . to_bool($cond->{"arguments"}->[1], $level) . ")"
            }
            if (($cond->isa("Perlito5::AST::Int")) || ($cond->isa("Perlito5::AST::Num")) || ($cond->isa("Perlito5::AST::Apply") && exists($op_to_bool{$cond->code()}))) {;
                return $cond->emit_javascript2($level, $wantarray)
            }
            else {;
                return "p5bool(" . $cond->emit_javascript2($level, $wantarray) . ")"
            }
        }
        sub Perlito5::JavaScript2::is_scalar {;
            !$_[0]->isa("Perlito5::AST::Int") && !$_[0]->isa("Perlito5::AST::Num") && !$_[0]->isa("Perlito5::AST::Buf") && !$_[0]->isa("Perlito5::AST::Sub") && !($_[0]->isa("Perlito5::AST::Var") && $_[0]->{"sigil"} eq "\$") && !($_[0]->isa("Perlito5::AST::Apply") && (exists($op_to_str{$_[0]->{"code"}}) || exists($op_to_num{$_[0]->{"code"}}) || exists($op_to_bool{$_[0]->{"code"}})))
        }
        sub Perlito5::JavaScript2::to_list {
            my $items = to_list_preprocess($_[0]);
            my $level = $_[1];
            my $literal_type = $_[2] || "array";
            my $wantarray = "list";
            my $interpolate = 0;
            for $_ (@{$items}) {;
                is_scalar($_) && ($interpolate = 1)
            }
            if ($literal_type eq "hash") {
                if (!$interpolate) {
                    my @out;
                    my $printable = 1;
                    my @in = @{$items};
                    while (@in) {
                        my $k = shift(@in);
                        my $v = shift(@in);
                        $k = $k->emit_javascript2($level, 0);
                        $k =~ m/[ \[]/ && ($printable = 0);
                        $v = $v ? $v->emit_javascript2($level, 0) : "null";
                        push(@out, $k . " : " . $v)
                    }
                    $printable && return "{" . join(", ", @out) . "}"
                }
                return "p5a_to_h(" . to_list($items, $level, "array") . ")"
            }
            $interpolate ? ("p5list_to_a([" . join(", ", map($_->emit_javascript2($level, $wantarray), @{$items})) . "])") : ("[" . join(", ", map($_->emit_javascript2($level, $wantarray), @{$items})) . "]")
        }
        sub Perlito5::JavaScript2::to_list_preprocess {
            my @items;
            for my $item (@{$_[0]}) {
                if ($item->isa("Perlito5::AST::Apply") && ($item->code() eq "circumfix:<( )>" || $item->code() eq "list:<,>" || $item->code() eq "infix:<=>>")) {
                    if ($item->isa("Perlito5::AST::Apply") && $item->code() eq "infix:<=>>") {;
                        $item->{"arguments"}->[0] = Perlito5::AST::Lookup::->autoquote($item->{"arguments"}->[0])
                    }
                    for my $arg (@{to_list_preprocess($item->arguments())}) {;
                        push(@items, $arg)
                    }
                }
                else {;
                    push(@items, $item)
                }
            }
            return \@items
        }
        sub Perlito5::JavaScript2::to_scalar {
            my $items = to_scalar_preprocess($_[0]);
            my $level = $_[1];
            my $wantarray = "scalar";
            @{$items} ? "(" . join(", ", map($_->emit_javascript2($level, $wantarray), @{$items})) . ")" : "null"
        }
        sub Perlito5::JavaScript2::to_scalar_preprocess {
            my @items;
            for my $item (@{$_[0]}) {
                if ($item->isa("Perlito5::AST::Apply") && ($item->code() eq "list:<,>" || $item->code() eq "infix:<=>>")) {
                    if ($item->isa("Perlito5::AST::Apply") && $item->code() eq "infix:<=>>") {;
                        $item->{"arguments"}->[0] = Perlito5::AST::Lookup::->autoquote($item->{"arguments"}->[0])
                    }
                    for my $arg (@{to_scalar_preprocess($item->arguments())}) {;
                        push(@items, $arg)
                    }
                }
                else {;
                    push(@items, $item)
                }
            }
            return \@items
        }
        sub Perlito5::JavaScript2::to_runtime_context {
            my $items = to_scalar_preprocess($_[0]);
            my $level = $_[1];
            my $wantarray = "runtime";
            @{$items} == 1 && is_scalar($items->[0]) && return $items->[0]->emit_javascript2($level, $wantarray);
            "p5context(" . "[" . join(", ", map($_->emit_javascript2($level, $wantarray), @{$items})) . "]" . ", p5want)"
        }
        sub Perlito5::JavaScript2::to_context {
            my $wantarray = shift;
            $wantarray eq "list" ? 1 : $wantarray eq "scalar" ? 0 : $wantarray eq "void" ? "null" : "p5want"
        }
        sub Perlito5::JavaScript2::autoquote {
            my $index = shift;
            my $level = shift;
            $index = Perlito5::AST::Lookup::->autoquote($index);
            return to_str($index, $level)
        }
        sub Perlito5::JavaScript2::emit_javascript2_autovivify {
            my $obj = shift;
            my $level = shift;
            my $type = shift;
            if ($obj->isa("Perlito5::AST::Index") || $obj->isa("Perlito5::AST::Lookup") || $obj->isa("Perlito5::AST::Call")) {;
                return $obj->emit_javascript2($level, 0, $type)
            }
            if ($obj->isa("Perlito5::AST::Apply") && $obj->code() eq "prefix:<\$>") {
                my $arg = $obj->{"arguments"}->[0];
                return "p5scalar_deref(" . $arg->emit_javascript2($level) . ", " . Perlito5::JavaScript2::escape_string($Perlito5::PKG_NAME) . ", " . Perlito5::JavaScript2::escape_string($type) . ")"
            }
            if ($obj->isa("Perlito5::AST::Apply")) {;
                return $obj->emit_javascript2($level)
            }
            if ($obj->isa("Perlito5::AST::Buf")) {;
                return $obj->emit_javascript2($level)
            }
            "(" . $obj->emit_javascript2($level) . " || (" . $obj->emit_javascript2($level) . " = " . ($type eq "array" ? "new p5ArrayRef([])" : $type eq "hash" ? "new p5HashRef({})" : "new p5ScalarRef(null)") . ")" . ")"
        }
        sub Perlito5::JavaScript2::emit_javascript2_list_with_tabs {
            (my($level), my($argument)) = @_;
            my $tab = Perlito5::JavaScript2::tab($level);
            return map {;
                ref($_) eq "ARRAY" ? emit_javascript2_list_with_tabs($level + 1, $_) : $tab . $_
            } @{$argument}
        }
        sub Perlito5::JavaScript2::emit_func_javascript2 {
            (my($level), my($wantarray), my(@argument)) = @_;
            return join("
", "function () {", emit_javascript2_list_with_tabs($level, [\@argument, "}"]))
        }
        sub Perlito5::JavaScript2::emit_wrap_javascript2 {
            (my($level), my($wantarray), my(@argument)) = @_;
            return join("
", "(function () {", emit_javascript2_list_with_tabs($level, [\@argument, "})()"]))
        }
        sub Perlito5::JavaScript2::emit_function_javascript2 {
            (my($level), my($wantarray), my($argument)) = @_;
            if ($argument->isa("Perlito5::AST::Apply") && ($argument->code() eq "return" || $argument->code() eq "last" || $argument->code() eq "next" || $argument->code() eq "redo")) {;
                emit_func_javascript2($level, $wantarray, $argument->emit_javascript2($level, $wantarray))
            }
            else {;
                emit_func_javascript2($level, $wantarray, "return " . $argument->emit_javascript2($level + 1, $wantarray))
            }
        }
        sub Perlito5::JavaScript2::emit_wrap_statement_javascript2 {
            (my($level), my($wantarray), my($argument)) = @_;
            if ($wantarray eq "void") {;
                return $argument
            }
            emit_wrap_javascript2($level, $wantarray, $argument)
        }
    }
    package Perlito5::JavaScript2::LexicalBlock;
    {
        sub Perlito5::JavaScript2::LexicalBlock::new {
            my $class = shift;
            bless({@_, }, $class)
        }
        sub Perlito5::JavaScript2::LexicalBlock::block {;
            $_[0]->{"block"}
        }
        sub Perlito5::JavaScript2::LexicalBlock::has_decl {
            my $self = $_[0];
            my $type = $_[1];
            for my $decl (@{$self->{"block"}}) {;
                (grep {;
                    $_->{"decl"} eq $type
                } $decl->emit_javascript2_get_decl()) && return 1
            }
            return 0
        }
        sub Perlito5::JavaScript2::LexicalBlock::emit_javascript2_subroutine_body {
            (my($self), my($level), my($wantarray)) = @_;
            $self->{"top_level"} = 1;
            my $outer_throw = $Perlito5::THROW;
            $Perlito5::THROW = 0;
            my $s = $self->emit_javascript2($level, $wantarray);
            $Perlito5::THROW = $outer_throw;
            return $s
        }
        sub Perlito5::JavaScript2::LexicalBlock::emit_javascript2 {
            (my($self), my($level), my($wantarray)) = @_;
            my $original_level = $level;
            my @block;
            for my $stmt (@{$self->{"block"}}) {;
                if (defined($stmt)) {;
                    push(@block, $stmt)
                }
            }
            if (!@block) {
                $wantarray eq "list" && return "return []";
                $wantarray eq "scalar" && return "return null";
                $wantarray eq "runtime" && return "return p5want ? [] : null";
                return "null;"
            }
            my @str;
            my $has_local = $self->has_decl("local");
            my $has_regex = 0;
            if (grep {;
                $_->emit_javascript2_has_regex()
            } @block) {
                $has_local = 1;
                $has_regex = 1
            }
            my $create_context = $self->{"create_context"} && $self->has_decl("my");
            my $outer_pkg = $Perlito5::PKG_NAME;
            if ($self->{"top_level"} || $create_context) {;
                $level++
            }
            my $last_statement;
            if ($wantarray ne "void") {;
                $last_statement = pop(@block)
            }
            for my $decl (@block) {
                if (ref($decl) eq "Perlito5::AST::Apply" && $decl->code() eq "package") {;
                    $Perlito5::PKG_NAME = $decl->{"namespace"}
                }
                my @var_decl = $decl->emit_javascript2_get_decl();
                for my $arg (@var_decl) {;
                    push(@str, $arg->emit_javascript2_init($level, $wantarray))
                }
                if (!($decl->isa("Perlito5::AST::Decl") && $decl->decl() eq "my")) {;
                    push(@str, $decl->emit_javascript2($level, "void") . ";")
                }
            }
            if ($last_statement) {
                my @var_decl = $last_statement->emit_javascript2_get_decl();
                for my $arg (@var_decl) {;
                    push(@str, $arg->emit_javascript2_init($level, $wantarray))
                }
                if ($last_statement->isa("Perlito5::AST::Apply") && $last_statement->code() eq "return" && $self->{"top_level"} && @{$last_statement->{"arguments"}}) {;
                    $last_statement = $last_statement->{"arguments"}->[0]
                }
                if ($last_statement->isa("Perlito5::AST::For") || $last_statement->isa("Perlito5::AST::While") || $last_statement->isa("Perlito5::AST::If") || $last_statement->isa("Perlito5::AST::Block") || $last_statement->isa("Perlito5::AST::Apply") && $last_statement->code() eq "goto" || $last_statement->isa("Perlito5::AST::Apply") && $last_statement->code() eq "return") {;
                    push(@str, $last_statement->emit_javascript2($level, $wantarray))
                }
                elsif ($has_local) {;
                    push(@str, "return p5cleanup_local(local_idx, (" . ($wantarray eq "runtime" ? Perlito5::JavaScript2::to_runtime_context([$last_statement], $level + 1) : $wantarray eq "scalar" ? Perlito5::JavaScript2::to_scalar([$last_statement], $level + 1) : $last_statement->emit_javascript2($level, $wantarray)) . "));")
                }
                else {;
                    push(@str, "return (" . ($wantarray eq "runtime" ? Perlito5::JavaScript2::to_runtime_context([$last_statement], $level + 1) : $wantarray eq "scalar" ? Perlito5::JavaScript2::to_scalar([$last_statement], $level + 1) : $last_statement->emit_javascript2($level, $wantarray)) . ");")
                }
            }
            if ($has_local) {
                unshift(@str, ("var local_idx = p5LOCAL.length;", ($has_regex ? ("var regex_tmp = p5_regex_capture;", "p5LOCAL.push(function(){ p5_regex_capture = regex_tmp });") : ())));
                push(@str, "p5cleanup_local(local_idx, null);")
            }
            my $out;
            if ($self->{"top_level"} && $Perlito5::THROW) {
                $level = $original_level;
                my $tab = "
" . Perlito5::JavaScript2::tab($level + 1);
                $out = "try {" . $tab . join($tab, @str) . "
" . Perlito5::JavaScript2::tab($level) . "}" . "
" . Perlito5::JavaScript2::tab($level) . "catch(err) {" . "
" . Perlito5::JavaScript2::tab($level + 1) . "if ( err instanceof Error ) {" . "
" . Perlito5::JavaScript2::tab($level + 2) . "throw(err);" . "
" . Perlito5::JavaScript2::tab($level + 1) . "}" . "
" . Perlito5::JavaScript2::tab($level + 1) . "else {" . "
" . Perlito5::JavaScript2::tab($level + 2) . ($has_local ? "return p5cleanup_local(local_idx, err)" : "return(err)") . ";
" . Perlito5::JavaScript2::tab($level + 1) . "}" . "
" . Perlito5::JavaScript2::tab($level) . "}"
            }
            elsif ($create_context) {
                $level = $original_level;
                my $tab = "
" . Perlito5::JavaScript2::tab($level + 1);
                $out = "(function () {" . $tab . join($tab, @str) . "
" . Perlito5::JavaScript2::tab($level) . "})();"
            }
            else {
                $level = $original_level;
                my $tab = "
" . Perlito5::JavaScript2::tab($level);
                $out = join($tab, @str)
            }
            $Perlito5::PKG_NAME = $outer_pkg;
            return $out
        }
        sub Perlito5::JavaScript2::LexicalBlock::emit_javascript2_has_regex {;
            ()
        }
    }
    package Perlito5::AST::CompUnit;
    {
        sub Perlito5::AST::CompUnit::emit_javascript2 {
            (my($self), my($level), my($wantarray)) = @_;
            return Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, Perlito5::JavaScript2::LexicalBlock::->new("block", $self->{"body"})->emit_javascript2($level + 1, $wantarray)) . ";"
        }
        sub Perlito5::AST::CompUnit::emit_javascript2_program {
            (my($comp_units), my(%options)) = @_;
            $Perlito5::PKG_NAME = "main";
            my $level = 0;
            my $wantarray = "void";
            my $str;
            $str .= Perlito5::Compiler::do_not_edit("//");
            if ($options{"expand_use"}) {
                $str .= Perlito5::JavaScript2::Runtime::->emit_javascript2();
                $str .= Perlito5::JavaScript2::Array::->emit_javascript2();
                $str .= Perlito5::JavaScript2::CORE::->emit_javascript2();
                $str .= Perlito5::JavaScript2::IO::->emit_javascript2();
                $str .= Perlito5::JavaScript2::Sprintf::->emit_javascript2()
            }
            $str .= "var p5want;
" . "var List__ = [];
";
            for my $comp_unit (@{$comp_units}) {;
                $str = $str . $comp_unit->emit_javascript2($level, $wantarray) . ";
"
            }
            return $str
        }
        sub Perlito5::AST::CompUnit::emit_javascript2_get_decl {;
            ()
        }
        sub Perlito5::AST::CompUnit::emit_javascript2_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Int;
    {
        sub Perlito5::AST::Int::emit_javascript2 {
            (my($self), my($level), my($wantarray)) = @_;
            $self->{"int"}
        }
        sub Perlito5::AST::Int::emit_javascript2_get_decl {;
            ()
        }
        sub Perlito5::AST::Int::emit_javascript2_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Num;
    {
        sub Perlito5::AST::Num::emit_javascript2 {
            (my($self), my($level), my($wantarray)) = @_;
            $self->{"num"}
        }
        sub Perlito5::AST::Num::emit_javascript2_get_decl {;
            ()
        }
        sub Perlito5::AST::Num::emit_javascript2_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Buf;
    {
        sub Perlito5::AST::Buf::emit_javascript2 {
            (my($self), my($level), my($wantarray)) = @_;
            Perlito5::JavaScript2::escape_string($self->{"buf"})
        }
        sub Perlito5::AST::Buf::emit_javascript2_get_decl {;
            ()
        }
        sub Perlito5::AST::Buf::emit_javascript2_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Block;
    {
        sub Perlito5::AST::Block::emit_javascript2 {
            (my($self), my($level), my($wantarray)) = @_;
            my $body;
            if ($wantarray ne "void") {;
                $body = Perlito5::JavaScript2::LexicalBlock::->new("block", $self->{"stmts"})
            }
            else {;
                $body = Perlito5::JavaScript2::LexicalBlock::->new("block", $self->{"stmts"})
            }
            my $init = '';
            if ($self->{"name"} eq "INIT") {
                my $tmp = "p5pkg.main." . Perlito5::JavaScript2::get_label();
                $init = Perlito5::JavaScript2::tab($level + 2) . "if (" . $tmp . ") { return }; " . $tmp . " = 1;
"
            }
            return ($wantarray ne "void" ? "return " : '') . "p5block(" . "function (v) {}, " . "function () {
" . $init . Perlito5::JavaScript2::tab($level + 2) . $body->emit_javascript2($level + 2, $wantarray) . "
" . Perlito5::JavaScript2::tab($level + 1) . "}, " . "[0], " . $self->emit_javascript2_continue($level, $wantarray) . ", " . Perlito5::JavaScript2::escape_string($self->{"label"} || '') . "
" . Perlito5::JavaScript2::tab($level) . ")"
        }
        sub Perlito5::AST::Block::emit_javascript2_continue {
            my $self = shift;
            my $level = shift;
            my $wantarray = shift;
            if (!$self->{"continue"} || !@{$self->{"continue"}->{"stmts"}}) {;
                return "false"
            }
            return "function () {
" . (Perlito5::JavaScript2::LexicalBlock::->new("block", $self->{"continue"}->stmts()))->emit_javascript2($level + 2, $wantarray) . "
" . Perlito5::JavaScript2::tab($level + 1) . "}"
        }
        sub Perlito5::AST::Block::emit_javascript2_get_decl {;
            ()
        }
        sub Perlito5::AST::Block::emit_javascript2_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Index;
    {
        sub Perlito5::AST::Index::emit_javascript2 {
            (my($self), my($level), my($wantarray), my($autovivification_type)) = @_;
            my $method = $autovivification_type || "p5aget";
            $autovivification_type eq "array" && ($method = "p5aget_array");
            $autovivification_type eq "hash" && ($method = "p5aget_hash");
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\@>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->sigil() eq "\@") || ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->code() eq "circumfix:<( )>")) {;
                return "p5list_slice(" . $self->{"obj"}->emit_javascript2($level, "list") . ", " . Perlito5::JavaScript2::to_list([$self->{"index_exp"}], $level) . ", " . Perlito5::JavaScript2::to_context($wantarray) . ")"
            }
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<%>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->sigil() eq "%")) {
                my $obj = $self->{"obj"};
                $obj->{"sigil"} eq "%" && ($obj->{"sigil"} = "\@");
                $obj->{"code"} eq "prefix:<%>" && ($obj->{"code"} = "prefix:<\@>");
                return "p5hash_slice(" . $self->{"obj"}->emit_javascript2($level, "list") . ", " . Perlito5::JavaScript2::to_list([$self->{"index_exp"}], $level) . ", " . Perlito5::JavaScript2::to_context($wantarray) . ")"
            }
            return $self->emit_javascript2_container($level) . "." . $method . "(" . Perlito5::JavaScript2::to_num($self->{"index_exp"}, $level) . ")"
        }
        sub Perlito5::AST::Index::emit_javascript2_set {
            (my($self), my($arguments), my($level), my($wantarray)) = @_;
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\@>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->sigil() eq "\@")) {;
                return Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, "var a = [];", "var v = " . Perlito5::JavaScript2::to_list([$self->{"index_exp"}], $level) . ";", "var src=" . Perlito5::JavaScript2::to_list([$arguments], $level) . ";", "var out=" . Perlito5::JavaScript2::emit_javascript2_autovivify($self->{"obj"}, $level, "array") . ";", "var tmp" . ";", "for (var i=0, l=v.length; i<l; ++i) {", ["tmp = src.p5aget(i);", "out.p5aset(v[i], tmp);", "a.push(tmp)"], "}", "return a")
            }
            return $self->emit_javascript2_container($level) . ".p5aset(" . Perlito5::JavaScript2::to_num($self->{"index_exp"}, $level + 1) . ", " . Perlito5::JavaScript2::to_scalar([$arguments], $level + 1) . ")"
        }
        sub Perlito5::AST::Index::emit_javascript2_set_list {
            (my($self), my($level), my($list)) = @_;
            my $wantarray = "list";
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\@>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->sigil() eq "\@")) {;
                return Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, "var a = [];", "var v = " . Perlito5::JavaScript2::to_list([$self->{"index_exp"}], $level) . ";", "var out=" . Perlito5::JavaScript2::emit_javascript2_autovivify($self->{"obj"}, $level, "array") . ";", "var tmp" . ";", "for (var i=0, l=v.length; i<l; ++i) {", ["tmp = " . $list . ".shift();", "out.p5aset(v[i], tmp);", "a.push(tmp)"], "}", "return a")
            }
            return $self->emit_javascript2_container($level) . ".p5aset(" . Perlito5::JavaScript2::to_num($self->{"index_exp"}, $level + 1) . ", " . $list . ".shift()" . ")"
        }
        sub Perlito5::AST::Index::emit_javascript2_container {
            my $self = shift;
            my $level = shift;
            if ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\$>") {
                my $v = Perlito5::AST::Apply::->new(%{$self->{"obj"}}, "code", "prefix:<\@>");
                return $v->emit_javascript2($level)
            }
            if ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->code() eq "circumfix:<( )>") {;
                return Perlito5::JavaScript2::to_list([$self->{"obj"}], $level)
            }
            if ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->sigil() eq "\$") {
                $self->{"obj"}->{"sigil"} = "\@";
                return $self->{"obj"}->emit_javascript2($level)
            }
            else {;
                return Perlito5::JavaScript2::emit_javascript2_autovivify($self->{"obj"}, $level, "array") . "._array_"
            }
        }
        sub Perlito5::AST::Index::emit_javascript2_get_decl {;
            ()
        }
        sub Perlito5::AST::Index::emit_javascript2_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Lookup;
    {
        sub Perlito5::AST::Lookup::emit_javascript2 {
            (my($self), my($level), my($wantarray), my($autovivification_type)) = @_;
            my $method = $autovivification_type || "p5hget";
            $autovivification_type eq "array" && ($method = "p5hget_array");
            $autovivification_type eq "hash" && ($method = "p5hget_hash");
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\@>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->sigil() eq "\@")) {
                my $v;
                if ($self->{"obj"}->isa("Perlito5::AST::Var")) {;
                    $v = $self->{"obj"}
                }
                $self->{"obj"}->isa("Perlito5::AST::Apply") && ($v = Perlito5::AST::Apply::->new("code", "prefix:<%>", "namespace", $self->{"obj"}->namespace(), "arguments", $self->{"obj"}->arguments()));
                return "p5list_lookup_slice(" . $v->emit_javascript2($level, "list") . ", " . Perlito5::JavaScript2::to_list([$self->{"index_exp"}], $level) . ", " . Perlito5::JavaScript2::to_context($wantarray) . ")"
            }
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<%>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->sigil() eq "%")) {
                my $v;
                if ($self->{"obj"}->isa("Perlito5::AST::Var")) {;
                    $v = $self->{"obj"}
                }
                $self->{"obj"}->isa("Perlito5::AST::Apply") && ($v = Perlito5::AST::Apply::->new("code", "prefix:<%>", "namespace", $self->{"obj"}->namespace(), "arguments", $self->{"obj"}->arguments()));
                return "p5hash_lookup_slice(" . $v->emit_javascript2($level, "list") . ", " . Perlito5::JavaScript2::to_list([$self->{"index_exp"}], $level) . ", " . Perlito5::JavaScript2::to_context($wantarray) . ")"
            }
            return $self->emit_javascript2_container($level) . "." . $method . "(" . Perlito5::JavaScript2::autoquote($self->{"index_exp"}, $level) . ")"
        }
        sub Perlito5::AST::Lookup::emit_javascript2_set {
            (my($self), my($arguments), my($level), my($wantarray)) = @_;
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\@>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->sigil() eq "\@")) {
                my $v;
                $self->{"obj"}->isa("Perlito5::AST::Var") && ($v = $self->{"obj"});
                $self->{"obj"}->isa("Perlito5::AST::Apply") && ($v = Perlito5::AST::Apply::->new("code", "prefix:<%>", "namespace", $self->{"obj"}->namespace(), "arguments", $self->{"obj"}->arguments()));
                return Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, "var a = [];", "var v = " . Perlito5::JavaScript2::to_list([$self->{"index_exp"}], $level) . ";", "var src=" . Perlito5::JavaScript2::to_list([$arguments], $level) . ";", "var out=" . $v->emit_javascript2($level) . ";", "var tmp" . ";", "for (var i=0, l=v.length; i<l; ++i)" . "{", ["tmp = src.p5hget(i);", "out.p5hset(v[i], tmp);", "a.push(tmp)"], "}", "return a")
            }
            return $self->emit_javascript2_container($level) . ".p5hset(" . Perlito5::JavaScript2::autoquote($self->{"index_exp"}, $level) . ", " . Perlito5::JavaScript2::to_scalar([$arguments], $level + 1) . ")"
        }
        sub Perlito5::AST::Lookup::emit_javascript2_set_list {
            (my($self), my($level), my($list)) = @_;
            my $wantarray = "list";
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\@>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->sigil() eq "\@")) {
                my $v;
                $self->{"obj"}->isa("Perlito5::AST::Var") && ($v = $self->{"obj"});
                $self->{"obj"}->isa("Perlito5::AST::Apply") && ($v = Perlito5::AST::Apply::->new("code", "prefix:<%>", "namespace", $self->{"obj"}->namespace(), "arguments", $self->{"obj"}->arguments()));
                return Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, "var a = [];", "var v = " . Perlito5::JavaScript2::to_list([$self->{"index_exp"}], $level) . ";", "var out=" . $v->emit_javascript2($level) . ";", "var tmp" . ";", "for (var i=0, l=v.length; i<l; ++i)" . "{", ["tmp = " . $list . ".shift();", "out.p5hset(v[i], tmp);", "a.push(tmp)"], "}", "return a")
            }
            return $self->emit_javascript2_container($level) . ".p5hset(" . Perlito5::JavaScript2::autoquote($self->{"index_exp"}, $level) . ", " . $list . ".shift()" . ")"
        }
        sub Perlito5::AST::Lookup::emit_javascript2_container {
            my $self = shift;
            my $level = shift;
            if ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\$>") {
                my $v = Perlito5::AST::Apply::->new(%{$self->{"obj"}}, "code", "prefix:<%>");
                return $v->emit_javascript2($level)
            }
            if ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->sigil() eq "\$") {
                my $v = Perlito5::AST::Var::->new(%{$self->{"obj"}}, "sigil", "%");
                return $v->emit_javascript2($level)
            }
            else {;
                return Perlito5::JavaScript2::emit_javascript2_autovivify($self->{"obj"}, $level, "hash") . "._hash_"
            }
        }
        sub Perlito5::AST::Lookup::emit_javascript2_get_decl {;
            ()
        }
        sub Perlito5::AST::Lookup::emit_javascript2_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Var;
    {
        my $table = {"\$", "v_", "\@", "List_", "%", "Hash_", "&", ''};
        sub Perlito5::AST::Var::emit_javascript2_global {
            (my($self), my($level), my($wantarray)) = @_;
            my $str_name = $self->{"name"};
            my $sigil = $self->{"_real_sigil"} || $self->{"sigil"};
            my $namespace = $self->{"namespace"} || $self->{"_namespace"};
            if ($sigil eq "\@" && $self->{"name"} eq "_" && $namespace eq "main") {
                my $s = "List__";
                if ($self->{"sigil"} eq "\$#") {;
                    return "(" . $s . ".length - 1)"
                }
                if ($wantarray eq "scalar") {;
                    return $s . ".length"
                }
                if ($wantarray eq "runtime") {;
                    return "(p5want" . " ? " . $s . " : " . $s . ".length" . ")"
                }
                return $s
            }
            if ($sigil eq "\$" && $self->{"name"} > 0) {;
                return "p5_regex_capture[" . ($self->{"name"} - 1) . "]"
            }
            if ($sigil eq "::") {
                $self->{"namespace"} eq "__PACKAGE__" && return Perlito5::JavaScript2::pkg();
                $self->{"namespace"} eq "__SUB__" && return $Perlito5::AST::Sub::SUB_REF // "__SUB__";
                return Perlito5::JavaScript2::escape_string($namespace)
            }
            my $s = "p5make_package(" . Perlito5::JavaScript2::escape_string($namespace) . ")[" . Perlito5::JavaScript2::escape_string($table->{$sigil} . $str_name) . "]";
            if ($sigil eq "*") {;
                return $s
            }
            if ($sigil eq "&") {;
                return $s . "(List__, " . Perlito5::JavaScript2::to_context($wantarray) . ")"
            }
            if ($sigil eq "\@") {
                $s = $s . " || (" . $s . " = [])";
                $s = "p5pkg[" . $s . ", " . Perlito5::JavaScript2::escape_string($namespace) . "][" . Perlito5::JavaScript2::escape_string($table->{$sigil} . $str_name) . "]";
                if ($self->{"sigil"} eq "\$#") {;
                    return "(" . $s . ".length - 1)"
                }
                if ($wantarray eq "scalar") {;
                    return $s . ".length"
                }
            }
            elsif ($sigil eq "%") {
                $s = $s . " || (" . $s . " = {})";
                $s = "p5pkg[" . $s . ", " . Perlito5::JavaScript2::escape_string($namespace) . "][" . Perlito5::JavaScript2::escape_string($table->{$sigil} . $str_name) . "]"
            }
            return $s
        }
        sub Perlito5::AST::Var::emit_javascript2 {
            (my($self), my($level), my($wantarray)) = @_;
            my $sigil = $self->{"_real_sigil"} || $self->{"sigil"};
            my $decl_type = $self->{"_decl"} || "global";
            if ($decl_type ne "my" && $decl_type ne "state") {;
                return $self->emit_javascript2_global($level, $wantarray)
            }
            my $str_name = $self->{"name"} . "_" . $self->{"_id"};
            if ($sigil eq "\@") {
                if ($wantarray eq "scalar") {;
                    return $self->emit_javascript2($level, "list") . ".length"
                }
                if ($wantarray eq "runtime") {;
                    return "(p5want" . " ? " . $self->emit_javascript2($level, "list") . " : " . $self->emit_javascript2($level, "list") . ".length" . ")"
                }
            }
            if ($self->{"sigil"} eq "\$#") {;
                return "(" . $table->{"\@"} . $str_name . ".length - 1)"
            }
            $table->{$sigil} . $str_name
        }
        sub Perlito5::AST::Var::emit_javascript2_set {
            (my($self), my($arguments), my($level), my($wantarray)) = @_;
            my $open = $wantarray eq "void" ? '' : "(";
            my $close = $wantarray eq "void" ? '' : ")";
            my $sigil = $self->{"_real_sigil"} || $self->{"sigil"};
            if ($sigil eq "\$") {;
                return $open . $self->emit_javascript2() . " = " . Perlito5::JavaScript2::to_scalar([$arguments], $level + 1) . $close
            }
            if ($sigil eq "\@") {
                if ($self->{"sigil"} eq "\$#") {
                    $self->{"sigil"} = "\@";
                    return $open . $self->emit_javascript2() . ".length = 1 + " . Perlito5::JavaScript2::to_scalar([$arguments], $level + 1) . $close
                }
                return $open . $self->emit_javascript2() . " = " . Perlito5::JavaScript2::to_list([$arguments], $level + 1) . $close
            }
            if ($sigil eq "%") {;
                return $open . $self->emit_javascript2() . " = " . Perlito5::JavaScript2::to_list([$arguments], $level + 1, "hash") . $close
            }
            if ($sigil eq "*") {
                my $namespace = $self->{"namespace"} || $self->{"_namespace"};
                return "p5typeglob_set(" . Perlito5::JavaScript2::escape_string($namespace) . ", " . Perlito5::JavaScript2::escape_string($self->{"name"}) . ", " . Perlito5::JavaScript2::to_scalar([$arguments], $level + 1) . ")"
            }
            die("don't know how to assign to variable ", $sigil, $self->name())
        }
        sub Perlito5::AST::Var::emit_javascript2_set_list {
            (my($self), my($level), my($list)) = @_;
            my $sigil = $self->{"_real_sigil"} || $self->{"sigil"};
            if ($sigil eq "\$") {;
                return $self->emit_javascript2() . " = " . $list . ".shift()"
            }
            if ($sigil eq "\@") {;
                return join(";
" . Perlito5::JavaScript2::tab($level), $self->emit_javascript2() . " = " . $list, $list . " = []")
            }
            if ($sigil eq "%") {;
                return join(";
" . Perlito5::JavaScript2::tab($level), $self->emit_javascript2() . " = p5a_to_h(" . $list . ")", $list . " = []")
            }
            die("don't know how to assign to variable ", $sigil, $self->name())
        }
        sub Perlito5::AST::Var::emit_javascript2_get_decl {;
            ()
        }
        sub Perlito5::AST::Var::emit_javascript2_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Decl;
    {
        sub Perlito5::AST::Decl::emit_javascript2 {
            (my($self), my($level), my($wantarray)) = @_;
            $self->{"var"}->emit_javascript2($level)
        }
        sub Perlito5::AST::Decl::emit_javascript2_init {
            (my($self), my($level), my($wantarray)) = @_;
            if ($self->{"decl"} eq "local") {
                my $var = $self->{"var"};
                my $var_set;
                my $tmp_name = Perlito5::JavaScript2::get_label();
                my $id = $Perlito5::ID++;
                my $tmp = Perlito5::AST::Var::->new("sigil", "\$", "name", $tmp_name, "_decl", "my", "_id", $id);
                if (ref($var) eq "Perlito5::AST::Var") {;
                    $var_set = $var->emit_javascript2() . " = " . $tmp->emit_javascript2()
                }
                else {;
                    $var_set = $var->emit_javascript2_set($tmp)
                }
                return Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, "var " . $tmp->emit_javascript2() . " = " . $var->emit_javascript2() . ";", "p5LOCAL.push(function(){ " . $var_set . " });", "return " . $var->emit_javascript2_set(Perlito5::AST::Apply::->new("code", "undef", "arguments", [], "namespace", ''), $level + 1) . ";") . ";"
            }
            if ($self->{"decl"} eq "my" || $self->{"decl"} eq "state") {
                my $str = "var " . $self->{"var"}->emit_javascript2();
                if ($self->{"var"}->sigil() eq "%") {;
                    $str = $str . " = {};"
                }
                elsif ($self->{"var"}->sigil() eq "\@") {;
                    $str = $str . " = [];"
                }
                else {;
                    $str = $str . ";"
                }
                return $str
            }
            elsif ($self->{"decl"} eq "our") {
                my $str = $self->{"var"}->emit_javascript2();
                if ($self->{"var"}->sigil() eq "%") {;
                    $str = $str . " = {};"
                }
                elsif ($self->{"var"}->sigil() eq "\@") {;
                    $str = $str . " = [];"
                }
                else {;
                    return "// our " . $str
                }
                return "if (typeof " . $self->{"var"}->emit_javascript2() . " == \"undefined\" ) { " . $str . "}"
            }
            else {;
                die("not implemented: Perlito5::AST::Decl '" . $self->{"decl"} . "'")
            }
        }
        sub Perlito5::AST::Decl::emit_javascript2_set {
            (my($self), my($arguments), my($level), my($wantarray)) = @_;
            $self->var()->emit_javascript2_set($arguments, $level, $wantarray)
        }
        sub Perlito5::AST::Decl::emit_javascript2_set_list {
            (my($self), my($level), my($list)) = @_;
            $self->var()->emit_javascript2_set_list($level, $list)
        }
        sub Perlito5::AST::Decl::emit_javascript2_get_decl {
            my $self = shift;
            return ($self)
        }
        sub Perlito5::AST::Decl::emit_javascript2_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Call;
    {
        sub Perlito5::AST::Call::emit_javascript2 {
            (my($self), my($level), my($wantarray), my($autovivification_type)) = @_;
            my $meth = $self->{"method"};
            if ($meth eq "postcircumfix:<[ ]>") {
                my $method = $autovivification_type || "p5aget";
                $autovivification_type eq "array" && ($method = "p5aget_array");
                $autovivification_type eq "hash" && ($method = "p5aget_hash");
                return Perlito5::JavaScript2::emit_javascript2_autovivify($self->{"invocant"}, $level, "array") . "._array_." . $method . "(" . Perlito5::JavaScript2::to_num($self->{"arguments"}, $level + 1) . ")"
            }
            if ($meth eq "postcircumfix:<{ }>") {
                my $method = $autovivification_type || "p5hget";
                $autovivification_type eq "array" && ($method = "p5hget_array");
                $autovivification_type eq "hash" && ($method = "p5hget_hash");
                return Perlito5::JavaScript2::emit_javascript2_autovivify($self->{"invocant"}, $level, "hash") . "._hash_." . $method . "(" . Perlito5::JavaScript2::autoquote($self->{"arguments"}, $level + 1, "list") . ")"
            }
            if ($meth eq "postcircumfix:<( )>") {
                my $invocant = $self->{"invocant"}->emit_javascript2($level, "scalar");
                return "(" . $invocant . ")(" . Perlito5::JavaScript2::to_list($self->{"arguments"}) . ", " . Perlito5::JavaScript2::to_context($wantarray) . ")"
            }
            my $invocant = $self->{"invocant"}->emit_javascript2($level, "scalar");
            if (ref($meth) eq "Perlito5::AST::Var") {;
                $meth = $meth->emit_javascript2($level, "scalar")
            }
            else {;
                $meth = Perlito5::JavaScript2::escape_string($meth)
            }
            return "p5call(" . $invocant . ", " . $meth . ", " . Perlito5::JavaScript2::to_list($self->{"arguments"}) . ", " . Perlito5::JavaScript2::to_context($wantarray) . ")"
        }
        sub Perlito5::AST::Call::emit_javascript2_set {
            (my($self), my($arguments), my($level), my($wantarray)) = @_;
            if ($self->{"method"} eq "postcircumfix:<[ ]>") {;
                return Perlito5::JavaScript2::emit_javascript2_autovivify($self->{"invocant"}, $level, "array") . "._array_.p5aset(" . Perlito5::JavaScript2::to_num($self->{"arguments"}, $level + 1) . ", " . Perlito5::JavaScript2::to_scalar([$arguments], $level + 1) . ")"
            }
            if ($self->{"method"} eq "postcircumfix:<{ }>") {;
                return Perlito5::JavaScript2::emit_javascript2_autovivify($self->{"invocant"}, $level, "hash") . "._hash_.p5hset(" . Perlito5::JavaScript2::autoquote($self->{"arguments"}, $level + 1, "list") . ", " . Perlito5::JavaScript2::to_scalar([$arguments], $level + 1) . ")"
            }
            die("don't know how to assign to method ", $self->{"method"})
        }
        sub Perlito5::AST::Call::emit_javascript2_set_list {
            (my($self), my($level), my($list)) = @_;
            if ($self->{"method"} eq "postcircumfix:<[ ]>") {;
                return Perlito5::JavaScript2::emit_javascript2_autovivify($self->{"invocant"}, $level, "array") . "._array_.p5aset(" . Perlito5::JavaScript2::to_num($self->{"arguments"}, $level + 1) . ", " . $list . ".shift()" . ")"
            }
            if ($self->{"method"} eq "postcircumfix:<{ }>") {;
                return Perlito5::JavaScript2::emit_javascript2_autovivify($self->{"invocant"}, $level, "hash") . "._hash_.p5hset(" . Perlito5::JavaScript2::autoquote($self->{"arguments"}, $level + 1, "list") . ", " . $list . ".shift()" . ")"
            }
            die("don't know how to assign to method ", $self->{"method"})
        }
        sub Perlito5::AST::Call::emit_javascript2_get_decl {;
            ()
        }
        sub Perlito5::AST::Call::emit_javascript2_has_regex {;
            ()
        }
    }
    package Perlito5::AST::If;
    {
        sub Perlito5::AST::If::emit_javascript2 {
            (my($self), my($level), my($wantarray)) = @_;
            my $cond = $self->{"cond"};
            my @str;
            my $old_level = $level;
            if ($cond) {
                my @var_decl = $cond->emit_javascript2_get_decl();
                for my $arg (@var_decl) {
                    $level = $old_level + 1;
                    push(@str, $arg->emit_javascript2_init($level, $wantarray))
                }
            }
            my $body = ref($self->{"body"}) ne "Perlito5::AST::Block" ? $self->{"body"} : (!@{$self->{"body"}->stmts()}) ? undef : $wantarray ne "void" ? Perlito5::JavaScript2::LexicalBlock::->new("block", $self->{"body"}->stmts()) : Perlito5::JavaScript2::LexicalBlock::->new("block", $self->{"body"}->stmts(), "create_context", 1);
            my $otherwise = ref($self->{"otherwise"}) ne "Perlito5::AST::Block" ? $self->{"otherwise"} : (!@{$self->{"otherwise"}->stmts()}) ? undef : $wantarray ne "void" ? Perlito5::JavaScript2::LexicalBlock::->new("block", $self->{"otherwise"}->stmts()) : Perlito5::JavaScript2::LexicalBlock::->new("block", $self->{"otherwise"}->stmts(), "create_context", 1);
            my $s = "if ( " . Perlito5::JavaScript2::to_bool($cond, $level + 1) . " ) {";
            if ($body) {;
                $s = $s . "
" . Perlito5::JavaScript2::tab($level + 1) . $body->emit_javascript2($level + 1, $wantarray) . "
" . Perlito5::JavaScript2::tab($level) . "}"
            }
            else {;
                $s = $s . "}"
            }
            if ($otherwise) {
                if (@{$otherwise->{"block"}} == 1 && ref($otherwise->{"block"}->[0]) eq "Perlito5::AST::If") {;
                    $s = $s . "
" . Perlito5::JavaScript2::tab($level) . "else " . $otherwise->{"block"}->[0]->emit_javascript2($level, $wantarray)
                }
                else {;
                    $s = $s . "
" . Perlito5::JavaScript2::tab($level) . "else {" . "
" . Perlito5::JavaScript2::tab($level + 1) . $otherwise->emit_javascript2($level + 1, $wantarray) . "
" . Perlito5::JavaScript2::tab($level) . "}"
                }
            }
            push(@str, $s);
            if (@str) {
                $level = $old_level;
                return ($wantarray ne "void" ? "return " : '') . Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, @str)
            }
            else {;
                return join("
" . Perlito5::JavaScript2::tab($level), @str)
            }
        }
        sub Perlito5::AST::If::emit_javascript2_get_decl {;
            ()
        }
        sub Perlito5::AST::If::emit_javascript2_has_regex {;
            ()
        }
    }
    package Perlito5::AST::When;
    {
        sub Perlito5::AST::When::emit_javascript2 {
            (my($self), my($level), my($wantarray)) = @_;
            my $cond = $self->{"cond"};
            my @str;
            my $old_level = $level;
            if ($cond) {
                my @var_decl = $cond->emit_javascript2_get_decl();
                for my $arg (@var_decl) {
                    $level = $old_level + 1;
                    push(@str, $arg->emit_javascript2_init($level, $wantarray))
                }
            }
            $cond = Perlito5::AST::Apply::->new("arguments", [Perlito5::AST::Var::SCALAR_ARG(), $cond], "code", "infix:<~~>", "namespace", '');
            my $next = Perlito5::AST::Apply::->new("arguments", [], "bareword", 1, "code", "next", "namespace", '');
            my $body = ref($self->{"body"}) ne "Perlito5::AST::Block" ? Perlito5::JavaScript2::LexicalBlock::->new("block", [$self->{"body"}]) : (!@{$self->{"body"}->stmts()}) ? undef : $wantarray ne "void" ? Perlito5::JavaScript2::LexicalBlock::->new("block", $self->{"body"}->stmts()) : Perlito5::JavaScript2::LexicalBlock::->new("block", $self->{"body"}->stmts(), "create_context", 1);
            push(@{$body->{"block"}}, $next);
            my $s = "if ( " . Perlito5::JavaScript2::to_bool($cond, $level + 1) . " ) {";
            if ($body) {;
                $s = $s . "
" . Perlito5::JavaScript2::tab($level + 1) . $body->emit_javascript2($level + 1, $wantarray) . "
" . Perlito5::JavaScript2::tab($level) . "}"
            }
            else {;
                $s = $s . "}"
            }
            push(@str, $s);
            if (@str) {
                $level = $old_level;
                return ($wantarray ne "void" ? "return " : '') . Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, @str)
            }
            else {;
                return join("
" . Perlito5::JavaScript2::tab($level), @str)
            }
        }
        sub Perlito5::AST::When::emit_javascript2_get_decl {;
            ()
        }
        sub Perlito5::AST::When::emit_javascript2_has_regex {;
            ()
        }
    }
    package Perlito5::AST::While;
    {
        sub Perlito5::AST::While::emit_javascript2 {
            (my($self), my($level), my($wantarray)) = @_;
            my $cond = $self->{"cond"};
            my @str;
            my $old_level = $level;
            if ($cond) {
                my @var_decl = $cond->emit_javascript2_get_decl();
                for my $arg (@var_decl) {
                    $level = $old_level + 1;
                    push(@str, $arg->emit_javascript2_init($level, $wantarray))
                }
            }
            if (ref($self->{"body"}) eq "Perlito5::AST::Apply" && $self->{"body"}->{"code"} eq "do") {;
                push(@str, "do {" . $self->{"body"}->emit_javascript2($level + 2, $wantarray) . "
" . Perlito5::JavaScript2::tab($level + 1) . "} while (" . Perlito5::JavaScript2::to_bool($cond, $level + 2) . ")")
            }
            else {
                my $body = ref($self->{"body"}) ne "Perlito5::AST::Block" ? [$self->{"body"}] : $self->{"body"}->{"stmts"};
                push(@str, "p5while(" . "function () {
" . Perlito5::JavaScript2::tab($level + 2) . (Perlito5::JavaScript2::LexicalBlock::->new("block", $body))->emit_javascript2($level + 2, $wantarray) . "
" . Perlito5::JavaScript2::tab($level + 1) . "}, " . Perlito5::JavaScript2::emit_function_javascript2($level + 1, "scalar", $cond) . ", " . Perlito5::AST::Block::emit_javascript2_continue($self, $level, $wantarray) . ", " . Perlito5::JavaScript2::escape_string($self->{"label"} || '') . ", " . 0 . ")")
            }
            if (@str) {
                $level = $old_level;
                return Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, @str)
            }
            else {;
                return join("
" . Perlito5::JavaScript2::tab($level), @str)
            }
        }
        sub Perlito5::AST::While::emit_javascript2_get_decl {;
            ()
        }
        sub Perlito5::AST::While::emit_javascript2_has_regex {;
            ()
        }
    }
    package Perlito5::AST::For;
    {
        sub Perlito5::AST::For::emit_javascript2 {
            (my($self), my($level), my($wantarray)) = @_;
            my $body = ref($self->{"body"}) ne "Perlito5::AST::Block" ? [$self->{"body"}] : $self->{"body"}->{"stmts"};
            my @str;
            my $old_level = $level;
            my $cond = ref($self->{"cond"}) eq "ARRAY" ? $self->{"cond"} : [$self->{"cond"}];
            for my $expr (@{$cond}, $self->{"topic"}) {;
                if ($expr) {
                    my @var_decl = $expr->emit_javascript2_get_decl();
                    for my $arg (@var_decl) {
                        $level = $old_level + 1;
                        push(@str, $arg->emit_javascript2_init($level, $wantarray))
                    }
                }
            }
            if (ref($self->{"cond"}) eq "ARRAY") {;
                push(@str, Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, "var label = " . Perlito5::JavaScript2::escape_string(($self->{"label"} || '')) . ";", "for ( " . ($self->{"cond"}->[0] ? $self->{"cond"}->[0]->emit_javascript2($level + 1) . "; " : "; ") . ($self->{"cond"}->[1] ? Perlito5::JavaScript2::to_bool($self->{"cond"}->[1], $level + 1) . "; " : "; ") . ($self->{"cond"}->[2] ? $self->{"cond"}->[2]->emit_javascript2($level + 1) . " " : '') . ") {", ["var _redo;", "do {", ["_redo = false;", "try {", [Perlito5::JavaScript2::LexicalBlock::->new("block", $body)->emit_javascript2($level + 4, "void")], "}", "catch(err) {", ["if (err instanceof p5_error && (err.v == label || err.v == '')) {", ["if (err.type == 'last') { return }", "else if (err.type == 'redo') { _redo = true }", "else if (err.type != 'next') { throw(err) }"], "}", "else {", ["throw(err)"], "}"], "}"], "} while (_redo);"], "}"))
            }
            else {
                my $cond = Perlito5::JavaScript2::to_list([$self->{"cond"}], $level + 1);
                my $topic = $self->{"topic"};
                my $decl = '';
                my $v = $topic;
                if ($v->{"decl"}) {
                    $decl = $v->{"decl"};
                    $v = $v->{"var"}
                }
                else {;
                    $decl = $v->{"_decl"} || "global"
                }
                my $namespace = $v->{"namespace"} || $v->{"_namespace"} || $Perlito5::PKG_NAME;
                my $s;
                if ($decl eq "my" || $decl eq "state") {
                    my $sig = $v->emit_javascript2($level + 1);
                    push(@str, "(function(){ " . "var " . $sig . "; " . "p5for_lex(" . "function (v) { " . $sig . " = v }, " . "function () {
" . Perlito5::JavaScript2::tab($level + 2) . (Perlito5::JavaScript2::LexicalBlock::->new("block", $body))->emit_javascript2($level + 2, $wantarray) . "
" . Perlito5::JavaScript2::tab($level + 1) . "}, " . $cond . ", " . Perlito5::AST::Block::emit_javascript2_continue($self, $level, $wantarray) . ", " . Perlito5::JavaScript2::escape_string($self->{"label"} || '') . ") " . "})()")
                }
                else {;
                    push(@str, "p5for(" . "p5make_package(" . Perlito5::JavaScript2::escape_string($namespace) . "), " . "\"v_" . $v->{"name"} . "\", " . "function () {" . "
" . Perlito5::JavaScript2::tab($level + 2) . (Perlito5::JavaScript2::LexicalBlock::->new("block", $body))->emit_javascript2($level + 2, $wantarray) . "
" . Perlito5::JavaScript2::tab($level + 1) . "}, " . $cond . ", " . Perlito5::AST::Block::emit_javascript2_continue($self, $level, $wantarray) . ", " . Perlito5::JavaScript2::escape_string($self->{"label"} || '') . ")")
                }
            }
            if (@str > 1) {
                $level = $old_level;
                return Perlito5::JavaScript2::emit_wrap_javascript2($level, $wantarray, @str)
            }
            else {;
                return join("
" . Perlito5::JavaScript2::tab($level), @str)
            }
        }
        sub Perlito5::AST::For::emit_javascript2_get_decl {;
            ()
        }
        sub Perlito5::AST::For::emit_javascript2_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Sub;
    {
        sub Perlito5::AST::Sub::emit_javascript2 {
            (my($self), my($level), my($wantarray)) = @_;
            if (my $node = $self->maybe_rewrite_statevars()) {;
                return $node->emit_javascript2(@_[1 .. $#_])
            }
            my $prototype = defined($self->{"sig"}) ? Perlito5::JavaScript2::escape_string($self->{"sig"}) : "null";
            my $sub_ref = Perlito5::JavaScript2::get_label();
            local $Perlito5::AST::Sub::SUB_REF = $sub_ref;
            local $Perlito5::JavaScript2::is_inside_subroutine = 1;
            my @captured;
            for my $stmt (@{$self->{"block"}->{"stmts"}}) {;
                push(@captured, $stmt->get_captures())
            }
            my %dont_capture = map {;
                $_->{"dont"} ? ($_->{"dont"}, 1) : ()
            } @captured;
            my %capture = map {;
                $_->{"dont"} ? () : $dont_capture{$_->{"_id"}} ? () : ($_->{"_decl"} eq "local" || $_->{"_decl"} eq "global" || $_->{"_decl"} eq '') ? () : ($_->{"_id"}, $_)
            } @captured;
            my @captures_ast = map {;
                $capture{$_}
            } sort {;
                $a cmp $b
            } keys(%capture);
            local @Perlito5::CAPTURES = @captures_ast;
            my $js_block = Perlito5::JavaScript2::LexicalBlock::->new("block", $self->{"block"}->{"stmts"})->emit_javascript2_subroutine_body($level + 2, "runtime");
            my @s = ("var " . $sub_ref . ";", $sub_ref . " = function (List__, p5want) {", [$js_block], "};", $sub_ref . "._prototype_ = " . $prototype . ";", "return " . $sub_ref);
            if ($self->{"name"}) {
                my $s = Perlito5::JavaScript2::emit_wrap_javascript2($level, "scalar", @s);
                return "p5typeglob_set(" . Perlito5::JavaScript2::escape_string($self->{"namespace"}) . ", " . Perlito5::JavaScript2::escape_string($self->{"name"}) . ", " . $s . ")"
            }
            else {
                my $s = Perlito5::JavaScript2::emit_wrap_javascript2($level, "scalar", @s);
                return $s
            }
        }
        sub Perlito5::AST::Sub::emit_javascript2_get_decl {;
            ()
        }
        sub Perlito5::AST::Sub::emit_javascript2_has_regex {;
            ()
        }
    }
    1
}
{
    package main;
    package Perlito5::JavaScript2::Runtime;
    sub Perlito5::JavaScript2::Runtime::perl5_to_js {
        (my($source), my($namespace), my($want), my($scalar_hints), my($hash_hints), my($scope_js)) = @_;
        local $_;
        local ${^GLOBAL_PHASE};
        local ${^H} = $scalar_hints;
        local %{^H} = %{$hash_hints};
        local $Perlito5::BASE_SCOPE = $scope_js->[0];
        local @Perlito5::SCOPE_STMT;
        local $Perlito5::CLOSURE_SCOPE = $Perlito5::BASE_SCOPE;
        local $Perlito5::SCOPE = $Perlito5::BASE_SCOPE;
        local $Perlito5::SCOPE_DEPTH = 0;
        local $Perlito5::PKG_NAME = $namespace;
        local @Perlito5::UNITCHECK_BLOCK;
        my $match = Perlito5::Grammar::exp_stmts($source, 0);
        if (!$match || $match->{"to"} != length($source)) {;
            die("Syntax error in eval near pos ", $match->{"to"})
        }
        my $ast = Perlito5::AST::Apply::->new("code", "do", "arguments", [Perlito5::AST::Block::->new("stmts", $match->{"capture"})]);
        $ast = $ast->emit_begin_scratchpad();
        my $js_code = $ast->emit_javascript2(0, $want);
        Perlito5::set_global_phase("UNITCHECK");
        $_->()
            while $_ = shift(@Perlito5::UNITCHECK_BLOCK);
        return $js_code
    }
    sub Perlito5::JavaScript2::Runtime::eval_ast {
        (my($ast)) = @_;
        my $want = 0;
        my $js_code = $ast->emit_javascript2(0, $want);
        Perlito5::set_global_phase("UNITCHECK");
        $_->()
            while $_ = shift(@Perlito5::UNITCHECK_BLOCK);
        $_ = $js_code;
        return JS::inline("eval(\"(function(){\" + p5pkg.main.v__ + \"})()\")")
    }
    sub Perlito5::JavaScript2::Runtime::emit_javascript2 {;
        return "//
// lib/Perlito5/JavaScript2/Runtime.js
//
// Runtime for \"Perlito\" Perl5-in-JavaScript2
//
// AUTHORS
//
// Flavio Soibelmann Glock  fglock\@gmail.com
//
// COPYRIGHT
//
// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.
//
// This program is free software; you can redistribute it and/or modify it
// under the same terms as Perl itself.
//
// See http://www.perl.com/perl/misc/Artistic.html

\"use strict\";
var isNode = typeof require != \"undefined\";

if (typeof p5pkg !== \"object\") {
    var p5pkg = {};
    var p5LOCAL = [];

    var universal = function () {};
    p5pkg.UNIVERSAL = new universal();
    p5pkg.UNIVERSAL._ref_ = \"UNIVERSAL\";
    p5pkg.UNIVERSAL.isa = function (List__) {
        var o = List__[0];
        var s = List__[1];
        var clas;
        if (typeof o === \"string\") {
            clas = p5pkg[o];
        }
        else {
            clas = o._class_;
        }
        if (!clas) {
            return false;
        }
        if (clas._ref_ == s) {
            return true;
        }
        var isa = clas.List_ISA;
        if (isa) {
            for (var i = 0; i < isa.length; i++) {
                if (isa[i] == s) {
                    return true;
                }
                if (p5pkg.UNIVERSAL.isa( isa[i], s )) {
                    return true;
                }
            }
        }
        return false;
    };
    p5pkg.UNIVERSAL.can = function (List__) {
        var o = List__[0];
        var s = List__[1];
        if (typeof o === \"string\") {
            return p5method_lookup(s, o, {})
        }
        if ( s.indexOf(\"::\") == -1 ) {
            return p5method_lookup(s, o._class_._ref_, {})
        }
        var c = s.split(\"::\");
        s = c.pop(); 
        return p5method_lookup(s, c.join(\"::\"), {});
    };
    p5pkg.UNIVERSAL.DOES = p5pkg.UNIVERSAL.can;

    var core = function () {};
    p5pkg[\"CORE\"] = new core();
    p5pkg[\"CORE\"]._ref_ = \"CORE\";

    var core_global = function () {};
    core_global.prototype = p5pkg.CORE;
    p5pkg[\"CORE::GLOBAL\"] = new core_global();
    p5pkg[\"CORE::GLOBAL\"]._ref_ = \"CORE::GLOBAL\";

    var p5_error = function (type, v) {
        this.type = type;
        this.v = this.message = v;
        this.toString = function(){
            if (this.type == 'break') {
                return 'Can\\'t \"break\" outside a given block'
            }
            if (this.type == 'next' || this.type == 'last' || this.type == 'redo') {
                if (this.v == \"\") { return 'Can\\'t \"' + this.type + '\" outside a loop block' }
                return 'Label not found for \"' + this.type + ' ' + this.v + '\"';
            }
            return this.v;
        };
    };
    p5_error.prototype = Error.prototype;
}

function p5make_package(pkg_name) {
    if (!p5pkg.hasOwnProperty(pkg_name)) {
        var tmp = function () {};
        tmp.prototype = p5pkg[\"CORE::GLOBAL\"];
        p5pkg[pkg_name] = new tmp();
        p5pkg[pkg_name]._ref_ = pkg_name;
        p5pkg[pkg_name]._class_ = p5pkg[pkg_name];  // XXX memory leak
        p5pkg[pkg_name]._is_package_ = 1;

        // TODO - add the other package global variables
        p5pkg[pkg_name][\"List_ISA\"] = [];
        p5pkg[pkg_name][\"v_a\"] = null;
        p5pkg[pkg_name][\"v_b\"] = null;
        p5pkg[pkg_name][\"v__\"] = null;
        p5pkg[pkg_name][\"v_AUTOLOAD\"] = null;
    }
    return p5pkg[pkg_name];
}

function p5get_class_for_method(method, class_name, seen) {
    // default mro
    // TODO - cache the methods that were already looked up
    if ( p5pkg[class_name].hasOwnProperty(method) ) {
        return class_name
    }
    var isa = p5pkg[class_name].List_ISA;
    if (isa) {
        for (var i = 0; i < isa.length; i++) {
            if (!seen[isa[i]]) {
                var m = p5get_class_for_method(method, isa[i], seen);
                if (m) {
                    return m 
                }
                seen[isa[i]]++;
            }
        }
    }
}

function p5method_lookup(method, class_name, seen) {
    var c = p5get_class_for_method(method, class_name, seen);
    if (c) {
        return p5pkg[c][method]
    }
    if ( p5pkg.UNIVERSAL.hasOwnProperty(method) ) {
        return p5pkg.UNIVERSAL[method]
    }
}

function p5method_not_found(method, class_name) {
    return \"Can't locate object method \\\"\"
        + method + \"\\\" via package \\\"\" + class_name + \"\\\" (perhaps you forgot to load \\\"\"
        + class_name + \"\\\"?)\";
}

function p5call(invocant, method, list, p5want) {
    var invocant_original = invocant;
    if (typeof invocant === \"string\") {
        list.unshift(invocant);
        invocant = p5make_package(invocant);
    }
    else if ( invocant.hasOwnProperty(\"_is_package_\") ) {
        list.unshift(invocant._ref_);   // invocant is a \"package\" object
    }
    else {
        list.unshift(invocant);
    }

    if ( invocant.hasOwnProperty(\"_class_\") ) {

        if ( invocant._class_.hasOwnProperty(method) ) {
            return invocant._class_[method](list, p5want)
        }
        var m = p5method_lookup(method, invocant._class_._ref_, {});
        if (m) {
            return m(list, p5want)
        }

        // method can have an optional namespace
        var pkg_name = method.split(/::/);
        if (pkg_name.length > 1) {
            var name = pkg_name.pop();
            pkg_name = pkg_name.join(\"::\");
            m = p5method_lookup(name, pkg_name, {});
            if (m) {
                return m(list, p5want)
            }
            p5pkg.CORE.die([p5method_not_found(name, pkg_name)]);
        }

        if (method == \"print\" || method == \"printf\" || method == \"say\" || method == \"close\") {
            list.shift();
            return p5pkg['Perlito5::IO'][method]( invocant_original, list, p5want);
        }

        if (method.substr(0, 1) != \"(\"
         && method != \"import\"
         && method != \"unimport\"
         && method != \"isa\"
         && method != \"can\"
        ) {
            pkg_name = p5get_class_for_method('AUTOLOAD', invocant._class_._ref_, {}) || p5get_class_for_method('AUTOLOAD', \"UNIVERSAL\", {});
            if (pkg_name) {
                p5pkg[pkg_name][\"v_AUTOLOAD\"] = invocant._class_._ref_ + \"::\" + method;
                return p5pkg[pkg_name][\"AUTOLOAD\"](list, p5want);
            }
        }
        p5pkg.CORE.die([p5method_not_found(method, invocant._class_._ref_)]);
    }
    p5pkg.CORE.die([\"Can't call method \", method, \" on unblessed reference\"]);
}

function p5cget(namespace, name) {
    if(p5pkg[namespace].hasOwnProperty(name)) {
        return p5pkg[namespace][name]
    }
    if(p5pkg[namespace].hasOwnProperty(\"AUTOLOAD\")) {
        p5pkg[namespace][\"v_AUTOLOAD\"] = namespace + \"::\" + name;
        return p5pkg[namespace][\"AUTOLOAD\"]
    }
    p5pkg.CORE.die([\"Undefined subroutine &\" + namespace + \"::\" + name]);
}

function p5cget_by_name(namespace, name) {
    // name can be a function already
    if (typeof name === \"function\") {
        return name;
    }
    // name can have an optional namespace
    var parts = name.split(/::/);
    if (parts.length > 1) {
        name = parts.pop();
        namespace = parts.join(\"::\");
    }
    if(p5pkg[namespace].hasOwnProperty(name)) {
        return p5pkg[namespace][name]
    }
    if(p5pkg[namespace].hasOwnProperty(\"AUTOLOAD\")) {
        p5pkg[namespace][\"v_AUTOLOAD\"] = namespace + \"::\" + name;
        return p5pkg[namespace][\"AUTOLOAD\"]
    }
    p5pkg.CORE.die([\"Undefined subroutine &\" + namespace + \"::\" + name]);
}

function p5code_lookup_by_name(package_name, sub_name) {
    // sub_name can be a function already
    if (typeof sub_name === \"function\") {
        return sub_name;
    }
    // sub_name can have an optional namespace
    var parts = sub_name.split(/::/);
    if (parts.length > 1) {
        sub_name = parts.pop();
        package_name = parts.join(\"::\");
    }
    if (p5pkg.hasOwnProperty(package_name)) {
        var c = p5pkg[package_name];
        if ( c.hasOwnProperty(sub_name) ) {
            return c[sub_name]
        }
    }
    return null;
}

function p5sub_exists(name, current_pkg_name) {
    var v = name;
    var pkg_name = v.split(/::/);
    if (pkg_name.length > 1) {
        v = pkg_name.pop();
        pkg_name = pkg_name.join(\"::\");
    }
    else {
        pkg_name = current_pkg_name;
    }
    var c = v.charCodeAt(0);
    if (c < 27) {
        pkg_name = 'main';
    }
    return p5pkg.hasOwnProperty(pkg_name) && p5pkg[pkg_name].hasOwnProperty(v) 
}

function p5sub_prototype(name, current_pkg_name) {
    if (!name) {
        return null;
    }
    if (typeof name === \"function\") {
        return name._prototype_;
    }
    var v = name;
    var pkg_name = v.split(/::/);
    if (pkg_name.length > 1) {
        v = pkg_name.pop();
        pkg_name = pkg_name.join(\"::\");
    }
    else {
        pkg_name = current_pkg_name;
    }
    var c = v.charCodeAt(0);
    if (c < 27) {
        pkg_name = 'main';
    }
    if (p5pkg.hasOwnProperty(pkg_name) && p5pkg[pkg_name].hasOwnProperty(v)) {
        return p5pkg[pkg_name][v]._prototype_
    }
    return p5pkg[\"Perlito5\"].v_PROTO._hash_[name] || p5pkg[\"Perlito5\"].v_CORE_PROTO._hash_[name]
}

function p5scalar_deref(v, current_pkg_name, autoviv_type) {
    if (typeof v === \"string\") {
        var pkg_name = v.split(/::/);
        if (pkg_name.length > 1) {
            v = pkg_name.pop();
            pkg_name = pkg_name.join(\"::\");
        }
        else {
            pkg_name = current_pkg_name;
        }
        var c = v.charCodeAt(0);
        if (c < 27) {
            pkg_name = 'main';
        }
        var name = \"v_\"+v;
        if (!p5make_package(pkg_name)[name]) {
            if (autoviv_type == 'array') {
                p5pkg[pkg_name][name] = new p5ArrayRef([]);
            }
            else if (autoviv_type == 'hash') {
                p5pkg[pkg_name][name] = new p5HashRef([]);
            }
            else if (autoviv_type == 'scalar') {
                p5pkg[pkg_name][name] = new p5ScalarRef([]);
            }
        }
        return p5pkg[pkg_name][name];
    }
    if (!v._scalar_) {
        if (autoviv_type == 'array') {
            v._scalar_ = new p5ArrayRef([]);
        }
        else if (autoviv_type == 'hash') {
            v._scalar_ = new p5HashRef([]);
        }
        else if (autoviv_type == 'scalar') {
            v._scalar_ = new p5ScalarRef([]);
        }
    }
    return v._scalar_;
}

function p5scalar_deref_set(v, n, current_pkg_name) {
    if (typeof v === \"string\") {
        var pkg_name = v.split(/::/);
        if (pkg_name.length > 1) {
            v = pkg_name.pop();
            pkg_name = pkg_name.join(\"::\");
        }
        else {
            pkg_name = current_pkg_name;
        }
        var c = v.charCodeAt(0);
        if (c < 27) {
            pkg_name = 'main';
        }
        var name = \"v_\"+v;
        p5make_package(pkg_name)[name] = n;
        return p5pkg[pkg_name][name];
    }
    v._scalar_ = n;
    return v._scalar_;
}

function p5array_deref(v, current_pkg_name) {
    if (typeof v === \"string\") {
        var pkg_name = v.split(/::/);
        if (pkg_name.length > 1) {
            v = pkg_name.pop();
            pkg_name = pkg_name.join(\"::\");
        }
        else {
            pkg_name = current_pkg_name;
        }
        var c = v.charCodeAt(0);
        if (c < 27) {
            pkg_name = 'main';
        }
        var name = \"List_\"+v;
        if (!p5make_package(pkg_name)[name]) {
                p5pkg[pkg_name][name] = [];
        }
        return p5pkg[pkg_name][name];
    }
    return v._array_;
}

function p5hash_deref(v, current_pkg_name) {
    if (typeof v === \"string\") {
        var pkg_name = v.split(/::/);
        if (pkg_name.length > 1) {
            v = pkg_name.pop();
            pkg_name = pkg_name.join(\"::\");
        }
        else {
            pkg_name = current_pkg_name;
        }
        var c = v.charCodeAt(0);
        if (c < 27) {
            pkg_name = 'main';
        }
        var name = \"Hash_\"+v;
        if (!p5make_package(pkg_name)[name]) {
                p5pkg[pkg_name][name] = [];
        }
        return p5pkg[pkg_name][name];
    }
    return v._hash_;
}

// regex globals
p5make_package(\"Regex\");
var p5_last_regex = new RegExp(\"\", \"\");
var p5_regex_capture = [];

p5make_package(\"main\");
p5make_package(\"Perlito5\");
p5pkg[\"Perlito5\"].v_PKG_NAME = \"main\";
p5make_package(\"main::STDIN\").file_handle = { id : 0, readline_buffer : '' };
p5make_package(\"main::STDOUT\").file_handle = { id : 1 };
p5make_package(\"main::STDERR\").file_handle = { id : 2 };
p5make_package(\"main::STDIN\")['List_ISA'] = ['Perlito5::IO'];
// p5make_package(\"main::STDOUT\")['List_ISA'] = ['Perlito5::IO'];
// p5make_package(\"main::STDERR\")['List_ISA'] = ['Perlito5::IO'];
p5make_package(\"ARGV\").file_handle = { id : null };
p5make_package(\"main\")[\"STDOUT\"] = p5pkg[\"main::STDOUT\"];
p5make_package(\"main\")[\"STDERR\"] = p5pkg[\"main::STDERR\"];
p5make_package(\"main\")[\"STDIN\"] = p5pkg[\"main::STDIN\"];
p5pkg[\"STDOUT\"] = p5pkg[\"main::STDOUT\"];
p5pkg[\"STDERR\"] = p5pkg[\"main::STDERR\"];
p5pkg[\"STDIN\"] = p5pkg[\"main::STDIN\"];
p5pkg[\"Perlito5\"].v_SELECT = \"main::STDOUT\";
p5pkg[\"main\"][\"v_\@\"] = [];      // \$\@
p5pkg[\"main\"][\"v_|\"] = 0;       // \$|
p5pkg[\"main\"][\"v_/\"] = \"\\n\";    // \$/
p5pkg[\"main\"]['v_\"'] = \" \";     // \$\"
p5pkg[\"main\"][\"List_#\"] = [];   // \@#
p5scalar_deref_set(String.fromCharCode(15), isNode ? \"node.js\" : \"javascript2\");  // \$^O
p5pkg[\"main\"][\"List_INC\"] = [];
p5pkg[\"main\"][\"Hash_INC\"] = {};
p5pkg[\"main\"][\"List_ARGV\"] = [];
p5pkg[\"main\"][\"Hash_ENV\"] = {};
p5pkg[\"main\"][\"Hash_SIG\"] = {};
if (isNode) {
    p5pkg[\"main\"][\"List_ARGV\"] = process.argv.splice(2);

    p5pkg[\"main\"][\"Hash_ENV\"] = {};
    for (var e in process.env) p5pkg[\"main\"][\"Hash_ENV\"][e] = process.env[e];

    p5pkg[\"main\"][\"v_\$\"] = process.pid;   // \$\$
    p5scalar_deref_set(String.fromCharCode(24), process.argv[0]);  // \$^X
} else if (typeof arguments === \"object\") {
    p5pkg[\"main\"][\"List_ARGV\"] = arguments;
}

p5make_package(\"Perlito5::IO\");
p5make_package(\"Perlito5::Runtime\");
p5make_package(\"Perlito5::Grammar\");

var sigils = { '\@' : 'List_', '%' : 'Hash_', '\$' : 'v_', '&' : '' };

function p5typeglob_set(namespace, name, obj) {
    p5make_package(namespace);
    if ( obj.hasOwnProperty(\"_ref_\") ) {
        if ( obj._ref_ == \"HASH\" ) {
            p5pkg[namespace][sigils['%'] + name] = obj._hash_;
        }
        else if ( obj._ref_ == \"ARRAY\" ) {
            p5pkg[namespace][sigils['\@'] + name] = obj._array_;
        }
        else if ( obj._ref_ == \"SCALAR\" ) {
            p5pkg[namespace][sigils['\$'] + name] = obj._scalar_;
        }
        else if ( obj._ref_ == \"CODE\" ) {
            p5pkg[namespace][sigils['&'] + name] = obj._code_;
        }
        else if ( obj._ref_ == \"GLOB\" ) {
            // TODO
            p5pkg[namespace][name] = obj;
        }
    }
    else {
        p5pkg[namespace][name] = obj;   // native CODE
        // TODO - non-reference
    }
    return p5pkg[namespace][name];  // TODO - return GLOB
}

function p5typeglob_deref_set(v, obj, current_pkg_name) {
    if (typeof v === \"string\") {
        var pkg_name = v.split(/::/);
        if (pkg_name.length > 1) {
            v = pkg_name.pop();
            pkg_name = pkg_name.join(\"::\");
        }
        else {
            pkg_name = current_pkg_name;
        }
        return p5typeglob_set(pkg_name, v, obj);
    }
    CORE.die([\"TODO: can't p5typeglob_deref_set()\"]);
}

function p5cleanup_local(idx, value) {
    while (p5LOCAL.length > idx) {
        var l = p5LOCAL.pop();
        l();
    }
    return value;
}

//-------- Reference

var p5id = Math.floor(Math.random() * 1000000000) + 1000000000;

function p5HashRef(o) {
    this._hash_ = o;
    this._ref_ = \"HASH\";
    this.bool = function() { return 1 };
}

function p5ArrayRef(o) {
    this._array_ = o;
    this._ref_ = \"ARRAY\";
    this.bool = function() { return 1 };
}

function p5ScalarRef(o) {
    this._scalar_ = o;
    this._ref_ = \"SCALAR\";
    this.bool = function() { return 1 };
}

function p5GlobRef(o) {
    this._scalar_ = o;
    this._ref_ = \"GLOB\";
    this.bool = function() { return 1 };
}

function p5CodeRef(o) {
    this._code_ = o;
    this._ref_ = \"CODE\";
    this.bool = function() { return 1 };
}

//-------- Hash 

Object.defineProperty( Object.prototype, \"p5hget\", {
    enumerable : false,
    value : function (i) { return this[i] }
});
Object.defineProperty( Object.prototype, \"p5hset\", {
    enumerable : false,
    value : function (i, v) { this[i] = v; return this[i] }
});

Object.defineProperty( Object.prototype, \"p5incr\", {
    enumerable : false,
    value : function (i) {
        this[i] = p5incr_(this[i]);
        return this[i];
    }
});
Object.defineProperty( Object.prototype, \"p5postincr\", {
    enumerable : false,
    value : function (i) {
        var v = this[i];
        this[i] = p5incr_(this[i]);
        return v;
    }
});
Object.defineProperty( Object.prototype, \"p5decr\", {
    enumerable : false,
    value : function (i) {
        this[i] = p5decr_(this[i]);
        return this[i];
    }
});
Object.defineProperty( Object.prototype, \"p5postdecr\", {
    enumerable : false,
    value : function (i) {
        var v = this[i];
        this[i] = p5decr_(this[i]);
        return v;
    }
});

Object.defineProperty( Object.prototype, \"p5hget_array\", {
    enumerable : false,
    value : function (i) {
        if (this[i] == null) { this[i] = new p5ArrayRef([]) }
        return this[i]
    }
});
Object.defineProperty( Object.prototype, \"p5hget_hash\", {
    enumerable : false,
    value : function (i) {
        if (this[i] == null) { this[i] = new p5HashRef({}) }
        return this[i]
    }
});

//-------


var p5context = function(List__, p5want) {
    if (p5want) {
        return p5list_to_a(List__);
    }
    // scalar: return the last value
    var o = List__;
    if (o instanceof Array) {
        o =   o.length
            ? o[o.length-1]
            : null;
    }
    if (o instanceof Array) {
        o =   o.length
    }
    return o;
}

var p5list_to_a = function(args) {
    var res = [];
    for (var i = 0; i < args.length; i++) {
        var o = args[i];
        if  (  o == null
            || o._class_    // perl5 blessed reference
            || o._ref_      // perl5 un-blessed reference
            )
        {
            res.push(o);
        }
        else if (o instanceof Array) {
            // perl5 array
            for (var j = 0; j < o.length; j++) {
                res.push(o[j]);
            }
        }
        else if (typeof o === \"object\") {
            // perl5 hash
            for(var j in o) {
                if (o.hasOwnProperty(j)) {
                    res.push(j);
                    res.push(o[j]);
                }
            }
        }
        else {
            // non-ref
            res.push(o);
        }
    }
    return res;
};

var p5_list_of_refs = function(a) {
    // implements \\( \@a )
    var res = [];
    for (var i = 0; i < a.length; i++) {
        res.push(new p5ScalarRef(a[i]));
    }
    return res;
};

var p5a_to_h = function(a) {
    var res = {};
    for (var i = 0; i < a.length; i+=2) {
        res[p5str(a[i])] = a[i+1];
    }
    return res;
};

var p5idx = function(a, i) {
    return i >= 0 ? i : a.length + i
};

var p5smrt_scalar = function(a1, a2) {
    if (a2 == null) {
        return a1 == null;
    }
    if (typeof a2 == \"string\") {
        return p5str(a1) == a2;
    }
    if (typeof a2 == \"number\") {
        return p5num(a1) == a2;
    }
    CORE.die(\"Not implemented: smartmatch operator with argument type '\", (typeof a2), \"'\");
};

var p5str = function(o) {
    if (o == null) {
        return \"\";
    }
    if (typeof o === \"object\") {
        if (o instanceof Array) {
            return CORE.join([\"\"].concat(o));
        }
        if ( o.hasOwnProperty(\"_ref_\") ) {
            var class_name = '';
            if (o._class_ && typeof o._class_._ref_ === \"string\") {
                // blessed reference
                // test for overload
                var meth = p5method_lookup('(\"\"', o._class_._ref_, {});
                if (meth) {
                    return p5str(meth([o], 0));
                }
                // TODO - test the \"fallback\" flag
                meth = p5method_lookup('(0+', o._class_._ref_, {});
                if (meth) {
                    return p5str(meth([o], 0));
                }
                // no overload, strigify the reference instead
                class_name = o._class_._ref_ + '=';
            }
            if (!o._id_) { o._id_ = p5id++ }
            return [class_name, o._ref_, '(0x', o._id_.toString( 16 ), ')'].join('');
        }
    }
    if (typeof o === \"function\") {
        var class_name = '';
        if (o._class_ && typeof o._class_._ref_ === \"string\") {
            // blessed reference
            class_name = o._class_._ref_ + '=';
        }
        if (!o._id_) { o._id_ = p5id++ }
        return [class_name, 'CODE(0x', o._id_.toString( 16 ), ')'].join('');
    }
    if (typeof o == \"number\" && Math.abs(o) < 0.0001 && o != 0) {
        return o.toExponential().replace(/e-(\\d)\$/,\"e-0\$1\");
    }
    if (typeof o === \"boolean\") {
        return o ? \"1\" : \"\";
    }
    if (typeof o !== \"string\") {
        return \"\" + o;
    }
    return o;
};

var p5num = function(o) {
    if (o == null) {
        return 0;
    }
    if (typeof o === \"object\") {
        if (o instanceof Array) {
            return o.length;
        }
        if ( o.hasOwnProperty(\"_ref_\") ) {
            if (o._class_ && typeof o._class_._ref_ === \"string\") {
                // blessed reference
                // test for overload
                var meth = p5method_lookup('(0+', o._class_._ref_, {});
                if (meth) {
                    return p5num(meth([o], 0));
                }
                // TODO - test the \"fallback\" flag
                meth = p5method_lookup('(\"\"', o._class_._ref_, {});
                if (meth) {
                    return p5num(meth([o], 0));
                }
            }
        }
    }
    if (typeof o !== \"number\") {
        var s = p5str(o).trim();
        var s1 = s.substr(0, 3).toUpperCase();
        if ( s1 == \"NAN\" ) { return NaN };
        if ( s1 == \"INF\" ) { return Infinity };
        s1 = s.substr(0, 4).toUpperCase();
        if ( s1 == \"-NAN\" ) { return NaN };
        if ( s1 == \"-INF\" ) { return -Infinity };
        s1 = parseFloat(s);
        if ( isNaN(s1) ) { return 0 };
        return s1;
    }
    return o;
};

var p5bool = function(o) {
    if (o) {
        if (typeof o === \"boolean\") {
            return o;
        }
        if (typeof o === \"number\") {
            return o;
        }
        if (typeof o === \"string\") {
            return o != \"\" && o != \"0\";
        }
        if (typeof o.length === \"number\") {
            return o.length;
        }
        if (o instanceof Error) {
            return true;
        }
        for (var i in o) {
            return true;
        }
    }
    return false;
};

var p5incr_ = function(o) {
    if (typeof o === \"number\") {
        return o + 1;
    }
    return p5str_inc(p5str(o));
};

var p5decr_ = function(o) {
    if (typeof o === \"number\") {
        return o - 1;
    }
    return p5num(o) - 1;
};

var p5modulo = function(o, k) {
    var m = o % k;
    if ( k < 0 && m > 0 ) {
        m = m + k;
    }
    else if ( k > 0 && m < 0 ) {
        m = m + k;
    }
    return m;
};

var p5shift_left = function(o, k) {
    return k < 31 ? o << k : o * Math.pow(2, k);
};

var p5and = function(a, fb) {
    if (p5bool(a)) {
        return fb();
    }
    return a;
};

var p5or = function(a, fb) {
    if (p5bool(a)) {
        return a;
    }
    return fb();
};

var p5defined_or = function(a, fb) {
    if (a == null) {
        return fb();
    }
    return a;
};

var p5xor = function(a, fb) {
    return p5bool(a) ? !p5bool(fb()) : fb()
};

var p5cmp = function(a, b) {
    return a > b ? 1 : a < b ? -1 : 0 
};

var p5complement = function(a) {
    return a < 0 ? ~a : 4294967295 - a
    // return a < 0 ? ~a : 18446744073709551615 - a
};

var p5str_replicate = function(o, n) {
    n = Math.floor(n);
    return n > 0 ? Array(n + 1).join(o) : \"\";
};

var p5list_replicate = function(o, n, want) {
    o = p5list_to_a([o]);
    n = p5num(n);

    if (!want) {
        return p5str_replicate(o.pop(), n);   // scalar context
    }

    var out = [];
    for(var i = 0; i < n; i++) {
        for(var j = 0; j < o.length; j++) {
            out.push(o[j]);
        }
    }
    return (want ? out : out.length)
};

var p5list_slice = function(o, ix, want) {
    var out = [];
    for (var i=0, l=ix.length; i<l; ++i) {
        if (ix[i] < o.length) {
            out[i] = o[ix[i]];
        }
    }
    if (want) { return out }
    return out.length ? out[out.length-1] : null;
}

var p5hash_slice = function(o, ix, want) {
    var out = [];
    for (var i=0, l=ix.length; i<l; ++i) {
        out.push(ix[i]);
        out.push(o[ix[i]]);
    }
    if (want) { return out }
    return out.length ? out[out.length-1] : null;
}

var p5list_lookup_slice = function(o, ix, want) {
    var out = [];
    for (var i=0, l=ix.length; i<l; ++i) {
        out[i] = o[ix[i]];
    }
    if (want) { return out }
    return out.length ? out[out.length-1] : null;
}

var p5hash_lookup_slice = function(o, ix, want) {
    var out = [];
    for (var i=0, l=ix.length; i<l; ++i) {
        out.push(ix[i]);
        out.push(o[ix[i]]);
    }
    if (want) { return out }
    return out.length ? out[out.length-1] : null;
}

var p5str_inc = function(s) {
    if (s.length < 2) {
        if ((s >= \"0\" && s <= \"8\") || (s >= \"A\" && s <= \"Y\") || (s >= \"a\" && s <= \"y\")) {
            return String.fromCharCode(s.charCodeAt(0) + 1);
        }
        if (s == \"9\") {
            return \"10\";
        }
        if (s == \"Z\") {
            return \"AA\";
        }
        if (s == \"z\") {
            return \"aa\";
        }
        return \"1\";
    }
    var c0 = s.substr(0, 1);
    if (c0 >= \"0\" && c0 <= \"9\") {
        return p5str(p5num(s)+1);
    }
    var c = p5str_inc(s.substr(s.length-1, 1));
    if (c.length == 1) {
        return s.substr(0, s.length-1) + c;
    }
    return p5str_inc(s.substr(0, s.length-1)) + c.substr(c.length-1, 1);
};

var p5looks_like_number = function(a) {
    if (typeof a === \"number\") {
        return 1;
    }
    a = a.trim();
    var s1 = a.toUpperCase();
    if ( s1 == \"NAN\" || s1 == \"INF\" || s1 == \"-NAN\" || s1 == \"-INF\" ) {
        return 1
    };
    if (s1.match(/^[\\+\\-]?[0-9]+\\.?(?:E[-+]?[0-9]+)?\$/)) {          // 999 999.
        return 1;
    }
    if (s1.match(/^[\\+\\-]?[0-9]*\\.[0-9]+(?:E[-+]?[0-9]+)?\$/)) {    // 999.999 .999
        return 1;
    }
    return 0;
}

var p5range_state = {};
var p5range = function(a, b, p5want, id, three_dots) {
    if (p5want) {
        // list context
        var tmp = [];
        if (typeof a === \"number\" || typeof b === \"number\") {
            a = p5num(a);
            b = p5num(b);
            if (isNaN(a) || isNaN(b) || a == Infinity || b == Infinity) {
                p5pkg.CORE.die([\"Range iterator outside integer range\"]);
            }
            a = CORE.int([a]);
            while (a <= b) {
                tmp.push(a);
                a++;
            }
        }
        else {
            a = p5str(a);
            b = p5str(b);
            if (a == '') {
                return [a];
            }

            if (a.substr(0, 1) != '0' && p5looks_like_number(a) && p5looks_like_number(b)) {
                // both sides look like number
                return p5range(p5num(a), p5num(b), p5want, id, three_dots)
            }

            // If the initial value specified isn't part of a magical increment sequence
            // (that is, a non-empty string matching /^[a-zA-Z]*[0-9]*\\z/ ),
            // only the initial value will be returned.
            if (!a.match(/^[a-zA-Z]*[0-9]*\$/)) {
                if (a.length > b.length) {
                    return []
                }
                return [a]
            }

            while (  (a.length < b.length)
                  || (a.length == b.length && a <= b) ) {
                tmp.push(a);
                a = p5incr_(a);
            }
        }
        return tmp;
    }
    // flip-flop operator
    var v;
    if (p5range_state[id]) {
        v = ++p5range_state[id];
        if (p5bool(b)) {
            p5range_state[id] = 0;
            v = v + \"E0\";
        }
        return v;
    }
    else {
        p5range_state[id] = 0;
        if (p5bool(a)) {
            p5range_state[id]++;
            v = p5range_state[id];
        }
        if (v && !three_dots && p5bool(b)) {
            p5range_state[id] = 0;
            v = v + \"E0\";
        }
        return v;
    }
};

var p5negative = function(o) {
    if (o == null) {
        return '-0';
    }
    if (typeof o === \"object\" && (o instanceof Array)) {
        return -(o.length);
    }
    if (typeof o !== \"number\") {
        var s = p5str(o);
        var c = s.substr(0, 1);
        if ( c == '+' ) { s = s.substr(1); return '-' + s }
        if ( c == '-' ) { s = s.substr(1); return '+' + s }
        var s1 = parseFloat(s.trim());
        if ( isNaN(s1) ) {
            if ( c.length && !c.match(/[ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz]/) ) {
                if ( s.trim().substr(0,1) == \"-\" ) { return 0 };
                return '-0';
            };
            return '-' + s
        };
        return -s1;
    }
    return -o;
};

function p5regex_s_modifier (s) {
    var cc = s.split(/(\\\\.)|/);
    var out = [];
    var is_char_class = false;
    for(var i = 0; i < cc.length; i++) {
        var c = cc[i];
        if (typeof c != \"undefined\") {
            if (c == \"[\")                    { is_char_class = true }
            if (c == \"]\" && is_char_class )  { is_char_class = false }
            if (c == \".\" && !is_char_class ) { c = \"[\\\\S\\\\s]\" }
            out.push(c);
        }
    }
    return out.join(\"\");
}

function p5regex_x_modifier (s) {
    var cc = s.split(/(\\\\.)|/);
    var out = [];
    var is_char_class = false;
    var is_comment = false;
    for(var i = 0; i < cc.length; i++) {
        var c = cc[i];
        if (typeof c != \"undefined\") {
            if (c == \"[\")                    { is_char_class = true }
            if (c == \"]\" && is_char_class )  { is_char_class = false }
            if (c == \" \" && !is_char_class ) { c = \"\" }
            if (c == \"#\" && !is_char_class ) { c = \"\"; is_comment = true }
            if (c == \"\\n\" && is_comment )    { c = \"\"; is_comment = false }
            if (is_comment)                  { c = \"\" }
            out.push(c);
        }
    }
    return out.join(\"\");
}

function p5regex_compile (s, flags) {
    if (flags.indexOf(\"s\") != -1) {
        flags = flags.replace(\"s\", \"\");
        s = p5regex_s_modifier(s);
    }
    if (flags.indexOf(\"x\") != -1) {
        flags = flags.replace(\"x\", \"\");
        s = p5regex_x_modifier(s);
    }
    return new RegExp(s, flags);
}

var p5qr = function(search, modifier) {
    // TODO - \"Regex\" stringification
    var re = p5regex_compile(search, modifier);
    return CORE.bless([(new p5ScalarRef(re)), 'Regex']);
};

var p5m = function(s, search, modifier, want) {
    // TODO - captures
    var re;
    if (search.hasOwnProperty('_scalar_')) {
        // search is a Regex object
        re = search._scalar_;
    }
    else {
        re = p5regex_compile(search, modifier);
    }

    p5_regex_capture = [];
    var res = [];
    var myArray;
    while ((myArray = re.exec(s)) !== null) {
        var m = myArray.shift();
        if (myArray.length) {
            res = res.concat(myArray);
            p5_regex_capture = p5_regex_capture.concat(myArray);
        }
        else {
            res.push(m);
        }
        if (re.lastIndex == 0) {
            return (want ? res : res.length)
        }
    }
    return (want ? res : res.length)
};

var p5s = function(s, search, fun_replace, modifier, want) {
    // TODO - captures
    var count = null;
    var re;
    if (search.hasOwnProperty('_scalar_')) {
        // search is a Regex object
        re = search._scalar_;
    }
    else {
        re = p5regex_compile(search, modifier);
    }

    p5_regex_capture = [];
    var res = [];
    var myArray;
    var last_index = 0;
    while ((myArray = re.exec(s)) !== null) {
        var m = myArray.shift();
        p5_regex_capture = [].concat(myArray);
        if (myArray.index > last_index) {
            res.push(s.substr(last_index, myArray.index - last_index));
        }
        res.push(fun_replace());
        last_index = re.lastIndex;
        if (last_index == 0) {
            count = 1;
            last_index = myArray.index + m.length;
            if (s.length > last_index) {
                res.push(s.substr(last_index, s.length - last_index));
            }
            return [res.join(''), count]
        }
        count++;
    }
    if (s.length > last_index) {
        res.push(s.substr(last_index, s.length - last_index));
    }
    return [res.join(''), count]
};

var p5tr = function(s, search, replace, modifier, want) {
    var count = 0;
    // TODO - expand character lists in spec
    // TODO - modifiers
    search = search.split(\"\");
    replace = replace.split(\"\");
    while (search.length > replace.length) {
        replace.push(replace[replace.length-1]);
    }
    var tr = {};
    for(var i = 0; i < search.length; i++) {
        tr[search[i]] = replace[i];
    }
    var res = s.split(\"\");
    for(var i = 0; i < res.length; i++) {
        if (tr.hasOwnProperty(res[i])) {
            res[i] = tr[res[i]];
            count++;
        }
    }
    return [res.join(''), count]
};

var p5chop = function(s) {
    // TODO - hash

    if (s instanceof Array) {
        // perl5 array
        var count = 0;
        var res;
        for (var j = 0; j < s.length; j++) {
            res = p5chop(p5str(s[j]));
            count = res[0];
            s[j] = res[1];
        }
        return [count, s];
    }

    s = p5str(s);
    return [s.substr(-1,1), s.substr(0,s.length-1)]
};

var p5chomp = function(s) {
    // TODO - hash
    // TODO - special cases of \$/ - empty string, reference

    if (s instanceof Array) {
        // perl5 array
        var count = 0;
        var res;
        for (var j = 0; j < s.length; j++) {
            res = p5chomp(p5str(s[j]));
            count = count + res[0];
            s[j] = res[1];
        }
        return [count, s];
    }

    s = p5str(s);
    var sep = p5pkg[\"main\"][\"v_/\"];  // \$/
    var c = s.substr(-sep.length);
    if (c == sep) {
        return [c.length, s.substr(0,s.length-sep.length)]
    }
    else {
        return [0, s]
    }
};

var p5for = function(namespace, var_name, func, args, cont, label) {
    var local_idx = p5LOCAL.length;
    var v_old = namespace[var_name];
    var _redo;
    p5LOCAL.push(function(){ namespace[var_name] = v_old });
    for(var i = 0; i < args.length; i++) {
        namespace[var_name] = args[i];
        do {
            _redo = false;
            try {
                func()
            }
            catch(err) {
                if (err instanceof p5_error && (err.v == label || err.v == '')) {
                    if (err.type == 'last') {
                        p5cleanup_local(local_idx, null);
                        return
                    }
                    else if (err.type == 'redo') { _redo = true }
                    else if (err.type != 'next') { throw(err) }
                }
                else {
                    throw(err)
                }
            }
            if (cont) {
                try {
                    if (!_redo) { cont() }
                }
                catch(err) {
                    if (err instanceof p5_error && (err.v == label || err.v == '')) {
                        if (err.type == 'last') {
                            p5cleanup_local(local_idx, null);
                            return
                        }
                        else if (err.type == 'redo') { _redo = true }
                        else if (err.type != 'next') { throw(err) }
                    }            
                    else {
                        throw(err)
                    }
                }
            }
        } while (_redo);
    }
    p5cleanup_local(local_idx, null);
};

var p5for_lex = function(set_var, func, args, cont, label) {
    var local_idx = p5LOCAL.length;
    var _redo;
    for(var i = 0; i < args.length; i++) {
        set_var(args[i]);
        do {
            _redo = false;
            try {
                func()
            }
            catch(err) {
                if (err instanceof p5_error && (err.v == label || err.v == '')) {
                    if (err.type == 'last') {
                        p5cleanup_local(local_idx, null);
                        return
                    }
                    else if (err.type == 'redo') { _redo = true }
                    else if (err.type != 'next') { throw(err) }
                }            
                else {
                    throw(err)
                }
            }
            if (cont) {
                try {
                    if (!_redo) { cont() }
                }
                catch(err) {
                    if (err instanceof p5_error && (err.v == label || err.v == '')) {
                        if (err.type == 'last') {
                            p5cleanup_local(local_idx, null);
                            return
                        }
                        else if (err.type == 'redo') { _redo = true }
                        else if (err.type != 'next') { throw(err) }
                    }            
                    else {
                        throw(err)
                    }
                }
            }
        } while (_redo);
    }
    p5cleanup_local(local_idx, null);
};

var p5block = function(set_var, func, args, cont, label) {
    var local_idx = p5LOCAL.length;
    var _redo;
    for(var i = 0; i < args.length; i++) {
        set_var(args[i]);
        do {
            _redo = false;
            try {
                return func()
            }
            catch(err) {
                if (err instanceof p5_error && (err.v == label || err.v == '')) {
                    if (err.type == 'last') {
                        p5cleanup_local(local_idx, null);
                        return
                    }
                    else if (err.type == 'redo') { _redo = true }
                    else if (err.type != 'next') { throw(err) }
                }            
                else {
                    throw(err)
                }
            }
            if (cont) {
                try {
                    if (!_redo) { cont() }
                }
                catch(err) {
                    if (err instanceof p5_error && (err.v == label || err.v == '')) {
                        if (err.type == 'last') {
                            p5cleanup_local(local_idx, null);
                            return
                        }
                        else if (err.type == 'redo') { _redo = true }
                        else if (err.type != 'next') { throw(err) }
                    }            
                    else {
                        throw(err)
                    }
                }
            }
        } while (_redo);
    }
    p5cleanup_local(local_idx, null);
};


var p5while = function(func, cond, cont, label, redo) {
    var local_idx = p5LOCAL.length;
    while (redo || p5bool(cond())) {
        redo = false;
        try {
            func()
        }
        catch(err) {
            if (err instanceof p5_error && (err.v == label || err.v == '')) {
                if (err.type == 'last') {
                    p5cleanup_local(local_idx, null);
                    return
                }
                else if (err.type == 'redo') { redo = true }
                else if (err.type != 'next') { throw(err) }
            }            
            else {
                throw(err)
            }
        }
        if (cont) {
            try {
                if (!redo) { cont() }
            }
            catch(err) {
                if (err instanceof p5_error && (err.v == label || err.v == '')) {
                    if (err.type == 'last') {
                        p5cleanup_local(local_idx, null);
                        return
                    }
                    else if (err.type == 'redo') { redo = true }
                    else if (err.type != 'next') { throw(err) }
                }            
                else {
                    throw(err)
                }
            }
        }
    }
    p5cleanup_local(local_idx, null);
};

var p5map = function(namespace, func, args) {
    var v_old = p5pkg[\"main\"][\"v__\"];
    var out = [];
    for(var i = 0; i < args.length; i++) {
        p5pkg[\"main\"][\"v__\"] = args[i];
        var o = p5list_to_a([func(1)]);
        for(var j = 0; j < o.length; j++) {
            out.push(o[j]);
        }
    }
    p5pkg[\"main\"][\"v__\"] = v_old;
    return out;
};

var p5grep = function(namespace, func, args) {
    var v_old = p5pkg[\"main\"][\"v__\"];
    var out = [];
    for(var i = 0; i < args.length; i++) {
        p5pkg[\"main\"][\"v__\"] = args[i];
        if (p5bool(func(0))) {
            out.push(args[i])
        }
    }
    p5pkg[\"main\"][\"v__\"] = v_old;
    return out;
};

var p5sort = function(namespace, func, args) {
    var a_old = namespace[\"v_a\"];
    var b_old = namespace[\"v_b\"];
    var out = 
        func == null
        ? args.sort()
        : args.sort(
            function(a, b) {
                namespace[\"v_a\"] = a;
                namespace[\"v_b\"] = b;
                return func(0);
            }
        );
    namespace[\"v_a\"] = a_old;
    namespace[\"v_b\"] = b_old;
    return out;
};

"
    }
    1
}
{
    package main;
    package Perlito5::JavaScript2::Lib;
    sub Perlito5::JavaScript2::Lib::init {;
        Perlito5::Grammar::Use::register_internal_module("MIME::Base64", "Perlito5X::JavaScript::MIME::Base64")
    }
    1
}
{
    package main;
    package Perlito5::JavaScript2::Array;
    sub Perlito5::JavaScript2::Array::emit_javascript2 {;
        return "//
// lib/Perlito5/JavaScript2/Runtime.js
//
// Runtime for \"Perlito\" Perl5-in-JavaScript2
//
// AUTHORS
//
// Flavio Soibelmann Glock  fglock\@gmail.com
//
// COPYRIGHT
//
// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.
//
// This program is free software; you can redistribute it and/or modify it
// under the same terms as Perl itself.
//
// See http://www.perl.com/perl/misc/Artistic.html

//-------- Array 

Object.defineProperty( Array.prototype, \"p5aget\", {
    enumerable : false,
    value : function (i) {
        if (i < 0) { i =  this.length + i };
        return this[i] 
    }
});
Object.defineProperty( Array.prototype, \"p5aset\", {
    enumerable : false,
    value : function (i, v) {
        if (i < 0) { i =  this.length + i };
        this[i] = v;
        return this[i]
    }
});

Object.defineProperty( Array.prototype, \"p5incr\", {
    enumerable : false,
    value : function (i) {
        if (i < 0) { i =  this.length + i };
        this[i] = p5incr_(this[i]);
        return this[i];
    }
});
Object.defineProperty( Array.prototype, \"p5postincr\", {
    enumerable : false,
    value : function (i) {
        if (i < 0) { i =  this.length + i };
        var v = this[i];
        this[i] = p5incr_(this[i]);
        return v;
    }
});
Object.defineProperty( Array.prototype, \"p5decr\", {
    enumerable : false,
    value : function (i) {
        if (i < 0) { i =  this.length + i };
        this[i] = p5decr_(this[i]);
        return this[i];
    }
});
Object.defineProperty( Array.prototype, \"p5postdecr\", {
    enumerable : false,
    value : function (i) {
        if (i < 0) { i =  this.length + i };
        var v = this[i];
        this[i] = p5decr_(this[i]);
        return v;
    }
});

Object.defineProperty( Array.prototype, \"p5aget_array\", {
    enumerable : false,
    value : function (i) {
        if (i < 0) { i =  this.length + i };
        if (this[i] == null) { this[i] = new p5ArrayRef([]) }
        return this[i]
    }
});
Object.defineProperty( Array.prototype, \"p5aget_hash\", {
    enumerable : false,
    value : function (i) {
        if (i < 0) { i =  this.length + i };
        if (this[i] == null) { this[i] = new p5HashRef({}) }
        return this[i]
    }
});
Object.defineProperty( Array.prototype, \"p5unshift\", {
    enumerable : false,
    configurable : true,
    value : function (args) { 
        for(var i = args.length-1; i >= 0; i--) {
            this.unshift(args[i]);
        }
        return this.length; 
    }
});
Object.defineProperty( Array.prototype, \"p5push\", {
    enumerable : false,
    configurable : true,
    value : function (args) { 
        for(var i = 0; i < args.length; i++) {
            this.push(args[i]);
        }
        return this.length; 
    }
});

var p5tie_array = function(v, List__) {
    var pkg_name = p5str(List__.shift());

    var res = p5call(pkg_name, 'TIEARRAY', List__, null);
    
    // TODO
    
    //  A class implementing an ordinary array should have the following methods:
    //      TIEARRAY pkg_name, LIST
    //      FETCH this, key
    //      STORE this, key, value
    //      FETCHSIZE this
    //      STORESIZE this, count
    //      CLEAR this
    //      PUSH this, LIST
    //      POP this
    //      SHIFT this
    //      UNSHIFT this, LIST
    //      SPLICE this, offset, length, LIST
    //      EXTEND this, count
    //      DESTROY this
    //      UNTIE this
    
    Object.defineProperty( v, \"p5aget\", {
        enumerable : false,
        configurable : true,
        value : function (i) {
            return p5call(res, 'FETCH', [i]);
        }
    });
    Object.defineProperty( v, \"p5aset\", {
        enumerable : false,
        configurable : true,
        value : function (i, value) {
            p5call(res, 'STORE', [i, value]);
            return value;
        }
    });
    Object.defineProperty( v, \"p5incr\", {
        enumerable : false,
        configurable : true,
        value : function (i) {
            var value = p5incr_(p5call(res, 'FETCH', [i]));
            p5call(res, 'STORE', [i, value]);
            return value;
        }
    });
    Object.defineProperty( v, \"p5postincr\", {
        enumerable : false,
        configurable : true,
        value : function (i) {
            var value = p5call(res, 'FETCH', [i]);
            p5call(res, 'STORE', [i, p5incr_(value)]);
            return value;
        }
    });
    Object.defineProperty( v, \"p5decr\", {
        enumerable : false,
        configurable : true,
        value : function (i) {
            var value = p5decr_(p5call(res, 'FETCH', [i]));
            p5call(res, 'STORE', [i, value]);
            return value;
        }
    });
    Object.defineProperty( v, \"p5postdecr\", {
        enumerable : false,
        configurable : true,
        value : function (i) {
            var value = p5call(res, 'FETCH', [i]);
            p5call(res, 'STORE', [i, p5decr_(value)]);
            return value;
        }
    });
    
    Object.defineProperty( v, \"p5aget_array\", {
        enumerable : false,
        configurable : true,
        value : function (i) {
            var value = p5call(res, 'FETCH', [i]);
            if (value == null) {
                value = new p5ArrayRef([]);
                p5call(res, 'STORE', [i, value]);
            }
            return value;
        }
    });
    Object.defineProperty( v, \"p5aget_hash\", {
        enumerable : false,
        configurable : true,
        value : function (i) {
            var value = p5call(res, 'FETCH', [i]);
            if (value == null) {
                value = new p5HashRef({});
                p5call(res, 'STORE', [i, value]);
            }
            return value;
        }
    });
    Object.defineProperty( v, \"p5untie\", {
        enumerable : false,
        configurable : true,
        value : function (i) { return p5call(res, 'UNTIE', []) }
    });
    Object.defineProperty( v, \"shift\", {
        enumerable : false,
        configurable : true,
        value : function () { return p5call(res, 'SHIFT', []) }
    });
    Object.defineProperty( v, \"pop\", {
        enumerable : false,
        configurable : true,
        value : function () { return p5call(res, 'POP', []) }
    });
    Object.defineProperty( v, \"p5unshift\", {
        enumerable : false,
        configurable : true,
        value : function (args) { 
            for(var i = args.length-1; i >= 0; i--) {
                p5call(res, 'UNSHIFT', [args[i]]);
            }
            return p5call(res, 'FETCHSIZE', []); 
        }
    });
    Object.defineProperty( v, \"p5push\", {
        enumerable : false,
        configurable : true,
        value : function (args) { 
            for(var i = 0; i < args.length; i++) {
                p5call(res, 'PUSH', [args[i]]);
            }
            return p5call(res, 'FETCHSIZE', []); 
        }
    });

    return res;
};

var p5untie_array = function(v) {
    if (v.hasOwnProperty('p5untie')) {
        var res = v.p5untie();  // call UNTIE
        delete v.p5aget;
        delete v.p5aset;
        delete v.p5incr;
        delete v.p5postincr;
        delete v.p5decr;
        delete v.p5postdecr;
        delete v.p5aget_array;
        delete v.p5aget_hash;
        delete v.p5untie;
        delete v.shift;
        delete v.pop;
        delete v.p5unshift;
        delete v.p5push;
        return res;
    }
    else {
        return null;
    }
};


function p5ArrayOfAlias(o) {

    // this is the structure that represents \@_
    // _array = [ ref, index,
    //            ref, index,
    //            ...
    //          ]

    // TODO - autovivify array cells

    this._array_ = o;

    this.p5aget = function (i) {
        if (i < 0) { i =  this.length + i };
        return this._array_[i+i][this._array_[i+i+1]]; 
    }
    this.p5aset = function (i, v) {
        if (i < 0) { i =  this.length + i };
        this._array_[i+i][this._array_[i+i+1]] = v;
        return this._array_[i+i][this._array_[i+i+1]]
    }
    this.p5incr = function (i) {
        if (i < 0) { i =  this.length + i };
        this._array_[i+i][this._array_[i+i+1]] = p5incr_(this._array_[i+i][this._array_[i+i+1]]);
        return this._array_[i+i][this._array_[i+i+1]];
    }
    this.p5postincr = function (i) {
        if (i < 0) { i =  this.length + i };
        var v = this._array_[i+i][this._array_[i+i+1]];
        this._array_[i+i][this._array_[i+i+1]] = p5incr_(this._array_[i+i][this._array_[i+i+1]]);
        return v;
    }
    this.p5decr = function (i) {
        if (i < 0) { i =  this.length + i };
        this._array_[i+i][this._array_[i+i+1]] = p5decr_(this._array_[i+i][this._array_[i+i+1]]);
        return this._array_[i+i][this._array_[i+i+1]];
    }
    this.p5postdecr = function (i) {
        if (i < 0) { i =  this.length + i };
        var v = this._array_[i+i][this._array_[i+i+1]];
        this._array_[i+i][this._array_[i+i+1]] = p5decr_(this._array_[i+i][this._array_[i+i+1]]);
        return v;
    }
    this.p5aget_array = function (i) {
        if (i < 0) { i =  this.length + i };
        if (this._array_[i+i][this._array_[i+i+1]] == null) {
            this._array_[i+i][this._array_[i+i+1]] = new p5ArrayRef([])
        }
        return this._array_[i+i][this._array_[i+i+1]]
    }
    this.p5aget_hash = function (i) {
        if (i < 0) { i =  this.length + i };
        if (this._array_[i+i][this._array_[i+i+1]] == null) {
            this._array_[i+i][this._array_[i+i+1]] = new p5HashRef({})
        }
        return this._array_[i+i][this._array_[i+i+1]]
    }
    this.p5unshift = function (args) { 
        for(var i = args.length-1; i >= 0; i--) {
            this.unshift(0);
            this.unshift([args[i]]);
        }
        return this._array_.length / 2; 
    }
    this.p5push = function (args) { 
        for(var i = 0; i < args.length; i++) {
            this.push([args[i]]);
            this.push(0);
        }
        return this._array_.length / 2; 
    }
    this.shift = function () { 
        var v0 = this._array_.shift();
        return v0[this._array_.shift()];
    }
    this.pop = function () { 
        var v1 = this._array_.pop();
        var v0 = this._array_.pop();
        return v0[v1];
    }
}


"
    }
    1
}
{
    package main;
    package Perlito5::JavaScript2::CORE;
    sub Perlito5::JavaScript2::CORE::emit_javascript2 {;
        return "//
//
// lib/Perlito5/JavaScript2/CORE.js
//
// CORE functions for \"Perlito\" Perl5-in-JavaScript2
//
// AUTHORS
//
// Flavio Soibelmann Glock  fglock\@gmail.com
//
// COPYRIGHT
//
// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.
//
// This program is free software; you can redistribute it and/or modify it
// under the same terms as Perl itself.
//
// See http://www.perl.com/perl/misc/Artistic.html

var CORE = p5pkg.CORE;

var isNode = typeof require != \"undefined\";

" . "if (isNode) {
    try {
        var sleep = require(\"sleep\");
        CORE.sleep = function(List__) {
            var n = p5num(List__[0]) || 1;
            sleep.usleep(n * 1000000);  // sleep for n seconds (1 second is 1000000 microseconds)
            return n;
        }
    }
    catch (err) {
        CORE.sleep = function(List__) {
            CORE.die(\"sleep() function failed. Maybe you need 'npm install sleep'?\\n\" + err);
        }
    }
}
if (!CORE.sleep) {
    CORE.sleep = function(List__) {
        CORE.die(\"sleep() not supported for this platform\");
    }
}

" . "if (isNode) {
    try {
        var crypt = require(\"crypt3\");
        CORE.crypt = function(List__) {
            var text = p5str(List__[0]);
            var salt = p5str(List__[1]);
            while(salt.length < 2) {
                salt += \"A\";
            }
            return crypt(text, salt);
        }
    }
    catch (err) {
        CORE.crypt = function(List__) {
            CORE.die(\"crypt() function failed. Maybe you need 'npm install crypt3'?\\n\" + err);
        }
    }
}
if (!CORE.crypt) {
    CORE.crypt = function(List__) {
        CORE.die(\"crypt() not supported for this platform\");
    }
}

" . "CORE.time = function(List__) {
    return CORE.int([Date.now() / 1000]);
}
" . "var _fmt_date = function(date) {
    return ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][date.getDay()] + ' ' +
        ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][date.getMonth()] + ' ' +
        date.getDate() + ' ' + 
        CORE.sprintf([ \"%02d:%02d:%02d \", date.getHours(), date.getMinutes(), date.getSeconds() ]) +
        date.getFullYear();
}
var _list_date = function(date) {
    var year_start = new Date(date);
    year_start.setMonth(0, 1);
    var year_day = Math.round((date-year_start)/8.64e7);

    var isdst = 0;  // not implemented

    return [date.getSeconds(),date.getMinutes(),date.getHours(),date.getDate(),
        date.getMonth(),date.getFullYear()-1900,date.getDay(),
        year_day,
        isdst
    ];
}
CORE.localtime = function(List__, want) {
    var n = List__.length ? p5num(List__[0]) : CORE.time() ;
    var date = new Date(n*1000);
    if (!want) {
        return _fmt_date(date);
    }
    return _list_date(date);
}
CORE.gmtime = function(List__, want) {
    var n = List__.length ? p5num(List__[0]) : CORE.time() ;
    var ofs = new Date().getTimezoneOffset() * 60;
    var date = new Date((n + ofs)*1000);
    if (!want) {
        return _fmt_date(date);
    }
    return _list_date(date);
}

CORE.bless = function(List__) {
    var o        = List__[0];
    var pkg_name = List__[1];
    if (typeof pkg_name === \"object\") {
        // bless {}, Class
        o._class_ = pkg_name;
        return o;
    }
    if (!p5pkg.hasOwnProperty(pkg_name)) {
        p5make_package(pkg_name);
    }
    o._class_ = p5pkg[pkg_name];
    return o;
};

CORE.caller = function(List__, want) {
    if ( p5pkg[\"Perlito5\"].List_CALLER[0] ) {
        // TODO
        return p5pkg[\"Perlito5\"].List_CALLER[0]._array_
    }
    return p5context([], want);
};

CORE.chr = function(List__) {
    var v = p5num(List__[0]);
    return String.fromCharCode(v >= 0 ? v : 65533);
};

CORE.ord = function(List__) {
    return p5str(List__[0]).charCodeAt(0);
};

CORE.hex = function(List__) {
    var v = List__[0];

    for(var i = 0; i < v.length; i++) {
        if (v.charCodeAt(i) > 255) {
            CORE.die([\"Wide character in hex\"]);
        }
    }

    var b1 = v.substr(0,1);
    var b2 = v.substr(0,2);
    if (b1 == \"x\" || b1 == \"X\" || b2 == \"0x\" || b2 == \"0X\") {
        return CORE.oct(List__);
    }
    v = \"0x\" + v;
    return CORE.oct([v]);
};

CORE.oct = function(List__) {
    var v = List__[0];
    v = v.trim();

    for(var i = 0; i < v.length; i++) {
        if (v.charCodeAt(i) > 255) {
            CORE.die([\"Wide character in oct\"]);
        }
    }

    var b = v.substr(0,1);
    if (b == \"b\" || b == \"B\" || b == \"x\" || b == \"X\") {
        v = \"0\" + v;
    }
    b = v.substr(0,2);

    for(var i = 2; i < v.length; i++) {
        if (v.substr(i,2) == \"__\") {
            v = v.substr(0, i);
        }
    }

    var re = new RegExp('_', 'g');
    v = v.replace(re, \"\");
    var result;

    if (b == \"0b\" || b == \"0B\") {
        for(var i = 2; i < v.length; i++) {
            var c = v.substr(i,1);
            if (c >= \"0\" && c <= \"1\") {}
            else {
                v = v.substr(0, i);
            }
        }
        if (v.length == 2) { return 0 }
        result = parseInt(v.substr(2), 2);
    }
    else if (b == \"0x\" || b == \"0X\") {
        for(var i = 2; i < v.length; i++) {
            var c = v.substr(i,1);
            if (c >= \"0\" && c <= \"9\" || c >= \"A\" && c <= \"F\" || c >= \"a\" && c <= \"f\") {}
            else {
                v = v.substr(0, i);
            }
        }
        if (v.length == 2) { return 0 }
        result = parseInt(v.substr(2), 16);
    }
    else {
        result = parseInt(v, 8);
    }
    return isNaN(result) ? 0 : result;
};

CORE.abs   = function(List__) { return Math.abs(List__[0]) };
CORE.exp   = function(List__) { return Math.exp(List__[0]) };
CORE.log   = function(List__) { return Math.log(List__[0]) };
CORE.cos   = function(List__) { return Math.cos(List__[0]) };
CORE.sin   = function(List__) { return Math.sin(List__[0]) };
CORE.sqrt  = function(List__) { return Math.sqrt(List__[0]) };
CORE.atan2 = function(List__) { return Math.atan2(List__[0], List__[1]) };
CORE.int   = function(List__) { return List__[0] > 0 ? Math.floor(List__[0]) : Math.ceil(List__[0]) };

var p5rand = function(v) { return Math.random() * v };
CORE.srand = function(List__) {
    if (List__.length > 0) {
        var v = p5num(List__[0]) || 1;
        p5rand = function() {
            v = Math.sin(v) * 10000;
            return v - Math.floor(v);
        };
        return List__[0];
    }
    return CORE.int(CORE.rand(100000));
};
CORE.rand = function(List__) {
    var v = p5num(List__[0]) || 1;
    return p5rand(v);
};

CORE.lc      = function(List__) { return p5str(List__[0]).toLowerCase() };
CORE.uc      = function(List__) { return p5str(List__[0]).toUpperCase() };
CORE.fc      = function(List__) { return p5str(List__[0]).toUpperCase() };

CORE.lcfirst = function(List__) {
    var s = p5str(List__[0]);
    var c = s.length > 0 ? s.slice(0,1).toLowerCase() : \"\";
    s = s.length > 1 ? s.substr(1) : \"\";
    return c + s
};

CORE.ucfirst = function(List__) {
    var s = p5str(List__[0]);
    var c = s.length > 0 ? s.slice(0,1).toUpperCase() : \"\";
    s = s.length > 1 ? s.substr(1) : \"\";
    return c + s
};

CORE.quotemeta = function(List__) {
    var s = p5str(List__[0]);
    var out = [];
    for(var i = 0; i < s.length; i++) {
        if (s.substr(i, 1).match(/[^0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz]/)) {
            out.push(String.fromCharCode(92));
        }
        out.push(s.substr(i, 1));
    }
    return out.join(\"\");       
};

CORE.substr = function(List__) {
    var expr        = List__[0];
    var offset      = List__[1];
    var length      = List__[2];
    var replacement = List__[3];
    if (length < 0) {
        var s = p5str(expr);
        length = s.length - offset + length;
    } 
    return p5str(expr).substr(offset, length);
};

CORE.values = function(List__, p5want) {
    var o = List__[0];
    delete o[\"_each_\"];
    if (p5want) {
        if (o == null) {
            return [];
        };
        if (typeof o.values === \"function\") {
            return o.values();
        }
        var out = [];
        for (var i in o) {
            out.push(o[i]);
        }
        return out;
    }
    return CORE.keys(List__, p5want);
};

CORE.keys = function(List__, p5want) {
    var o = List__[0];
    delete o[\"_each_\"];
    if (p5want) {
        if (o == null) {
            return [];
        }
        if (typeof o.keys === \"function\") {
            return o.keys();
        }
        var out = [];
        for (var i in o) {
            out.push(i);
        }
        return out;
    }
    else {
        if (o == null) {
            return 0;
        }
        if (typeof o.keys === \"function\") {
            return p5num(o.keys());
        }
        var out = 0;
        for (var i in o) {
            out++;
        }
        return out;
    }
};

CORE.each = function(List__, p5want) {
    var o = List__[0];
    if (o.hasOwnProperty(\"_each_\")) {
        return o._each_(p5want)
    }
    var keys = CORE.keys([o], 1);
    var i = 0;
    o._each_ = function () {
        if (i < keys.length) {
            i++;
            return p5want ? [keys[i-1], o[keys[i-1]]] : keys[i-1];
        }
        i = 0;
        return p5want ? [] : null;
    };
    return o._each_(p5want);
};

CORE.reverse = function(List__, p5want) {
    var o = List__;
    if (p5want) {
        if (o == null) {
            return [];
        }
        return List__.reverse();
    }
    o = p5str(o);
    return o.split(\"\").reverse().join(\"\")
};

CORE.splice = function(List__, p5want) {
    var array  = List__.shift();
    // CORE.say([ array ]);
    var offset = p5num(List__.shift());
    var limit  = List__.length ? p5num(List__.shift()) : (array.length + 1);

    if (limit < 0) {
        limit = array.length + limit - 1;
    }

    var list = [offset, limit];
    for(var i = 0; i < List__.length; i++) {
        list = p5list_to_a([ list, List__[i] ]);
    }

    var out = array.splice.apply(array, list);
    // CORE.say([ CORE.join([\":\",array]), \" ofs=\", offset, \" lim=\", limit, \" list=\", list, \" out=\", CORE.join([\":\",out])  ]);
    return p5want ? out : out.pop();
};

CORE.join = function(List__) {
    var s = List__.shift();
    var o = [];
    for (var i = 0; i < List__.length; i++) {
        o.push(p5str(List__[i]));
    }
    return o.join(s);
};

CORE.index = function(List__) {
    var o = List__[0];
    var s = List__[1];
    try {
        return o.indexOf(s, p5num(List__[2]));
    }
    catch(err) {
        return -1;
    }
};
CORE.rindex = function(List__) {
    var o = List__[0];
    var s = List__[1];
    try {
        if (List__.length > 2) {
            var i = p5num(List__[2]);
            if (i < 0) {
                if (s.length == 0) {
                    return 0;
                }
                return -1;
            }
            return o.lastIndexOf(s, i);
        }
        return o.lastIndexOf(s);
    }
    catch(err) {
        return -1;
    }
};

CORE.length = function(List__) {
    return p5str(List__[0]).length;
};

CORE.pack    = function(List__) { CORE.warn([ \"CORE::pack not implemented\" ]) };
CORE.unpack  = function(List__) { CORE.warn([ \"CORE::unpack not implemented\" ]) };

CORE.ref = function(List__) {
    var o = List__[0];
    if (o == null) {
        return \"\";
    }
    if (o._class_ && typeof o._class_._ref_ === \"string\") {
        // blessed reference
        return o._class_._ref_;
    }
    if (typeof o._ref_ === \"string\") {
        // un-blessed reference
        return o._ref_;
    }
    if (typeof o === \"function\") {
        return \"CODE\";
    }
    return \"\";
};

CORE.split = function(List__, want) {
    var pattern = List__[0];
    var s       = p5str(List__[1]);
    var limit   = p5num(List__[2]);
    if (!want) {
        // scalar context
        return p5num(CORE.split(List__, 1));
    }
    if (limit == 0) {
        // strip trailing empty strings and undef
        var res = CORE.split([pattern, s, -1], 1);
        while (res.length && (res[res.length - 1] == '' || typeof res[res.length - 1] == \"undefined\") ) {
            res.pop()
        }
        return res;
    }
    if (s == '') {
        return []
    }
    // make sure pattern is a RegExp
    if (typeof pattern === \"object\" && (pattern instanceof RegExp)) {
        pattern = pattern.source;
    }
    else {
        pattern = p5str(pattern);
        if (pattern == \" \") {
            // single space string is special
            pattern = \"(?: |\\t|\\n)+\";
            s = s.replace(/^(?: |\\t|\\n)+/, \"\");
        }
    }
    // add \"g\", \"m\" modifiers
    var flags = \"g\";
    if (pattern.substr(0, 1) == \"^\" || pattern.substr(-1,1) == \"\$\") {
        flags = flags + \"m\";
    }
    pattern = new RegExp(pattern, flags);
    var res = [];
    var pos = 0;
    var count = 0;
    while (1) {
        if (limit > 0 && limit <= (count + 1)) {
            res.push(s.substr(pos));
            return res;
        }
        var m = pattern.exec(s);
        if (m === null) {
            // no match
            res.push(s.substr(pos));
            return res;
        }
        if (m[0].length == 0 && m.index == pos) {
            // pointer didn't move
            pattern.lastIndex = pattern.lastIndex + 1;
        }
        else {
            var part = s.substr(pos, m.index - pos);
            res.push(part);
            count++;
            pos = m.index + m[0].length;
            pattern.lastIndex = pos;
        }
        for (var i = 1; i < m.length ; i++) {
            res.push(m[i]);     // captured substrings; don't increment count
        }
    }
};


"
    }
    1
}
{
    package main;
    package Perlito5::JavaScript2::IO;
    sub Perlito5::JavaScript2::IO::emit_javascript2 {;
        return "//
//
// lib/Perlito5/JavaScript2/IO.js
//
// I/O functions for \"Perlito\" Perl5-in-JavaScript2
//
// AUTHORS
//
// Flavio Soibelmann Glock  fglock\@gmail.com
//
// COPYRIGHT
//
// Copyright 2009, 2010, 2011, 2012 by Flavio Soibelmann Glock and others.
//
// This program is free software; you can redistribute it and/or modify it
// under the same terms as Perl itself.
//
// See http://www.perl.com/perl/misc/Artistic.html

var isNode = typeof require != \"undefined\";
if (isNode) {

    var fs = require(\"fs\");

    p5typeglob_set(\"Perlito5::IO\", \"print\", function (filehandle, List__, p5want) {
        try {
            var v = filehandle;
            var pkg;
            if (CORE.ref([v])) {
                // looks like a filehandle
                pkg = v;
            }
            else {
                // looks like a package name
                pkg = p5make_package(v);
            }
            if (!pkg.file_handle) {
                pkg.file_handle = {};
            }
            var handle_id = pkg.file_handle.id;
            if (handle_id == 1) {
                for (var i = 0; i < List__.length; i++) {
                    process.stdout.write(p5str(List__[i]));
                }
            }
            else if (handle_id == 2) {
                for (var i = 0; i < List__.length; i++) {
                    process.stderr.write(p5str(List__[i]));
                }
            }
            else {
                for (var i = 0; i < List__.length; i++) {
                    fs.writeSync(handle_id, p5str(List__[i]));
                }
            }
            return 1;
        }
        catch(err) {
            p5pkg[\"main\"][\"v_!\"] = err;
            return '';
        }
    } );

    var p5_extra_buffer_size = 100;
    p5typeglob_set(\"Perlito5::IO\", \"read\", function (filehandle, List__, p5want) {
        try {
            var v = filehandle;
            var length = List__.shift();
            var pkg;
            if (CORE.ref([v])) {
                // looks like a filehandle
                pkg = v;
            }
            else {
                // looks like a package name
                pkg = p5make_package(v);
            }
            if (!pkg.file_handle) {
                pkg.file_handle = {};
            }
            var handle_id = pkg.file_handle.id;

            if (!pkg.file_handle.buffer) {
                // we don't have any data yet
                var length_wanted = length + 2 * p5_extra_buffer_size;
                var buffer = new Buffer(length_wanted);
                var bytes_read = fs.readSync(handle_id, buffer, 0, length_wanted, null);
                if (bytes_read < length_wanted) {
                    pkg.file_handle.buffer_eof = 1;
                }
                pkg.file_handle.buffer = buffer;
                pkg.file_handle.buffer_start = 0;
                pkg.file_handle.buffer_end = bytes_read;
                pkg.file_handle.buffer_length = pkg.file_handle.buffer_end;
            }
            else if (pkg.file_handle.buffer_length > (length + p5_extra_buffer_size)) {
                // we have enough data
            }
            else if (!pkg.file_handle.buffer_eof) {
                // we have some data; append more data to the internal buffer
                var length_wanted = length + 2 * p5_extra_buffer_size;
                var buffer = new Buffer(pkg.file_handle.buffer_length + length_wanted);
                pkg.file_handle.buffer.copy(buffer, 0, pkg.file_handle.buffer_start, pkg.file_handle.buffer_end);
                var bytes_read = fs.readSync(handle_id, buffer, pkg.file_handle.buffer_length, length_wanted, null);
                if (bytes_read < length_wanted) {
                    pkg.file_handle.buffer_eof = 1;
                }
                pkg.file_handle.buffer = buffer;
                pkg.file_handle.buffer_start = 0;
                pkg.file_handle.buffer_end = pkg.file_handle.buffer_length + bytes_read;
                pkg.file_handle.buffer_length = pkg.file_handle.buffer_end;
            }

            var s = pkg.file_handle.buffer.toString('utf-8', pkg.file_handle.buffer_start, pkg.file_handle.buffer_end).substr(0, length);

            // how many bytes we actually used
            var buffer_used = Buffer.byteLength(s, 'utf-8');

            pkg.file_handle.buffer_start = pkg.file_handle.buffer_start + buffer_used;
            pkg.file_handle.buffer_length = pkg.file_handle.buffer_length - buffer_used;

            if ( handle_id == 0) {
                // STDIN
                pkg.file_handle.buffer_eof = (s.length ? 0 : 1);
                pkg.file_handle.eof = (s.length ? 0 : 1);
            }
            else if ( pkg.file_handle.buffer_eof && pkg.file_handle.buffer_length <= 0 ) {
                pkg.file_handle.eof = 1;
            }

            return [s.length, s];
        }
        catch(err) {
            p5pkg[\"main\"][\"v_!\"] = err;
            return [];
        }
    } );

    var p5ARGV = 0;
    (function (f) {
        p5typeglob_set(\"Perlito5::IO\", \"readline\", f);
        p5typeglob_set(\"Perlito5::IO\", \"getline\", f);
    })(function (List__, p5want) {
        var filehandle = List__.shift();

        if (p5want) {
            var out = [];
            while (1) {
                var s = p5pkg[\"Perlito5::IO\"].readline([filehandle], 0);
                if (s == null) {
                    return out;
                }
                out.push(s);
            }
        }

        var v = filehandle;
        var pkg;
        if (CORE.ref([v])) {
            // looks like a filehandle
            pkg = v;
        }
        else {
            // looks like a package name
            pkg = p5make_package(v);
            if (v == \"ARGV\") {
                // ARGV is magical
                if (pkg.file_handle.id == null) {
                    if (!p5ARGV) {
                        if (p5pkg[\"main\"][\"List_ARGV\"].length == 0) {
                            p5pkg[\"main\"][\"List_ARGV\"].push('-');
                        }
                    }
                    p5ARGV = 1;
                    // TODO - open \$ARGV[1], ...
                    var filename = p5pkg[\"main\"][\"List_ARGV\"].shift();
                    CORE.open([ \"ARGV\", \"<\", filename ]) || CORE.die([ p5pkg[\"main\"][\"v_!\"] ]);
                }
            }
        }
        if (!pkg.file_handle) {
            pkg.file_handle = {};
        }

        if (CORE.eof([v])) {
            return null;
        }

        var separator = p5pkg[\"main\"][\"v_/\"];  // input record separator
        var buf = pkg.file_handle.readline_buffer;
        var pos;

        if (separator) {
            pos = buf.indexOf(separator);
            while ( pos < 0 && !pkg.file_handle.eof ) {
                var r = p5pkg[\"Perlito5::IO\"].read(filehandle, [100]);
                buf = buf + r[1];
                pos = buf.indexOf(separator);
            }
        }
        else {
            // no separator
            pos = -1;
            while ( !pkg.file_handle.eof ) {
                var r = p5pkg[\"Perlito5::IO\"].read(filehandle, [100]);
                buf = buf + r[1];
            }
        }

        if (pos < 0) {
            pkg.file_handle.readline_buffer = '';
            if (!buf.length) {
                pkg.file_handle.readline_buffer = '';
                pkg.file_handle.eof = 1;
                return null
            }
            return buf;
        }
        var s = buf.substr(0, pos + separator.length);
        pkg.file_handle.readline_buffer = buf.substr(pos + separator.length);
        if (!s.length) {
            pkg.file_handle.readline_buffer = '';
            pkg.file_handle.eof = 1;
            return null
        }
        return s;
    });

    p5typeglob_set(\"Perlito5::IO\", \"close\", function (filehandle, List__, p5want) {
        try {
            var v = filehandle;
            var pkg;
            if (CORE.ref([v])) {
                // looks like a filehandle
                pkg = v;
            }
            else {
                // looks like a package name
                pkg = p5make_package(v);
            }
            if (!pkg.file_handle) {
                pkg.file_handle = {};
            }
            var handle_id = pkg.file_handle.id;
            if (handle_id == 1) {
                process.stdout.close();
            }
            else if (handle_id == 2) {
                process.stderr.close();
            }
            else {
                fs.closeSync(handle_id);
            }
            pkg.file_handle.id = null;
            return 1;
        }
        catch(err) {
            p5pkg[\"main\"][\"v_!\"] = err;
            return '';
        }
    } );

    CORE.eof = function(List__) {
        try {
            var filehandle = List__.shift();
            var v = filehandle;
            var pkg;
            if (CORE.ref([v])) {
                // looks like a filehandle
                pkg = v;
            }
            else {
                // looks like a package name
                pkg = p5make_package(v);
            }
            if (!pkg.file_handle) {
                pkg.file_handle = {};
            }
            var handle_id = pkg.file_handle.id;
            if (handle_id == null) {
                return 1;  // file is not open
            }
            return pkg.file_handle.eof && pkg.file_handle.readline_buffer.length == 0;
        }
        catch(err) {
            p5pkg[\"main\"][\"v_!\"] = err;
            return '';
        }
    };

    CORE.open = function(List__) {
        try {
            var filehandle = List__.shift();
            var flags = List__.shift();
            var path;
            if (List__.length) {
                path = List__.shift();
            }
            else {
                // 2-argument open
                var re = new RegExp(\"^([<>+|]*)(.*)\$\", \"\");
                var capture = re.exec(flags);
                flags = capture[1];
                path = capture[2];
            }
            var v = filehandle;
            var pkg;
            if (CORE.ref([v])) {
                // looks like a filehandle
                pkg = v;
            }
            else {
                // looks like a package name
                pkg = p5make_package(v);
                if (path == \"-\") {
                    if (flags == '>' || flags == '>>' || flags == '+>' || flags == '+>>') {
                        pkg.file_handle = p5pkg[\"STDOUT\"].file_handle;
                    }
                    else {
                        pkg.file_handle = p5pkg[\"STDIN\"].file_handle;
                    }
                }
            }
            if (!pkg.file_handle) {
                pkg.file_handle = {};
            }
            var handle_id = pkg.file_handle.id;
            if (handle_id != null) {
                if (handle_id < 2) {
                    return 1;   // STDIN, STDOUT, STDERR
                }
                p5pkg[\"Perlito5::IO\"].close(filehandle, []);
            }
            if (flags == '>') {
                flags = 'w'
            }
            else if (flags == '>>') {
                flags = 'a'
            }
            else if (flags == '<' || flags == '' || flags == '<:encoding(UTF-8)') {
                flags = 'r'
            }
            else if (flags == '+>') {
                flags = 'w+'
            }
            else if (flags == '+>>') {
                flags = 'a+'
            }
            else if (flags == '+<') {
                flags = 'r+'
            }
            else {
                CORE.die([ \"don't know what to do with MODE '\", flags, \"'\" ]);
            }
            var id = fs.openSync(path, flags);
            pkg.file_handle = { id : id, readline_buffer : '' };
            return 1;
        }
        catch(err) {
            p5pkg[\"main\"][\"v_!\"] = err;
            return '';
        }
    };

    var p5atime = function(s) {
        try {
            var stat = fs.statSync(s); return stat[\"atime\"];
        }
        catch(err) {
            return '';
        }
    };
    var p5mtime = function(s) {
        try {
            var stat = fs.statSync(s); return stat[\"mtime\"];
        }
        catch(err) {
            return '';
        }
    };
    var p5ctime = function(s) {
        try {
            var stat = fs.statSync(s); return stat[\"ctime\"];
        }
        catch(err) {
            return '';
        }
    };
    var p5size = function(s) {
        try {
            var stat = fs.statSync(s); return stat[\"size\"];
        }
        catch(err) {
            return '';
        }
    };
    var p5is_file = function(s) {
        try {
            var stat = fs.statSync(s); return stat.isFile() ? 1 : 0;
        }
        catch(err) {
            return '';
        }
    };
    var p5is_directory = function(s) {
        try {
            var stat = fs.statSync(s); return stat.isDirectory() ? 1 : 0;
        }
        catch(err) {
            return '';
        }
    };
    var p5file_exists = function(s) {
        return p5is_file(s) || p5is_directory(s);
    };
    var p5is_pipe = function(s) {
        try {
            var stat = fs.statSync(s);
            return stat.isFIFO() ? 1 : \"\";
        }
        catch(err) {
            try {
                var filehandle = s;
                var v = filehandle;
                var pkg;
                if (CORE.ref([v])) {
                    // looks like a filehandle
                    pkg = v;
                }
                else {
                    // looks like a package name
                    pkg = p5make_package(v);
                }
                if (!pkg.file_handle) {
                    pkg.file_handle = {};
                }
                var handle_id = pkg.file_handle.id;
                if (handle_id == 0) {
                    return process.stdin.isTTY ? \"\" : 1;
                }
                else if (handle_id == 1) {
                    return process.stdout.isTTY ? \"\" : 1;
                }
                else if (handle_id == 2) {
                    return process.stderr.isTTY ? \"\" : 1;
                }
            }
            catch(err) {
            }
        }
        return '';
    };

    CORE.binmode = function(List__) {
        try {
            // TODO
            return 1;
        }
        catch(err) {
            p5pkg[\"main\"][\"v_!\"] = err;
            return '';
        }
    };

    CORE.rmdir = function(List__) {
        try {
            fs.rmdir(p5str(List__[0]));
            return 1;
        }
        catch(err) {
            p5pkg[\"main\"][\"v_!\"] = err;
            return '';
        }
    };

    CORE.chdir = function(List__) {
        try {
            process.chdir(p5str(List__[0]));
            return 1;
        }
        catch(err) {
            p5pkg[\"main\"][\"v_!\"] = err;
            return '';
        }
    };

    CORE.exit = function(List__) {
        process.exit(List__[0]);
    };

    CORE.rename = function(List__) {
        try {
            fs.renameSync(p5str(List__[0]), p5str(List__[1]));
            return 1;
        }
        catch(err) {
            p5pkg[\"main\"][\"v_!\"] = err;
            return '';
        }
    };

    CORE.unlink = function(List__) {
        var count = 0;
        try {
            for(var i = 0; i < List__.length; i++) {
                fs.unlinkSync(p5str(List__[i]));
                count++;
            }
            return count;
        }
        catch(err) {
            p5pkg[\"main\"][\"v_!\"] = err;
            return count;
        }
    };

} else {
    // not running in node.js
    p5typeglob_set(\"Perlito5::IO\", \"print\", function (filehandle, List__, p5want) {
        var s = \"\";
        for (var i = 0; i < List__.length; i++) {
            s = s + p5str(List__[i]);
        }
        if (console && typeof console.log === 'function') {
            console.log(s);
        }
        else if (typeof write === 'function') {
            // d8 shell uses \"write\"
            write(s);
        }
        else if (typeof print === 'function') {
            // Rhino uses \"print\"
            print(s);
        }
        else {
            alert(s);
        }
        return 1;
    });
}

p5typeglob_set(\"Perlito5::IO\", \"say\", function (filehandle, List__, p5want) {
    p5pkg['Perlito5::IO'].print( filehandle, List__);
    p5pkg['Perlito5::IO'].print( filehandle, [\"\\n\"]);
    return 1;
} );
p5typeglob_set(\"Perlito5::IO\", \"printf\", function (filehandle, List__, p5want) {
    p5pkg[\"Perlito5::IO\"].print( filehandle, CORE.sprintf(List__));
    return 1;
} );

CORE.select = function(List__) {
    if (List__.length == 1) {
        var v = List__[0];
        p5pkg[\"Perlito5\"].v_SELECT = v;
    }
    return p5pkg[\"Perlito5\"].v_SELECT;
};

CORE.die = function(List__) {
    var i;
    var s = \"\";
    for (var i = 0; i < List__.length; i++) {
        s = s + p5str(List__[i]);
    }
    if (s.substr(-1, 1) != \"\\n\") {
        try {
            if (s == \"\") {
                s = \"Died\";
            }
            s = s + \" at \" + p5pkg[\"Perlito5\"].v_FILE_NAME + \" line \" + p5pkg[\"Perlito5\"].v_LINE_NUMBER;
            s = s + \"\\n\" + new Error().stack + \"\\n\";
        }
        catch(err) { }
    }
    p5pkg[\"main\"][\"v_\@\"] = s;
    throw(new p5_error(\"die\", s));
};

CORE.say = function(List__) {
    return p5pkg['Perlito5::IO'].say( 'STDOUT', List__);
};
CORE.print = function(List__) {
    return p5pkg['Perlito5::IO'].print( 'STDOUT', List__);
};
CORE.printf = function(List__) {
    return p5pkg['Perlito5::IO'].printf( 'STDOUT', List__);
};
CORE.readline = function(List__, p5want) {
    return p5pkg['Perlito5::IO'].readline(List__, p5want);
};

CORE.warn = function(List__) {
    var i;
    var s = \"\";
    for (var i = 0; i < List__.length; i++) {
        s = s + p5str(List__[i]);
    }
    if (s.substr(-1, 1) != \"\\n\") {
        try {
            if (s == \"\") {
                s = \"Warning: something's wrong\";
            }
            s = s + \" at \" + p5pkg[\"Perlito5\"].v_FILE_NAME + \" line \" + p5pkg[\"Perlito5\"].v_LINE_NUMBER;
            s = s + \"\\n\" + new Error().stack + \"\\n\";
        }
        catch(err) { }
    }
    p5pkg['Perlito5::IO'].print( 'STDERR', [s]);
};


"
    }
    1
}
{
    package main;
    package Perlito5::JavaScript2::Sprintf;
    sub Perlito5::JavaScript2::Sprintf::emit_javascript2 {;
        return "/**
 * Copyright (c) 2010 Jakob Westhoff
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the \"Software\"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

CORE.sprintf = function(List__) {
    var format = List__.shift();
    var list = List__;

    // Check for format definition
    if ( typeof format != 'string' ) {
        CORE.die([\"sprintf: The first arguments need to be a valid format string.\"]);
    }
    
    /**
     * Define the regex to match a formating string
     * The regex consists of the following parts:
     * percent sign to indicate the start
     * (optional) sign specifier
     * (optional) padding specifier
     * (optional) alignment specifier
     * (optional) width specifier
     * (optional) precision specifier
     * type specifier:
     *  % - literal percent sign
     *  b - binary number
     *  c - ASCII character represented by the given value
     *  d - signed decimal number
     *  f - floating point value
     *  o - octal number
     *  s - string
     *  x - hexadecimal number (lowercase characters)
     *  X - hexadecimal number (uppercase characters)
     */
    var r = new RegExp( /%(\\+)?([0 ]|'(.))?(-)?([0-9]+)?(\\.([0-9]+))?([%bcdfosxX])/g );

    /**
     * Each format string is splitted into the following parts:
     * 0: Full format string
     * 1: sign specifier (+)
     * 2: padding specifier (0/<space>/'<any char>)
     * 3: if the padding character starts with a ' this will be the real 
     *    padding character
     * 4: alignment specifier
     * 5: width specifier
     * 6: precision specifier including the dot
     * 7: precision specifier without the dot
     * 8: type specifier
     */
    var parts      = [];
    var paramIndex = 0;
    var part;
    while ( part = r.exec( format ) ) {
        // Check if an input value has been provided, for the current
        // format string
        if ( paramIndex >= list.length ) {
            CORE.die([\"sprintf: At least one argument was missing.\"]);
        }

        parts[parts.length] = {
            /* beginning of the part in the string */
            begin: part.index,
            /* end of the part in the string */
            end: part.index + part[0].length,
            /* force sign */
            sign: ( part[1] == '+' ),
            /* is the given data negative */
            negative: ( parseInt( list[paramIndex] ) < 0 ) ? true : false,
            /* padding character (default: <space>) */
            padding: ( part[2] == undefined )
                     ? ( ' ' ) /* default */
                     : ( ( part[2].substring( 0, 1 ) == \"'\" ) 
                         ? ( part[3] ) /* use special char */
                         : ( part[2] ) /* use normal <space> or zero */
                       ),
            /* should the output be aligned left?*/
            alignLeft: ( part[4] == '-' ),
            /* width specifier (number or false) */
            width: ( part[5] != undefined ) ? part[5] : false,
            /* precision specifier (number or false) */
            precision: ( part[7] != undefined ) ? part[7] : false,
            /* type specifier */
            type: part[8],
            /* the given data associated with this part converted to a string */
            data: ( part[8] != '%' ) ? String ( list[paramIndex++] ) : false
        };
    }

    var newString = \"\";
    var start = 0;
    // Generate our new formated string
    for( var i=0; i<parts.length; ++i ) {
        // Add first unformated string part
        newString += format.substring( start, parts[i].begin );
        
        // Mark the new string start
        start = parts[i].end;

        // Create the appropriate preformat substitution
        // This substitution is only the correct type conversion. All the
        // different options and flags haven't been applied to it at this
        // point
        var preSubstitution = \"\";
        switch ( parts[i].type ) {
            case '%':
                preSubstitution = \"%\";
            break;
            case 'b':
                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 2 );
            break;
            case 'c':
                preSubstitution = String.fromCharCode( Math.abs( parseInt( parts[i].data ) ) );
            break;
            case 'd':
                preSubstitution = String( Math.abs( parseInt( parts[i].data ) ) );
            break;
            case 'f':
                preSubstitution = ( parts[i].precision == false )
                                  ? ( String( ( Math.abs( parseFloat( parts[i].data ) ) ) ) )
                                  : ( Math.abs( parseFloat( parts[i].data ) ).toFixed( parts[i].precision ) );
            break;
            case 'o':
                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 8 );
            break;
            case 's':
                preSubstitution = parts[i].data.substring( 0, parts[i].precision ? parts[i].precision : parts[i].data.length ); /* Cut if precision is defined */
            break;
            case 'x':
                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 16 ).toLowerCase();
            break;
            case 'X':
                preSubstitution = Math.abs( parseInt( parts[i].data ) ).toString( 16 ).toUpperCase();
            break;
            default:
                throw 'sprintf: Unknown type \"' + parts[i].type + '\" detected. This should never happen. Maybe the regex is wrong.';
        }

        // The % character is a special type and does not need further processing
        if ( parts[i].type ==  \"%\" ) {
            newString += preSubstitution;
            continue;
        }

        // Modify the preSubstitution by taking sign, padding and width
        // into account

        // Pad the string based on the given width
        if ( parts[i].width != false ) {
            // Padding needed?
            if ( parts[i].width > preSubstitution.length ) 
            {
                var origLength = preSubstitution.length;
                for( var j = 0; j < parts[i].width - origLength; ++j ) 
                {
                    preSubstitution = ( parts[i].alignLeft == true ) 
                                      ? ( preSubstitution + parts[i].padding )
                                      : ( parts[i].padding + preSubstitution );
                }
            }
        }

        // Add a sign symbol if neccessary or enforced, but only if we are
        // not handling a string
        if ( parts[i].type == 'b' 
          || parts[i].type == 'd' 
          || parts[i].type == 'o' 
          || parts[i].type == 'f' 
          || parts[i].type == 'x' 
          || parts[i].type == 'X' ) {
            if ( parts[i].negative == true ) {
                preSubstitution = \"-\" + preSubstitution;
            }
            else if ( parts[i].sign == true ) {
                preSubstitution = \"+\" + preSubstitution;
            }
        }

        // Add the substitution to the new string
        newString += preSubstitution;
    }

    // Add the last part of the given format string, which may still be there
    newString += format.substring( start, format.length );

    return newString;
};

"
    }
    1
}
{
    package main;
    package Perlito5::Perl5;
    {
        sub Perlito5::Perl5::escape_string {;
            return Perlito5::Dumper::escape_string($_[0])
        }
        sub Perlito5::Perl5::emit_perl5_block {
            my $block = $_[0];
            return ["block", map {;
                defined($_) && $_->emit_perl5()
            } @{$block}]
        }
    }
    package Perlito5::AST::CompUnit;
    {
        sub Perlito5::AST::CompUnit::emit_perl5 {
            my $self = $_[0];
            return ["block", (["stmt", ["keyword", "package"], ["bareword", $self->{"name"}]], map {;
                defined($_) && $_->emit_perl5()
            } @{$self->{"body"}})]
        }
        sub Perlito5::AST::CompUnit::emit_perl5_program {
            my $comp_units = $_[0];
            return ["comment", Perlito5::Compiler::do_not_edit("#")], map {;
                $_->emit_perl5()
            } map {;
                ref($_) eq "ARRAY" ? @{$_} : $_
            } @{$comp_units}
        }
    }
    package Perlito5::AST::Int;
    {;
        sub Perlito5::AST::Int::emit_perl5 {
            my $self = $_[0];
            ["number", $self->{"int"}]
        }
    }
    package Perlito5::AST::Num;
    {;
        sub Perlito5::AST::Num::emit_perl5 {
            my $self = $_[0];
            ["number", $self->{"num"}]
        }
    }
    package Perlito5::AST::Buf;
    {;
        sub Perlito5::AST::Buf::emit_perl5 {
            my $self = $_[0];
            if ($self->{"is_vstring"}) {;
                return join(".", map {;
                    ord($_)
                } split(m//, $self->{"buf"}))
            }
            Perlito5::Perl5::escape_string($self->{"buf"})
        }
    }
    package Perlito5::AST::Block;
    {;
        sub Perlito5::AST::Block::emit_perl5 {
            my $self = $_[0];
            my @out;
            $self->{"label"} && push(@out, ["label", $self->{"label"}]);
            if ($self->{"name"}) {;
                push(@out, ["stmt", ["keyword", $self->{"name"}], Perlito5::Perl5::emit_perl5_block($self->{"stmts"})])
            }
            else {;
                push(@out, Perlito5::Perl5::emit_perl5_block($self->{"stmts"}))
            }
            if ($self->{"continue"} && @{$self->{"continue"}->{"stmts"}}) {;
                push(@out, ["stmt", ["keyword", "continue"], Perlito5::Perl5::emit_perl5_block($self->{"continue"}->{"stmts"})])
            }
            return @out
        }
    }
    package Perlito5::AST::Index;
    {;
        sub Perlito5::AST::Index::emit_perl5 {
            my $self = $_[0];
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\@>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && ($self->{"obj"}->sigil() eq "\$" || $self->{"obj"}->sigil() eq "\@"))) {;
                return ["apply", "[", $self->{"obj"}->emit_perl5(), $self->{"index_exp"}->emit_perl5()]
            }
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<%>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && ($self->{"obj"}->sigil() eq "%"))) {;
                return ["apply", "[", $self->{"obj"}->emit_perl5(), $self->{"index_exp"}->emit_perl5()]
            }
            if ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\$>") {;
                return ["op", "infix:<->>", $self->{"obj"}->{"arguments"}->[0]->emit_perl5(), ["op", "circumfix:<[ ]>", $self->{"index_exp"}->emit_perl5()]]
            }
            return ["op", "infix:<->>", $self->{"obj"}->emit_perl5(), ["op", "circumfix:<[ ]>", $self->{"index_exp"}->emit_perl5()]]
        }
    }
    package Perlito5::AST::Lookup;
    {;
        sub Perlito5::AST::Lookup::emit_perl5 {
            my $self = $_[0];
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\@>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && ($self->{"obj"}->sigil() eq "\$" || $self->{"obj"}->sigil() eq "\@"))) {;
                return ["apply", "{", $self->{"obj"}->emit_perl5(), $self->autoquote($self->{"index_exp"})->emit_perl5()]
            }
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<%>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && ($self->{"obj"}->sigil() eq "%"))) {;
                return ["apply", "{", $self->{"obj"}->emit_perl5(), $self->autoquote($self->{"index_exp"})->emit_perl5()]
            }
            if ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\$>") {;
                return ["op", "infix:<->>", $self->{"obj"}->{"arguments"}->[0]->emit_perl5(), ["op", "circumfix:<{ }>", $self->autoquote($self->{"index_exp"})->emit_perl5()]]
            }
            return ["op", "infix:<->>", $self->{"obj"}->emit_perl5(), ["op", "circumfix:<{ }>", $self->autoquote($self->{"index_exp"})->emit_perl5()]]
        }
    }
    package Perlito5::AST::Var;
    {;
        sub Perlito5::AST::Var::emit_perl5 {
            my $self = $_[0];
            my $str_name = $self->{"name"};
            my $c = substr($str_name, 0, 1);
            if ($c lt " " && $self->{"sigil"} ne "::") {;
                return $self->{"sigil"} . "{^" . chr(ord($c) + ord("A") - 1) . substr($str_name, 1) . "}"
            }
            my $ns = '';
            if ($self->{"namespace"}) {
                $self->{"sigil"} eq "::" && return $self->{"namespace"} . "::";
                if ($self->{"namespace"} eq "main" && substr($str_name, 0, 1) eq "^") {;
                    return $self->{"sigil"} . "{" . $str_name . "}"
                }
                else {;
                    $ns = $self->{"namespace"} . "::"
                }
            }
            if (($c ge "a" && $c le "z") || ($c ge "A" && $c le "Z") || ($c eq "_") || ($str_name eq "/" || $str_name eq "&") || ((0 + $str_name) eq $str_name)) {;
                return $self->{"sigil"} . $ns . $str_name
            }
            return $self->{"sigil"} . "{" . Perlito5::Perl5::escape_string($ns . $str_name) . "}"
        }
    }
    package Perlito5::AST::Call;
    {;
        sub Perlito5::AST::Call::emit_perl5 {
            my $self = $_[0];
            my $invocant = $self->{"invocant"}->emit_perl5();
            if ($self->{"method"} eq "postcircumfix:<[ ]>") {;
                return ["op", "infix:<->>", $invocant, ["op", "circumfix:<[ ]>", $self->{"arguments"}->emit_perl5()]]
            }
            if ($self->{"method"} eq "postcircumfix:<{ }>") {;
                return ["op", "infix:<->>", $invocant, ["op", "circumfix:<{ }>", Perlito5::AST::Lookup::->autoquote($self->{"arguments"})->emit_perl5()]]
            }
            my $meth = $self->{"method"};
            if ($meth eq "postcircumfix:<( )>") {;
                $meth = ''
            }
            if (ref($meth) eq "Perlito5::AST::Var") {;
                $meth = $meth->emit_perl5()
            }
            if ($meth) {;
                return ["call", $invocant, $meth, map {;
                    $_->emit_perl5()
                } @{$self->{"arguments"}}]
            }
            return ["op", "infix:<->>", $invocant, ["op", "list:<,>", map {;
                $_->emit_perl5()
            } @{$self->{"arguments"}}]]
        }
    }
    package Perlito5::AST::Apply;
    {
        sub Perlito5::AST::Apply::emit_perl5_args {
            my $self = $_[0];
            !$self->{"arguments"} && return ();
            return map {;
                $_->emit_perl5()
            } @{$self->{"arguments"}}
        }
        sub Perlito5::AST::Apply::emit_perl5_choose_regex_quote {
            if (!(grep {;
                $_ =~ m!\/!
            } @_)) {;
                return "/"
            }
            if (!(grep {;
                $_ =~ m/!/
            } @_)) {;
                return "!"
            }
            if (!(grep {;
                $_ =~ m/%/
            } @_)) {;
                return "%"
            }
            if (!(grep {;
                $_ =~ m/:/
            } @_)) {;
                return ":"
            }
            if (!(grep {;
                $_ =~ m/;/
            } @_)) {;
                return ";"
            }
            return "^"
        }
        sub Perlito5::AST::Apply::emit_perl5_regex_expression {
            my $ast = $_[0];
            if ($ast->isa("Perlito5::AST::Buf")) {
                my $replace = $ast->{"buf"};
                return $replace
            }
            if ($ast->isa("Perlito5::AST::Apply") && $ast->{"code"} eq "list:<.>") {
                my $s = '';
                for my $a (@{$ast->{"arguments"}}) {;
                    $s .= emit_perl5_regex_expression($a)
                }
                return $s
            }
            my $out = [];
            Perlito5::Perl5::PrettyPrinter::pretty_print([$ast->emit_perl5()], 0, $out);
            my $code = join('', @{$out});
            chomp($code);
            return $code
        }
        sub Perlito5::AST::Apply::emit_perl5 {
            my $self = $_[0];
            if (ref($self->{"code"})) {
                my $code = $self->{"code"};
                if (ref($code) eq "Perlito5::AST::Apply" && $code->code() eq "prefix:<&>") {;
                    return ["apply", "(", $code->emit_perl5(), $self->emit_perl5_args()]
                }
                return ["op", "infix:<->>", $self->{"code"}->emit_perl5(), $self->emit_perl5_args()]
            }
            if ($self->{"code"} eq "infix:<=>>") {;
                return ["op", $self->{"code"}, Perlito5::AST::Lookup::->autoquote($self->{"arguments"}->[0])->emit_perl5(), $self->{"arguments"}->[1]->emit_perl5()]
            }
            if ($self->{"namespace"} eq "Perlito5") {;
                if ($self->{"code"} eq "eval_ast") {;
                    $self->{"namespace"} = "Perlito5::Perl5::Runtime"
                }
            }
            my $ns = '';
            if ($self->{"namespace"}) {;
                $ns = $self->{"namespace"} . "::"
            }
            my $code = $ns . $self->{"code"};
            if ($code eq "circumfix:<{ }>" && @{$self->{"arguments"}} == 1) {;
                return ["op", $code, $self->{"arguments"}->[0]->emit_perl5(), '']
            }
            if ($code eq "prefix:<\$>" || $code eq "prefix:<\@>" || $code eq "prefix:<%>" || $code eq "prefix:<&>" || $code eq "prefix:<*>" || $code eq "prefix:<\$#>") {
                my $arg = $self->{"arguments"}->[0];
                if (ref($arg) eq "Perlito5::AST::Apply" && $arg->{"code"} eq "do") {
                    my $arg = $arg->{"arguments"}->[0];
                    if (ref($arg) eq "Perlito5::AST::Block") {;
                        return ["op", $code, $arg->emit_perl5()]
                    }
                }
                $code =~ m/<([^>]+)>/;
                my $cap = $1;
                return ["apply", "{", $cap, $arg->emit_perl5()]
            }
            if (($code eq "eval" || $code eq "do") && ref($self->{"arguments"}->[0]) eq "Perlito5::AST::Block") {;
                return ["op", "prefix:<" . $code . ">", $self->{"arguments"}->[0]->emit_perl5()]
            }
            if ($Perlito5::Perl5::PrettyPrinter::op{$self->{"code"}}) {;
                return ["op", $self->{"code"}, $self->emit_perl5_args()]
            }
            if ($self->{"code"} eq "p5:s") {
                my $replace0 = emit_perl5_regex_expression($self->{"arguments"}->[0]);
                my $replace1 = emit_perl5_regex_expression($self->{"arguments"}->[1]);
                my $q = emit_perl5_choose_regex_quote($replace0, $replace1, $self->{"arguments"}->[2]->{"buf"});
                return "s" . $q . $replace0 . $q . $replace1 . $q . $self->{"arguments"}->[2]->{"buf"}
            }
            if ($self->{"code"} eq "p5:m") {
                my $replace0 = emit_perl5_regex_expression($self->{"arguments"}->[0]);
                my $q = emit_perl5_choose_regex_quote($replace0, $self->{"arguments"}->[1]->{"buf"});
                return "m" . $q . $replace0 . $q . $self->{"arguments"}->[1]->{"buf"}
            }
            if ($self->{"code"} eq "p5:tr") {
                my $replace0 = emit_perl5_regex_expression($self->{"arguments"}->[0]);
                my $replace1 = emit_perl5_regex_expression($self->{"arguments"}->[1]);
                my $q = emit_perl5_choose_regex_quote($replace0, $replace1, $self->{"arguments"}->[2]->{"buf"});
                return "tr" . $q . $replace0 . $q . $replace1 . $q . $self->{"arguments"}->[2]->{"buf"}
            }
            if ($self->{"code"} eq "p5:qr") {
                my $replace0 = emit_perl5_regex_expression($self->{"arguments"}->[0]);
                my $q = emit_perl5_choose_regex_quote($replace0, $self->{"arguments"}->[1]->{"buf"});
                return "qr" . $q . $replace0 . $q . $self->{"arguments"}->[1]->{"buf"}
            }
            if ($self->{"code"} eq "package") {;
                return ["stmt", "package", ["bareword", $self->{"namespace"}]]
            }
            if ($code eq "map" || $code eq "grep" || $code eq "sort" || $code eq "print" || $code eq "use") {
                if ($self->{"special_arg"}) {;
                    return ["op", "prefix:<" . $code . ">", $self->{"special_arg"}->emit_perl5(), ["op", "list:<,>", $self->emit_perl5_args()]]
                }
                return ["apply", "(", $code, $self->emit_perl5_args()]
            }
            if ($code eq "readline") {;
                return ["paren", "<", $self->emit_perl5_args()]
            }
            $self->{"ignore_proto"} && ($code = "&" . $code);
            if ($self->{"bareword"} && !@{$self->{"arguments"}}) {
                my $effective_name = ($self->{"namespace"} || $Perlito5::PKG_NAME) . "::" . $self->{"code"};
                if (exists($Perlito5::PROTO->{$effective_name})) {;
                    $code = $effective_name
                }
                else {;
                    return ["bareword", $code]
                }
            }
            return ["apply", "(", $code, $self->emit_perl5_args()]
        }
    }
    package Perlito5::AST::If;
    {;
        sub Perlito5::AST::If::emit_perl5 {
            my $self = $_[0];
            if ($self->{"body"} && ref($self->{"body"}) ne "Perlito5::AST::Block") {;
                return ["stmt_modifier", $self->{"body"}->emit_perl5(), ["stmt", "if", $self->{"cond"}->emit_perl5()]]
            }
            if ($self->{"otherwise"} && ref($self->{"otherwise"}) ne "Perlito5::AST::Block") {;
                return ["stmt_modifier", $self->{"otherwise"}->emit_perl5(), ["stmt", "unless", $self->{"cond"}->emit_perl5()]]
            }
            my @out = (["stmt", ["keyword", "if"], ["paren", "(", $self->{"cond"}->emit_perl5()], Perlito5::Perl5::emit_perl5_block($self->{"body"}->stmts())]);
            my $otherwise = $self->{"otherwise"};
            while ($otherwise && @{$otherwise->{"stmts"}} == 1 && ref($otherwise->{"stmts"}->[0]) eq "Perlito5::AST::If" && ($otherwise->{"stmts"}->[0]->{"body"} && ref($otherwise->{"stmts"}->[0]->{"body"}) eq "Perlito5::AST::Block")) {
                push(@out, ["stmt", ["keyword", "elsif"], ["paren", "(", $otherwise->{"stmts"}->[0]->{"cond"}->emit_perl5()], Perlito5::Perl5::emit_perl5_block($otherwise->{"stmts"}->[0]->{"body"}->{"stmts"})]);
                $otherwise = $otherwise->{"stmts"}->[0]->{"otherwise"}
            }
            !($otherwise && scalar(@{$otherwise->stmts()})) && return @out;
            push(@out, ["stmt", ["keyword", "else"], Perlito5::Perl5::emit_perl5_block($otherwise->stmts())]);
            return @out
        }
    }
    package Perlito5::AST::When;
    {;
        sub Perlito5::AST::When::emit_perl5 {
            my $self = $_[0];
            return ["stmt", ["keyword", "when"], ["paren", "(", $self->{"cond"}->emit_perl5()], Perlito5::Perl5::emit_perl5_block($self->{"body"}->stmts())]
        }
    }
    package Perlito5::AST::While;
    {;
        sub Perlito5::AST::While::emit_perl5 {
            my $self = $_[0];
            my @out;
            $self->{"label"} && push(@out, ["label", $self->{"label"}]);
            if ($self->{"body"} && ref($self->{"body"}) ne "Perlito5::AST::Block") {;
                return @out, ["stmt_modifier", $self->{"body"}->emit_perl5(), ["stmt", ["keyword", "while"], $self->{"cond"}->emit_perl5()]]
            }
            push(@out, ["stmt", ["keyword", "while"], ["paren", "(", $self->{"cond"}->emit_perl5()], Perlito5::Perl5::emit_perl5_block($self->{"body"}->stmts())]);
            if ($self->{"continue"} && @{$self->{"continue"}->{"stmts"}}) {;
                push(@out, ["stmt", ["keyword", "continue"], Perlito5::Perl5::emit_perl5_block($self->{"continue"}->{"stmts"})])
            }
            return @out
        }
    }
    package Perlito5::AST::For;
    {;
        sub Perlito5::AST::For::emit_perl5 {
            my $self = $_[0];
            my @out;
            $self->{"label"} && push(@out, ["label", $self->{"label"}]);
            if ($self->{"body"} && ref($self->{"body"}) ne "Perlito5::AST::Block") {;
                return @out, ["stmt_modifier", $self->{"body"}->emit_perl5(), ["stmt", "for", $self->{"cond"}->emit_perl5()]]
            }
            my $cond;
            if (ref($self->{"cond"}) eq "ARRAY") {;
                $cond = ["paren_semicolon", "(", ($self->{"cond"}->[0] ? $self->{"cond"}->[0]->emit_perl5() : []), ($self->{"cond"}->[1] ? $self->{"cond"}->[1]->emit_perl5() : []), ($self->{"cond"}->[2] ? $self->{"cond"}->[2]->emit_perl5() : [])]
            }
            else {;
                $cond = ["paren", "(", $self->{"cond"}->emit_perl5()]
            }
            my @sig;
            my $sig_ast = $self->{"topic"};
            if (!$sig_ast) {}
            else {;
                @sig = $sig_ast->emit_perl5()
            }
            push(@out, ["stmt", ["keyword", "for"], @sig, $cond, Perlito5::Perl5::emit_perl5_block($self->{"body"}->stmts())]);
            if ($self->{"continue"} && @{$self->{"continue"}->{"stmts"}}) {;
                push(@out, ["stmt", ["keyword", "continue"], Perlito5::Perl5::emit_perl5_block($self->{"continue"}->{"stmts"})])
            }
            return @out
        }
    }
    package Perlito5::AST::Decl;
    {;
        sub Perlito5::AST::Decl::emit_perl5 {
            my $self = $_[0];
            return ["op", "prefix:<" . $self->{"decl"} . ">", ($self->{"type"} ? $self->{"type"} : ()), $self->{"var"}->emit_perl5()]
        }
    }
    package Perlito5::AST::Sub;
    {;
        sub Perlito5::AST::Sub::emit_perl5 {
            my $self = $_[0];
            my @sig;
            my @parts;
            defined($self->{"sig"}) && push(@sig, ["paren", "(", ["bareword", $self->{"sig"}]]);
            if (defined($self->{"block"})) {;
                push(@parts, Perlito5::Perl5::emit_perl5_block($self->{"block"}->{"stmts"}))
            }
            !$self->{"name"} && return ["op", "prefix:<sub>", @sig, @parts];
            return ["stmt", ["keyword", "sub"], ["bareword", $self->{"namespace"} . "::" . $self->{"name"}], @sig, @parts]
        }
    }
    1
}
{
    package main;
    package Perlito5::Perl5::PrettyPrinter;
    my %dispatch = ("stmt", sub {;
        statement(@_)
    }, "stmt_modifier", sub {;
        statement_modifier(@_)
    }, "block", sub {;
        block(@_)
    }, "keyword", sub {;
        keyword(@_)
    }, "bareword", sub {;
        bareword(@_)
    }, "number", sub {;
        number(@_)
    }, "op", sub {;
        op(@_)
    }, "paren", sub {;
        paren(@_)
    }, "paren_semicolon", sub {;
        paren_semicolon(@_)
    }, "apply", sub {;
        apply(@_)
    }, "call", sub {;
        call(@_)
    }, "comment", sub {;
        comment(@_)
    }, "label", sub {;
        label(@_)
    });
    my %pair = ("(", ")", "[", "]", "{", "}", "<", ">");
    our %op = ("prefix:<\$>", {"fix", "deref", "prec", 0, "str", "\$"}, "prefix:<\@>", {"fix", "deref", "prec", 0, "str", "\@"}, "prefix:<%>", {"fix", "deref", "prec", 0, "str", "%"}, "prefix:<&>", {"fix", "deref", "prec", 0, "str", "&"}, "prefix:<*>", {"fix", "deref", "prec", 0, "str", "*"}, "prefix:<\$#>", {"fix", "deref", "prec", 0, "str", "\$#"}, "circumfix:<[ ]>", {"fix", "circumfix", "prec", 0, "str", "["}, "circumfix:<{ }>", {"fix", "circumfix", "prec", 0, "str", "{"}, "circumfix:<( )>", {"fix", "circumfix", "prec", 0, "str", "("}, "infix:<->>", {"fix", "infix", "prec", -1, "str", "->"}, "prefix:<-->", {"fix", "prefix", "prec", 1, "str", "--"}, "prefix:<++>", {"fix", "prefix", "prec", 1, "str", "++"}, "postfix:<-->", {"fix", "postfix", "prec", 1, "str", "--"}, "postfix:<++>", {"fix", "postfix", "prec", 1, "str", "++"}, "infix:<**>", {"fix", "infix", "prec", 2, "str", "**"}, "prefix:<\\>", {"fix", "prefix", "prec", 3, "str", "\\"}, "prefix:<+>", {"fix", "prefix", "prec", 3, "str", "+"}, "prefix:<->", {"fix", "prefix", "prec", 3, "str", "-"}, "prefix:<~>", {"fix", "prefix", "prec", 3, "str", "~"}, "prefix:<!>", {"fix", "prefix", "prec", 3, "str", "!"}, "infix:<=~>", {"fix", "infix", "prec", 4, "str", " =~ "}, "infix:<!~>", {"fix", "infix", "prec", 4, "str", " !~ "}, "infix:<*>", {"fix", "infix", "prec", 5, "str", " * "}, "infix:</>", {"fix", "infix", "prec", 5, "str", " / "}, "infix:<%>", {"fix", "infix", "prec", 5, "str", " % "}, "infix:<x>", {"fix", "infix", "prec", 5, "str", " x "}, "infix:<+>", {"fix", "infix", "prec", 6, "str", " + "}, "infix:<->", {"fix", "infix", "prec", 6, "str", " - "}, "list:<.>", {"fix", "list", "prec", 6, "str", " . "}, "infix:<<<>", {"fix", "infix", "prec", 7, "str", " << "}, "infix:<>>>", {"fix", "infix", "prec", 7, "str", " >> "}, "infix:<lt>", {"fix", "infix", "prec", 9, "str", " lt "}, "infix:<le>", {"fix", "infix", "prec", 9, "str", " le "}, "infix:<gt>", {"fix", "infix", "prec", 9, "str", " gt "}, "infix:<ge>", {"fix", "infix", "prec", 9, "str", " ge "}, "infix:<<=>", {"fix", "infix", "prec", 9, "str", " <= "}, "infix:<>=>", {"fix", "infix", "prec", 9, "str", " >= "}, "infix:<<>", {"fix", "infix", "prec", 9, "str", " < "}, "infix:<>>", {"fix", "infix", "prec", 9, "str", " > "}, "infix:<<=>>", {"fix", "infix", "prec", 10, "str", " <=> "}, "infix:<cmp>", {"fix", "infix", "prec", 10, "str", " cmp "}, "infix:<==>", {"fix", "infix", "prec", 10, "str", " == "}, "infix:<!=>", {"fix", "infix", "prec", 10, "str", " != "}, "infix:<ne>", {"fix", "infix", "prec", 10, "str", " ne "}, "infix:<eq>", {"fix", "infix", "prec", 10, "str", " eq "}, "infix:<&>", {"fix", "infix", "prec", 11, "str", " & "}, "infix:<|>", {"fix", "infix", "prec", 12, "str", " | "}, "infix:<^>", {"fix", "infix", "prec", 12, "str", " ^ "}, "infix:<..>", {"fix", "infix", "prec", 13, "str", " .. "}, "infix:<...>", {"fix", "infix", "prec", 13, "str", " ... "}, "infix:<~~>", {"fix", "infix", "prec", 13, "str", " ~~ "}, "infix:<&&>", {"fix", "infix", "prec", 14, "str", " && "}, "infix:<||>", {"fix", "infix", "prec", 15, "str", " || "}, "infix:<//>", {"fix", "infix", "prec", 15, "str", " // "}, "ternary:<? :>", {"fix", "ternary", "prec", 16}, "infix:<=>", {"fix", "infix", "prec", 17, "str", " = "}, "infix:<**=>", {"fix", "infix", "prec", 17, "str", " **= "}, "infix:<+=>", {"fix", "infix", "prec", 17, "str", " += "}, "infix:<-=>", {"fix", "infix", "prec", 17, "str", " -= "}, "infix:<*=>", {"fix", "infix", "prec", 17, "str", " *= "}, "infix:</=>", {"fix", "infix", "prec", 17, "str", " /= "}, "infix:<x=>", {"fix", "infix", "prec", 17, "str", " x= "}, "infix:<|=>", {"fix", "infix", "prec", 17, "str", " |= "}, "infix:<&=>", {"fix", "infix", "prec", 17, "str", " &= "}, "infix:<.=>", {"fix", "infix", "prec", 17, "str", " .= "}, "infix:<<<=>", {"fix", "infix", "prec", 17, "str", " <<= "}, "infix:<>>=>", {"fix", "infix", "prec", 17, "str", " >>= "}, "infix:<%=>", {"fix", "infix", "prec", 17, "str", " %= "}, "infix:<||=>", {"fix", "infix", "prec", 17, "str", " ||= "}, "infix:<&&=>", {"fix", "infix", "prec", 17, "str", " &&= "}, "infix:<^=>", {"fix", "infix", "prec", 17, "str", " ^= "}, "infix:<//=>", {"fix", "infix", "prec", 17, "str", " //= "}, "infix:<=>>", {"fix", "infix", "prec", 18, "str", " => "}, "list:<,>", {"fix", "list", "prec", 19, "str", ", "}, "prefix:<not>", {"fix", "prefix", "prec", 20, "str", " not "}, "infix:<and>", {"fix", "infix", "prec", 21, "str", " and "}, "infix:<or>", {"fix", "infix", "prec", 22, "str", " or "}, "infix:<xor>", {"fix", "infix", "prec", 22, "str", " xor "});
    $op{"prefix:<" . $_ . ">"} = {"fix", "prefix", "prec", 8, "str", $_ . " "}
        for "-r", "-w", "-x", "-o", "-R", "-W", "-X", "-O", "-e", "-z", "-s", "-f", "-d", "-l", "-p", "-S", "-b", "-c", "-t", "-u", "-g", "-k", "-T", "-B", "-M", "-A", "-C";
    $op{"prefix:<" . $_ . ">"} = {"fix", "parsed", "prec", 15, "str", $_}
        for "do", "sub", "my", "our", "state", "local", "eval", "map", "grep", "sort", "print", "use";
    my %tab;
    sub Perlito5::Perl5::PrettyPrinter::tab {
        my $level = $_[0];
        $tab{$level} //= "    " x $level
    }
    sub Perlito5::Perl5::PrettyPrinter::render {
        (my($data), my($level), my($out)) = @_;
        if (ref($data)) {;
            $dispatch{$data->[0]}->($data, $level, $out)
        }
        else {;
            push(@{$out}, $data)
        }
    }
    sub Perlito5::Perl5::PrettyPrinter::op_precedence {
        (my($data)) = @_;
        !ref($data) && return 0;
        $data->[0] ne "op" && return 0;
        return $op{$data->[1]}->{"prec"} || 0
    }
    sub Perlito5::Perl5::PrettyPrinter::statement_need_semicolon {
        (my($data)) = @_;
        !ref($data) && return 1;
        ($data->[0] eq "block" || $data->[0] eq "comment" || $data->[0] eq "label") && return 0;
        if ($data->[0] eq "stmt") {;
            if (ref($data->[1])) {
                my $dd = $data->[1];
                if ($dd->[0] eq "keyword") {;
                    ref($data->[-1]) && $data->[-1]->[0] eq "block" && return 0
                }
            }
        }
        return 1
    }
    sub Perlito5::Perl5::PrettyPrinter::op_render {
        (my($data), my($level), my($out), my($current_op)) = @_;
        if (ref($data)) {
            my $this_prec = op_precedence($data);
            $this_prec && $current_op->{"prec"} && $current_op->{"prec"} < $this_prec && push(@{$out}, "(");
            render($data, $level, $out);
            $this_prec && $current_op->{"prec"} && $current_op->{"prec"} < $this_prec && push(@{$out}, ")")
        }
        else {;
            push(@{$out}, $data)
        }
    }
    sub Perlito5::Perl5::PrettyPrinter::op {
        (my($data), my($level), my($out)) = @_;
        my $op = $data->[1];
        my $spec = $op{$op} || die("unknown op: " . $op);
        if ($spec->{"fix"} eq "infix") {
            op_render($data->[2], $level, $out, $spec);
            push(@{$out}, $spec->{"str"});
            op_render($data->[3], $level, $out, $spec)
        }
        elsif ($spec->{"fix"} eq "prefix") {
            push(@{$out}, $spec->{"str"});
            if ($op eq "prefix:<not>" && !$data->[2]) {;
                push(@{$out}, "()")
            }
            else {;
                op_render($data->[2], $level, $out, $spec)
            }
        }
        elsif ($spec->{"fix"} eq "postfix") {
            op_render($data->[2], $level, $out, $spec);
            push(@{$out}, $spec->{"str"})
        }
        elsif ($spec->{"fix"} eq "ternary") {
            op_render($data->[2], $level, $out, $spec);
            push(@{$out}, " ? ");
            op_render($data->[3], $level, $out, $spec);
            push(@{$out}, " : ");
            op_render($data->[4], $level, $out, $spec)
        }
        elsif ($spec->{"fix"} eq "deref") {
            push(@{$out}, $spec->{"str"});
            op_render($data->[2], $level, $out, $spec)
        }
        elsif ($spec->{"fix"} eq "circumfix") {
            push(@{$out}, $spec->{"str"});
            for my $line (2 .. $#{$data}) {
                op_render($data->[$line], $level, $out, $spec);
                $line != $#{$data} && push(@{$out}, ", ")
            }
            push(@{$out}, $pair{$spec->{"str"}})
        }
        elsif ($spec->{"fix"} eq "list") {;
            for my $line (2 .. $#{$data}) {
                op_render($data->[$line], $level, $out, $spec);
                $line != $#{$data} && push(@{$out}, $spec->{"str"})
            }
        }
        elsif ($spec->{"fix"} eq "parsed") {
            push(@{$out}, $spec->{"str"});
            for my $line (2 .. $#{$data}) {
                my $d = $data->[$line];
                push(@{$out}, " ");
                render($d, $level, $out)
            }
        }
        else {;
            die("unknown fixity: " . $spec->{"fix"})
        }
        return
    }
    sub Perlito5::Perl5::PrettyPrinter::call {
        (my($data), my($level), my($out)) = @_;
        my @dd = @{$data};
        shift(@dd);
        my $open = "(";
        render(shift(@dd), $level, $out);
        push(@{$out}, "->");
        my $d = $dd[0];
        render($d, $level, $out);
        $dd[0] = "list:<,>";
        push(@{$out}, $open);
        op(["op", @dd], $level, $out);
        push(@{$out}, $pair{$open})
    }
    sub Perlito5::Perl5::PrettyPrinter::apply {
        (my($data), my($level), my($out)) = @_;
        my @dd = @{$data};
        shift(@dd);
        my $open = shift(@dd);
        my $d = $dd[0];
        if ($d eq "return") {;
            $open = " "
        }
        render($d, $level, $out);
        $dd[0] = "list:<,>";
        push(@{$out}, $open);
        op(["op", @dd], $level, $out);
        push(@{$out}, $pair{$open})
    }
    sub Perlito5::Perl5::PrettyPrinter::paren {
        (my($data), my($level), my($out)) = @_;
        my @dd = @{$data};
        shift(@dd);
        my $open = $dd[0];
        $dd[0] = "list:<,>";
        push(@{$out}, $open);
        op(["op", @dd], $level, $out);
        push(@{$out}, $pair{$open})
    }
    sub Perlito5::Perl5::PrettyPrinter::paren_semicolon {
        (my($data), my($level), my($out)) = @_;
        push(@{$out}, $data->[1]);
        for my $line (2 .. $#{$data}) {
            @{$data->[$line]} && render($data->[$line], $level, $out);
            if ($line != $#{$data}) {
                if (@{$data->[$line + 1]}) {;
                    push(@{$out}, "; ")
                }
                else {;
                    push(@{$out}, ";")
                }
            }
        }
        push(@{$out}, $pair{$data->[1]})
    }
    sub Perlito5::Perl5::PrettyPrinter::label {
        (my($data), my($level), my($out)) = @_;
        push(@{$out}, $data->[1], ":");
        return
    }
    sub Perlito5::Perl5::PrettyPrinter::keyword {
        (my($data), my($level), my($out)) = @_;
        push(@{$out}, $data->[1]);
        return
    }
    sub Perlito5::Perl5::PrettyPrinter::bareword {
        (my($data), my($level), my($out)) = @_;
        push(@{$out}, $data->[1]);
        return
    }
    sub Perlito5::Perl5::PrettyPrinter::number {
        (my($data), my($level), my($out)) = @_;
        push(@{$out}, $data->[1]);
        return
    }
    sub Perlito5::Perl5::PrettyPrinter::comment {
        (my($data), my($level), my($out)) = @_;
        push(@{$out}, $data->[1]);
        return
    }
    sub Perlito5::Perl5::PrettyPrinter::statement {
        (my($data), my($level), my($out)) = @_;
        for my $line (1 .. $#{$data}) {
            my $d = $data->[$line];
            render($d, $level, $out);
            $line != $#{$data} && push(@{$out}, " ")
        }
    }
    sub Perlito5::Perl5::PrettyPrinter::statement_modifier {
        (my($data), my($level), my($out)) = @_;
        render($data->[1], $level, $out);
        push(@{$out}, "
", tab($level + 1));
        render($data->[2], $level, $out)
    }
    sub Perlito5::Perl5::PrettyPrinter::block {
        (my($data), my($level), my($out)) = @_;
        if (@{$data} == 1) {
            push(@{$out}, "{}");
            return
        }
        if (@{$data} == 2) {;
            push(@{$out}, "{;", "
")
        }
        else {;
            push(@{$out}, "{", "
")
        }
        $level++;
        for my $line (1 .. $#{$data}) {
            my $d = $data->[$line];
            push(@{$out}, tab($level));
            render($d, $level, $out);
            $line != $#{$data} && statement_need_semicolon($d) && push(@{$out}, ";");
            push(@{$out}, "
")
        }
        $level--;
        push(@{$out}, tab($level), "}")
    }
    sub Perlito5::Perl5::PrettyPrinter::pretty_print {
        (my($data), my($level), my($out)) = @_;
        for my $line (0 .. $#{$data}) {
            my $d = $data->[$line];
            push(@{$out}, tab($level));
            render($d, $level, $out);
            $line != $#{$data} && statement_need_semicolon($d) && push(@{$out}, ";");
            push(@{$out}, "
")
        }
    }
    1
}
{
    package main;
    package Perlito5::Perl5::Runtime;
    sub Perlito5::Perl5::Runtime::eval_ast {
        (my($ast)) = @_;
        my $want = 0;
        my @data = $ast->emit_perl5(0, $want);
        my $out = [];
        Perlito5::Perl5::PrettyPrinter::pretty_print(\@data, 0, $out);
        my $code = "package " . $Perlito5::PKG_NAME . "; " . join('', @{$out}) . "
";
        Perlito5::set_global_phase("UNITCHECK");
        $_->()
            while $_ = shift(@Perlito5::UNITCHECK_BLOCK);
        $code = "#line " . $Perlito5::LINE_NUMBER . " \"" . $Perlito5::FILE_NAME . "\"
" . $code;
        return eval($code)
    }
    sub Perlito5::Perl5::Runtime::emit_perl5 {;
        return "
use v5.10;
use feature 'say';

"
    }
    1
}
{
    package main;
    package Perlito5::Perl6::TreeGrammar;
    sub Perlito5::Perl6::TreeGrammar::refactor_range_operator {
        (my($class), my($in)) = @_;
        Perlito5::TreeGrammar::render(["And", ["Lookup", "code", ["Value", "infix:<..>"]], ["Lookup", "arguments", ["And", ["Index", 0, ["And", ["Ref", "Perlito5::AST::Int"], ["Lookup", "int", ["Value", 0]]]], ["Index", 1, ["Or", ["And", ["Ref", "Perlito5::AST::Int"], ["Action", sub {
            $in->{"code"} = "p6_prefix:<^>";
            $_[0]->{"int"}++;
            shift(@{$in->{"arguments"}})
        }]], ["And", ["Ref", "Perlito5::AST::Apply"], ["Lookup", "code", ["Value", "prefix:<\$#>"]], ["Action", sub {
            bless($in, "Perlito5::AST::Call");
            delete($in->{"code"});
            $in->{"method"} = "keys";
            shift(@{$in->{"arguments"}});
            my $invocant = shift(@{$in->{"arguments"}});
            $in->{"invocant"} = $invocant->{"arguments"}->[0]
        }]], ["And", ["Ref", "Perlito5::AST::Var"], ["Lookup", "sigil", ["Value", "\$#"]], ["Action", sub {
            bless($in, "Perlito5::AST::Call");
            delete($in->{"code"});
            $in->{"method"} = "keys";
            $in->{"arguments"} = [];
            my $invocant = $_[0];
            $invocant->{"sigil"} = "\@";
            $in->{"invocant"} = $invocant
        }]]]]]]], $in)
    }
    sub Perlito5::Perl6::TreeGrammar::refactor_while_glob {
        (my($class), my($in)) = @_;
        Perlito5::TreeGrammar::render(["Ref", "Perlito5::AST::While", ["Lookup", "cond", ["And", ["Ref", "Perlito5::AST::Apply"], ["Lookup", "code", ["Value", "readline"]], ["Action", sub {;
            bless($in, "Perlito5::AST::For")
        }]]]], $in)
    }
    sub Perlito5::Perl6::TreeGrammar::refactor_sub_arguments {
        (my($class), my($in)) = @_;
        (my($rule), my($result));
        $rule = Perlito5::Perl6::TreeGrammar::is_sub(["Action", sub {
            my $sub = $_[0];
            my $stmts;
            my $var;
            Perlito5::TreeGrammar::render(["Lookup", "block", ["Progn", ["Action", sub {;
                $stmts = $_[0]
            }], ["Star", ["Index", 0, Perlito5::Perl6::TreeGrammar::operator_eq("infix:<=>", ["Lookup", "arguments", ["And", ["Index", 0, Perlito5::Perl6::TreeGrammar::my_var(["Action", sub {;
                $var = $_[0]->{"var"}
            }])], ["Index", 1, Perlito5::Perl6::TreeGrammar::shift_arg()], ["Action", sub {
                push(@{$sub->{"args"}}, $var);
                shift(@{$stmts})
            }]]])]]]], $sub)
        }]);
        $result = Perlito5::TreeGrammar::scan($rule, $in)
    }
    sub Perlito5::Perl6::TreeGrammar::is_sub {;
        ["Ref", "Perlito5::AST::Sub", (@_ ? ["Progn", @_] : ())]
    }
    sub Perlito5::Perl6::TreeGrammar::named_sub {;
        ["Ref", "Perlito5::AST::Sub", ["And", ["Lookup", "name", ["Not", ["Value", '']]], (@_ ? ["Progn", @_] : ())]]
    }
    sub Perlito5::Perl6::TreeGrammar::operator_eq {
        my $name = shift;
        ["Ref", "Perlito5::AST::Apply", ["And", ["Lookup", "code", ["Value", $name]], (@_ ? ["Progn", @_] : ())]]
    }
    sub Perlito5::Perl6::TreeGrammar::my_var {;
        ["Ref", "Perlito5::AST::Decl", ["And", ["Lookup", "decl", ["Value", "my"]], (@_ ? ["Progn", @_] : ())]]
    }
    sub Perlito5::Perl6::TreeGrammar::var_is_at {;
        ["Ref", "Perlito5::AST::Var", ["And", ["Lookup", "sigil", ["Value", "\@"]], ["Lookup", "name", ["Value", "_"]], (@_ ? ["Progn", @_] : ())]]
    }
    sub Perlito5::Perl6::TreeGrammar::shift_arg {;
        ["Ref", "Perlito5::AST::Apply", ["And", ["Lookup", "code", ["Value", "shift"]], ["Or", ["Lookup", "arguments", ["Not", ["Index", 0]]], ["Lookup", "arguments", ["Index", 0, var_is_at()]]], (@_ ? ["Progn", @_] : ())]]
    }
    1
}
{
    package main;
    {
        package Perlito5::Perl6;
        sub Perlito5::Perl6::emit_perl6_block {
            my $block = $_[0];
            return ["block", map {;
                defined($_) && $_->emit_perl6()
            } @{$block}]
        }
        my %safe_char = (" ", 1, "!", 1, "\"", 1, "#", 1, "\$", 1, "%", 1, "&", 1, "(", 1, ")", 1, "*", 1, "+", 1, ",", 1, "-", 1, ".", 1, "/", 1, ":", 1, ";", 1, "<", 1, "=", 1, ">", 1, "?", 1, "\@", 1, "[", 1, "]", 1, "^", 1, "_", 1, "`", 1, "{", 1, "|", 1, "}", 1, "~", 1);
        sub Perlito5::Perl6::escape_string {
            my $s = shift;
            my @out;
            my $tmp = '';
            $s eq '' && return "''";
            for my $i (0 .. length($s) - 1) {
                my $c = substr($s, $i, 1);
                if (($c ge "a" && $c le "z") || ($c ge "A" && $c le "Z") || ($c ge 0 && $c le 9) || exists($safe_char{$c})) {;
                    $tmp = $tmp . $c
                }
                else {
                    $tmp ne '' && push(@out, "'" . $tmp . "'");
                    push(@out, "chr(" . ord($c) . ")");
                    $tmp = ''
                }
            }
            $tmp ne '' && push(@out, "'" . $tmp . "'");
            @out < 2 && return @out;
            return ["op", "list:<~>", @out]
        }
    }
    package Perlito5::AST::CompUnit;
    {
        sub Perlito5::AST::CompUnit::emit_perl6 {
            my $self = $_[0];
            my @body = grep {;
                defined($_)
            } @{$self->{"body"}};
            my @out;
            my $pkg = {"name", "main", "body", []};
            for my $stmt (@body) {
                if (ref($stmt) eq "Perlito5::AST::Apply" && $stmt->{"code"} eq "package") {
                    $Perlito5::PKG_NAME = $stmt->{"namespace"};
                    @{$pkg->{"body"}} && push(@out, ["stmt", ["keyword", "class"], ["bareword", $pkg->{"name"}], ["block", map {;
                        $_->emit_perl6()
                    } @{$pkg->{"body"}}]]);
                    $pkg = {"name", $stmt->{"namespace"}, "body", []}
                }
                else {;
                    push(@{$pkg->{"body"}}, $stmt)
                }
            }
            @{$pkg->{"body"}} && push(@out, ["stmt", ["keyword", "class"], ["bareword", $pkg->{"name"}], ["block", map {;
                $_->emit_perl6()
            } @{$pkg->{"body"}}]]);
            return @out
        }
        sub Perlito5::AST::CompUnit::emit_perl6_program {
            my $comp_units = $_[0];
            my @body = @{$comp_units};
            my @out;
            push(@out, ["comment", Perlito5::Compiler::do_not_edit("#")]);
            my $pkg = {"name", "main", "body", []};
            for my $stmt (@body) {
                if (ref($stmt) eq "Perlito5::AST::Apply" && $stmt->{"code"} eq "package") {
                    $Perlito5::PKG_NAME = $stmt->{"namespace"};
                    if (@{$pkg->{"body"}}) {
                        if ($pkg->{"name"} eq "main") {;
                            push(@out, map {;
                                $_->emit_perl6()
                            } @{$pkg->{"body"}})
                        }
                        else {;
                            push(@out, ["stmt", ["keyword", "class"], ["bareword", $pkg->{"name"}], ["block", map {;
                                $_->emit_perl6()
                            } @{$pkg->{"body"}}]])
                        }
                    }
                    $pkg = {"name", $stmt->{"namespace"}, "body", []}
                }
                else {;
                    push(@{$pkg->{"body"}}, $stmt)
                }
            }
            if (@{$pkg->{"body"}}) {
                if ($pkg->{"name"} eq "main") {;
                    push(@out, map {;
                        $_->emit_perl6()
                    } @{$pkg->{"body"}})
                }
                else {;
                    push(@out, ["stmt", ["keyword", "class"], ["bareword", $pkg->{"name"}], ["block", map {;
                        $_->emit_perl6()
                    } @{$pkg->{"body"}}]])
                }
            }
            return @out
        }
    }
    package Perlito5::AST::Int;
    {;
        sub Perlito5::AST::Int::emit_perl6 {
            my $self = $_[0];
            ["number", $self->{"int"}]
        }
    }
    package Perlito5::AST::Num;
    {;
        sub Perlito5::AST::Num::emit_perl6 {
            my $self = $_[0];
            ["number", $self->{"num"}]
        }
    }
    package Perlito5::AST::Buf;
    {;
        sub Perlito5::AST::Buf::emit_perl6 {
            my $self = $_[0];
            Perlito5::Perl6::escape_string($self->{"buf"})
        }
    }
    package Perlito5::AST::Block;
    {;
        sub Perlito5::AST::Block::emit_perl6 {
            my $self = $_[0];
            my @out;
            $self->{"label"} && push(@out, ["label", $self->{"label"}]);
            if ($self->{"name"}) {;
                push(@out, ["stmt", ["keyword", $self->{"name"}], Perlito5::Perl6::emit_perl6_block($self->{"stmts"})])
            }
            else {;
                push(@out, Perlito5::Perl6::emit_perl6_block($self->{"stmts"}))
            }
            if ($self->{"continue"} && @{$self->{"continue"}->{"stmts"}}) {;
                push(@out, ["stmt", ["keyword", "continue"], Perlito5::Perl6::emit_perl6_block($self->{"continue"}->{"stmts"})])
            }
            return @out
        }
    }
    package Perlito5::AST::Index;
    {
        sub Perlito5::AST::Index::emit_perl6_index {
            my $self = $_[0];
            my $index = $self->{"index_exp"};
            if ($index->isa("Perlito5::AST::Apply") && $index->{"code"} eq "prefix:<->") {
                my $arg = $index->{"arguments"}->[0];
                if ($arg->isa("Perlito5::AST::Int")) {;
                    return ["op", "infix:<->", ["bareword", "*"], $arg->emit_perl6()]
                }
            }
            return $self->{"index_exp"}->emit_perl6()
        }
        sub Perlito5::AST::Index::emit_perl6 {
            my $self = $_[0];
            if ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\@>") {;
                return ["apply", "[", $self->{"obj"}->emit_perl6(), $self->emit_perl6_index()]
            }
            if ($self->{"obj"}->isa("Perlito5::AST::Var") && ($self->{"obj"}->sigil() eq "\$" || $self->{"obj"}->sigil() eq "\@")) {
                $self->{"obj"}->{"sigil"} = "\@";
                return ["apply", "[", $self->{"obj"}->emit_perl6(), $self->emit_perl6_index()]
            }
            if ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\$>") {;
                return ["apply", "[", $self->{"obj"}->{"arguments"}->[0]->emit_perl6(), $self->emit_perl6_index()]
            }
            return ["op", "infix:<.>", $self->{"obj"}->emit_perl6(), ["op", "circumfix:<[ ]>", $self->emit_perl6_index()]]
        }
    }
    package Perlito5::AST::Lookup;
    {;
        sub Perlito5::AST::Lookup::emit_perl6 {
            my $self = $_[0];
            if ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\@>") {
                $self->{"obj"}->{"sigil"} = "%";
                return ["apply", "{", $self->{"obj"}->emit_perl6(), $self->autoquote($self->{"index_exp"})->emit_perl6()]
            }
            if ($self->{"obj"}->isa("Perlito5::AST::Var") && ($self->{"obj"}->sigil() eq "\$" || $self->{"obj"}->sigil() eq "\@")) {
                $self->{"obj"}->{"sigil"} = "%";
                return ["apply", "{", $self->{"obj"}->emit_perl6(), $self->autoquote($self->{"index_exp"})->emit_perl6()]
            }
            if ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\$>") {;
                return ["apply", "{", $self->{"obj"}->{"arguments"}->[0]->emit_perl6(), $self->autoquote($self->{"index_exp"})->emit_perl6()]
            }
            return ["op", "infix:<.>", $self->{"obj"}->emit_perl6(), ["op", "circumfix:<{ }>", $self->autoquote($self->{"index_exp"})->emit_perl6()]]
        }
    }
    package Perlito5::AST::Var;
    {;
        sub Perlito5::AST::Var::emit_perl6 {
            my $self = $_[0];
            if ($self->{"sigil"} eq "\$#") {
                my $v = Perlito5::AST::Var::->new(%{$self}, "sigil", "\@");
                return ["op", "infix:<.>", $v->emit_perl6(), ["keyword", "end"]]
            }
            my $str_name = $self->{"name"};
            $str_name eq "\\" && ($str_name = "\\\\");
            $str_name eq "\"" && ($str_name = "\\\"");
            if ($self->{"sigil"} eq "::") {
                if ($self->{"namespace"} eq "__PACKAGE__") {;
                    return ["bareword", "\$?PACKAGE"]
                }
                return $self->{"namespace"}
            }
            my $ns = '';
            if ($self->{"namespace"}) {
                if ($self->{"namespace"} eq "main" && substr($self->{"name"}, 0, 1) eq "^") {;
                    return $self->{"sigil"} . "{" . $self->{"name"} . "}"
                }
                else {;
                    $ns = $self->{"namespace"} . "::"
                }
            }
            my $bareword = $ns . $str_name;
            my $c = substr($self->{"name"}, 0, 1);
            if (($c ge "a" && $c le "z") || ($c ge "A" && $c le "Z") || ($c eq "_")) {
                $self->{"sigil"} eq "\@" && $bareword eq "ARGV" && return "\@*ARGS";
                return $self->{"sigil"} . $bareword
            }
            if ($self->{"sigil"} eq "\$") {
                $bareword eq "/" && return "\"\\n\"";
                $bareword eq "\$" && return "\$*PID";
                $bareword eq 0 && return "\$*PROGRAM_NAME";
                $bareword eq "\@" && return "\$!";
                $bareword >= 1 && return "\$" . ($bareword - 1)
            }
            my $str = $self->{"sigil"} . "{'" . $bareword . "'}";
            return $str
        }
    }
    package Perlito5::AST::Call;
    {;
        sub Perlito5::AST::Call::emit_perl6 {
            my $self = $_[0];
            my $invocant = $self->{"invocant"}->emit_perl6();
            if ($self->{"method"} eq "postcircumfix:<[ ]>") {;
                return ["op", "infix:<.>", $invocant, ["op", "circumfix:<[ ]>", $self->{"arguments"}->emit_perl6()]]
            }
            if ($self->{"method"} eq "postcircumfix:<{ }>") {;
                return ["op", "infix:<.>", $invocant, ["op", "circumfix:<{ }>", Perlito5::AST::Lookup::->autoquote($self->{"arguments"})->emit_perl6()]]
            }
            my $meth = $self->{"method"};
            if ($meth eq "postcircumfix:<( )>") {
                if ((ref($self->{"invocant"}) eq "Perlito5::AST::Var" && $self->{"invocant"}->{"sigil"} eq "&") || (ref($self->{"invocant"}) eq "Perlito5::AST::Apply" && $self->{"invocant"}->{"code"} eq "prefix:<&>")) {;
                    return ["apply", "(", $invocant, map {;
                        $_->emit_perl6()
                    } @{$self->{"arguments"}}]
                }
                $meth = ''
            }
            if (ref($meth) eq "Perlito5::AST::Var") {;
                $meth = $meth->emit_perl6()
            }
            if ($meth) {;
                return ["call", $invocant, $meth, map {;
                    $_->emit_perl6()
                } @{$self->{"arguments"}}]
            }
            return ["op", "infix:<.>", $invocant, ["op", "list:<,>", map {;
                $_->emit_perl6()
            } @{$self->{"arguments"}}]]
        }
    }
    package Perlito5::AST::Apply;
    {
        my %special_var = (chr(15), "\$*VM");
        my %op_translate = ("list:<.>", "list:<~>", "infix:<.=>", "infix:<~=>", "infix:<=~>", "infix:<~~>", "infix:<!~>", "infix:<!~~>", "infix:<cmp>", "infix:<leq>", "ternary:<? :>", "ternary:<?? !!>", "reverse", "flip");
        sub Perlito5::AST::Apply::emit_perl6_args {
            my $self = $_[0];
            !$self->{"arguments"} && return ();
            return map {;
                $_->emit_perl6()
            } @{$self->{"arguments"}}
        }
        sub Perlito5::AST::Apply::emit_perl6 {
            my $self = $_[0];
            my $code = $self->{"code"};
            if (ref($code)) {;
                return ["op", "infix:<.>", $code->emit_perl6(), $self->emit_perl6_args()]
            }
            if ($code eq "infix:<=>>") {;
                return ["op", $code, Perlito5::AST::Lookup::->autoquote($self->{"arguments"}->[0])->emit_perl6(), $self->{"arguments"}->[1]->emit_perl6()]
            }
            if ($code eq "nan" && !$self->{"namespace"}) {;
                return ["keyword", "NaN"]
            }
            if ($code eq "inf" && !$self->{"namespace"}) {;
                return ["keyword", "Inf"]
            }
            if ($code eq "__PACKAGE__" && !$self->{"namespace"}) {;
                return ["bareword", "\$?PACKAGE"]
            }
            if ($code eq "prefix:<\$#>") {;
                return ["op", "infix:<.>", $self->{"arguments"}->[0]->emit_perl6(), ["keyword", "end"]]
            }
            if ($code eq "scalar") {
                my $arg = $self->{"arguments"}->[0];
                if ($arg->isa("Perlito5::AST::Var") && $arg->{"sigil"} eq "\@") {;
                    return ["op", "infix:<.>", $arg->emit_perl6(), ["keyword", "elems"]]
                }
            }
            if (($code eq "shift" || $code eq "pop") && !@{$self->{"arguments"}}) {;
                return ["apply", "(", $code, "\@_"]
            }
            if ($code eq "readline" && ref($self->{"arguments"}->[0]) eq "Perlito5::AST::Buf" && $self->{"arguments"}->[0]->{"buf"} eq '') {;
                return ["apply", "(", ["keyword", "lines"]]
            }
            if ($code eq "infix:<x>") {
                my $arg = $self->{"arguments"}->[0];
                if (ref($arg) eq "Perlito5::AST::Apply" && $arg->{"code"} eq "circumfix:<( )>") {;
                    $code = "infix:<xx>"
                }
            }
            if (($code eq "print" || $code eq "say") && !@{$self->{"arguments"}}) {;
                return ["keyword", "." . $code]
            }
            if ($code eq "infix:<..>") {
                Perlito5::Perl6::TreeGrammar::->refactor_range_operator($self);
                if (ref($self) ne "Perlito5::AST::Apply") {;
                    return $self->emit_perl6()
                }
                $code = $self->{"code"}
            }
            $op_translate{$code} && ($code = $op_translate{$code});
            if ($code eq "prefix:<\$>") {
                my $arg = $self->{"arguments"}->[0];
                $arg->isa("Perlito5::AST::Buf") && exists($special_var{$arg->{"buf"}}) && return $special_var{$arg->{"buf"}}
            }
            if ($Perlito5::Perl6::PrettyPrinter::op{$code}) {;
                return ["op", $code, $self->emit_perl6_args()]
            }
            if ($code eq "undef") {
                if (@{$self->{"arguments"}}) {;
                    die("TODO - undef(expr)")
                }
                else {;
                    return "Any"
                }
            }
            my $ns = '';
            if ($self->{"namespace"}) {;
                $ns = $self->{"namespace"} . "::"
            }
            $code = $ns . $code;
            if ($self->{"code"} eq "p5:s") {
                my $modifier = $self->{"arguments"}->[2]->{"buf"};
                $modifier && ($modifier = ":" . $modifier);
                return "s:P5" . $modifier . "!" . $self->{"arguments"}->[0]->{"buf"} . "!" . $self->{"arguments"}->[1]->{"buf"} . "!"
            }
            if ($self->{"code"} eq "p5:m") {
                my $s;
                if ($self->{"arguments"}->[0]->isa("Perlito5::AST::Buf")) {;
                    $s = $self->{"arguments"}->[0]->{"buf"}
                }
                else {;
                    for my $ast (@{$self->{"arguments"}->[0]->{"arguments"}}) {
                        if ($ast->isa("Perlito5::AST::Buf")) {;
                            $s .= $ast->{"buf"}
                        }
                        else {;
                            $s .= $ast->emit_perl6()
                        }
                    }
                }
                my $modifier = $self->{"arguments"}->[1]->{"buf"};
                $modifier && ($modifier = ":" . $modifier);
                return "m:P5" . $modifier . "!" . $s . "!"
            }
            if ($self->{"code"} eq "p5:tr") {;
                return "tr!" . $self->{"arguments"}->[0]->{"buf"} . "!" . $self->{"arguments"}->[1]->{"buf"} . "!"
            }
            if ($self->{"code"} eq "package") {
                $Perlito5::PKG_NAME = $self->{"namespace"};
                return ["stmt", "class", ["bareword", $self->{"namespace"}]]
            }
            if ($code eq "map" || $code eq "grep" || $code eq "sort") {
                if ($self->{"special_arg"}) {;
                    return ["op", "prefix:<" . $code . ">", ["block", map {;
                        $_->emit_perl6()
                    } @{$self->{"special_arg"}->{"stmts"}}], ["op", "list:<,>", $self->emit_perl6_args()]]
                }
                return ["apply", "(", $code, $self->emit_perl6_args()]
            }
            if ($self->{"bareword"} && !@{$self->{"arguments"}}) {;
                return ["bareword", $code]
            }
            if ($code eq "eval") {;
                $code = "EVAL"
            }
            return ["apply", "(", $code, $self->emit_perl6_args()]
        }
    }
    package Perlito5::AST::If;
    {;
        sub Perlito5::AST::If::emit_perl6 {
            my $self = $_[0];
            if ($self->{"body"} && ref($self->{"body"}) ne "Perlito5::AST::Block") {;
                return ["stmt_modifier", $self->{"body"}->emit_perl6(), ["stmt", "if", $self->{"cond"}->emit_perl6()]]
            }
            if ($self->{"otherwise"} && ref($self->{"otherwise"}) ne "Perlito5::AST::Block") {;
                return ["stmt_modifier", $self->{"otherwise"}->emit_perl6(), ["stmt", "unless", $self->{"cond"}->emit_perl6()]]
            }
            my @out = (["stmt", ["keyword", "if"], $self->{"cond"}->emit_perl6(), Perlito5::Perl6::emit_perl6_block($self->{"body"}->stmts())]);
            my $otherwise = $self->{"otherwise"};
            while ($otherwise && @{$otherwise->{"stmts"}} == 1 && ref($otherwise->{"stmts"}->[0]) eq "Perlito5::AST::If" && ($otherwise->{"stmts"}->[0]->{"body"} && ref($otherwise->{"stmts"}->[0]->{"body"}) eq "Perlito5::AST::Block")) {
                push(@out, ["stmt", ["keyword", "elsif"], $otherwise->{"stmts"}->[0]->{"cond"}->emit_perl6(), Perlito5::Perl6::emit_perl6_block($otherwise->{"stmts"}->[0]->{"body"}->{"stmts"})]);
                $otherwise = $otherwise->{"stmts"}->[0]->{"otherwise"}
            }
            !($otherwise && scalar(@{$otherwise->stmts()})) && return @out;
            push(@out, ["stmt", ["keyword", "else"], Perlito5::Perl6::emit_perl6_block($otherwise->stmts())]);
            return @out
        }
    }
    package Perlito5::AST::When;
    {;
        sub Perlito5::AST::When::emit_perl6 {
            my $self = $_[0];
            return ["stmt", ["keyword", "when"], $self->{"cond"}->emit_perl6(), Perlito5::Perl6::emit_perl6_block($self->{"body"}->stmts())]
        }
    }
    package Perlito5::AST::While;
    {;
        sub Perlito5::AST::While::emit_perl6 {
            my $self = $_[0];
            Perlito5::Perl6::TreeGrammar::->refactor_while_glob($self);
            if (ref($self) ne "Perlito5::AST::While") {;
                return $self->emit_perl6()
            }
            my @out;
            $self->{"label"} && push(@out, ["label", $self->{"label"}]);
            if ($self->{"body"} && ref($self->{"body"}) ne "Perlito5::AST::Block") {;
                return @out, ["stmt_modifier", $self->{"body"}->emit_perl6(), ["stmt", ["keyword", "while"], $self->{"cond"}->emit_perl6()]]
            }
            push(@out, ["stmt", ["keyword", "while"], $self->{"cond"}->emit_perl6(), Perlito5::Perl6::emit_perl6_block($self->{"body"}->stmts())]);
            if ($self->{"continue"} && @{$self->{"continue"}->{"stmts"}}) {;
                push(@out, ["stmt", ["keyword", "continue"], Perlito5::Perl6::emit_perl6_block($self->{"continue"}->{"stmts"})])
            }
            return @out
        }
    }
    package Perlito5::AST::For;
    {;
        sub Perlito5::AST::For::emit_perl6 {
            my $self = $_[0];
            my @out;
            $self->{"label"} && push(@out, ["label", $self->{"label"}]);
            if ($self->{"body"} && ref($self->{"body"}) ne "Perlito5::AST::Block") {;
                return @out, ["stmt_modifier", $self->{"body"}->emit_perl6(), ["stmt", "for", $self->{"cond"}->emit_perl6()]]
            }
            my $cond;
            my $keyword;
            if (ref($self->{"cond"}) eq "ARRAY") {
                $keyword = "loop";
                $cond = ["paren_semicolon", "(", ($self->{"cond"}->[0] ? $self->{"cond"}->[0]->emit_perl6() : []), ($self->{"cond"}->[1] ? $self->{"cond"}->[1]->emit_perl6() : []), ($self->{"cond"}->[2] ? $self->{"cond"}->[2]->emit_perl6() : [])]
            }
            else {
                $keyword = "for";
                $cond = $self->{"cond"}->emit_perl6()
            }
            my @sig;
            my $sig_ast = $self->{"topic"};
            if (!$sig_ast) {}
            else {
                ref($sig_ast) eq "Perlito5::AST::Decl" && ($sig_ast = $sig_ast->{"var"});
                @sig = ("->", $sig_ast->emit_perl6())
            }
            push(@out, ["stmt", ["keyword", $keyword], $cond, @sig, Perlito5::Perl6::emit_perl6_block($self->{"body"}->stmts())]);
            if ($self->{"continue"} && @{$self->{"continue"}->{"stmts"}}) {;
                push(@out, ["stmt", ["keyword", "continue"], Perlito5::Perl6::emit_perl6_block($self->{"continue"}->{"stmts"})])
            }
            return @out
        }
    }
    package Perlito5::AST::Decl;
    {;
        sub Perlito5::AST::Decl::emit_perl6 {
            my $self = $_[0];
            return ["op", "prefix:<" . $self->{"decl"} . ">", ($self->{"type"} ? $self->{"type"} : ()), $self->{"var"}->emit_perl6()]
        }
    }
    package Perlito5::AST::Sub;
    {;
        sub Perlito5::AST::Sub::emit_perl6 {
            my $self = $_[0];
            Perlito5::Perl6::TreeGrammar::->refactor_sub_arguments($self);
            my @parts;
            if ($self->{"args"}) {;
                push(@parts, ["paren", "(", (map {;
                    ["var", $_->emit_perl6(), "?"]
                } @{$self->{"args"}}), ["var", "*\@_"]])
            }
            else {;
                push(@parts, ["paren", "(", ["var", "*\@_"]])
            }
            defined($self->{"block"}) && push(@parts, Perlito5::Perl6::emit_perl6_block($self->{"block"}->{"stmts"}));
            !$self->{"name"} && return ["op", "prefix:<sub>", @parts];
            my $is_our = 1;
            $self->{"decl"} eq "my" && ($is_our = 0);
            my $name = $self->{"name"};
            if ($Perlito5::PKG_NAME ne $self->{"namespace"}) {
                $name = $self->{"namespace"} . "::" . $name;
                $is_our = 0
            }
            if ($is_our) {;
                return ["stmt", ["keyword", "our"], ["keyword", "sub"], ["bareword", $name], @parts]
            }
            else {;
                return ["stmt", ["keyword", "sub"], ["bareword", $name], @parts]
            }
        }
    }
    1
}
{
    package main;
    package Perlito5::Perl6::PrettyPrinter;
    my %dispatch = ("stmt", sub {;
        statement(@_)
    }, "stmt_modifier", sub {;
        statement_modifier(@_)
    }, "block", sub {;
        block(@_)
    }, "keyword", sub {;
        keyword(@_)
    }, "bareword", sub {;
        bareword(@_)
    }, "number", sub {;
        number(@_)
    }, "op", sub {;
        op(@_)
    }, "paren", sub {;
        paren(@_)
    }, "paren_semicolon", sub {;
        paren_semicolon(@_)
    }, "apply", sub {;
        apply(@_)
    }, "call", sub {;
        call(@_)
    }, "comment", sub {;
        comment(@_)
    }, "label", sub {;
        label(@_)
    }, "var", sub {;
        var(@_)
    });
    my %pair = ("(", ")", "[", "]", "{", "}");
    our %op = ("prefix:<\$>", {"fix", "deref", "prec", 0, "str", "\$"}, "prefix:<\@>", {"fix", "deref", "prec", 0, "str", "\@"}, "prefix:<%>", {"fix", "deref", "prec", 0, "str", "%"}, "prefix:<&>", {"fix", "deref", "prec", 0, "str", "&"}, "prefix:<*>", {"fix", "deref", "prec", 0, "str", "*"}, "prefix:<\$#>", {"fix", "deref", "prec", 0, "str", "\$#"}, "circumfix:<[ ]>", {"fix", "circumfix", "prec", 0, "str", "["}, "circumfix:<{ }>", {"fix", "circumfix", "prec", 0, "str", "{"}, "circumfix:<( )>", {"fix", "circumfix", "prec", 0, "str", "("}, "infix:<.>", {"fix", "infix", "prec", -1, "str", "."}, "prefix:<-->", {"fix", "prefix", "prec", 1, "str", "--"}, "prefix:<++>", {"fix", "prefix", "prec", 1, "str", "++"}, "postfix:<-->", {"fix", "postfix", "prec", 1, "str", "--"}, "postfix:<++>", {"fix", "postfix", "prec", 1, "str", "++"}, "infix:<**>", {"fix", "infix", "prec", 2, "str", "**"}, "p6_prefix:<^>", {"fix", "prefix", "prec", 3, "str", "^"}, "prefix:<\\>", {"fix", "prefix", "prec", 3, "str", "\\"}, "prefix:<+>", {"fix", "prefix", "prec", 3, "str", "+"}, "prefix:<->", {"fix", "prefix", "prec", 3, "str", "-"}, "prefix:<~>", {"fix", "prefix", "prec", 3, "str", "~"}, "prefix:<!>", {"fix", "prefix", "prec", 3, "str", "!"}, "infix:<=~>", {"fix", "infix", "prec", 4, "str", " =~ "}, "infix:<!~>", {"fix", "infix", "prec", 4, "str", " !~ "}, "infix:<*>", {"fix", "infix", "prec", 5, "str", " * "}, "infix:</>", {"fix", "infix", "prec", 5, "str", " / "}, "infix:<%>", {"fix", "infix", "prec", 5, "str", " % "}, "infix:<+>", {"fix", "infix", "prec", 6, "str", " + "}, "infix:<->", {"fix", "infix", "prec", 6, "str", " - "}, "infix:<x>", {"fix", "infix", "prec", 8, "str", " x "}, "infix:<xx>", {"fix", "infix", "prec", 8, "str", " xx "}, "list:<~>", {"fix", "list", "prec", 10, "str", " ~ "}, "infix:<~>", {"fix", "infix", "prec", 10, "str", " ~ "}, "infix:<<<>", {"fix", "infix", "prec", 12, "str", " << "}, "infix:<>>>", {"fix", "infix", "prec", 12, "str", " >> "}, "infix:<lt>", {"fix", "infix", "prec", 90, "str", " lt "}, "infix:<le>", {"fix", "infix", "prec", 90, "str", " le "}, "infix:<gt>", {"fix", "infix", "prec", 90, "str", " gt "}, "infix:<ge>", {"fix", "infix", "prec", 90, "str", " ge "}, "infix:<<=>", {"fix", "infix", "prec", 90, "str", " <= "}, "infix:<>=>", {"fix", "infix", "prec", 90, "str", " >= "}, "infix:<<>", {"fix", "infix", "prec", 90, "str", " < "}, "infix:<>>", {"fix", "infix", "prec", 90, "str", " > "}, "infix:<<=>>", {"fix", "infix", "prec", 100, "str", " <=> "}, "infix:<cmp>", {"fix", "infix", "prec", 100, "str", " cmp "}, "infix:<leq>", {"fix", "infix", "prec", 100, "str", " leq "}, "infix:<==>", {"fix", "infix", "prec", 100, "str", " == "}, "infix:<!=>", {"fix", "infix", "prec", 100, "str", " != "}, "infix:<ne>", {"fix", "infix", "prec", 100, "str", " ne "}, "infix:<eq>", {"fix", "infix", "prec", 100, "str", " eq "}, "infix:<&>", {"fix", "infix", "prec", 110, "str", " & "}, "infix:<|>", {"fix", "infix", "prec", 120, "str", " | "}, "infix:<^>", {"fix", "infix", "prec", 120, "str", " ^ "}, "infix:<..>", {"fix", "infix", "prec", 130, "str", " .. "}, "infix:<...>", {"fix", "infix", "prec", 130, "str", " ... "}, "infix:<~~>", {"fix", "infix", "prec", 130, "str", " ~~ "}, "infix:<&&>", {"fix", "infix", "prec", 140, "str", " && "}, "infix:<||>", {"fix", "infix", "prec", 150, "str", " || "}, "infix:<//>", {"fix", "infix", "prec", 150, "str", " // "}, "ternary:<?? !!>", {"fix", "ternary", "prec", 160}, "infix:<=>", {"fix", "infix", "prec", 170, "str", " = "}, "infix:<**=>", {"fix", "infix", "prec", 170, "str", " **= "}, "infix:<+=>", {"fix", "infix", "prec", 170, "str", " += "}, "infix:<-=>", {"fix", "infix", "prec", 170, "str", " -= "}, "infix:<*=>", {"fix", "infix", "prec", 170, "str", " *= "}, "infix:</=>", {"fix", "infix", "prec", 170, "str", " /= "}, "infix:<x=>", {"fix", "infix", "prec", 170, "str", " x= "}, "infix:<|=>", {"fix", "infix", "prec", 170, "str", " |= "}, "infix:<&=>", {"fix", "infix", "prec", 170, "str", " &= "}, "infix:<.=>", {"fix", "infix", "prec", 170, "str", " .= "}, "infix:<<<=>", {"fix", "infix", "prec", 170, "str", " <<= "}, "infix:<>>=>", {"fix", "infix", "prec", 170, "str", " >>= "}, "infix:<%=>", {"fix", "infix", "prec", 170, "str", " %= "}, "infix:<||=>", {"fix", "infix", "prec", 170, "str", " ||= "}, "infix:<&&=>", {"fix", "infix", "prec", 170, "str", " &&= "}, "infix:<^=>", {"fix", "infix", "prec", 170, "str", " ^= "}, "infix:<//=>", {"fix", "infix", "prec", 170, "str", " //= "}, "infix:<~=>", {"fix", "infix", "prec", 170, "str", " ~= "}, "infix:<=>>", {"fix", "infix", "prec", 180, "str", " => "}, "list:<,>", {"fix", "list", "prec", 190, "str", ", "}, "infix:<:>", {"fix", "infix", "prec", 190, "str", ":"}, "prefix:<not>", {"fix", "prefix", "prec", 200, "str", " not "}, "infix:<and>", {"fix", "infix", "prec", 210, "str", " and "}, "infix:<or>", {"fix", "infix", "prec", 220, "str", " or "}, "infix:<xor>", {"fix", "infix", "prec", 220, "str", " xor "});
    $op{"prefix:<" . $_ . ">"} = {"fix", "prefix", "prec", 8, "str", $_ . " "}
        for "-r", "-w", "-x", "-o", "-R", "-W", "-X", "-O", "-e", "-z", "-s", "-f", "-d", "-l", "-p", "-S", "-b", "-c", "-t", "-u", "-g", "-k", "-T", "-B", "-M", "-A", "-C";
    $op{"prefix:<" . $_ . ">"} = {"fix", "parsed", "prec", 8, "str", $_}
        for "do", "sub", "my", "our", "state", "local", "map", "grep", "sort";
    my %tab;
    sub Perlito5::Perl6::PrettyPrinter::tab {
        my $level = $_[0];
        $tab{$level} //= "    " x $level
    }
    sub Perlito5::Perl6::PrettyPrinter::render {
        (my($data), my($level), my($out)) = @_;
        if (ref($data)) {;
            $dispatch{$data->[0]}->($data, $level, $out)
        }
        else {;
            push(@{$out}, $data)
        }
    }
    sub Perlito5::Perl6::PrettyPrinter::op_precedence {
        (my($data)) = @_;
        !ref($data) && return 0;
        $data->[0] ne "op" && return 0;
        return $op{$data->[1]}->{"prec"} || 0
    }
    sub Perlito5::Perl6::PrettyPrinter::statement_need_semicolon {
        (my($data)) = @_;
        !ref($data) && return 1;
        ($data->[0] eq "block" || $data->[0] eq "comment" || $data->[0] eq "label") && return 0;
        if ($data->[0] eq "stmt") {;
            if (ref($data->[1])) {
                my $dd = $data->[1];
                if ($dd->[0] eq "keyword") {;
                    ref($data->[-1]) && $data->[-1]->[0] eq "block" && return 0
                }
            }
        }
        return 1
    }
    sub Perlito5::Perl6::PrettyPrinter::op_render {
        (my($data), my($level), my($out), my($current_op)) = @_;
        if (ref($data)) {
            my $this_prec = op_precedence($data);
            $this_prec && $current_op->{"prec"} && $current_op->{"prec"} < $this_prec && push(@{$out}, "(");
            render($data, $level, $out);
            $this_prec && $current_op->{"prec"} && $current_op->{"prec"} < $this_prec && push(@{$out}, ")")
        }
        else {;
            push(@{$out}, $data)
        }
    }
    sub Perlito5::Perl6::PrettyPrinter::op {
        (my($data), my($level), my($out)) = @_;
        my $op = $data->[1];
        my $spec = $op{$op} || die("unknown op: " . $op);
        if ($spec->{"fix"} eq "infix") {
            op_render($data->[2], $level, $out, $spec);
            push(@{$out}, $spec->{"str"});
            op_render($data->[3], $level, $out, $spec)
        }
        elsif ($spec->{"fix"} eq "prefix") {
            push(@{$out}, $spec->{"str"});
            op_render($data->[2], $level, $out, $spec)
        }
        elsif ($spec->{"fix"} eq "postfix") {
            op_render($data->[2], $level, $out, $spec);
            push(@{$out}, $spec->{"str"})
        }
        elsif ($spec->{"fix"} eq "ternary") {
            op_render($data->[2], $level, $out, $spec);
            push(@{$out}, " ?? ");
            op_render($data->[3], $level, $out, $spec);
            push(@{$out}, " !! ");
            op_render($data->[4], $level, $out, $spec)
        }
        elsif ($spec->{"fix"} eq "deref") {
            push(@{$out}, $spec->{"str"}, "(");
            op_render($data->[2], $level, $out, $spec);
            push(@{$out}, ")")
        }
        elsif ($spec->{"fix"} eq "circumfix") {
            push(@{$out}, $spec->{"str"});
            for my $line (2 .. $#{$data}) {
                op_render($data->[$line], $level, $out, $spec);
                $line != $#{$data} && push(@{$out}, ", ")
            }
            push(@{$out}, $pair{$spec->{"str"}})
        }
        elsif ($spec->{"fix"} eq "list") {;
            for my $line (2 .. $#{$data}) {
                op_render($data->[$line], $level, $out, $spec);
                $line != $#{$data} && push(@{$out}, $spec->{"str"})
            }
        }
        elsif ($spec->{"fix"} eq "parsed") {
            push(@{$out}, $spec->{"str"});
            for my $line (2 .. $#{$data}) {
                my $d = $data->[$line];
                push(@{$out}, " ");
                render($d, $level, $out)
            }
        }
        else {;
            die("unknown fixity: " . $spec->{"fix"})
        }
        return
    }
    sub Perlito5::Perl6::PrettyPrinter::call {
        (my($data), my($level), my($out)) = @_;
        my @dd = @{$data};
        shift(@dd);
        my $open = "(";
        render(shift(@dd), $level, $out);
        push(@{$out}, ".");
        my $d = $dd[0];
        render($d, $level, $out);
        if ($open eq "(" && @dd == 1) {;
            return
        }
        $dd[0] = "list:<,>";
        push(@{$out}, $open);
        op(["op", @dd], $level, $out);
        push(@{$out}, $pair{$open})
    }
    sub Perlito5::Perl6::PrettyPrinter::apply {
        (my($data), my($level), my($out)) = @_;
        my @dd = @{$data};
        shift(@dd);
        my $open = shift(@dd);
        my $d = $dd[0];
        render($d, $level, $out);
        if ($open eq "(" && @dd == 1) {;
            return
        }
        $dd[0] = "list:<,>";
        push(@{$out}, $open);
        op(["op", @dd], $level, $out);
        push(@{$out}, $pair{$open})
    }
    sub Perlito5::Perl6::PrettyPrinter::paren {
        (my($data), my($level), my($out)) = @_;
        my @dd = @{$data};
        shift(@dd);
        my $open = $dd[0];
        $dd[0] = "list:<,>";
        push(@{$out}, $open);
        op(["op", @dd], $level, $out);
        push(@{$out}, $pair{$open})
    }
    sub Perlito5::Perl6::PrettyPrinter::paren_semicolon {
        (my($data), my($level), my($out)) = @_;
        push(@{$out}, $data->[1]);
        for my $line (2 .. $#{$data}) {
            @{$data->[$line]} && render($data->[$line], $level, $out);
            if ($line != $#{$data}) {
                if (@{$data->[$line + 1]}) {;
                    push(@{$out}, "; ")
                }
                else {;
                    push(@{$out}, ";")
                }
            }
        }
        push(@{$out}, $pair{$data->[1]})
    }
    sub Perlito5::Perl6::PrettyPrinter::var {
        (my($data), my($level), my($out)) = @_;
        push(@{$out}, @{$data}[1 .. $#{$data}]);
        return
    }
    sub Perlito5::Perl6::PrettyPrinter::label {
        (my($data), my($level), my($out)) = @_;
        push(@{$out}, $data->[1], ":");
        return
    }
    sub Perlito5::Perl6::PrettyPrinter::keyword {
        (my($data), my($level), my($out)) = @_;
        push(@{$out}, $data->[1]);
        return
    }
    sub Perlito5::Perl6::PrettyPrinter::bareword {
        (my($data), my($level), my($out)) = @_;
        push(@{$out}, $data->[1]);
        return
    }
    sub Perlito5::Perl6::PrettyPrinter::number {
        (my($data), my($level), my($out)) = @_;
        push(@{$out}, $data->[1]);
        return
    }
    sub Perlito5::Perl6::PrettyPrinter::comment {
        (my($data), my($level), my($out)) = @_;
        push(@{$out}, $data->[1]);
        return
    }
    sub Perlito5::Perl6::PrettyPrinter::statement {
        (my($data), my($level), my($out)) = @_;
        for my $line (1 .. $#{$data}) {
            my $d = $data->[$line];
            render($d, $level, $out);
            $line != $#{$data} && push(@{$out}, " ")
        }
    }
    sub Perlito5::Perl6::PrettyPrinter::statement_modifier {
        (my($data), my($level), my($out)) = @_;
        render($data->[1], $level, $out);
        push(@{$out}, "
", tab($level + 1));
        render($data->[2], $level, $out)
    }
    sub Perlito5::Perl6::PrettyPrinter::block {
        (my($data), my($level), my($out)) = @_;
        if (@{$data} == 1) {
            push(@{$out}, "{}");
            return
        }
        push(@{$out}, "{", "
");
        $level++;
        for my $line (1 .. $#{$data}) {
            my $d = $data->[$line];
            push(@{$out}, tab($level));
            render($d, $level, $out);
            $line != $#{$data} && statement_need_semicolon($d) && push(@{$out}, ";");
            push(@{$out}, "
")
        }
        $level--;
        push(@{$out}, tab($level), "}")
    }
    sub Perlito5::Perl6::PrettyPrinter::pretty_print {
        (my($data), my($level), my($out)) = @_;
        for my $line (0 .. $#{$data}) {
            my $d = $data->[$line];
            push(@{$out}, tab($level));
            render($d, $level, $out);
            $line != $#{$data} && statement_need_semicolon($d) && push(@{$out}, ";");
            push(@{$out}, "
")
        }
    }
    1
}
{
    package main;
    package Perlito5::AST::Apply;
    {
        sub Perlito5::AST::Apply::emit_qr_java {
            (my($regex), my($modifier), my($level)) = @_;
            if ($modifier eq '' && ref($regex) eq "Perlito5::AST::Var" && $regex->{"sigil"} eq "\$") {;
                return $regex->emit_java($level)
            }
            my %flags = map {;
                $_ => 1
            } split(m//, $modifier);
            my $flag_string = join(" | ", ($flags{"i"} ? "Pattern.CASE_INSENSITIVE" : ()), ($flags{"x"} ? "Pattern.COMMENTS" : ()), ($flags{"m"} ? "Pattern.MULTILINE" : ()), ($flags{"s"} ? "Pattern.DOTALL" : ())) || 0;
            my $flag_xx = "false";
            $modifier =~ m/xx/ && ($flag_xx = "true");
            my $s = "new PlRegex(" . Perlito5::Java::to_str($regex) . ", " . $flag_string . ", " . $flag_xx . ")";
            if (ref($regex) eq "Perlito5::AST::Buf") {
                my $label = Perlito5::Java::get_label();
                push(@Perlito5::Java::Java_constants, "public static final PlRegex " . $label . " = " . $s . ";");
                return $label
            }
            return $s
        }
        sub Perlito5::AST::Apply::emit_regex_java {
            my $op = shift;
            my $var = shift;
            my $regex = shift;
            my $level = shift;
            my $wantarray = shift;
            $regex = Perlito5::Macro::preprocess_regex($regex);
            my $str;
            my $code = $regex->{"code"};
            my $regex_args = $regex->{"arguments"};
            my $modifier_global = "false";
            if ($code eq "p5:s") {
                my $replace = $regex_args->[1];
                my $modifier = $regex_args->[2]->{"buf"};
                my $replace_java;
                if (ref($replace) eq "Perlito5::AST::Buf") {
                    $replace_java = $replace->{"buf"};
                    $replace_java = Perlito5::Java::escape_string($replace_java)
                }
                else {
                    if (ref($replace) ne "Perlito5::AST::Block") {;
                        $replace = Perlito5::AST::Block::->new("stmts", [$replace])
                    }
                    $replace_java = Perlito5::AST::Sub::->new("block", $replace, "attributes", [], "_do_block", 1)->emit_java($level);
                    $modifier =~ s/e//g
                }
                if ($modifier =~ m/g/) {
                    $modifier_global = "true";
                    $modifier =~ s/g//g
                }
                $str = "PerlOp.replace(" . $var->emit_java($level) . ", " . emit_qr_java($regex_args->[0], $modifier, $level) . ", " . $replace_java . ", " . Perlito5::Java::to_context($wantarray) . ", " . $modifier_global . ")"
            }
            elsif ($code eq "p5:m") {
                my $modifier = $regex_args->[1]->{"buf"};
                if ($modifier =~ m/g/) {
                    $modifier_global = "true";
                    $modifier =~ s/g//g
                }
                my $modifier_c = "false";
                if ($modifier =~ m/c/) {
                    $modifier_c = "true";
                    $modifier =~ s/c//g
                }
                $str = "PerlOp.match(" . $var->emit_java($level) . ", " . emit_qr_java($regex_args->[0], $modifier, $level) . ", " . Perlito5::Java::to_context($wantarray) . ", " . $modifier_global . ", " . $modifier_c . ")"
            }
            elsif ($code eq "p5:tr") {;
                $str = "PerlOp.tr(" . $var->emit_java($level) . ", " . $regex_args->[0]->emit_java($level) . ", " . $regex_args->[1]->emit_java($level) . ", " . Perlito5::Java::escape_string($regex_args->[2]->{"buf"}) . ", " . Perlito5::Java::to_context($wantarray) . ")"
            }
            else {;
                die("Error: regex emitter - unknown operator " . $code)
            }
            if ($op eq "=~") {;
                return $str
            }
            if ($op eq "!~") {;
                return "new PlBool(!(" . $str . ".to_boolean()))"
            }
            die("Error: regex emitter")
        }
        sub Perlito5::AST::Apply::emit_java_set {
            (my($self), my($arguments), my($level), my($wantarray)) = @_;
            my $code = $self->{"code"};
            if ($code eq "my" || $code eq "state" || $code eq "local" || $code eq "circumfix:<( )>") {;
                return "PlArray.static_list_set(" . join(", ", Perlito5::Java::to_context($wantarray), Perlito5::Java::to_list([$arguments], $level), map($_->emit_java($level, "list", "lvalue"), @{$self->{"arguments"}})) . ")"
            }
            if ($code eq "pos") {
                my @lvalue = @{$self->{"arguments"}};
                if (!@lvalue) {;
                    push(@lvalue, Perlito5::AST::Var::SCALAR_ARG())
                }
                return "PerlOp.set_pos(" . $lvalue[0]->emit_java($level, "scalar") . ", " . $arguments->emit_java($level, "scalar") . ")"
            }
            if ($code eq "prefix:<\$#>") {;
                return Perlito5::Java::emit_java_autovivify($self->{"arguments"}->[0], $level + 1, "array") . ".array_deref().set_end_of_array_index(" . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")"
            }
            if ($code eq "prefix:<\$>") {;
                return Perlito5::Java::emit_java_autovivify($self->{"arguments"}->[0], $level + 1, "scalar") . ".scalar_deref_set(" . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ", " . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")"
            }
            if ($code eq "prefix:<\@>") {;
                return Perlito5::Java::emit_java_autovivify($self->{"arguments"}->[0], $level + 1, "array") . ".array_deref_set(" . Perlito5::Java::to_list([$arguments], $level + 1) . ")"
            }
            if ($code eq "prefix:<%>") {;
                return Perlito5::Java::emit_java_autovivify($self->{"arguments"}->[0], $level + 1, "hash") . ".hash_deref_set(" . Perlito5::Java::to_list([$arguments], $level + 1) . ")"
            }
            if ($code eq "prefix:<*>") {;
                return "PlV.glob_set(" . Perlito5::Java::to_scalar($self->{"arguments"}, $level + 1) . ", " . Perlito5::Java::to_scalar([$arguments], $level + 1) . ", " . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ")"
            }
            my $open = $wantarray eq "void" ? '' : "(";
            my $close = $wantarray eq "void" ? '' : ")";
            $open . $self->emit_java($level + 1) . " = " . $arguments->emit_java($level + 1) . $close
        }
        my %emit_js = ("infix:<=~>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            emit_regex_java("=~", $self->{"arguments"}->[0], $self->{"arguments"}->[1], $level, $wantarray)
        }, "infix:<!~>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            emit_regex_java("!~", $self->{"arguments"}->[0], $self->{"arguments"}->[1], $level, $wantarray)
        }, "p5:s", sub {
            (my($self), my($level), my($wantarray)) = @_;
            emit_regex_java("=~", $self->{"arguments"}->[3], $self, $level, $wantarray)
        }, "p5:m", sub {
            (my($self), my($level), my($wantarray)) = @_;
            emit_regex_java("=~", $self->{"arguments"}->[2], $self, $level, $wantarray)
        }, "p5:tr", sub {
            (my($self), my($level), my($wantarray)) = @_;
            emit_regex_java("=~", $self->{"arguments"}->[3], $self, $level, $wantarray)
        }, "p5:qr", sub {
            (my($self), my($level), my($wantarray)) = @_;
            return emit_qr_java($self->{"arguments"}->[0], $self->{"arguments"}->[1]->{"buf"}, $level)
        }, "__PACKAGE__", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "new PlString(" . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ")"
        }, "__SUB__", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "this.getCurrentSub()"
        }, "wantarray", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "(want == PlCx.VOID ? PlCx.UNDEF : new PlInt(want-1))"
        }, "uc", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "new PlString(" . $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".toString().toUpperCase())"
        }, "lc", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "new PlString(" . $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".toString().toLowerCase())"
        }, "ucfirst", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".ucfirst()"
        }, "lcfirst", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".lcfirst()"
        }, "quotemeta", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".quotemeta()"
        }, "index", sub {
            (my($self), my($level), my($wantarray)) = @_;
            if ($self->{"arguments"}->[2]) {;
                $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".index(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ", " . $self->{"arguments"}->[2]->emit_java($level, "scalar") . ")"
            }
            else {;
                $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".index(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ")"
            }
        }, "rindex", sub {
            (my($self), my($level), my($wantarray)) = @_;
            if ($self->{"arguments"}->[2]) {;
                $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".rindex(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ", " . $self->{"arguments"}->[2]->emit_java($level, "scalar") . ")"
            }
            else {;
                $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".rindex(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ")"
            }
        }, "ord", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "PerlOp.ord(" . Perlito5::Java::to_str($self->{"arguments"}->[0], $level) . ")"
        }, "chr", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "new PlString(new String(Character.toChars(" . $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".to_int())))"
        }, "rand", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "PerlOp.rand(" . ($self->{"arguments"}->[0] ? $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".to_double()" : "1.0") . ")"
        }, "srand", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "PerlOp.srand(" . ($self->{"arguments"}->[0] ? $self->{"arguments"}->[0]->emit_java($level, "scalar") : '') . ")"
        }, (map {
            my $op = $_;
            ($op, sub {
                my($self, $level, $wantarray) = @_;
                $self->{"arguments"}->[0]->emit_java($level, "scalar") . "." . $op . "()"
            })
        } "abs", "sqrt", "cos", "sin", "exp", "log"), (map {
            my $op = $_;
            ($op, sub {
                my($self, $level, $wantarray) = @_;
                $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".op_" . $op . "()"
            })
        } "int"), "infix:<%>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            return $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".mod(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ")"
        }, "infix:<>>>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".int_shr(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ")"
        }, "infix:<<<>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".int_shl(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ")"
        }, "infix:<^>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".int_xor(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ")"
        }, "infix:<&>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".int_and(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ")"
        }, "infix:<|>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".int_or(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ")"
        }, "infix:<+>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".add(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ")"
        }, "infix:<->", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".sub(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ")"
        }, "infix:<*>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".mul(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ")"
        }, "infix:</>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".div(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ")"
        }, "infix:<==>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".num_eq(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ")"
        }, "infix:<!=>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".num_ne(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ")"
        }, "infix:<>>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".num_gt(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ")"
        }, "infix:<>=>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".num_ge(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ")"
        }, "infix:<<>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".num_lt(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ")"
        }, "infix:<<=>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".num_le(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ")"
        }, "infix:<eq>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".str_eq(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ")"
        }, "infix:<ne>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".str_ne(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ")"
        }, "infix:<gt>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".str_gt(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ")"
        }, "infix:<ge>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".str_ge(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ")"
        }, "infix:<lt>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".str_lt(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ")"
        }, "infix:<le>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".str_le(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ")"
        }, "infix:<~~>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg0 = $self->{"arguments"}->[0];
            my $arg1 = $self->{"arguments"}->[1];
            "PerlOp.smartmatch_scalar(" . $arg0->emit_java($level, "scalar") . ", " . $arg1->emit_java($level, "scalar") . ")"
        }, "infix:<&&>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            if ($wantarray eq "void") {;
                return "(" . Perlito5::Java::to_boolean($self->{"arguments"}->[0], $level) . " ? " . $self->{"arguments"}->[1]->emit_java($level, $wantarray) . " : PlCx.UNDEF)"
            }
            "(PerlOp.and1(" . $self->{"arguments"}->[0]->emit_java($level, "scalar") . ") ? " . $self->{"arguments"}->[1]->emit_java($level, $wantarray) . " : PerlOp.and3())"
        }, "infix:<and>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            if ($wantarray eq "void") {;
                return "(" . Perlito5::Java::to_boolean($self->{"arguments"}->[0], $level) . " ? " . $self->{"arguments"}->[1]->emit_java($level, $wantarray) . " : PlCx.UNDEF)"
            }
            "(PerlOp.and1(" . $self->{"arguments"}->[0]->emit_java($level, "scalar") . ") ? " . $self->{"arguments"}->[1]->emit_java($level, $wantarray) . " : PerlOp.and3())"
        }, "infix:<||>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            if ($wantarray eq "void") {;
                return "(" . Perlito5::Java::to_boolean($self->{"arguments"}->[0], $level) . " ? " . " PlCx.UNDEF : " . $self->{"arguments"}->[1]->emit_java($level, $wantarray) . ")"
            }
            "(PerlOp.or1(" . $self->{"arguments"}->[0]->emit_java($level, "scalar") . ") ? PerlOp.or2() : " . $self->{"arguments"}->[1]->emit_java($level, $wantarray) . ")"
        }, "infix:<or>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            if ($wantarray eq "void") {;
                return "(" . Perlito5::Java::to_boolean($self->{"arguments"}->[0], $level) . " ? " . " PlCx.UNDEF : " . $self->{"arguments"}->[1]->emit_java($level, $wantarray) . ")"
            }
            "(PerlOp.or1(" . $self->{"arguments"}->[0]->emit_java($level, "scalar") . ") ? PerlOp.or2() : " . $self->{"arguments"}->[1]->emit_java($level, $wantarray) . ")"
        }, "infix:<xor>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "( " . Perlito5::Java::to_boolean($self->{"arguments"}->[0], $level) . " ? new PlBool(!" . Perlito5::Java::to_boolean($self->{"arguments"}->[1], $level) . ") : " . ($self->{"arguments"}->[1])->emit_java($level, $wantarray) . ")"
        }, "infix:<=>>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            Perlito5::AST::Lookup::->autoquote($self->{"arguments"}->[0])->emit_java($level) . ", " . $self->{"arguments"}->[1]->emit_java($level)
        }, "infix:<cmp>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".str_cmp(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ")"
        }, "infix:<<=>>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".num_cmp(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ")"
        }, "infix:<**>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".pow(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ")"
        }, "atan2", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $self->{"arguments"}->[0]->emit_java($level, "scalar") . ".atan2(" . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ")"
        }, "prefix:<!>", sub {
            my $self = shift;
            my $level = shift;
            "new PlBool(!(" . Perlito5::Java::to_boolean($self->{"arguments"}->[0], $level) . "))"
        }, "prefix:<not>", sub {
            my $self = shift;
            my $level = shift;
            my $arg = pop(@{$self->{"arguments"}});
            if (!$arg) {;
                return "PlCx.TRUE"
            }
            "new PlBool(!( " . Perlito5::Java::to_boolean($arg, $level) . "))"
        }, "prefix:<~>", sub {
            my $self = shift;
            my $level = shift;
            my $arg = $self->{"arguments"}->[0];
            $arg->emit_java($level, "scalar") . ".complement()"
        }, "prefix:<->", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ($arg->isa("Perlito5::AST::Int")) {
                $arg = Perlito5::AST::Int::->new("int", -$arg->{"int"});
                return $arg->emit_java($level, "scalar")
            }
            if ($arg->isa("Perlito5::AST::Num")) {
                $arg = Perlito5::AST::Num::->new("num", -$arg->{"num"});
                return $arg->emit_java($level, "scalar")
            }
            if ($arg->isa("Perlito5::AST::Apply") && $arg->{"bareword"}) {;
                $arg = Perlito5::AST::Buf::->new("buf", $arg->{"code"})
            }
            $arg->emit_java($level, "scalar") . ".neg()"
        }, "prefix:<+>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $self->{"arguments"}->[0]->emit_java($level, $wantarray)
        }, "require", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ($arg->{"is_version_string"}) {;
                return "PlV.apply(\"Perlito5::test_perl_version\", PlCx.VOID, new PlArray(" . $arg->emit_java($level, "scalar") . "))"
            }
            "PlCORE.require(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_str($self->{"arguments"}->[0]) . ", " . ($self->{"arguments"}->[0]->{"bareword"} ? "true" : "false") . ")"
        }, "prefix:<\$>", sub {
            (my($self), my($level), my($wantarray), my($autovivification_type)) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ($autovivification_type eq "lvalue") {;
                return $arg->emit_java($level, "scalar", "lvalue") . ".scalar_deref_lvalue(" . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ")"
            }
            elsif ($self->{"_strict_refs"}) {;
                return $arg->emit_java($level, "scalar", "scalar") . ".scalar_deref_strict()"
            }
            return $arg->emit_java($level, "scalar", "scalar") . ".scalar_deref(" . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ")"
        }, "prefix:<\@>", sub {
            (my($self), my($level), my($wantarray), my($autovivification_type)) = @_;
            my $arg = $self->{"arguments"}->[0];
            my $s;
            if ($autovivification_type eq "lvalue") {;
                $s = Perlito5::Java::emit_java_autovivify($arg, $level, "array") . ".array_deref_lvalue()"
            }
            elsif ($self->{"_strict_refs"}) {;
                $s = Perlito5::Java::emit_java_autovivify($arg, $level, "array") . ".array_deref_strict()"
            }
            else {;
                $s = Perlito5::Java::emit_java_autovivify($arg, $level, "array") . ".array_deref()"
            }
            return $wantarray eq "scalar" ? $s . ".scalar()" : $s
        }, "prefix:<\$#>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0];
            return Perlito5::Java::emit_java_autovivify($arg, $level, "array") . ".array_deref().end_of_array_index()"
        }, "prefix:<%>", sub {
            (my($self), my($level), my($wantarray), my($autovivification_type)) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ($autovivification_type eq "lvalue") {;
                return Perlito5::Java::emit_java_autovivify($arg, $level, "hash") . ".hash_deref()"
            }
            elsif ($self->{"_strict_refs"}) {;
                return Perlito5::Java::emit_java_autovivify($arg, $level, "hash") . ".hash_deref_strict()"
            }
            return Perlito5::Java::emit_java_autovivify($arg, $level, "hash") . ".hash_deref()"
        }, "prefix:<&>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0];
            "PlV.code_lookup_by_name(" . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ", " . $arg->emit_java($level) . ")" . ".apply(" . Perlito5::Java::to_context($wantarray) . ", " . "List__" . ")"
        }, "prefix:<*>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0];
            return Perlito5::Java::to_filehandle($arg, $level + 1)
        }, "circumfix:<[ ]>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "new PlArrayRef(new PlArray(" . Perlito5::Java::to_list($self->{"arguments"}, $level) . "))"
        }, "circumfix:<{ }>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "(new PlHashRef(new PlHash(" . Perlito5::Java::to_list($self->{"arguments"}, $level) . ")))"
        }, "prefix:<\\>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ($arg->isa("Perlito5::AST::Apply")) {
                if ($arg->{"code"} eq "prefix:<\@>") {;
                    return "new PlArrayRef(" . $arg->emit_java($level) . ")"
                }
                if ($arg->{"code"} eq "prefix:<%>") {;
                    return "new PlHashRef(" . $arg->emit_java($level) . ")"
                }
                if ($arg->{"code"} eq "circumfix:<( )>") {;
                    return "PlArray.construct_list_of_references(" . Perlito5::Java::to_list($arg->{"arguments"}, $level) . ")"
                }
                if ($arg->{"code"} eq "prefix:<&>") {;
                    return "PlV.code_lookup_by_name(" . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ", " . $arg->{"arguments"}->[0]->emit_java($level) . ")"
                }
            }
            if ($arg->isa("Perlito5::AST::Var")) {
                if ($arg->sigil() eq "\@") {;
                    return "new PlArrayRef(" . $arg->emit_java($level) . ")"
                }
                if ($arg->sigil() eq "%") {;
                    return "(new PlHashRef(" . $arg->emit_java($level) . "))"
                }
                if ($arg->sigil() eq "*") {;
                    return "(new PlGlobRef(" . $arg->emit_java($level) . "))"
                }
                if ($arg->sigil() eq "&") {
                    my $namespace = $arg->{"namespace"} || $Perlito5::PKG_NAME;
                    return "PlV.cget(" . Perlito5::Java::escape_string($namespace . "::" . $arg->{"name"}) . ")"
                }
            }
            return "(new PlLvalueRef(" . $arg->emit_java($level) . "))"
        }, "postfix:<++>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0];
            if (ref($arg) eq "Perlito5::AST::Var" && $arg->{"_id"}) {
                my $id = $arg->{"_id"};
                my $Java_var = Perlito5::Java::get_java_var_info();
                my $type = $Java_var->{$id}->{"type"} || "PlLvalue";
                if ($type ne "PlLvalue") {;
                    return Perlito5::Java::to_native_num($arg, $level, $wantarray) . "++"
                }
            }
            $arg->emit_java($level, "scalar", "lvalue") . ".post_incr()"
        }, "postfix:<-->", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0];
            if (ref($arg) eq "Perlito5::AST::Var" && $arg->{"_id"}) {
                my $id = $arg->{"_id"};
                my $Java_var = Perlito5::Java::get_java_var_info();
                my $type = $Java_var->{$id}->{"type"} || "PlLvalue";
                if ($type ne "PlLvalue") {;
                    return Perlito5::Java::to_native_num($arg, $level, $wantarray) . "--"
                }
            }
            $arg->emit_java($level, "scalar", "lvalue") . ".post_decr()"
        }, "prefix:<++>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0];
            if (ref($arg) eq "Perlito5::AST::Var" && $arg->{"_id"}) {
                my $id = $arg->{"_id"};
                my $Java_var = Perlito5::Java::get_java_var_info();
                my $type = $Java_var->{$id}->{"type"} || "PlLvalue";
                if ($type ne "PlLvalue") {;
                    return "++" . Perlito5::Java::to_native_num($arg, $level, $wantarray)
                }
            }
            $arg->emit_java($level, "scalar", "lvalue") . ".pre_incr()"
        }, "prefix:<-->", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0];
            if (ref($arg) eq "Perlito5::AST::Var" && $arg->{"_id"}) {
                my $id = $arg->{"_id"};
                my $Java_var = Perlito5::Java::get_java_var_info();
                my $type = $Java_var->{$id}->{"type"} || "PlLvalue";
                if ($type ne "PlLvalue") {;
                    return "--" . Perlito5::Java::to_native_num($arg, $level, $wantarray)
                }
            }
            $arg->emit_java($level, "scalar", "lvalue") . ".pre_decr()"
        }, "infix:<x>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0];
            if (ref($arg) eq "Perlito5::AST::Apply" && ($arg->{"code"} eq "circumfix:<( )>" || $arg->{"code"} eq "list:<,>")) {;
                return "PerlOp.list_replicate(" . Perlito5::Java::to_list([$self->{"arguments"}->[0]], $level) . ", " . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ", " . Perlito5::Java::to_context($wantarray) . ")"
            }
            "PerlOp.string_replicate(" . Perlito5::Java::to_str($self->{"arguments"}->[0], $level) . "," . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ")"
        }, "list:<.>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "new PlString(" . join(" + ", map(Perlito5::Java::to_native_str($_, $level, "scalar"), @{$self->{"arguments"}})) . ")"
        }, "list:<,>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            Perlito5::Java::to_list($self->{"arguments"}, $level)
        }, "infix:<..>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            return "new PerlRange(" . $self->{"arguments"}->[0]->emit_java($level) . ", " . $self->{"arguments"}->[1]->emit_java($level) . ").range(" . Perlito5::Java::to_context($wantarray) . ", " . "\"" . Perlito5::Java::get_label() . "\"" . ", " . 0 . ")"
        }, "infix:<...>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            return "new PerlRange(" . $self->{"arguments"}->[0]->emit_java($level) . ", " . $self->{"arguments"}->[1]->emit_java($level) . ").range(" . Perlito5::Java::to_context($wantarray) . ", " . "\"" . Perlito5::Java::get_label() . "\"" . ", " . 1 . ")"
        }, "delete", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ($arg->isa("Perlito5::AST::Lookup")) {
                my $v = $arg->obj();
                if ($v->isa("Perlito5::AST::Var") && $v->{"_real_sigil"} eq "%") {
                    $v = Perlito5::AST::Var::->new(%{$v}, "sigil", "%");
                    return $v->emit_java($level) . ".delete(" . Perlito5::Java::to_context($wantarray) . ", " . $arg->autoquote($arg->{"index_exp"})->emit_java($level) . ")"
                }
                return $v->emit_java($level, $wantarray, "hash") . ".delete(" . $arg->autoquote($arg->{"index_exp"})->emit_java($level) . ")"
            }
            if ($arg->isa("Perlito5::AST::Index")) {
                my $v = $arg->obj();
                if ($v->isa("Perlito5::AST::Var") && $v->{"_real_sigil"} eq "\@") {
                    $v = Perlito5::AST::Var::->new(%{$v}, "sigil", "\@");
                    return $v->emit_java($level) . ".delete(" . Perlito5::Java::to_context($wantarray) . ", " . $arg->{"index_exp"}->emit_java($level) . ")"
                }
                return $v->emit_java($level, $wantarray, "array") . ".delete(" . $arg->{"index_exp"}->emit_java($level) . ")"
            }
            if ($arg->isa("Perlito5::AST::Call")) {
                if ($arg->method() eq "postcircumfix:<{ }>") {;
                    return $arg->invocant()->emit_java($level, $wantarray, "hash") . ".delete(" . Perlito5::AST::Lookup::->autoquote($arg->{"arguments"})->emit_java($level) . ")"
                }
                if ($arg->method() eq "postcircumfix:<[ ]>") {;
                    return $arg->invocant()->emit_java($level, $wantarray, "array") . ".delete(" . $arg->{"arguments"}->emit_java($level) . ")"
                }
            }
            if ($arg->isa("Perlito5::AST::Var") && $arg->sigil() eq "&") {;
                die("TODO delete &code")
            }
            if ($arg->isa("Perlito5::AST::Apply") && $arg->{"code"} eq "prefix:<&>") {;
                die("TODO delete &\$code")
            }
        }, "scalar", sub {
            (my($self), my($level), my($wantarray)) = @_;
            if (@{$self->{"arguments"}} > 1) {;
                return "PerlOp.context(" . join(", ", Perlito5::Java::to_context("scalar"), map($_->emit_java($level, $wantarray), @{$self->{"arguments"}})) . ")"
            }
            Perlito5::Java::to_scalar($self->{"arguments"}, $level + 1)
        }, "ternary:<? :>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "( " . Perlito5::Java::to_boolean($self->{"arguments"}->[0], $level) . " ? " . ($self->{"arguments"}->[1])->emit_java($level, $wantarray) . " : " . ($self->{"arguments"}->[2])->emit_java($level, $wantarray) . ")"
        }, "my", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "PerlOp.context(" . join(", ", Perlito5::Java::to_context($wantarray), map($_->emit_java($level, $wantarray), @{$self->{"arguments"}})) . ")"
        }, "state", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "PerlOp.context(" . join(", ", Perlito5::Java::to_context($wantarray), map($_->emit_java($level, $wantarray), @{$self->{"arguments"}})) . ")"
        }, "our", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "PerlOp.context(" . join(", ", Perlito5::Java::to_context($wantarray), map($_->emit_java($level, $wantarray), @{$self->{"arguments"}})) . ")"
        }, "local", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "PerlOp.context(" . join(", ", Perlito5::Java::to_context($wantarray), map($_->emit_java($level, $wantarray), @{$self->{"arguments"}})) . ")"
        }, "circumfix:<( )>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "PerlOp.context(" . join(", ", Perlito5::Java::to_context($wantarray), map($_->emit_java($level, $wantarray), @{$self->{"arguments"}})) . ")"
        }, "infix:<=>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $parameters = $self->{"arguments"}->[0];
            my $arguments = $self->{"arguments"}->[1];
            return $parameters->emit_java_set($arguments, $level + 1, $wantarray)
        }, "break", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $Perlito5::THROW = 1;
            die("TODO - break() not implemented")
        }, "next", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $Perlito5::THROW = 1;
            my $label = Perlito5::Java::get_java_loop_label($self->{"arguments"}->[0]->{"code"});
            if ($label == 0) {;
                return "PerlOp.next()"
            }
            "PerlOp.next(" . $label . ")"
        }, "last", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $Perlito5::THROW = 1;
            my $label = Perlito5::Java::get_java_loop_label($self->{"arguments"}->[0]->{"code"});
            if ($label == 0) {;
                return "PerlOp.last()"
            }
            "PerlOp.last(" . $label . ")"
        }, "redo", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $Perlito5::THROW = 1;
            my $label = Perlito5::Java::get_java_loop_label($self->{"arguments"}->[0]->{"code"});
            "PerlOp.redo(" . $label . ")"
        }, "return", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $Perlito5::THROW_RETURN = 1;
            if (!@{$self->{"arguments"}}) {;
                return "PerlOp.ret(PerlOp.context(want))"
            }
            "PerlOp.ret(" . Perlito5::Java::to_runtime_context($self->{"arguments"}, $level + 1) . ")"
        }, "goto", sub {
            (my($self), my($level), my($wantarray)) = @_;
            $Perlito5::THROW_RETURN = 1;
            my $arg = $self->{"arguments"}->[0];
            if (ref($arg) eq "Perlito5::AST::Var" && $arg->{"sigil"} eq "&") {;
                return "PerlOp.ret(" . $arg->emit_java($level) . ")"
            }
            return "PerlOp.gotoOp(" . Perlito5::Java::to_context($wantarray) . ", " . $arg->emit_java($level) . ", " . "List__" . ")"
        }, "caller", sub {
            (my($self), my($level), my($wantarray)) = @_;
            return "PerlOp.caller(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_list($self->{"arguments"}, $level) . ")"
        }, "do", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ($arg->isa("Perlito5::AST::Block")) {
                my $ast = Perlito5::AST::Sub::->new("block", $arg, "attributes", [], "_do_block", 1);
                return $ast->emit_java($level + 1, $wantarray) . ".apply(" . Perlito5::Java::to_context($wantarray) . ", " . "List__" . ")"
            }
            my $ast = Perlito5::AST::Apply::->new("code", "eval", "namespace", '', "arguments", [Perlito5::AST::Apply::->new("code", "slurp_file", "namespace", "Perlito5::Grammar::Use", "arguments", $self->{"arguments"})], "_scope", Perlito5::Grammar::Scope::->new_base_scope(), "_hash_hints", {}, "_scalar_hints", 0);
            my $js = $ast->emit_java($level, $wantarray);
            return $js
        }, "eval", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0] || Perlito5::AST::Var::SCALAR_ARG();
            my $eval;
            if ($arg->isa("Perlito5::AST::Block")) {
                $Perlito5::THROW = 1;
                my $ast = Perlito5::AST::Call::->new("method", "postcircumfix:<( )>", "invocant", Perlito5::AST::Sub::->new("block", $arg, "attributes", [], "_eval_block", 1), "arguments", [Perlito5::AST::Var::LIST_ARG()]);
                return $ast->emit_java($level + 1, $wantarray)
            }
            if (!$Perlito5::JAVA_EVAL) {;
                return "PlCORE.die(\"This script has eval string disabled - the 'java_eval' switch is turned off\")"
            }
            my %vars;
            for my $var (@{$self->{"_scope"}->{"block"}}, @Perlito5::CAPTURES) {;
                if ($var->{"_decl"} && $var->{"_decl"} ne "global") {;
                    $vars{$var->{"_real_sigil"} || $var->{"sigil"}}->{$var->emit_java(0)} = $var
                }
            }
            my $scope = Perlito5::DumpToAST::dump_to_ast($self->{"_scope"}, {}, "s")->emit_java(0);
            my $hash_hints = Perlito5::DumpToAST::dump_to_ast($self->{"_hash_hints"}, {}, "s")->emit_java(0);
            my @out;
            {
                local %Perlito5::Java::Java_var_name;
                my %type = ("\$", "PlLvalue", "\@", "PlArray", "%", "PlHash");
                for my $sigil ("\$", "\@", "%") {
                    my @str;
                    my @val;
                    for my $var (keys(%{$vars{$sigil}})) {
                        push(@str, Perlito5::Java::escape_string($vars{$sigil}->{$var}->emit_java(0)));
                        push(@val, $var)
                    }
                    push(@out, "new String[]{" . join(", ", @str) . "}");
                    push(@out, "new " . $type{$sigil} . "[]{" . join(", ", @val) . "}")
                }
            }
            return "PlJavaCompiler.eval_perl_string(" . $arg->emit_java($level, $wantarray) . ".toString(), " . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ", " . Perlito5::Java::escape_string($wantarray) . ", " . "new PlInt(" . (0 + $self->{"_scalar_hints"}) . "L), " . $hash_hints . ", " . $scope . ", " . join(", ", @out) . ", " . Perlito5::Java::to_context($wantarray) . ", " . "List__" . ")"
        }, "length", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = shift(@{$self->{"arguments"}});
            return Perlito5::Java::to_str($arg) . ".length(" . ")"
        }, "substr", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = shift(@{$self->{"arguments"}});
            return Perlito5::Java::to_str($arg) . ".substr(" . join(", ", map($_->emit_java($level, "scalar"), @{$self->{"arguments"}})) . ")"
        }, "undef", sub {
            (my($self), my($level), my($wantarray)) = @_;
            if ($self->{"arguments"} && @{$self->{"arguments"}}) {
                my $arg = $self->{"arguments"}->[0];
                if (ref($arg) eq "Perlito5::AST::Var" && $arg->{"sigil"} eq "&") {
                    my $name = $arg->{"name"};
                    my $namespace = $arg->{"namespace"} || $Perlito5::PKG_NAME;
                    return "PlV.cset(" . Perlito5::Java::escape_string($namespace . "::" . $name) . ", PlCx.UNDEF)"
                }
                $self->{"arguments"} = [];
                return $arg->emit_java_set($self, $level, $wantarray)
            }
            return "PlCx.UNDEF"
        }, "defined", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0];
            my $invocant;
            if (ref($arg) eq "Perlito5::AST::Apply" && $arg->{"code"} eq "prefix:<&>") {
                my $arg2 = $arg->{"arguments"}->[0];
                $invocant = "PlV.code_lookup_by_name_no_autoload(" . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ", " . $arg2->emit_java($level) . ")"
            }
            elsif (ref($arg) eq "Perlito5::AST::Var" && $arg->{"sigil"} eq "&") {
                my $name = $arg->{"name"};
                my $namespace = $arg->{"namespace"} || $Perlito5::PKG_NAME;
                $invocant = "PlV.cget_no_autoload(" . Perlito5::Java::escape_string($namespace . "::" . $name) . ")"
            }
            else {;
                $invocant = $arg->emit_java($level, "scalar")
            }
            "new PlBool(!" . $invocant . ".is_undef())"
        }, "shift", sub {
            (my($self), my($level), my($wantarray)) = @_;
            if ($self->{"arguments"} && @{$self->{"arguments"}}) {;
                return $self->{"arguments"}->[0]->emit_java($level) . ".shift()"
            }
            if ($Perlito5::Java::is_inside_subroutine) {;
                return "List__.shift()"
            }
            return "PlV.array_get(\"main::ARGV\").shift()"
        }, "pop", sub {
            (my($self), my($level), my($wantarray)) = @_;
            if ($self->{"arguments"} && @{$self->{"arguments"}}) {;
                return $self->{"arguments"}->[0]->emit_java($level) . ".pop()"
            }
            if ($Perlito5::Java::is_inside_subroutine) {;
                return "List__.pop()"
            }
            return "PlV.array_get(\"main::ARGV\").pop()"
        }, "unshift", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @arguments = @{$self->{"arguments"}};
            my $v = shift(@arguments);
            return $v->emit_java($level) . ".unshift(" . Perlito5::Java::to_list(\@arguments, $level) . ")"
        }, "push", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @arguments = @{$self->{"arguments"}};
            my $v = shift(@arguments);
            if (@arguments == 1 && ref($arguments[0]) eq "Perlito5::AST::Var" && $arguments[0]->{"sigil"} eq "\$") {;
                return $v->emit_java($level) . ".push(" . $arguments[0]->emit_java($level) . ")"
            }
            return $v->emit_java($level) . ".push(" . Perlito5::Java::to_list(\@arguments, $level) . ")"
        }, "splice", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @arguments = @{$self->{"arguments"}};
            my $array = shift(@arguments);
            my $offset = shift(@arguments);
            my $length = shift(@arguments);
            "PlCORE.splice(" . Perlito5::Java::to_context($wantarray) . ", " . $array->emit_java($level) . ($offset ? (", " . $offset->emit_java($level)) : ()) . ($length ? (", " . $length->emit_java($level)) : ()) . (@arguments ? (", " . Perlito5::Java::to_list(\@arguments, $level)) : ()) . ")"
        }, "pos", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @arguments = @{$self->{"arguments"}};
            if (!@arguments) {;
                push(@arguments, Perlito5::AST::Var::SCALAR_ARG())
            }
            "PerlOp.pos(" . $arguments[0]->emit_java($level, "scalar") . ")"
        }, "tie", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @arguments = @{$self->{"arguments"}};
            my $v = shift(@arguments);
            if (ref($v) eq "Perlito5::AST::Decl") {;
                $v = $v->{"var"}
            }
            if (($v->isa("Perlito5::AST::Var") && ($v->{"sigil"} eq "%" || $v->{"sigil"} eq "\@")) || ($v->isa("Perlito5::AST::Apply") && ($v->{"code"} eq "prefix:<\@>" || $v->{"code"} eq "prefix:<%>"))) {;
                return $v->emit_java($level) . ".tie(" . Perlito5::Java::to_list(\@arguments, $level) . ")"
            }
            return $v->emit_java($level, "scalar", "lvalue") . ".tie(" . Perlito5::Java::to_list(\@arguments, $level) . ")"
        }, "untie", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @arguments = @{$self->{"arguments"}};
            my $v = shift(@arguments);
            return $v->emit_java($level) . ".untie()"
        }, "tied", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @arguments = @{$self->{"arguments"}};
            my $v = shift(@arguments);
            return $v->emit_java($level) . ".tied()"
        }, "print", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun;
            if ($self->{"special_arg"}) {;
                $fun = Perlito5::Java::to_filehandle($self->{"special_arg"}, $level + 1)
            }
            else {;
                $fun = "PlCx.STDOUT"
            }
            my $list = Perlito5::Java::to_list(\@in, $level);
            "PlCORE.print(" . Perlito5::Java::to_context($wantarray) . ", " . $fun . ", " . $list . ")"
        }, "say", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun;
            if ($self->{"special_arg"}) {;
                $fun = Perlito5::Java::to_filehandle($self->{"special_arg"}, $level + 1)
            }
            else {;
                $fun = "PlCx.STDOUT"
            }
            my $list = Perlito5::Java::to_list(\@in, $level);
            "PlCORE.say(" . Perlito5::Java::to_context($wantarray) . ", " . $fun . ", " . $list . ")"
        }, "printf", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun;
            if ($self->{"special_arg"}) {;
                $fun = Perlito5::Java::to_filehandle($self->{"special_arg"}, $level + 1)
            }
            else {;
                $fun = "PlCx.STDOUT"
            }
            my $list = "new PlArray(PlCORE.sprintf(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_list(\@in, $level) . "))";
            "PlCORE.print(" . Perlito5::Java::to_context($wantarray) . ", " . $fun . ", " . $list . ")"
        }, "hex", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "PlCORE.hex(" . Perlito5::Java::to_context($wantarray) . ", " . $self->{"arguments"}->[0]->emit_java($level) . ")"
        }, "oct", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "PlCORE.oct(" . Perlito5::Java::to_context($wantarray) . ", " . $self->{"arguments"}->[0]->emit_java($level) . ")"
        }, "fc", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "PlCORE.fc(" . Perlito5::Java::to_context($wantarray) . ", " . $self->{"arguments"}->[0]->emit_java($level) . ")"
        }, "values", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "PlCORE.values(" . Perlito5::Java::to_context($wantarray) . ", " . $self->{"arguments"}->[0]->emit_java($level) . ")"
        }, "keys", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "PlCORE.keys(" . Perlito5::Java::to_context($wantarray) . ", " . $self->{"arguments"}->[0]->emit_java($level) . ")"
        }, "each", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "PlCORE.each(" . Perlito5::Java::to_context($wantarray) . ", " . $self->{"arguments"}->[0]->emit_java($level) . ")"
        }, "mkdir", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @arguments = @{$self->{"arguments"}};
            if (@arguments < 1) {;
                push(@arguments, Perlito5::AST::Var::SCALAR_ARG())
            }
            if (@arguments < 2) {;
                push(@arguments, Perlito5::AST::Int::->new("int", 511))
            }
            "PlCORE.mkdir(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_list($self->{"arguments"}, $level) . ")"
        }, "rmdir", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @arguments = @{$self->{"arguments"}};
            if (@arguments < 1) {;
                push(@arguments, Perlito5::AST::Var::SCALAR_ARG())
            }
            "PlCORE.rmdir(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_list($self->{"arguments"}, $level) . ")"
        }, "chdir", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @arguments = @{$self->{"arguments"}};
            if (@arguments < 1) {;
                push(@arguments, Perlito5::AST::Var::SCALAR_ARG())
            }
            "PlCORE.chdir(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_list($self->{"arguments"}, $level) . ")"
        }, "unlink", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @arguments = @{$self->{"arguments"}};
            if (@arguments < 1) {;
                push(@arguments, Perlito5::AST::Var::SCALAR_ARG())
            }
            "PlCORE.unlink(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_list($self->{"arguments"}, $level) . ")"
        }, "chomp", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "PlCORE.chomp(" . Perlito5::Java::to_context($wantarray) . ", " . $self->{"arguments"}->[0]->emit_java($level) . ")"
        }, "chop", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "PlCORE.chop(" . Perlito5::Java::to_context($wantarray) . ", " . $self->{"arguments"}->[0]->emit_java($level) . ")"
        }, "getc", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun = shift(@in);
            if ($fun) {;
                $fun = Perlito5::Java::to_filehandle($fun, $level + 1)
            }
            else {;
                $fun = "PlCx.STDIN"
            }
            "PlCORE.getc(" . Perlito5::Java::to_context($wantarray) . ", " . $fun . ", " . Perlito5::Java::to_param_list(\@in, $level + 1) . ")"
        }, "readline", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun = shift(@in) || bless({"arguments", [], "bareword", 1, "code", "ARGV", "namespace", "main"}, "Perlito5::AST::Apply");
            my $list = Perlito5::Java::to_list(\@in, $level);
            "PlCORE.readline(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_filehandle($fun, $level + 1) . ", " . $list . ")"
        }, "map", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun;
            if ($self->{"special_arg"}) {;
                $fun = $self->{"special_arg"}
            }
            else {;
                $fun = shift(@in)
            }
            my $list = Perlito5::Java::to_list(\@in, $level);
            if (ref($fun) eq "Perlito5::AST::Block") {;
                $fun = $fun->{"stmts"}
            }
            else {;
                $fun = [$fun]
            }
            my $sub = Perlito5::AST::Sub::->new("block", Perlito5::AST::Block::->new("stmts", $fun));
            "PerlOp.map(" . $sub->emit_java($level + 1) . ", " . $list . ", " . "List__, " . Perlito5::Java::to_context($wantarray) . ")"
        }, "grep", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun;
            if ($self->{"special_arg"}) {;
                $fun = $self->{"special_arg"}
            }
            else {;
                $fun = shift(@in)
            }
            my $list = Perlito5::Java::to_list(\@in, $level);
            if (ref($fun) eq "Perlito5::AST::Block") {;
                $fun = $fun->{"stmts"}
            }
            else {;
                $fun = [$fun]
            }
            my $sub = Perlito5::AST::Sub::->new("block", Perlito5::AST::Block::->new("stmts", $fun));
            "PerlOp.grep(" . $sub->emit_java($level + 1) . ", " . $list . ", " . "List__, " . Perlito5::Java::to_context($wantarray) . ")"
        }, "bless", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $items = Perlito5::Java::to_list_preprocess($self->{"arguments"});
            my @in = @{$items};
            my $ref = shift(@in);
            my $class = shift(@in);
            if ($class) {;
                $class = Perlito5::Java::to_native_str($class)
            }
            else {;
                $class = Perlito5::Java::escape_string($Perlito5::PKG_NAME)
            }
            return $ref->emit_java($level, "scalar") . ".bless(" . $class . ")"
        }, "sort", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @in = @{$self->{"arguments"}};
            my $fun;
            my $list;
            if ($self->{"special_arg"}) {;
                $fun = $self->{"special_arg"}
            }
            elsif (ref($in[0]) eq "Perlito5::AST::Block") {;
                $fun = shift(@in)
            }
            if (ref($fun) eq "Perlito5::AST::Block") {;
                $fun = $fun->{"stmts"}
            }
            else {;
                die("TODO: sort without block not implemented yet")
            }
            $list = Perlito5::Java::to_list(\@in, $level);
            my $sub = Perlito5::AST::Sub::->new("block", Perlito5::AST::Block::->new("stmts", $fun));
            "PerlOp.sort(" . $sub->emit_java($level + 1) . ", " . $list . ", " . "List__, " . Perlito5::Java::to_context($wantarray) . ")"
        }, "infix:<//>", sub {
            (my($self), my($level), my($wantarray)) = @_;
            "(PerlOp.defined_or1(" . $self->{"arguments"}->[0]->emit_java($level, "scalar") . ") ? PerlOp.defined_or2() : " . $self->{"arguments"}->[1]->emit_java($level, "scalar") . ")"
        }, "exists", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0];
            if ($arg->isa("Perlito5::AST::Lookup")) {
                my $v = $arg->obj();
                if ($v->isa("Perlito5::AST::Var") && $v->sigil() eq "\$") {;
                    return $v->emit_java($level, $wantarray) . ".exists(" . $arg->autoquote($arg->{"index_exp"})->emit_java($level) . ")"
                }
                return $v->emit_java($level, $wantarray, "hash") . ".exists(" . $arg->autoquote($arg->{"index_exp"})->emit_java($level) . ")"
            }
            if ($arg->isa("Perlito5::AST::Index")) {
                my $v = $arg->obj();
                if ($v->isa("Perlito5::AST::Var") && $v->sigil() eq "\$") {;
                    return $v->emit_java($level, "array") . ".exists(" . $arg->{"index_exp"}->emit_java($level) . ")"
                }
                return $v->emit_java($level, $wantarray, "array") . ".exists(" . $arg->{"index_exp"}->emit_java($level) . ")"
            }
            if ($arg->isa("Perlito5::AST::Call")) {
                if ($arg->method() eq "postcircumfix:<{ }>") {;
                    return $arg->invocant()->emit_java($level, $wantarray, "hash") . ".exists(" . Perlito5::AST::Lookup::->autoquote($arg->{"arguments"})->emit_java($level) . ")"
                }
                if ($arg->method() eq "postcircumfix:<[ ]>") {;
                    return $arg->invocant()->emit_java($level, $wantarray, "array") . ".exists(" . $arg->{"arguments"}->emit_java($level) . ")"
                }
            }
            if ($arg->isa("Perlito5::AST::Var") && $arg->sigil() eq "&") {
                my $name = $arg->{"name"};
                my $namespace = $arg->{"namespace"} || $Perlito5::PKG_NAME;
                return "new PlBool(PlV.cget_no_autoload(" . Perlito5::Java::escape_string($namespace . "::" . $name) . ").is_coderef())"
            }
            if ($arg->isa("Perlito5::AST::Apply") && $arg->{"code"} eq "prefix:<&>") {
                my $arg2 = $arg->{"arguments"}->[0];
                return "new PlBool(" . "PlV.code_lookup_by_name_no_autoload(" . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ", " . $arg2->emit_java($level) . ")" . ".is_coderef())"
            }
        }, "prototype", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my $arg = $self->{"arguments"}->[0];
            return "PerlOp.prototype(" . $arg->emit_java($level) . ", " . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ")"
        }, "split", sub {
            (my($self), my($level), my($wantarray)) = @_;
            my @arguments = @{$self->{"arguments"}};
            if (@arguments < 1) {;
                push(@arguments, Perlito5::AST::Buf::->new("buf", " "))
            }
            if (@arguments < 2) {;
                push(@arguments, Perlito5::AST::Var::SCALAR_ARG())
            }
            if (@arguments < 3) {;
                push(@arguments, Perlito5::AST::Int::->new("int", 0))
            }
            my @js;
            my $arg = $arguments[0];
            if ($arg && $arg->isa("Perlito5::AST::Apply") && $arg->{"code"} eq "p5:m") {
                my $flags = $arg->{"arguments"}->[1]->{"buf"};
                $flags !~ m/m/ && ($flags .= "m");
                push(@js, emit_qr_java($arg->{"arguments"}->[0], $flags));
                shift(@arguments)
            }
            return "PlCORE.split(" . join(", ", Perlito5::Java::to_context($wantarray), @js, map($_->emit_java($level), @arguments)) . ")"
        });
        for my $op ("close", "closedir", "open", "opendir", "readdir", "seek", "seekdir", "read", "sysread") {;
            $emit_js{$op} = sub {
                (my($self), my($level), my($wantarray)) = @_;
                my @in = @{$self->{"arguments"}};
                my $fun = shift(@in);
                "PlCORE." . $op . "(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_filehandle($fun, $level + 1) . ", " . Perlito5::Java::to_param_list(\@in, $level + 1) . ")"
            }
        }
        for my $op ("sleep", "ref", "exit", "warn", "die", "system", "qx", "pack", "unpack", "sprintf", "crypt", "join", "reverse", "select") {;
            $emit_js{$op} = sub {
                (my($self), my($level), my($wantarray)) = @_;
                "PlCORE." . $op . "(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_list($self->{"arguments"}, $level) . ")"
            }
        }
        for my $op ("time") {;
            $emit_js{$op} = sub {
                (my($self), my($level), my($wantarray)) = @_;
                "PlV.apply_maybe_core(" . Perlito5::Java::escape_string($Perlito5::PKG_NAME . "::" . $op) . ", " . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_list($self->{"arguments"}, $level) . ")"
            }
        }
        sub Perlito5::AST::Apply::emit_java {
            (my($self), my($level), my($wantarray), my($autovivification_type)) = @_;
            my $apply = $self->op_assign();
            if ($apply) {;
                return $apply->emit_java($level)
            }
            my $apply = $self->op_auto();
            if ($apply) {;
                return $apply->emit_java($level)
            }
            my $code = $self->{"code"};
            if (ref($code) ne '') {
                my $items = Perlito5::Java::to_list_preprocess($self->{"arguments"});
                if (ref($code) eq "Perlito5::AST::Apply" && $code->code() eq "prefix:<&>") {
                    my $arg = $code->{"arguments"}->[0];
                    my $invocant = "PlV.code_lookup_by_name(" . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ", " . $arg->emit_java($level) . ")";
                    return $invocant . ".apply(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_param_list($items, $level + 1) . ")"
                }
                return $self->{"code"}->emit_java($level) . ".apply(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_param_list($items, $level + 1) . ")"
            }
            $code eq "package" && return '';
            exists($emit_js{$code}) && ($self->{"namespace"} eq '' || $self->{"namespace"} eq "GLOBAL") && return $emit_js{$code}->($self, $level, $wantarray, $autovivification_type);
            if (exists($Perlito5::Java::op_prefix_js_str{$code})) {;
                return $Perlito5::Java::op_prefix_js_str{$code} . "(" . Perlito5::Java::to_str($self->{"arguments"}->[0]) . ")"
            }
            if ($self->{"namespace"}) {
                if ($self->{"namespace"} eq "Java" && $code eq "inline") {
                    my @args = @{$self->{"arguments"}};
                    if (@args != 1) {;
                        die("Java::inline needs a single argument")
                    }
                    if ($args[0]->isa("Perlito5::AST::Apply") && $args[0]->{"code"} eq "list:<.>") {
                        @args = @{$args[0]->{"arguments"}};
                        if (@args != 1) {;
                            die("Java::inline needs a string constant, got:", Perlito5::Dumper::Dumper(\@args))
                        }
                    }
                    if ($args[0]->isa("Perlito5::AST::Buf")) {;
                        return $args[0]->{"buf"}
                    }
                    else {;
                        die("Java::inline needs a string constant, got:", Perlito5::Dumper::Dumper(\@args))
                    }
                }
                if ($self->{"namespace"} eq "Perlito5") {;
                    if ($code eq "eval_ast") {;
                        $self->{"namespace"} = "Perlito5::Java::Runtime"
                    }
                }
                $code = $self->{"namespace"} . "::" . $code
            }
            else {;
                $code = $Perlito5::PKG_NAME . "::" . $code
            }
            my $sig;
            my $may_need_autoload;
            {
                my $name = $self->{"code"};
                my $namespace = $self->{"namespace"} || $Perlito5::PKG_NAME;
                my $effective_name = $namespace . "::" . $self->{"code"};
                if (exists($Perlito5::PROTO->{$effective_name})) {;
                    $sig = $Perlito5::PROTO->{$effective_name}
                }
                elsif ((!$self->{"namespace"} || $namespace eq "CORE") && exists($Perlito5::CORE_PROTO->{"CORE::" . $name})) {
                    $effective_name = "CORE::" . $name;
                    $sig = $Perlito5::CORE_PROTO->{$effective_name}
                }
                else {
                    if ($self->{"bareword"}) {;
                        return Perlito5::AST::Buf::->new("buf", ($self->{"namespace"} ? $self->{"namespace"} . "::" : '') . $name)->emit_java($level + 1, "scalar")
                    }
                    $may_need_autoload = 1
                }
                (exists($self->{"proto"})) && ($sig = $self->{"proto"})
            }
            $self->{"ignore_proto"} && ($sig = '');
            if ($sig) {
                my @out = ();
                my @in = @{$self->{"arguments"} || []};
                my $optional = 0;
                while (length($sig)) {
                    my $c = substr($sig, 0, 1);
                    if ($c eq ";") {;
                        $optional = 1
                    }
                    elsif ($c eq "\$" || $c eq "_") {;
                        (@in || !$optional) && push(@out, shift(@in)->emit_java($level + 1, "scalar"))
                    }
                    elsif ($c eq "\@") {
                        (@in || !$optional) && push(@out, Perlito5::Java::to_list(\@in, $level + 1));
                        @in = ()
                    }
                    elsif ($c eq "&") {;
                        push(@out, shift(@in)->emit_java($level + 1, "scalar"))
                    }
                    elsif ($c eq "*") {;
                        if (@in || !$optional) {
                            my $arg = shift(@in);
                            if ($arg->{"bareword"}) {;
                                push(@out, Perlito5::AST::Buf::->new("buf", $arg->{"code"})->emit_java($level + 1, "scalar"))
                            }
                            else {;
                                push(@out, $arg->emit_java($level + 1, "scalar"))
                            }
                        }
                    }
                    elsif ($c eq "\\") {
                        if (substr($sig, 0, 2) eq "\\\$") {
                            $sig = substr($sig, 1);
                            (@in || !$optional) && push(@out, shift(@in)->emit_java($level + 1, "scalar"))
                        }
                        elsif (substr($sig, 0, 2) eq "\\\@" || substr($sig, 0, 2) eq "\\%") {
                            $sig = substr($sig, 1);
                            (@in || !$optional) && push(@out, shift(@in)->emit_java($level + 1, "list"))
                        }
                        elsif (substr($sig, 0, 5) eq "\\[\@%]") {
                            $sig = substr($sig, 4);
                            (@in || !$optional) && push(@out, shift(@in)->emit_java($level + 1, "list"))
                        }
                        elsif (substr($sig, 0, 6) eq "\\[\$\@%]") {
                            $sig = substr($sig, 5);
                            (@in || !$optional) && push(@out, shift(@in)->emit_java($level + 1, "list"))
                        }
                    }
                    $sig = substr($sig, 1)
                }
                return "PlV.apply(" . Perlito5::Java::escape_string($code) . ", " . Perlito5::Java::to_context($wantarray) . ", PlArray.construct_list_of_aliases(" . join(", ", @out) . ")" . ")"
            }
            my $items = Perlito5::Java::to_list_preprocess($self->{"arguments"});
            "PlV.apply(" . Perlito5::Java::escape_string($code) . ", " . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_param_list($items, $level + 1) . ")"
        }
        sub Perlito5::AST::Apply::emit_java_get_decl {
            my $self = shift;
            my $code = $self->{"code"};
            if ($code eq "my" || $code eq "state" || $code eq "local") {;
                return (map {;
                    ref($_) eq "Perlito5::AST::Var" ? Perlito5::AST::Decl::->new("decl", $code, "type", '', "var", $_) : ()
                } @{$self->{"arguments"}})
            }
            if ($code ne "do" && $code ne "eval") {;
                $self->{"arguments"} && return (map(+($_->emit_java_get_decl()), @{$self->{"arguments"}}))
            }
            return ()
        }
        sub Perlito5::AST::Apply::emit_java_has_regex {
            my $self = shift;
            my $code = $self->{"code"};
            if ($code eq "p5:m" || $code eq "p5:s" || $code eq "infix:<=~>" || $code eq "infix:<!~>") {;
                return 1
            }
            return ()
        }
    }
    1
}
{
    package main;
    package Perlito5::Java;
    {
        my %label;
        my %Java_class;
        our %Java_var_name;
        my %Java_var;
        our @Java_init;
        our $is_inside_subroutine;
        sub Perlito5::Java::pkg {;
            Perlito5::Java::escape_string($Perlito5::PKG_NAME)
        }
        sub Perlito5::Java::get_label {;
            "tmp" . $Perlito5::ID++
        }
        sub Perlito5::Java::tab {
            my $level = shift;
            "    " x $level
        }
        sub Perlito5::Java::get_java_class_info {;
            return \%Java_class
        }
        sub Perlito5::Java::get_java_var_info {;
            return \%Java_var
        }
        sub Perlito5::Java::set_java_class_defaults {
            (my($perl_package), my($java_import)) = @_;
            my $Java_class = Perlito5::Java::get_java_class_info();
            my @parts = split(m/\./, $java_import);
            $Java_class->{$perl_package}->{"java_type"} //= $parts[-1];
            $Java_class->{$perl_package}->{"java_native_to_perl"} //= "p" . $Java_class->{$perl_package}->{"java_type"};
            $Java_class->{$perl_package}->{"java_native_to_perl"} =~ s/[<>]/_/g;
            my $perl_to_java = $perl_package;
            $perl_to_java =~ s/:://g;
            $Java_class->{$perl_package}->{"perl_to_java"} //= "to_" . $perl_to_java;
            $Java_class->{$perl_package}->{"perl_package"} = $perl_package
        }
        sub Perlito5::Java::init_java_class {
            my $Java_class = Perlito5::Java::get_java_class_info();
            $Java_class->{"String"} = {"java_type", "String", "java_native_to_perl", "PlString", "perl_to_java", "toString", "perl_package", "String"};
            $Java_class->{"Long"} = {"java_type", "Long", "java_native_to_perl", "PlInt", "perl_to_java", "to_long", "perl_package", "Long"};
            $Java_class->{"Integer"} = {"java_type", "Integer", "java_native_to_perl", "PlInt", "perl_to_java", "to_int", "perl_package", "Integer"};
            $Java_class->{"Boolean"} = {"java_type", "Boolean", "java_native_to_perl", "PlBool", "perl_to_java", "to_boolean", "perl_package", "Boolean"};
            $Java_class->{"Double"} = {"java_type", "Double", "java_native_to_perl", "PlDouble", "perl_to_java", "to_double", "perl_package", "Double"};
            $Java_class->{"Byte"} = {"java_type", "Byte", "java_native_to_perl", "PlInt", "perl_to_java", "to_byte", "perl_package", "Byte"};
            $Java_class->{"Short"} = {"java_type", "Short", "java_native_to_perl", "PlInt", "perl_to_java", "to_short", "perl_package", "Short"};
            $Java_class->{"Float"} = {"java_type", "Float", "java_native_to_perl", "PlDouble", "perl_to_java", "to_float", "perl_package", "Float"};
            $Java_class->{"Character"} = {"java_type", "Character", "java_native_to_perl", "PlString", "perl_to_java", "to_char", "perl_package", "Character"};
            $Java_class->{"long"} = {"java_type", "long", "java_native_to_perl", "PlInt", "perl_to_java", "to_long", "perl_package", "long"};
            $Java_class->{"int"} = {"java_type", "int", "java_native_to_perl", "PlInt", "perl_to_java", "to_int", "perl_package", "int"};
            $Java_class->{"short"} = {"java_type", "short", "java_native_to_perl", "PlInt", "perl_to_java", "to_long", "perl_package", "short"};
            $Java_class->{"byte"} = {"java_type", "byte", "java_native_to_perl", "PlInt", "perl_to_java", "to_long", "perl_package", "byte"};
            $Java_class->{"boolean"} = {"java_type", "boolean", "java_native_to_perl", "PlBool", "perl_to_java", "to_boolean", "perl_package", "boolean"};
            $Java_class->{"double"} = {"java_type", "double", "java_native_to_perl", "PlDouble", "perl_to_java", "to_double", "perl_package", "double"};
            $Java_class->{"float"} = {"java_type", "float", "java_native_to_perl", "PlDouble", "perl_to_java", "to_float", "perl_package", "float"};
            $Java_class->{"char"} = {"java_type", "char", "java_native_to_perl", "PlString", "perl_to_java", "to_char", "perl_package", "char"}
        }
        our %Java_loop_label;
        sub Perlito5::Java::get_java_loop_label {
            my $s = shift;
            !$s && return 0;
            exists($Java_loop_label{$s}) && return $Java_loop_label{$s};
            my $label = $Perlito5::ID++;
            $Java_loop_label{$s} = $label;
            return $label
        }
        our %op_prefix_js_str = ("prefix:<-A>", "PerlOp.p5atime", "prefix:<-C>", "PerlOp.p5ctime", "prefix:<-M>", "PerlOp.p5mtime", "prefix:<-d>", "PerlOp.p5is_directory", "prefix:<-e>", "PerlOp.p5file_exists", "prefix:<-f>", "PerlOp.p5is_file", "prefix:<-s>", "PerlOp.p5size");
        our %op_infix_js_str = ("infix:<eq>", " == ", "infix:<ne>", " != ", "infix:<le>", " <= ", "infix:<ge>", " >= ", "infix:<lt>", " < ", "infix:<gt>", " > ");
        our %op_to_boolean = map(+($_, 1), "prefix:<!>", "infix:<!=>", "infix:<==>", "infix:<<=>", "infix:<>=>", "infix:<>>", "infix:<<>", "infix:<eq>", "infix:<ne>", "infix:<ge>", "infix:<le>", "infix:<gt>", "infix:<lt>", "prefix:<not>", "exists", "defined");
        our %op_to_str = map(+($_, 1), "substr", "join", "list:<.>", "chr", "lc", "uc", "lcfirst", "ucfirst", "ref");
        our %op_to_num = map(+($_, 1), "length", "index", "rindex", "ord", "oct", "infix:<->", "infix:<+>", "infix:<*>", "infix:</>", "infix:<%>", "infix:<**>", "infix:<|>", "infix:<&>");
        our %native_op = ("infix:<->", "-", "infix:<+>", "+", "infix:<*>", "*", "infix:</>", "/", "infix:<!=>", "!=", "infix:<==>", "==", "infix:<<=>", "<=", "infix:<>=>", ">=", "infix:<>>", ">", "infix:<<>", "<");
        our %native_op_unary = ("postfix:<++>", 1, "postfix:<-->", 1, "prefix:<++>", 1, "prefix:<-->", 1);
        our %native_op_to_boolean = ("infix:<!=>", "!=", "infix:<==>", "==", "infix:<<=>", "<=", "infix:<>=>", ">=", "infix:<>>", ">", "infix:<<>", "<");
        our %valid_java_statement = ("print", 1, "say", 1, "printf", 1, "return", 1, "push", 1, "infix:<=>", 1, "postfix:<++>", 1, "postfix:<-->", 1, "prefix:<++>", 1, "prefix:<-->", 1, "tie", 1, "untie", 1);
        my %safe_char = (" ", 1, "!", 1, "#", 1, "\$", 1, "%", 1, "&", 1, "(", 1, ")", 1, "*", 1, "+", 1, ",", 1, "-", 1, ".", 1, "/", 1, ":", 1, ";", 1, "<", 1, "=", 1, ">", 1, "?", 1, "\@", 1, "[", 1, "]", 1, "^", 1, "_", 1, "`", 1, "{", 1, "|", 1, "}", 1, "~", 1);
        sub Perlito5::Java::escape_string {
            my $s = shift;
            my @out;
            my $tmp = '';
            my $has_char = 0;
            $s eq '' && return "\"\"";
            for my $i (0 .. length($s) - 1) {
                my $c = substr($s, $i, 1);
                if (($c ge "a" && $c le "z") || ($c ge "A" && $c le "Z") || ($c ge 0 && $c le 9) || exists($safe_char{$c})) {;
                    $tmp = $tmp . $c
                }
                elsif (ord($c) > 65535) {
                    $tmp ne '' && push(@out, "\"" . $tmp . "\"");
                    push(@out, "new String(Character.toChars(" . ord($c) . "))");
                    $has_char = 1;
                    $tmp = ''
                }
                else {
                    $tmp ne '' && push(@out, "\"" . $tmp . "\"");
                    push(@out, "(char)" . ord($c) . '');
                    $has_char = 1;
                    $tmp = ''
                }
            }
            $tmp ne '' && push(@out, "\"" . $tmp . "\"");
            $has_char && unshift(@out, "\"\"");
            return join(" + ", @out)
        }
        sub Perlito5::Java::is_native {
            my $self = shift;
            if (ref($self) eq "Perlito5::AST::Call") {
                if (ref($self->{"invocant"}) eq "Perlito5::AST::Var" && $self->{"invocant"}->{"sigil"} eq "::") {
                    my $Java_class = Perlito5::Java::get_java_class_info();
                    if (exists($Java_class->{$self->{"invocant"}->{"namespace"}})) {;
                        return 1
                    }
                }
                if (ref($self->{"invocant"}) eq "Perlito5::AST::Var" && $self->{"invocant"}->{"_id"}) {
                    my $id = $self->{"invocant"}->{"_id"};
                    my $Java_var = Perlito5::Java::get_java_var_info();
                    my $type = $Java_var->{$id}->{"type"} || "PlLvalue";
                    if ($type ne "PlLvalue") {;
                        return 1
                    }
                }
                if (is_native($self->{"invocant"})) {;
                    return 1
                }
                my $meth = $self->{"method"};
                if ($meth =~ m/^to/) {
                    my $Java_class = Perlito5::Java::get_java_class_info();
                    for my $info (values(%{$Java_class})) {;
                        if ($meth eq $info->{"perl_to_java"}) {;
                            return 1
                        }
                    }
                }
            }
            return 0
        }
        sub Perlito5::Java::is_native_bool {
            my $self = shift;
            if (is_native_args([$self])) {;
                return 1
            }
            my $is_apply = $self->isa("Perlito5::AST::Apply") && $self->{"arguments"} && @{$self->{"arguments"}};
            if ($is_apply && exists($native_op_to_boolean{$self->{"code"}}) && is_native_args($self->{"arguments"})) {;
                return 1
            }
            return 0
        }
        sub Perlito5::Java::to_native_args {
            my $args = shift;
            my $level = shift;
            my $wantarray = "scalar";
            my $s = '';
            my @out;
            for my $cond (@{$args}) {
                my $is_apply = $cond->isa("Perlito5::AST::Apply") && $cond->{"arguments"} && @{$cond->{"arguments"}};
                if ($is_apply && $cond->code() eq "circumfix:<( )>") {;
                    push(@out, to_native_args($cond->{"arguments"}->[0], $level))
                }
                elsif ($is_apply && exists($native_op{$cond->code()})) {;
                    push(@out, "(" . to_native_num($cond->{"arguments"}->[0], $level, $wantarray) . " " . $native_op{$cond->code()} . " " . to_native_num($cond->{"arguments"}->[1], $level, $wantarray) . ")")
                }
                elsif ($is_apply && exists($op_to_num{$cond->code()})) {;
                    push(@out, "(" . $cond->emit_java($level, $wantarray) . ")." . ($cond->{"arguments"}->[0]->isa("Perlito5::AST::Num") || $cond->{"arguments"}->[1]->isa("Perlito5::AST::Num") ? "to_double()" : "to_long()"))
                }
                elsif ($is_apply && exists($op_to_str{$cond->code()})) {;
                    push(@out, "(" . $cond->emit_java($level, $wantarray) . ").toString()")
                }
                elsif ($cond->isa("Perlito5::AST::Apply") && $cond->{"code"} eq "undef") {;
                    push(@out, "null")
                }
                elsif ($cond->isa("Perlito5::AST::Buf")) {;
                    push(@out, Perlito5::Java::escape_string($cond->{"buf"}))
                }
                elsif ($cond->isa("Perlito5::AST::Int")) {;
                    push(@out, $cond->{"int"})
                }
                elsif ($cond->isa("Perlito5::AST::Num")) {;
                    push(@out, $cond->{"num"})
                }
                else {;
                    push(@out, $cond->emit_java($level, $wantarray))
                }
            }
            return join(", ", @out)
        }
        sub Perlito5::Java::is_native_args {
            my $args = shift;
            my $wantarray = "scalar";
            my $s = '';
            my @out;
            for my $cond (@{$args}) {
                my $is_apply = $cond->isa("Perlito5::AST::Apply") && $cond->{"arguments"} && @{$cond->{"arguments"}};
                if ($is_apply && $cond->code() eq "circumfix:<( )>") {;
                    is_native_args($cond->{"arguments"}) || return 0
                }
                elsif ($is_apply && exists($native_op{$cond->code()})) {;
                    is_native_args($cond->{"arguments"}) || return 0
                }
                elsif ($is_apply && exists($native_op_unary{$cond->code()})) {;
                    is_native_args($cond->{"arguments"}) || return 0
                }
                elsif ($cond->isa("Perlito5::AST::Int")) {}
                elsif ($cond->isa("Perlito5::AST::Num")) {}
                elsif (ref($cond) eq "Perlito5::AST::Var" && $cond->{"_id"}) {
                    my $id = $cond->{"_id"};
                    my $Java_var = Perlito5::Java::get_java_var_info();
                    my $type = $Java_var->{$id}->{"type"} || "PlLvalue";
                    if ($type eq "PlLvalue") {;
                        return 0
                    }
                }
                else {;
                    is_native($cond) || return 0
                }
            }
            @{$args} && return 1;
            return 0
        }
        sub Perlito5::Java::to_native_bool {
            my $cond = shift;
            my $level = shift;
            my $wantarray = shift;
            if ($cond->isa("Perlito5::AST::Apply") && $cond->code() eq "circumfix:<( )>" && $cond->{"arguments"} && @{$cond->{"arguments"}}) {;
                return to_native_bool($cond->{"arguments"}->[0], $level, $wantarray)
            }
            elsif ($cond->isa("Perlito5::AST::Int")) {
                if ($cond->{"int"} == 0) {;
                    return "false"
                }
                return "(" . $cond->{"int"} . " != 0)"
            }
            elsif ($cond->isa("Perlito5::AST::Num")) {;
                return "(" . $cond->{"num"} . " != 0.0)"
            }
            else {;
                return to_native_args([$cond], $level)
            }
        }
        sub Perlito5::Java::to_native_num {
            my $cond = shift;
            my $level = shift;
            my $wantarray = shift;
            if ($cond->isa("Perlito5::AST::Apply") && $cond->code() eq "circumfix:<( )>" && $cond->{"arguments"} && @{$cond->{"arguments"}}) {;
                return to_native_num($cond->{"arguments"}->[0], $level, $wantarray)
            }
            elsif ($cond->isa("Perlito5::AST::Int")) {;
                return $cond->{"int"}
            }
            elsif ($cond->isa("Perlito5::AST::Num")) {;
                return $cond->{"num"}
            }
            else {;
                return to_native_args([$cond], $level)
            }
        }
        sub Perlito5::Java::to_native_str {
            my $cond = shift;
            my $level = shift;
            my $wantarray = shift;
            if ($cond->isa("Perlito5::AST::Apply") && $cond->code() eq "circumfix:<( )>" && $cond->{"arguments"} && @{$cond->{"arguments"}}) {;
                return to_native_str($cond->{"arguments"}->[0], $level, $wantarray)
            }
            if ($cond->isa("Perlito5::AST::Buf")) {;
                return Perlito5::Java::escape_string($cond->{"buf"})
            }
            elsif ($cond->isa("Perlito5::AST::Int")) {;
                return Perlito5::Java::escape_string($cond->{"int"})
            }
            elsif ($cond->isa("Perlito5::AST::Num")) {;
                return Perlito5::Java::escape_string($cond->{"num"})
            }
            else {;
                return $cond->emit_java($level, $wantarray) . ".toString()"
            }
        }
        sub Perlito5::Java::to_str {
            my $cond = shift;
            my $level = shift;
            my $wantarray = "scalar";
            if ($cond->isa("Perlito5::AST::Apply") && $cond->code() eq "circumfix:<( )>" && $cond->{"arguments"} && @{$cond->{"arguments"}}) {;
                return to_str($cond->{"arguments"}->[0], $level)
            }
            if (($cond->isa("Perlito5::AST::Buf")) || ($cond->isa("Perlito5::AST::Apply") && exists($op_to_str{$cond->code()}))) {;
                return $cond->emit_java($level, $wantarray)
            }
            else {;
                return "new PlString(" . $cond->emit_java($level, $wantarray) . ".toString())"
            }
        }
        sub Perlito5::Java::to_num {
            my $cond = shift;
            my $level = shift;
            my $type = shift;
            my $wantarray = "scalar";
            if ($cond->isa("Perlito5::AST::Int") || $cond->isa("Perlito5::AST::Num") || ($cond->isa("Perlito5::AST::Apply") && exists($op_to_num{$cond->code()}))) {;
                return $cond->emit_java($level, $wantarray)
            }
            else {
                if ($type eq "int") {;
                    return "new PlInt(" . $cond->emit_java($level, $wantarray) . ".to_long())"
                }
                return "new PlDouble(" . $cond->emit_java($level, $wantarray) . ".to_double())"
            }
        }
        sub Perlito5::Java::to_boolean {
            my $cond = shift;
            my $level = shift;
            my $wantarray = "scalar";
            if ($cond->isa("Perlito5::AST::Apply") && $cond->code() eq "circumfix:<( )>" && $cond->{"arguments"} && @{$cond->{"arguments"}}) {;
                return to_boolean($cond->{"arguments"}->[0], $level)
            }
            if ($cond->isa("Perlito5::AST::Apply") && ($cond->code() eq "infix:<&&>" || $cond->code() eq "infix:<and>")) {;
                return "(" . to_boolean($cond->{"arguments"}->[0], $level) . " && " . to_boolean($cond->{"arguments"}->[1], $level) . ")"
            }
            if ($cond->isa("Perlito5::AST::Apply") && ($cond->code() eq "infix:<||>" || $cond->code() eq "infix:<or>")) {;
                return "(" . to_boolean($cond->{"arguments"}->[0], $level) . " || " . to_boolean($cond->{"arguments"}->[1], $level) . ")"
            }
            if ($cond->isa("Perlito5::AST::Apply") && ($cond->code() eq "prefix:<!>" || $cond->code() eq "prefix:<not>")) {;
                if (@{$cond->{"arguments"}} == 1) {;
                    return "!" . to_boolean($cond->{"arguments"}->[0], $level)
                }
            }
            if ($cond->isa("Perlito5::AST::Apply") && ($cond->code() eq "defined")) {;
                if (@{$cond->{"arguments"}} == 1) {
                    my $arg = $cond->{"arguments"}->[0];
                    if (ref($arg) eq "Perlito5::AST::Var" && $arg->{"sigil"} eq "\$") {;
                        return "!" . $arg->emit_java($level, "scalar") . ".is_undef()"
                    }
                }
            }
            if (($cond->isa("Perlito5::AST::Int")) || ($cond->isa("Perlito5::AST::Num")) || ($cond->isa("Perlito5::AST::Apply") && exists($op_to_boolean{$cond->code()}))) {;
                return $cond->emit_java($level, $wantarray) . ".to_boolean()"
            }
            else {;
                return $cond->emit_java($level, $wantarray) . ".to_boolean()"
            }
        }
        sub Perlito5::Java::is_scalar {;
            $_[0]->isa("Perlito5::AST::Int") || $_[0]->isa("Perlito5::AST::Num") || $_[0]->isa("Perlito5::AST::Buf") || Perlito5::AST::Sub::is_anon_sub($_[0]) || ($_[0]->isa("Perlito5::AST::Var") && $_[0]->{"sigil"} eq "\$") || ($_[0]->isa("Perlito5::AST::Apply") && (exists($op_to_str{$_[0]->{"code"}}) || exists($op_to_num{$_[0]->{"code"}}) || exists($op_to_boolean{$_[0]->{"code"}})))
        }
        sub Perlito5::Java::to_filehandle {
            (my($item), my($level)) = @_;
            return "PerlOp.get_filehandle(" . $item->emit_java($level) . ", " . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ")"
        }
        sub Perlito5::Java::to_param_list {
            my $items = to_list_preprocess($_[0]);
            my $level = $_[1];
            if (@{$items} == 0) {;
                return "new PlArray()"
            }
            my $item = $items->[0];
            if ($item->isa("Perlito5::AST::Apply") && ($item->code() eq "infix:<..>")) {;
                return "(PlArray)(" . $item->emit_java($level, "list") . ")"
            }
            "PlArray.construct_list_of_aliases(" . join(", ", map($_->emit_java($level, "list", "lvalue"), @{$items})) . ")"
        }
        sub Perlito5::Java::to_list {
            my $items = to_list_preprocess($_[0]);
            my $level = $_[1];
            if (@{$items} == 0) {;
                return "new PlArray()"
            }
            my $item = $items->[0];
            if (@{$items} == 1 && $item->isa("Perlito5::AST::Var") && ($item->sigil() eq "\@")) {;
                return $item->emit_java($level, "list")
            }
            return "new PlArray(" . join(", ", map($_->emit_java($level, "list"), @{$items})) . ")"
        }
        sub Perlito5::Java::to_list_preprocess {
            my @items;
            for my $item (@{$_[0]}) {
                if ($item->isa("Perlito5::AST::Apply") && ($item->code() eq "circumfix:<( )>" || $item->code() eq "list:<,>" || $item->code() eq "infix:<=>>")) {
                    if ($item->isa("Perlito5::AST::Apply") && $item->code() eq "infix:<=>>") {;
                        $item->{"arguments"}->[0] = Perlito5::AST::Lookup::->autoquote($item->{"arguments"}->[0])
                    }
                    for my $arg (@{to_list_preprocess($item->arguments())}) {;
                        push(@items, $arg)
                    }
                }
                else {;
                    push(@items, $item)
                }
            }
            return \@items
        }
        sub Perlito5::Java::to_scalar {
            my $items = to_scalar_preprocess($_[0]);
            my $level = $_[1];
            my $wantarray = "scalar";
            @{$items} ? "(" . join(", ", map($_->emit_java($level, $wantarray), @{$items})) . ")" : "null"
        }
        sub Perlito5::Java::to_scalar_preprocess {
            my @items;
            for my $item (@{$_[0]}) {
                if ($item->isa("Perlito5::AST::Apply") && ($item->code() eq "list:<,>" || $item->code() eq "infix:<=>>")) {
                    if ($item->isa("Perlito5::AST::Apply") && $item->code() eq "infix:<=>>") {;
                        $item->{"arguments"}->[0] = Perlito5::AST::Lookup::->autoquote($item->{"arguments"}->[0])
                    }
                    for my $arg (@{to_scalar_preprocess($item->arguments())}) {;
                        push(@items, $arg)
                    }
                }
                else {;
                    push(@items, $item)
                }
            }
            return \@items
        }
        sub Perlito5::Java::to_runtime_context {
            my $items = to_scalar_preprocess($_[0]);
            my $level = $_[1];
            my $wantarray = "runtime";
            @{$items} == 1 && is_scalar($items->[0]) && return $items->[0]->emit_java($level, $wantarray);
            "PerlOp.context(want, " . join(", ", map($_->emit_java($level, $wantarray), @{$items})) . ")"
        }
        sub Perlito5::Java::to_context {
            my $wantarray = shift;
            $wantarray eq "list" ? "PlCx.LIST" : $wantarray eq "scalar" ? "PlCx.SCALAR" : $wantarray eq "void" ? "PlCx.VOID" : "want"
        }
        sub Perlito5::Java::autoquote {
            my $index = shift;
            my $level = shift;
            $index = Perlito5::AST::Lookup::->autoquote($index);
            return to_str($index, $level)
        }
        sub Perlito5::Java::emit_java_autovivify {
            my $obj = shift;
            my $level = shift;
            my $type = shift;
            if ($obj->isa("Perlito5::AST::Index") || $obj->isa("Perlito5::AST::Lookup") || $obj->isa("Perlito5::AST::Call")) {;
                return $obj->emit_java($level, 0, $type)
            }
            $obj->emit_java($level)
        }
        sub Perlito5::Java::emit_java_list_with_tabs {
            (my($level), my($argument)) = @_;
            my $tab = Perlito5::Java::tab($level);
            return map {;
                ref($_) eq "ARRAY" ? emit_java_list_with_tabs($level + 1, $_) : $tab . $_
            } @{$argument}
        }
        sub Perlito5::Java::emit_wrap_java {
            (my($level), my(@argument)) = @_;
            wantarray && return @argument;
            my $s;
            !ref($argument[0]) && ($s = shift(@argument));
            return join("
", ($s ? $s : ()), emit_java_list_with_tabs($level, [\@argument]))
        }
        sub Perlito5::Java::emit_wrap_statement_java {
            (my($level), my($wantarray), my($argument)) = @_;
            if ($wantarray eq "void") {;
                return $argument
            }
            emit_wrap_java($level, $argument)
        }
        sub Perlito5::Java::emit_wrap_last_exception_java {
            (my($self), my($stmts)) = @_;
            my $block_label = Perlito5::Java::get_java_loop_label($self->{"label"});
            my $test_label = "e.label_id != 0";
            $block_label && ($test_label = "e.label_id != " . $block_label . " && e.label_id != 0");
            return ("try {", [@{$stmts}], "}", "catch(PlLastException e) {", ["if (" . $test_label . ") {", ["throw e;"], "}"], "}")
        }
    }
    package Perlito5::Java::LexicalBlock;
    {
        sub Perlito5::Java::LexicalBlock::new {
            my $class = shift;
            bless({@_, }, $class)
        }
        sub Perlito5::Java::LexicalBlock::block {;
            $_[0]->{"block"}
        }
        sub Perlito5::Java::LexicalBlock::has_decl {
            my $self = $_[0];
            my $type = $_[1];
            for my $decl (@{$self->{"block"}}) {;
                (grep {;
                    $_->{"decl"} eq $type
                } $decl->emit_java_get_decl()) && return 1
            }
            return 0
        }
        sub Perlito5::Java::LexicalBlock::emit_return {
            (my($has_local), my($local_label), my($value)) = @_;
            $has_local ? "return PerlOp.cleanup_local(" . $local_label . ", " . $value . ")" : "return " . $value
        }
        sub Perlito5::Java::LexicalBlock::emit_java {
            (my($self), my($level), my($wantarray)) = @_;
            my $original_level = $level;
            my $block_label = Perlito5::Java::get_java_loop_label($self->{"block_label"});
            $block_label && ($Perlito5::THROW = 1);
            my @block;
            for my $stmt (@{$self->{"block"}}) {;
                if (defined($stmt)) {
                    if (ref($stmt) eq "Perlito5::AST::Apply" && $stmt->code() eq "undef" && !@{$stmt->{"arguments"}}) {}
                    else {;
                        push(@block, $stmt)
                    }
                }
            }
            if ($self->{"top_level"} && !@block) {;
                push(@block, Perlito5::AST::Apply::->new("code", "return", "arguments", []))
            }
            my @str;
            my @pre;
            my $has_local = $self->has_decl("local");
            my $has_regex = 0;
            if (grep {;
                $_->emit_java_has_regex()
            } @block) {
                $has_local = 1;
                $has_regex = 1
            }
            my $local_label = Perlito5::Java::get_label();
            if ($has_local) {
                push(@pre, "int " . $local_label . " = PerlOp.local_length();");
                if ($has_regex) {;
                    push(@pre, "PerlOp.push_local_regex_result();")
                }
            }
            my $create_context = $self->{"create_context"} && $self->has_decl("my");
            my $outer_pkg = $Perlito5::PKG_NAME;
            if ($self->{"top_level"} || $create_context) {;
                $level++
            }
            my $last_statement;
            if ($wantarray ne "void") {;
                $last_statement = pop(@block)
            }
            for my $decl (@block) {
                if (ref($decl) eq "Perlito5::AST::Apply" && $decl->code() eq "package") {;
                    $Perlito5::PKG_NAME = $decl->{"namespace"}
                }
                my @var_decl = $decl->emit_java_get_decl();
                for my $arg (@var_decl) {;
                    push(@str, $arg->emit_java_init($level, $wantarray))
                }
                if (!($decl->isa("Perlito5::AST::Decl") && ($decl->decl() eq "my" || $decl->decl() eq "our"))) {
                    if (($decl->isa("Perlito5::AST::Int")) || ($decl->isa("Perlito5::AST::Num")) || ($decl->isa("Perlito5::AST::Buf")) || ($decl->isa("Perlito5::AST::Var"))) {}
                    elsif ($decl->isa("Perlito5::AST::Apply") && !($decl->{"namespace"} eq "Java" && $decl->{"code"} eq "inline") && !($Perlito5::Java::valid_java_statement{$decl->{"code"}})) {;
                        push(@str, "PerlOp.statement(" . $decl->emit_java($level + 1, "void") . ");")
                    }
                    elsif ($decl->isa("Perlito5::AST::CompUnit") || $decl->isa("Perlito5::AST::For") || $decl->isa("Perlito5::AST::While") || $decl->isa("Perlito5::AST::If") || $decl->isa("Perlito5::AST::Block")) {;
                        push(@str, $decl->emit_java($level, "void"))
                    }
                    else {;
                        push(@str, $decl->emit_java($level, "void") . ";")
                    }
                }
            }
            if ($last_statement) {
                my @var_decl = $last_statement->emit_java_get_decl();
                for my $arg (@var_decl) {;
                    push(@str, $arg->emit_java_init($level, $wantarray))
                }
                my @stmt = Perlito5::Macro::insert_return($last_statement);
                $last_statement = pop(@stmt);
                for $_ (@stmt) {;
                    push(@str, $_->emit_java($level, "void") . ";")
                }
                if ($last_statement->isa("Perlito5::AST::Apply") && $last_statement->code() eq "return") {
                    if ($self->{"top_level"} || $last_statement->{"_return_from_block"}) {
                        if (!@{$last_statement->{"arguments"}}) {;
                            push(@str, emit_return($has_local, $local_label, "PerlOp.context(want)") . ";")
                        }
                        else {;
                            push(@str, emit_return($has_local, $local_label, $wantarray eq "runtime" ? Perlito5::Java::to_runtime_context([$last_statement->{"arguments"}->[0]], $level + 1) : $wantarray eq "scalar" ? Perlito5::Java::to_scalar([$last_statement->{"arguments"}->[0]], $level + 1) : $last_statement->{"arguments"}->[0]->emit_java($level, $wantarray)) . ";")
                        }
                    }
                    elsif (!@{$last_statement->{"arguments"}}) {
                        $Perlito5::THROW_RETURN = 1;
                        push(@str, "return PerlOp.ret(PerlOp.context(want));")
                    }
                    else {
                        $Perlito5::THROW_RETURN = 1;
                        push(@str, "return PerlOp.ret(" . Perlito5::Java::to_runtime_context([$last_statement->{"arguments"}->[0]], $level + 1) . ");")
                    }
                }
                else {
                    my $s = $last_statement->emit_java($level, "runtime");
                    $last_statement->isa("Perlito5::AST::If") || $last_statement->isa("Perlito5::AST::While") || $last_statement->isa("Perlito5::AST::Block") || ($s .= ";");
                    push(@str, $s)
                }
            }
            my $out;
            if ($self->{"eval_block"}) {;
                return (@pre, "try {", \@str, "}", "catch(PlReturnException e) {", [emit_return($has_local, $local_label, "e.ret") . ";"], "}", "catch(PlNextException e) {", ["throw e;"], "}", "catch(PlLastException e) {", ["throw e;"], "}", "catch(PlRedoException e) {", ["throw e;"], "}", "catch(PlDieException e) {", ["PlV.sset(\"main::\@\", e.ret);", "return PlCx.UNDEF;"], "}", "catch(Exception e) {", ["PlV.sset(\"main::\@\", new PlString(e.getMessage()));", "return PlCx.UNDEF;"], "}")
            }
            elsif ($self->{"top_level"} && $Perlito5::THROW_RETURN) {
                push(@pre, "try {", [@str], "}", "catch(PlReturnException e) {", [emit_return($has_local, $local_label, "e.ret") . ";"], "}");
                @str = ()
            }
            elsif (($Perlito5::THROW || ($self->{"continue"} && @{$self->{"continue"}->{"stmts"}} > 0)) && !$self->{"not_a_loop"}) {
                my $redo_label = Perlito5::Java::get_label();
                my $test_label = "e.label_id != 0";
                $block_label && ($test_label = "e.label_id != " . $block_label . " && e.label_id != 0");
                my @continue;
                if ($self->{"continue"}) {;
                    push(@continue, "if (!" . $redo_label . ") {", ["try {", [Perlito5::Java::LexicalBlock::->new("block", $self->{"continue"}->{"stmts"}, "not_a_loop", 1)->emit_java($level + 2, $wantarray)], "}", "catch(PlNextException e) {", ["if (" . $test_label . ") {", ["throw e;"], "}"], "}", "catch(PlRedoException e) {", ["if (" . $test_label . ") {", ["throw e;"], "}", $redo_label . " = true;"], "}"], "}")
                }
                push(@pre, "boolean " . $redo_label . ";", "do {", [$redo_label . " = false;", "try {", [@str], "}", "catch(PlNextException e) {", ["if (" . $test_label . ") {", ["throw e;"], "}"], "}", "catch(PlRedoException e) {", ["if (" . $test_label . ") {", ["throw e;"], "}", $redo_label . " = true;"], "}", @continue], "} while (" . $redo_label . ");");
                @str = ()
            }
            elsif ($has_local && !$last_statement) {;
                push(@str, "PerlOp.cleanup_local(" . $local_label . ", PlCx.UNDEF);")
            }
            $Perlito5::PKG_NAME = $outer_pkg;
            return (@pre, @str)
        }
        sub Perlito5::Java::LexicalBlock::emit_java_has_regex {;
            ()
        }
    }
    package Perlito5::AST::CompUnit;
    {
        sub Perlito5::AST::CompUnit::emit_java {
            (my($self), my($level), my($wantarray)) = @_;
            return Perlito5::Java::LexicalBlock::->new("block", $self->{"body"}, "not_a_loop", 1)->emit_java($level + 1, $wantarray)
        }
        sub Perlito5::AST::CompUnit::process_java_import_statement {
            (my($namespace), my($annotation_ast)) = @_;
            my $str = '';
            my $Java_class = Perlito5::Java::get_java_class_info();
            my $class = $namespace;
            my $args_ast = $annotation_ast;
            my $out = [];
            Perlito5::Perl5::PrettyPrinter::pretty_print([$args_ast->emit_perl5()], 0, $out);
            my $args_perl5 = join('', @{$out});
            $Java_class->{$class} = eval($args_perl5) or die("error in arguments to generate Java class:
" . ${"\@"} . "
" . $args_perl5);
            if ($Java_class->{$class}->{"java_path"}) {;
                $str .= "package " . $Java_class->{$class}->{"java_path"} . ";
"
            }
            elsif ($Java_class->{$class}->{"import"}) {;
                Perlito5::Java::set_java_class_defaults($class, $Java_class->{$class}->{"import"})
            }
            elsif ($Java_class->{$class}->{"extends"}) {
                my $extended = $Java_class->{$Java_class->{$class}->{"extends"}};
                if ($extended) {;
                    $Java_class->{$class}->{"extends_java_type"} = $extended->{"java_type"}
                }
                else {;
                    die("cannot extend class '" . $Java_class->{$class}->{"extends"} . "' because it was not declared")
                }
                my $perl_to_java = $class;
                $perl_to_java =~ s/:://g;
                Perlito5::Java::set_java_class_defaults($class, $perl_to_java)
            }
            elsif ($Java_class->{$class}->{"implements"}) {
                my $implemented = $Java_class->{$Java_class->{$class}->{"implements"}};
                if ($implemented) {;
                    $Java_class->{$class}->{"implements_java_type"} = $implemented->{"java_type"}
                }
                else {;
                    die("cannot implement class '" . $Java_class->{$class}->{"implements"} . "' because it was not declared")
                }
                my $perl_to_java = $class;
                $perl_to_java =~ s/:://g;
                Perlito5::Java::set_java_class_defaults($class, $perl_to_java)
            }
            else {;
                die("missing 'import' argument to generate Java class")
            }
            return $str
        }
        sub Perlito5::AST::CompUnit::emit_java_program {
            (my($comp_units), my(%options)) = @_;
            $Perlito5::PKG_NAME = "main";
            $Perlito5::THROW = 0;
            $Perlito5::THROW_RETURN = 0;
            my $level = 0;
            my $wantarray = "void";
            my $str;
            $str .= Perlito5::Compiler::do_not_edit("//");
            Perlito5::Java::init_java_class();
            for my $ann (@Perlito::ANNOTATION) {;
                $str .= process_java_import_statement(@{$ann})
            }
            my @main;
            for my $comp_unit (@{$comp_units}) {
                my @str = $comp_unit->emit_java($level + 1, $wantarray);
                @str && !ref($str[-1]) && ($str[-1] .= ";
");
                push(@main, @str)
            }
            if ($options{"expand_use"}) {
                my $Java_class = Perlito5::Java::get_java_class_info();
                $str .= join('', Perlito5::Java::Runtime::->emit_java("java_classes", $Java_class, "java_constants", []))
            }
            my $main_class = "Main";
            $Perlito5::BOOTSTRAP_JAVA_EVAL && ($main_class = "LibPerl");
            $str .= Perlito5::Java::emit_wrap_java(-1, "class " . $main_class . " {", [@Perlito5::Java::Java_constants, "public static void main(String[] args) {", [($Perlito5::JAVA_EVAL ? "org.perlito.Perlito5.LibPerl.main( new String[]{} );" : ()), "PlV.init(args);", "int want = PlCx.VOID;", "PlArray List__ = new PlArray();", "Exception ee = null;", "try {", [@Perlito5::Java::Java_init, @main], "}", "catch(PlReturnException e) {", "}", "catch(PlNextException e) {", ["ee = new PlDieException(new PlString(\"Can't \\\"next\\\" outside a loop block\"));"], "}", "catch(PlLastException e) {", ["ee = new PlDieException(new PlString(\"Can't \\\"last\\\" outside a loop block\"));"], "}", "catch(PlRedoException e) {", ["ee = new PlDieException(new PlString(\"Can't \\\"redo\\\" outside a loop block\"));"], "}", "catch(Exception e) {", ["ee = e;"], "}", "if (ee != null) {", ["ee.printStackTrace(System.err);"], "}", "for (PlObject code : PlV.array_get(\"Perlito5::END_BLOCK\")) {", ["code.apply(PlCx.VOID, new PlArray());"], "}", "if (ee != null) {", ["System.exit(1);"], "}"], "}"], ["public static void init() {", ["main(new String[]{});"], "}"], ["public static PlObject[] apply(String functionName, String... args) {", ["PlArray list = new PlArray(args);", "PlObject result = PlV.apply(functionName, PlCx.LIST, list);", "PlArray res = result instanceof PlArray ? (PlArray) result : new PlArray(result);", "PlObject[] out = new PlObject[res.to_int()];", "int i = 0;", "for (PlObject s : res) {", ["out[i++] = s;"], "}", "return out;"], "}"], ["public static PlObject[] apply(String functionName, PlObject... args) {", ["PlArray list = new PlArray(args);", "PlObject result = PlV.apply(functionName, PlCx.LIST, list);", "PlArray res = result instanceof PlArray ? (PlArray) result : new PlArray(result);", "PlObject[] out = new PlObject[res.to_int()];", "int i = 0;", "for (PlObject s : res) {", ["out[i++] = s;"], "}", "return out;"], "}"], "}") . "
";
            return $str
        }
        sub Perlito5::AST::CompUnit::emit_java_get_decl {;
            ()
        }
        sub Perlito5::AST::CompUnit::emit_java_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Int;
    {
        sub Perlito5::AST::Int::emit_java {
            (my($self), my($level), my($wantarray)) = @_;
            my $v = $self->{"int"};
            if (length($v) > 19 || $v > 2**62) {
                if (length($v) > 19 || $v >= 9223372036854775806.0) {;
                    return "new PlDouble(" . $v . ".0d)"
                }
                return "new PlInt(" . $v . "L)"
            }
            if ($v >= -2 && $v < 0) {;
                return "PlCx.MIN" . abs($v)
            }
            if ($v >= 0 && $v <= 2) {;
                return "PlCx.INT" . abs($v)
            }
            "new PlInt(" . $v . "L)"
        }
        sub Perlito5::AST::Int::emit_java_set {;
            die("Can't modify constant item in scalar assignment")
        }
        sub Perlito5::AST::Int::emit_java_get_decl {;
            ()
        }
        sub Perlito5::AST::Int::emit_java_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Num;
    {
        sub Perlito5::AST::Num::emit_java {
            (my($self), my($level), my($wantarray)) = @_;
            "new PlDouble(" . $self->{"num"} . "d)"
        }
        sub Perlito5::AST::Num::emit_java_set {;
            die("Can't modify constant item in scalar assignment")
        }
        sub Perlito5::AST::Num::emit_java_get_decl {;
            ()
        }
        sub Perlito5::AST::Num::emit_java_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Buf;
    {
        sub Perlito5::AST::Buf::emit_java {
            (my($self), my($level), my($wantarray)) = @_;
            "new PlString(" . Perlito5::Java::escape_string($self->{"buf"}) . ")"
        }
        sub Perlito5::AST::Buf::emit_java_set {;
            die("Can't modify constant item in scalar assignment")
        }
        sub Perlito5::AST::Buf::emit_java_get_decl {;
            ()
        }
        sub Perlito5::AST::Buf::emit_java_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Block;
    {
        sub Perlito5::AST::Block::emit_java {
            (my($self), my($level), my($wantarray)) = @_;
            local $Perlito5::THROW = 0;
            my $body;
            if ($wantarray ne "void") {;
                $body = Perlito5::Java::LexicalBlock::->new("block", $self->{"stmts"}, "block_label", $self->{"label"}, "continue", $self->{"continue"})
            }
            else {;
                $body = Perlito5::Java::LexicalBlock::->new("block", $self->{"stmts"}, "block_label", $self->{"label"}, "continue", $self->{"continue"})
            }
            my $init = '';
            if ($self->{"name"} eq "INIT") {
                my $tmp = "p5pkg.main." . Perlito5::Java::get_label();
                $init = Perlito5::Java::tab($level + 2) . "if (" . $tmp . ") { return }; " . $tmp . " = 1;
"
            }
            my @str = $body->emit_java($level + 1, $wantarray);
            if ($Perlito5::THROW) {;
                @str = Perlito5::Java::emit_wrap_last_exception_java($self, \@str)
            }
            return Perlito5::Java::emit_wrap_java($level, @str)
        }
        sub Perlito5::AST::Block::emit_java_get_decl {;
            ()
        }
        sub Perlito5::AST::Block::emit_java_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Index;
    {
        sub Perlito5::AST::Index::emit_java {
            (my($self), my($level), my($wantarray), my($autovivification_type)) = @_;
            my $method = $autovivification_type || "aget";
            $autovivification_type eq "scalar" && ($method = "aget_scalarref");
            $autovivification_type eq "array" && ($method = "aget_arrayref");
            $autovivification_type eq "hash" && ($method = "aget_hashref");
            $autovivification_type eq "lvalue" && ($method = "aget_lvalue");
            $autovivification_type eq "local" && ($method = "aget_lvalue_local");
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\@>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->sigil() eq "\@") || ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->code() eq "circumfix:<( )>")) {;
                return $self->{"obj"}->emit_java($level, "list", "lvalue") . ".aget_list_of_aliases(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_list([$self->{"index_exp"}], $level) . ")"
            }
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<%>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->sigil() eq "%")) {
                my $obj = $self->{"obj"};
                $obj->{"sigil"} eq "%" && ($obj->{"sigil"} = "\@");
                $obj->{"code"} eq "prefix:<%>" && ($obj->{"code"} = "prefix:<\@>");
                return $self->{"obj"}->emit_java($level) . ".aget_hash_list_of_aliases(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_list([$self->{"index_exp"}], $level) . ")"
            }
            if ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\$>") {;
                return Perlito5::AST::Call::->new("method", "postcircumfix:<[ ]>", "invocant", $self->{"obj"}->{"arguments"}->[0], "arguments", $self->{"index_exp"})->emit_java($level, $wantarray, $autovivification_type)
            }
            my $arg = $self->{"index_exp"};
            my $s;
            if ($arg->isa("Perlito5::AST::Int")) {;
                $s = $arg->{"int"}
            }
            else {;
                $s = $arg->emit_java($level, "scalar")
            }
            return $self->emit_java_container($level) . "." . $method . "(" . $s . ")"
        }
        sub Perlito5::AST::Index::emit_java_set {
            (my($self), my($arguments), my($level), my($wantarray), my($localize)) = @_;
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\@>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->sigil() eq "\@")) {;
                return "((PlArray)" . $self->emit_java($level, "list") . ").list_set(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_list([$arguments], $level) . ")"
            }
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<%>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->sigil() eq "%")) {;
                die("Can't modify index/value array slice in list assignment")
            }
            if ($localize) {;
                return $self->emit_java_container($level) . ".aget_lvalue_local(" . Perlito5::Java::autoquote($self->{"index_exp"}, $level) . ").set(" . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")"
            }
            my $arg = $self->{"index_exp"};
            my $s;
            if ($arg->isa("Perlito5::AST::Int")) {;
                $s = $arg->{"int"}
            }
            else {;
                $s = $arg->emit_java($level, "scalar")
            }
            if ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\$>") {
                my $obj = Perlito5::Java::emit_java_autovivify($self->{"obj"}->{"arguments"}->[0], $level + 1, "array");
                return $obj . ".aset(" . $s . ", " . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")"
            }
            return $self->emit_java_container($level) . ".aset(" . $s . ", " . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")"
        }
        sub Perlito5::AST::Index::emit_java_container {
            my $self = shift;
            my $level = shift;
            if ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\$>") {
                my $v = Perlito5::AST::Apply::->new(%{$self->{"obj"}}, "code", "prefix:<\@>");
                return $v->emit_java($level)
            }
            if ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->code() eq "circumfix:<( )>") {;
                return Perlito5::Java::to_list([$self->{"obj"}], $level)
            }
            if ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->sigil() eq "\$") {
                $self->{"obj"}->{"sigil"} = "\@";
                return $self->{"obj"}->emit_java($level)
            }
            else {;
                return Perlito5::Java::emit_java_autovivify($self->{"obj"}, $level, "array")
            }
        }
        sub Perlito5::AST::Index::emit_java_get_decl {;
            ()
        }
        sub Perlito5::AST::Index::emit_java_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Lookup;
    {
        sub Perlito5::AST::Lookup::emit_java {
            (my($self), my($level), my($wantarray), my($autovivification_type)) = @_;
            my $method = $autovivification_type || "hget";
            $autovivification_type eq "scalar" && ($method = "hget_scalarref");
            $autovivification_type eq "array" && ($method = "hget_arrayref");
            $autovivification_type eq "hash" && ($method = "hget_hashref");
            $autovivification_type eq "lvalue" && ($method = "hget_lvalue");
            $autovivification_type eq "local" && ($method = "hget_lvalue_local");
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\@>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->sigil() eq "\@")) {
                my $v;
                if ($self->{"obj"}->isa("Perlito5::AST::Var")) {;
                    $v = $self->{"obj"}
                }
                $self->{"obj"}->isa("Perlito5::AST::Apply") && ($v = Perlito5::AST::Apply::->new("code", "prefix:<%>", "namespace", $self->{"obj"}->namespace(), "arguments", $self->{"obj"}->arguments()));
                return "((PlHash)" . $v->emit_java($level, "scalar") . ").hget_list_of_aliases(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_list([$self->{"index_exp"}], $level) . ")"
            }
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<%>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->sigil() eq "%")) {
                my $v;
                if ($self->{"obj"}->isa("Perlito5::AST::Var")) {;
                    $v = $self->{"obj"}
                }
                $self->{"obj"}->isa("Perlito5::AST::Apply") && ($v = Perlito5::AST::Apply::->new("code", "prefix:<%>", "namespace", $self->{"obj"}->namespace(), "arguments", $self->{"obj"}->arguments()));
                return $v->emit_java($level) . ".hget_hash_list_of_aliases(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_list([$self->{"index_exp"}], $level) . ")"
            }
            if ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\$>") {;
                return Perlito5::AST::Call::->new("method", "postcircumfix:<{ }>", "invocant", $self->{"obj"}->{"arguments"}->[0], "arguments", $self->{"index_exp"})->emit_java($level, $wantarray, $autovivification_type)
            }
            my $index = Perlito5::AST::Lookup::->autoquote($self->{"index_exp"});
            return $self->emit_java_container($level) . "." . $method . "(" . Perlito5::Java::to_native_str($index, $level) . ")"
        }
        sub Perlito5::AST::Lookup::emit_java_set {
            (my($self), my($arguments), my($level), my($wantarray), my($localize)) = @_;
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\@>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->sigil() eq "\@")) {;
                return "((PlArray)" . $self->emit_java($level, "list") . ").list_set(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_list([$arguments], $level) . ")"
            }
            if (($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<%>") || ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->sigil() eq "%")) {;
                die("Can't modify index/value array slice in list assignment")
            }
            if ($localize) {;
                return $self->emit_java_container($level) . ".hget_lvalue_local(" . Perlito5::Java::autoquote($self->{"index_exp"}, $level) . ").set(" . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")"
            }
            if ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\$>") {
                my $obj = Perlito5::Java::emit_java_autovivify($self->{"obj"}->{"arguments"}->[0], $level + 1, "hash");
                return $obj . ".hset(" . Perlito5::Java::autoquote($self->{"index_exp"}, $level) . ", " . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")"
            }
            my $index = Perlito5::AST::Lookup::->autoquote($self->{"index_exp"});
            return $self->emit_java_container($level) . ".hset(" . Perlito5::Java::to_native_str($index, $level) . ", " . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")"
        }
        sub Perlito5::AST::Lookup::emit_java_container {
            my $self = shift;
            my $level = shift;
            if ($self->{"obj"}->isa("Perlito5::AST::Apply") && $self->{"obj"}->{"code"} eq "prefix:<\$>") {
                my $v = Perlito5::AST::Apply::->new(%{$self->{"obj"}}, "code", "prefix:<%>");
                return $v->emit_java($level)
            }
            if ($self->{"obj"}->isa("Perlito5::AST::Var") && $self->{"obj"}->sigil() eq "\$") {
                my $v = Perlito5::AST::Var::->new(%{$self->{"obj"}}, "sigil", "%");
                return $v->emit_java($level)
            }
            else {;
                return Perlito5::Java::emit_java_autovivify($self->{"obj"}, $level, "hash")
            }
        }
        sub Perlito5::AST::Lookup::emit_java_get_decl {;
            ()
        }
        sub Perlito5::AST::Lookup::emit_java_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Var;
    {
        my $table = {"\$", '', "\@", '', "%", '', "&", ''};
        sub Perlito5::AST::Var::emit_java_global {
            (my($self), my($level), my($wantarray), my($localize)) = @_;
            my $local = $localize ? "_local" : '';
            my $str_name = $self->{"name"};
            my $sigil = $self->{"_real_sigil"} || $self->{"sigil"};
            my $namespace = $self->{"namespace"} || $self->{"_namespace"};
            if ($sigil eq "\@" && $self->{"name"} eq "_" && $namespace eq "main") {
                my $s = "List__";
                if ($self->{"sigil"} eq "\$#") {;
                    return $s . ".end_of_array_index()"
                }
                if ($wantarray eq "scalar") {;
                    return $s . ".length_of_array()"
                }
                if ($wantarray eq "runtime") {;
                    return "(want == PlCx.LIST" . " ? " . $s . " : " . $s . ".length_of_array()" . ")"
                }
                return $s
            }
            if ($sigil eq "\$") {
                if ($self->{"name"} > 0) {;
                    return "PerlOp.regex_var(" . (0 + $self->{"name"}) . ")"
                }
                if ($self->{"name"} eq "&" || $self->{"name"} eq "`" || $self->{"name"} eq "'") {;
                    return "PerlOp.regex_var(" . Perlito5::Java::escape_string($self->{"name"}) . ")"
                }
                if ($self->{"name"} eq "\$") {;
                    return "PerlOp.getPID()"
                }
            }
            if ($sigil eq "::") {;
                return Perlito5::Java::escape_string($namespace)
            }
            my $index = Perlito5::Java::escape_string($namespace . "::" . $table->{$sigil} . $str_name);
            if ($sigil eq "\$") {;
                return "PlV.sget" . $local . "(" . $index . ")"
            }
            if ($sigil eq "*") {;
                return "PlV.fget" . $local . "(" . $index . ")"
            }
            if ($sigil eq "&") {
                my $namespace = $self->{"namespace"} || $Perlito5::PKG_NAME;
                return "PlV.apply(" . Perlito5::Java::escape_string($namespace . "::" . $str_name) . ", " . Perlito5::Java::to_context($wantarray) . ", List__)"
            }
            if ($sigil eq "\@") {
                if ($self->{"sigil"} eq "\$#") {;
                    return "PlV.array_get" . $local . "(" . $index . ").end_of_array_index()"
                }
                my $s = "PlV.array_get" . $local . "(" . $index . ")";
                if ($wantarray eq "scalar") {;
                    return $s . ".length_of_array()"
                }
                return $s
            }
            if ($sigil eq "%") {;
                return "PlV.hash_get" . $local . "(" . $index . ")"
            }
            die("don't know how to access variable ", $sigil, $self->name())
        }
        sub Perlito5::AST::Var::emit_java_global_set {
            (my($self), my($arguments), my($level), my($wantarray), my($localize)) = @_;
            my $local = $localize ? "_local" : '';
            my $str_name = $self->{"name"};
            my $sigil = $self->{"_real_sigil"} || $self->{"sigil"};
            my $namespace = $self->{"namespace"} || $self->{"_namespace"};
            if ($sigil eq "\@" && $self->{"name"} eq "_" && $namespace eq "main") {
                my $s = "List__";
                if ($self->{"sigil"} eq "\$#") {;
                    return $s . ".set_end_of_array_index(" . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")"
                }
                if ($wantarray eq "scalar") {;
                    return $s . ".to_long()"
                }
                return $s . ".set(" . Perlito5::Java::to_list([$arguments], $level + 1) . ")"
            }
            if ($sigil eq "\$" && $self->{"name"} > 0) {;
                return "p5_regex_capture[" . ($self->{"name"} - 1) . "]"
            }
            if ($sigil eq "::") {;
                return Perlito5::Java::escape_string($namespace)
            }
            my $index = Perlito5::Java::escape_string($namespace . "::" . $table->{$sigil} . $str_name);
            if ($sigil eq "\$") {;
                return "PlV.sset" . $local . "(" . $index . ", " . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")"
            }
            if ($sigil eq "\@") {
                if ($self->{"sigil"} eq "\$#") {
                    $self->{"sigil"} = "\@";
                    return "PlV.array_get(" . $index . ").set_end_of_array_index(" . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")"
                }
                return "PlV.array_set" . $local . "(" . $index . ", " . Perlito5::Java::to_list([$arguments], $level + 1) . ")"
            }
            if ($sigil eq "%") {;
                return "PlV.hash_set" . $local . "(" . $index . ", " . Perlito5::Java::to_list([$arguments], $level + 1) . ")"
            }
            if ($sigil eq "*") {;
                return "PlV.glob_set" . $local . "(" . $index . ", " . Perlito5::Java::to_scalar([$arguments], $level + 1) . ", " . Perlito5::Java::escape_string($Perlito5::PKG_NAME) . ")"
            }
            if ($sigil eq "&") {}
            die("don't know how to assign to variable ", $sigil, $self->name())
        }
        sub Perlito5::AST::Var::emit_java_global_set_alias {
            (my($self), my($arguments), my($level), my($wantarray), my($localize)) = @_;
            $localize && die("can't localize emit_java_global_set_alias()");
            my $str_name = $self->{"name"};
            my $sigil = $self->{"_real_sigil"} || $self->{"sigil"};
            my $namespace = $self->{"namespace"} || $self->{"_namespace"};
            if ($sigil eq "\$" && $self->{"name"} > 0) {;
                die("not implemented emit_java_global_set_alias() for regex capture")
            }
            my $index = Perlito5::Java::escape_string($namespace . "::" . $table->{$sigil} . $str_name);
            ref($arguments) && ($arguments = Perlito5::Java::to_scalar([$arguments], $level + 1));
            $sigil eq "\$" && return "PlV.sset_alias(" . $index . ", " . $arguments . ")";
            $sigil eq "\@" && return "PlV.aset_alias(" . $index . ", " . $arguments . ")";
            $sigil eq "%" && return "PlV.hset_alias(" . $index . ", " . $arguments . ")";
            die("can't emit_java_global_set_alias() for sigil '" . $sigil . "'")
        }
        sub Perlito5::AST::Var::emit_java {
            (my($self), my($level), my($wantarray)) = @_;
            my $sigil = $self->{"_real_sigil"} || $self->{"sigil"};
            my $decl_type = $self->{"_decl"} || "global";
            if ($decl_type ne "my" && $decl_type ne "state") {;
                return $self->emit_java_global($level, $wantarray)
            }
            my $str_name = $table->{$sigil} . $self->{"name"} . "_" . $self->{"_id"};
            exists($Perlito5::Java::Java_var_name{$self->{"_id"}}) && ($str_name = $Perlito5::Java::Java_var_name{$self->{"_id"}});
            if ($sigil eq "\@") {
                if ($wantarray eq "scalar") {;
                    return $self->emit_java($level, "list") . ".length_of_array()"
                }
                if ($wantarray eq "runtime") {;
                    return "(want == PlCx.LIST" . " ? " . $self->emit_java($level, "list") . " : " . $self->emit_java($level, "list") . ".length_of_array()" . ")"
                }
            }
            if ($self->{"sigil"} eq "\$#") {;
                return $str_name . ".end_of_array_index()"
            }
            return $str_name
        }
        sub Perlito5::AST::Var::emit_java_set {
            (my($self), my($arguments), my($level), my($wantarray)) = @_;
            my $decl_type = $self->{"_decl"} || "global";
            if ($decl_type ne "my" && $decl_type ne "state") {;
                return $self->emit_java_global_set($arguments, $level, $wantarray)
            }
            my $open = $wantarray eq "void" ? '' : "(";
            my $close = $wantarray eq "void" ? '' : ")";
            my $sigil = $self->{"_real_sigil"} || $self->{"sigil"};
            if ($sigil eq "\$") {
                my $id = $self->{"_id"};
                my $Java_var = Perlito5::Java::get_java_var_info();
                my $type = $Java_var->{$id}->{"type"} || "PlLvalue";
                if ($type ne "PlLvalue") {;
                    return $self->emit_java($level) . " = " . Perlito5::Java::to_native_args([$arguments])
                }
                return $self->emit_java($level) . ".set(" . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")"
            }
            if ($sigil eq "\@") {
                if ($self->{"sigil"} eq "\$#") {
                    $self->{"sigil"} = "\@";
                    return $open . $self->emit_java($level) . ".set_end_of_array_index(" . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")" . $close
                }
                return $self->emit_java($level) . ".set(" . Perlito5::Java::to_list([$arguments], $level + 1) . ")"
            }
            if ($sigil eq "%") {;
                return $self->emit_java($level) . ".set(" . Perlito5::Java::to_list([$arguments], $level + 1, "hash") . ")"
            }
            if ($sigil eq "*") {
                my $namespace = $self->{"namespace"} || $self->{"_namespace"};
                return "p5typeglob_set(" . Perlito5::Java::escape_string($namespace) . ", " . Perlito5::Java::escape_string($self->{"name"}) . ", " . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")"
            }
            die("don't know how to assign to variable ", $sigil, $self->name())
        }
        sub Perlito5::AST::Var::emit_java_get_decl {;
            ()
        }
        sub Perlito5::AST::Var::emit_java_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Decl;
    {
        sub Perlito5::AST::Decl::emit_java {
            (my($self), my($level), my($wantarray)) = @_;
            my $var = $self->{"var"};
            my $localize = '';
            if ($self->{"decl"} eq "local") {
                $localize = "local";
                if (ref($var) eq "Perlito5::AST::Var") {;
                    return $var->emit_java_global($level, $wantarray, $localize)
                }
            }
            $var->emit_java($level, $wantarray, $localize)
        }
        sub Perlito5::AST::Decl::emit_java_init {
            (my($self), my($level), my($wantarray)) = @_;
            my $var = $self->{"var"};
            my $Java_var = Perlito5::Java::get_java_var_info();
            my $type = $self->{"type"} || "PlLvalue";
            my $id = $self->{"var"}->{"_id"};
            if ($id) {;
                $Java_var->{$id} = {"id", $id, "type", $type}
            }
            if ($self->{"decl"} eq "our") {;
                return ''
            }
            if ($self->{"decl"} eq "local") {;
                return ''
            }
            if ($self->{"decl"} eq "my" || $self->{"decl"} eq "state") {
                if ($self->{"var"}->sigil() eq "%") {;
                    return "PlHash " . $self->{"var"}->emit_java($level) . " = new PlHash();"
                }
                elsif ($self->{"var"}->sigil() eq "\@") {;
                    return "PlArray " . $self->{"var"}->emit_java($level) . " = new PlArray();"
                }
                else {
                    my $Java_class = Perlito5::Java::get_java_class_info();
                    my $java_type = $Java_class->{$type}->{"java_type"} || "PlLvalue";
                    if ($java_type eq "PlLvalue") {;
                        return $java_type . " " . $self->{"var"}->emit_java($level) . " = new " . $java_type . "();"
                    }
                    else {;
                        return $java_type . " " . $self->{"var"}->emit_java($level) . ";"
                    }
                }
            }
            else {;
                die("not implemented: Perlito5::AST::Decl '" . $self->{"decl"} . "'")
            }
        }
        sub Perlito5::AST::Decl::emit_java_set {
            (my($self), my($arguments), my($level), my($wantarray)) = @_;
            my $var = $self->{"var"};
            my $localize = '';
            if ($self->{"decl"} eq "local") {
                $localize = "local";
                if (ref($var) eq "Perlito5::AST::Var") {;
                    return $var->emit_java_global_set($arguments, $level, $wantarray, $localize)
                }
            }
            $var->emit_java_set($arguments, $level, $wantarray, $localize)
        }
        sub Perlito5::AST::Decl::emit_java_get_decl {
            my $self = shift;
            return ($self)
        }
        sub Perlito5::AST::Decl::emit_java_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Call;
    {
        sub Perlito5::AST::Call::emit_java {
            (my($self), my($level), my($wantarray), my($autovivification_type)) = @_;
            my $meth = $self->{"method"};
            if ($meth eq "postcircumfix:<[ ]>") {
                my $method = $autovivification_type || "aget";
                $autovivification_type eq "scalar" && ($method = "aget_scalarref");
                $autovivification_type eq "array" && ($method = "aget_arrayref");
                $autovivification_type eq "hash" && ($method = "aget_hashref");
                $autovivification_type eq "lvalue" && ($method = "aget_lvalue");
                return Perlito5::Java::emit_java_autovivify($self->{"invocant"}, $level, "array") . "." . $method . "(" . Perlito5::Java::to_scalar([$self->{"arguments"}], $level + 1) . ")"
            }
            if ($meth eq "postcircumfix:<{ }>") {
                my $method = $autovivification_type || "hget";
                $autovivification_type eq "scalar" && ($method = "hget_scalarref");
                $autovivification_type eq "array" && ($method = "hget_arrayref");
                $autovivification_type eq "hash" && ($method = "hget_hashref");
                $autovivification_type eq "lvalue" && ($method = "hget_lvalue");
                return Perlito5::Java::emit_java_autovivify($self->{"invocant"}, $level, "hash") . "." . $method . "(" . Perlito5::Java::autoquote($self->{"arguments"}, $level + 1, "list") . ")"
            }
            if ($meth eq "postcircumfix:<( )>") {
                my $invocant;
                if (ref($self->{"invocant"}) eq "Perlito5::AST::Var" && $self->{"invocant"}->{"sigil"} eq "::" && ($self->{"invocant"}->{"namespace"} eq "__SUB__" || $self->{"invocant"}->{"namespace"} eq "CORE::__SUB__")) {;
                    $invocant = "this.getCurrentSub()"
                }
                else {;
                    $invocant = $self->{"invocant"}->emit_java($level, "scalar")
                }
                return $invocant . ".apply(" . Perlito5::Java::to_context($wantarray) . ", " . Perlito5::Java::to_list($self->{"arguments"}) . ")"
            }
            if (ref($self->{"invocant"}) eq "Perlito5::AST::Var" && $self->{"invocant"}->{"sigil"} eq "::") {
                my $Java_class = Perlito5::Java::get_java_class_info();
                if (exists($Java_class->{$self->{"invocant"}->{"namespace"}})) {
                    my $info = $Java_class->{$self->{"invocant"}->{"namespace"}};
                    if ($meth eq "new") {;
                        return "new " . $info->{"java_type"} . "(" . Perlito5::Java::to_native_args($self->{"arguments"}) . ")"
                    }
                    if ($self->{"_no_params"}) {;
                        return $info->{"java_type"} . "." . $meth
                    }
                    else {;
                        return $info->{"java_type"} . "." . $meth . "(" . Perlito5::Java::to_native_args($self->{"arguments"}) . ")"
                    }
                }
            }
            my $invocant = $self->{"invocant"}->emit_java($level, "scalar");
            if (ref($self->{"invocant"}) eq "Perlito5::AST::Var" && $self->{"invocant"}->{"_id"}) {
                my $id = $self->{"invocant"}->{"_id"};
                my $Java_var = Perlito5::Java::get_java_var_info();
                my $type = $Java_var->{$id}->{"type"} || "PlLvalue";
                if ($type ne "PlLvalue") {
                    if ($self->{"_no_params"}) {;
                        return $invocant . "." . $meth
                    }
                    else {;
                        return $invocant . "." . $meth . "(" . Perlito5::Java::to_native_args($self->{"arguments"}) . ")"
                    }
                }
            }
            if (Perlito5::Java::is_native($self->{"invocant"})) {
                if ($self->{"_no_params"}) {;
                    return $invocant . "." . $meth
                }
                else {;
                    return $invocant . "." . $meth . "(" . Perlito5::Java::to_native_args($self->{"arguments"}) . ")"
                }
            }
            if ($meth =~ m/^to/) {
                my $Java_class = Perlito5::Java::get_java_class_info();
                for my $info (values(%{$Java_class})) {;
                    if ($meth eq $info->{"perl_to_java"}) {;
                        return $invocant . "." . $meth . "()"
                    }
                }
            }
            if (ref($meth) eq "Perlito5::AST::Var") {;
                $meth = $meth->emit_java($level, "scalar")
            }
            else {;
                $meth = Perlito5::Java::escape_string($meth)
            }
            return "PerlOp.call(" . $invocant . ", " . $meth . ", " . Perlito5::Java::to_list($self->{"arguments"}) . ", " . Perlito5::Java::to_context($wantarray) . ")"
        }
        sub Perlito5::AST::Call::emit_java_set {
            (my($self), my($arguments), my($level), my($wantarray)) = @_;
            if ($self->{"method"} eq "postcircumfix:<[ ]>") {;
                return Perlito5::Java::emit_java_autovivify($self->{"invocant"}, $level, "array") . ".aset(" . Perlito5::Java::to_num($self->{"arguments"}, $level + 1) . ", " . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")"
            }
            if ($self->{"method"} eq "postcircumfix:<{ }>") {;
                return Perlito5::Java::emit_java_autovivify($self->{"invocant"}, $level, "hash") . ".hset(" . Perlito5::Java::autoquote($self->{"arguments"}, $level + 1, "list") . ", " . Perlito5::Java::to_scalar([$arguments], $level + 1) . ")"
            }
            die("don't know how to assign to method ", $self->{"method"})
        }
        sub Perlito5::AST::Call::emit_java_get_decl {;
            ()
        }
        sub Perlito5::AST::Call::emit_java_has_regex {;
            ()
        }
    }
    package Perlito5::AST::If;
    {
        sub Perlito5::AST::If::emit_java {
            (my($self), my($level), my($wantarray)) = @_;
            my $cond = $self->{"cond"};
            my @str;
            my $old_level = $level;
            if ($cond) {
                my @var_decl = $cond->emit_java_get_decl();
                for my $arg (@var_decl) {
                    $level = $old_level + 1;
                    push(@str, $arg->emit_java_init($level, $wantarray))
                }
            }
            my $body = ref($self->{"body"}) ne "Perlito5::AST::Block" ? $self->{"body"} : (!@{$self->{"body"}->stmts()}) ? undef : $wantarray ne "void" ? Perlito5::Java::LexicalBlock::->new("block", $self->{"body"}->stmts(), "not_a_loop", 1) : Perlito5::Java::LexicalBlock::->new("block", $self->{"body"}->stmts(), "create_context", 1, "not_a_loop", 1);
            my $otherwise = ref($self->{"otherwise"}) ne "Perlito5::AST::Block" ? $self->{"otherwise"} : (!@{$self->{"otherwise"}->stmts()}) ? undef : $wantarray ne "void" ? Perlito5::Java::LexicalBlock::->new("block", $self->{"otherwise"}->stmts(), "not_a_loop", 1) : Perlito5::Java::LexicalBlock::->new("block", $self->{"otherwise"}->stmts(), "create_context", 1, "not_a_loop", 1);
            push(@str, "if (" . Perlito5::Java::to_boolean($cond, $level + 1) . ") {");
            if ($body) {;
                push(@str, [$body->emit_java($level + 1, $wantarray)])
            }
            push(@str, "}");
            if ($otherwise) {
                if (@{$otherwise->{"block"}} == 1 && ref($otherwise->{"block"}->[0]) eq "Perlito5::AST::If") {;
                    push(@str, "else", [$otherwise->{"block"}->[0]->emit_java($level, $wantarray)])
                }
                else {;
                    push(@str, "else {", [$otherwise->emit_java($level + 1, $wantarray)], "}")
                }
            }
            return Perlito5::Java::emit_wrap_java($level, @str)
        }
        sub Perlito5::AST::If::emit_java_get_decl {;
            ()
        }
        sub Perlito5::AST::If::emit_java_has_regex {;
            ()
        }
    }
    package Perlito5::AST::When;
    {
        sub Perlito5::AST::When::emit_java {
            (my($self), my($level), my($wantarray)) = @_;
            my $cond = $self->{"cond"};
            my @str;
            my $old_level = $level;
            if ($cond) {
                my @var_decl = $cond->emit_java_get_decl();
                for my $arg (@var_decl) {
                    $level = $old_level + 1;
                    push(@str, $arg->emit_java_init($level, $wantarray))
                }
            }
            $cond = Perlito5::AST::Apply::->new("arguments", [Perlito5::AST::Var::SCALAR_ARG(), $cond], "code", "infix:<~~>", "namespace", '');
            my $next = Perlito5::AST::Apply::->new("arguments", [], "bareword", 1, "code", "next", "namespace", '');
            my $body = ref($self->{"body"}) ne "Perlito5::AST::Block" ? Perlito5::Java::LexicalBlock::->new("block", [$self->{"body"}], "not_a_loop", 1) : (!@{$self->{"body"}->stmts()}) ? undef : $wantarray ne "void" ? Perlito5::Java::LexicalBlock::->new("block", $self->{"body"}->stmts(), "not_a_loop", 1) : Perlito5::Java::LexicalBlock::->new("block", $self->{"body"}->stmts(), "create_context", 1, "not_a_loop", 1);
            push(@{$body->{"block"}}, $next);
            push(@str, "if (" . Perlito5::Java::to_boolean($cond, $level + 1) . ") {");
            if ($body) {;
                push(@str, [$body->emit_java($level + 1, $wantarray)])
            }
            push(@str, "}");
            return Perlito5::Java::emit_wrap_java($level, @str)
        }
        sub Perlito5::AST::When::emit_java_get_decl {;
            ()
        }
        sub Perlito5::AST::When::emit_java_has_regex {;
            ()
        }
    }
    package Perlito5::AST::While;
    {
        sub Perlito5::AST::While::emit_java {
            (my($self), my($level), my($wantarray)) = @_;
            my $cond = $self->{"cond"};
            my @str;
            my $old_level = $level;
            if ($cond) {
                my @var_decl = $cond->emit_java_get_decl();
                for my $arg (@var_decl) {
                    $level = $old_level + 1;
                    push(@str, $arg->emit_java_init($level, $wantarray))
                }
            }
            my $expression;
            if (Perlito5::Java::is_native_bool($cond)) {;
                $expression = Perlito5::Java::to_native_bool($cond, $level + 1)
            }
            else {;
                $expression = Perlito5::Java::to_boolean($cond, $level + 1)
            }
            if ($expression eq "false") {;
                return "PerlOp.statement();"
            }
            if (ref($self->{"body"}) eq "Perlito5::AST::Apply" && $self->{"body"}->{"code"} eq "do") {;
                push(@str, "do {", [Perlito5::Java::LexicalBlock::->new("block", $self->{"body"}->{"arguments"}->[0]->{"stmts"}, "not_a_loop", 1)->emit_java($level + 2, $wantarray)], "}", "while (" . $expression . ");")
            }
            else {
                local $Perlito5::THROW = 0;
                my $body = ref($self->{"body"}) ne "Perlito5::AST::Block" ? [$self->{"body"}] : $self->{"body"}->{"stmts"};
                push(@str, "while (" . $expression . ") {", [Perlito5::Java::LexicalBlock::->new("block", $body, "block_label", $self->{"label"}, "continue", $self->{"continue"})->emit_java($level + 2, $wantarray)], "}");
                if ($Perlito5::THROW) {;
                    @str = Perlito5::Java::emit_wrap_last_exception_java($self, \@str)
                }
            }
            return Perlito5::Java::emit_wrap_java($level, @str)
        }
        sub Perlito5::AST::While::emit_java_get_decl {;
            ()
        }
        sub Perlito5::AST::While::emit_java_has_regex {;
            ()
        }
    }
    package Perlito5::AST::For;
    {
        sub Perlito5::AST::For::emit_java {
            (my($self), my($level), my($wantarray)) = @_;
            local $Perlito5::THROW = 0;
            my $body = ref($self->{"body"}) ne "Perlito5::AST::Block" ? [$self->{"body"}] : $self->{"body"}->{"stmts"};
            my @str;
            my $cond = ref($self->{"cond"}) eq "ARRAY" ? $self->{"cond"} : [$self->{"cond"}];
            for my $expr (@{$cond}) {;
                if ($expr) {
                    my @var_decl = $expr->emit_java_get_decl();
                    for my $arg (@var_decl) {;
                        push(@str, $arg->emit_java_init($level, $wantarray))
                    }
                }
            }
            if (ref($self->{"cond"}) eq "ARRAY") {;
                push(@str, "for ( " . ($self->{"cond"}->[0] ? $self->{"cond"}->[0]->emit_java($level + 1) . "; " : "; ") . ($self->{"cond"}->[1] ? Perlito5::Java::to_boolean($self->{"cond"}->[1], $level + 1) . "; " : "; ") . ($self->{"cond"}->[2] ? $self->{"cond"}->[2]->emit_java($level + 1) . " " : '') . ") {", [(Perlito5::Java::LexicalBlock::->new("block", $body, "block_label", $self->{"label"}))->emit_java($level + 2, $wantarray)], "}")
            }
            else {
                my $cond = $self->{"cond"};
                if ($cond->isa("Perlito5::AST::Apply") && $cond->{"code"} eq "infix:<..>") {;
                    $cond = "new PerlRange(" . $cond->{"arguments"}->[0]->emit_java($level + 1) . ", " . $cond->{"arguments"}->[1]->emit_java($level + 1) . ")"
                }
                else {;
                    $cond = Perlito5::Java::to_param_list([$cond], $level + 1)
                }
                my $topic = $self->{"topic"};
                my $local_label = Perlito5::Java::get_label();
                my $decl = '';
                my $v = $topic;
                if ($v->{"decl"}) {
                    $decl = $v->{"decl"};
                    $v = $v->{"var"}
                }
                else {;
                    $decl = $v->{"_decl"} || "global"
                }
                my $namespace = $v->{"namespace"} || $v->{"_namespace"} || $Perlito5::PKG_NAME;
                my $s;
                if ($decl eq "my" || $decl eq "state") {;
                    push(@str, "for (PlObject " . $local_label . " : " . $cond . ") {", ["PlLvalue " . $v->emit_java($level + 1) . " = (PlLvalue)" . $local_label . ";", Perlito5::Java::LexicalBlock::->new("block", $body, "block_label", $self->{"label"}, "continue", $self->{"continue"})->emit_java($level + 2, $wantarray)], "}")
                }
                else {
                    my $local_label2 = Perlito5::Java::get_label();
                    push(@str, "int " . $local_label2 . " = PerlOp.local_length();");
                    push(@str, $v->emit_java_global($level + 1, "scalar", 1) . ";");
                    push(@str, "for (PlObject " . $local_label . " : " . $cond . ") {", [$v->emit_java_global_set_alias("(PlLvalue)" . $local_label, $level + 1) . ";", Perlito5::Java::LexicalBlock::->new("block", $body, "block_label", $self->{"label"}, "continue", $self->{"continue"})->emit_java($level + 2, $wantarray)], "}");
                    push(@str, "PerlOp.cleanup_local(" . $local_label2 . ", PlCx.UNDEF);")
                }
            }
            if ($Perlito5::THROW) {;
                @str = Perlito5::Java::emit_wrap_last_exception_java($self, \@str)
            }
            return Perlito5::Java::emit_wrap_java($level, @str)
        }
        sub Perlito5::AST::For::emit_java_get_decl {;
            ()
        }
        sub Perlito5::AST::For::emit_java_has_regex {;
            ()
        }
    }
    package Perlito5::AST::Sub;
    {
        sub Perlito5::AST::Sub::emit_java {
            (my($self), my($level), my($wantarray)) = @_;
            if (my $node = $self->maybe_rewrite_statevars()) {;
                return $node->emit_java($level, $wantarray)
            }
            local $Perlito5::THROW;
            !$self->{"_do_block"} && (local $Perlito5::THROW_RETURN);
            my $prototype = defined($self->{"sig"}) ? "new PlString(" . Perlito5::Java::escape_string($self->{"sig"}) . ")" : "PlCx.UNDEF";
            my $outer_sub;
            $Perlito5::Java::is_inside_subroutine && ($outer_sub = "this.getCurrentSub()");
            my $sub_ref = Perlito5::Java::get_label();
            local $Perlito5::Java::is_inside_subroutine = 1;
            my $block = Perlito5::Java::LexicalBlock::->new("block", $self->{"block"}->{"stmts"}, "not_a_loop", 1);
            my @captures_ast = @Perlito5::CAPTURES;
            {
                my @captured;
                for my $stmt (@{$self->{"block"}->{"stmts"}}) {;
                    push(@captured, $stmt->get_captures())
                }
                my %dont_capture = map {;
                    $_->{"dont"} ? ($_->{"dont"}, 1) : ()
                } @captured;
                my %capture = map {;
                    $_->{"dont"} ? () : $dont_capture{$_->{"_id"}} ? () : ($_->{"_decl"} eq "local" || $_->{"_decl"} eq "global" || $_->{"_decl"} eq '') ? () : ($_->{"_id"}, $_)
                } @captured;
                my %seen = map {;
                    $_->{"_id"} => 1
                } @captures_ast;
                my @more = (grep {;
                    !$seen{$_->{"_id"}}
                } map {;
                    $capture{$_}
                } sort {;
                    $a cmp $b
                } keys(%capture));
                push(@captures_ast, @more)
            }
            local @Perlito5::CAPTURES = @captures_ast;
            my @captures_java = map {;
                $_->emit_java($level, "list")
            } @captures_ast;
            local %Perlito5::Java::Java_var_name;
            my $i = 0;
            for $_ (@captures_ast) {
                my $capture_name = "this.env[" . $i . "]";
                my $sigil = $_->{"_real_sigil"} || $_->{"sigil"};
                if ($sigil eq "\$") {;
                    $capture_name = "((PlLvalue)" . $capture_name . ")"
                }
                elsif ($sigil eq "\@") {;
                    $capture_name = "((PlArray)" . $capture_name . ")"
                }
                elsif ($sigil eq "%") {;
                    $capture_name = "((PlHash)" . $capture_name . ")"
                }
                $Perlito5::Java::Java_var_name{$_->{"_id"}} = $capture_name;
                $i++
            }
            my @js_block;
            if ($self->{"_do_block"}) {;
                @js_block = $block->emit_java($level + 3, "runtime")
            }
            elsif ($self->{"_eval_block"}) {
                $block->{"top_level"} = 1;
                $block->{"eval_block"} = 1;
                my $outer_throw = $Perlito5::THROW_RETURN;
                $Perlito5::THROW_RETURN = 0;
                @js_block = $block->emit_java($level + 3, "runtime"), $Perlito5::THROW_RETURN = $outer_throw
            }
            else {
                $block->{"top_level"} = 1;
                my $outer_throw = $Perlito5::THROW_RETURN;
                $Perlito5::THROW_RETURN = 0;
                @js_block = $block->emit_java($level + 3, "runtime");
                $Perlito5::THROW_RETURN = $outer_throw
            }
            if (!@js_block) {;
                push(@js_block, "return PerlOp.context(want, PerlOp.context(want));")
            }
            my @closure_args = ($prototype, "new PlObject[]{ " . join(", ", @captures_java) . " }", Perlito5::Java::pkg());
            if (($self->{"_do_block"} || $self->{"_eval_block"}) && $outer_sub) {;
                push(@closure_args, $outer_sub)
            }
            my @s = ("new PlClosure(" . join(", ", @closure_args) . ") {", ["public PlObject apply(int want, PlArray List__) {", [@js_block], "}"], "}");
            if ($self->{"name"}) {
                my $idx = Perlito5::Java::get_label();
                return Perlito5::Java::emit_wrap_java($level, "if (!PlV.sget(\"main::init_" . $idx . "\").to_boolean()) {", ["PlV.sset(\"main::init_" . $idx . "\", (PlCx.INT1));", "PlV.cset(" . Perlito5::Java::escape_string($self->{"namespace"} . "::" . $self->{"name"}) . ", " . Perlito5::Java::emit_wrap_java($level + 1, @s) . ");"], "}")
            }
            else {;
                return '' . Perlito5::Java::emit_wrap_java($level, @s)
            }
        }
        sub Perlito5::AST::Sub::emit_java_get_decl {;
            ()
        }
        sub Perlito5::AST::Sub::emit_java_has_regex {;
            ()
        }
    }
    1
}
{
    package main;
    package Perlito5::Java::CORE;
    my %FileFunc = ("open", "        int argCount = List__.to_int();
        Path path = null; 
        String mode = \"\";
        String s = \"\";
        try {
            fh.readlineBuffer = new StringBuilder();
            fh.eof = false;
            if (fh.outputStream != null) {
                fh.outputStream.close();
            }
            if (fh.reader != null) {
                fh.reader.close();
            }
            if (argCount == 0) {
                PlCORE.die(\"TODO - not implemented: single argument open()\");
            }
            else if (argCount == 1) {

                if (List__.aget(0).ref().str_eq(new PlString(\"SCALAR\")).to_boolean()) {
                    PlObject o = List__.aget(0).scalar_deref(\"main\");
                    fh.reader = new PlStringReader(o);
                    fh.reader.mark(o.toString().length());
                    fh.outputStream = null;
                    return PlCx.INT1;
                }

                // EXPR
                s = List__.aget(0).toString();
                if (s.length() > 0 && s.charAt(0) == '+') {
                    mode = mode + s.substring(0, 1);
                    s = s.substring(1);
                }
                if (s.length() > 1 && s.substring(0, 2) == \">>\") {
                    mode = mode + s.substring(0, 2);
                    s = s.substring(2);
                }
                else if (s.length() > 0 && (s.charAt(0) == '>' || s.charAt(0) == '<')) {
                    mode = mode + s.substring(0, 1);
                    s = s.substring(1);
                }
                while (s.length() > 0 && (s.charAt(0) == ' ' || s.charAt(0) == '\\t')) {
                    s = s.substring(1);
                }
            }
            else if (argCount > 1) {
                // MODE,EXPR,LIST?
                mode = List__.aget(0).toString();

                if (List__.aget(1).ref().str_eq(new PlString(\"SCALAR\")).to_boolean()) {
                    // TODO - input stream, charset

                    PlObject o = List__.aget(1).scalar_deref(\"main\");
                    fh.reader = new PlStringReader(o);
                    fh.reader.mark(o.toString().length());
                    fh.outputStream = null;
                    return PlCx.INT1;
                }

                s = List__.aget(1).toString();
            }
            path = PlV.path.resolve(s).toRealPath();
            // PlCORE.say(\"path \" + path.toString());
            if (mode.equals(\"<\") || mode.equals(\"\")) {
                // TODO: charset
                fh.reader = Files.newBufferedReader(path, PlCx.UTF8);
                fh.outputStream = null;
            }
            else if (mode.equals(\"<:encoding(UTF-8)\")) {
                fh.reader = Files.newBufferedReader(path, PlCx.UTF8);
                fh.outputStream = null;
            }
            else if (mode.equals(\">\")) {
                // TODO: charset
                fh.reader = null;
                fh.outputStream = new PrintStream(Files.newOutputStream(path, StandardOpenOption.CREATE));
            }
            else if (mode.equals(\">>\")) {
                // TODO: charset
                fh.reader = null;
                fh.outputStream = new PrintStream(Files.newOutputStream(path, StandardOpenOption.CREATE, StandardOpenOption.APPEND));
            }
            else {
                PlCORE.die(\"TODO - not implemented: open() mode '\" + mode + \"'\");
            }
        }
        catch(IOException e) {
            PlV.sset(\"main::!\", new PlString(e.getMessage()));
            return PlCx.UNDEF;
        }
        return PlCx.INT1;
", "close", "        try {
            fh.readlineBuffer = new StringBuilder();
            fh.eof = true;
            if (fh.outputStream != null) {
                fh.outputStream.close();
            }
            if (fh.reader != null) {
                fh.reader.close();
            }
        }
        catch(IOException e) {
            PlV.sset(\"main::!\", new PlString(e.getMessage()));
            return PlCx.UNDEF;
        }
        return PlCx.INT1;
", "opendir", "        try {
            String s = List__.aget(0).toString();
            Path path = PlV.path.resolve(s).toRealPath();

            fh.directoryStream = Files.newDirectoryStream(path);
            fh.directoryIterator = fh.directoryStream.iterator();
        }
        catch(IOException e) {
            PlV.sset(\"main::!\", new PlString(e.getMessage()));
            return PlCx.UNDEF;
        }
        return PlCx.INT1;
", "readdir", "        Iterator<Path> iter = fh.directoryIterator;
        if (want == PlCx.LIST) {
            // read all lines
            PlArray res = new PlArray();
            while (iter.hasNext()) {
                res.push(new PlString(iter.next().getFileName().toString()));
            }
            return res;
        }
        if (!iter.hasNext()) {
            return PlCx.UNDEF;
        }
        Path entry = iter.next();
        return new PlString(entry.getFileName().toString());
", "closedir", "        try {
            fh.readlineBuffer = new StringBuilder();
            fh.eof = true;
            if (fh.directoryStream != null) {
                fh.directoryStream.close();
            }
        }
        catch(IOException e) {
            PlV.sset(\"main::!\", new PlString(e.getMessage()));
            return PlCx.UNDEF;
        }
        return PlCx.INT1;
", "print", "        for (int i = 0; i < List__.to_int(); i++) {
            fh.outputStream.print(List__.aget(i).toString());
        }
        return PlCx.INT1;
", "say", "        for (int i = 0; i < List__.to_int(); i++) {
            fh.outputStream.print(List__.aget(i).toString());
        }
        fh.outputStream.println(\"\");
        return PlCx.INT1;
", "readline", "        if (want == PlCx.LIST) {
            // read all lines
            PlArray res = new PlArray();
            PlObject s;
            while (!(s = PlCORE.readline(PlCx.SCALAR, fh, List__)).is_undef()) {
                res.push(s);
            }
            return res;
        }
        PlObject plsep = PlV.sget(\"main::/\");
        boolean slurp = false;
        if (plsep.is_undef()) {
            slurp = true;
        }
        if (fh.eof) {
            if (fh.is_argv) {
                // \"ARGV\" is special
                PlArray argv = PlV.array_get(\"main::ARGV\");
                PlFileHandle in = new PlFileHandle();
                if (argv.to_int() > 0) {
                    // arg list contains file name
                    PlCORE.open(PlCx.VOID, in, new PlArray(new PlString(\"<\"), argv.shift()));
                }
                else {
                    // read from STDIN
                    fh.is_argv = false;     // clear the magic bit
                    in  = PlCx.STDIN;
                }
                fh.readlineBuffer   = in.readlineBuffer;
                fh.eof              = in.eof;
                fh.outputStream     = in.outputStream;
                fh.reader           = in.reader;
            }
            if (fh.eof) {
                return PlCx.UNDEF;
            }
        }
        String sep = plsep.toString();
        StringBuilder buf = fh.readlineBuffer;
        // read from filehandle until \"sep\" or eof()
        int pos = slurp ? -1 : buf.indexOf(sep);
        while (pos < 0 && !fh.eof) {
            // read more
            int len = 1000;
            char[] c = new char[len];
            int num_chars = 0;
            try {
                num_chars = fh.reader.read(c, 0, len);
                if (num_chars > 0) {
                    // TODO - use: new String(bytes,\"UTF-8\")
                    String s = new String(c, 0, num_chars);
                    buf.append(s);
                }
            }
            catch(IOException e) {
                PlV.sset(\"main::!\", new PlString(e.getMessage()));
                return PlCx.UNDEF;
            }
            if (num_chars > 0) {
                if (!slurp) {
                    pos = buf.indexOf(sep);
                }
            }
            else {
                // eof
                fh.eof = true;
            }
        }
        String s;
        if (fh.eof || pos < 0) {
            s = buf.toString();
            fh.readlineBuffer = new StringBuilder();
            fh.eof = true;
            if (s.length() == 0) {
                return PlCx.UNDEF;
            }
        }
        else {
            pos += sep.length();
            s = buf.substring(0, pos);
            fh.readlineBuffer = new StringBuilder(buf.substring(pos));
        }
        return new PlString(s);
", "getc", "        PlLvalue buf = new PlLvalue();
        PlCORE.sysread(want, fh, PlArray.construct_list_of_aliases(buf, PlCx.INT1));
        return buf;
", "read", "        return PlCORE.sysread(want, fh, List__);
", "sysread", "        int leng = List__.aget(1).to_int();
        int ofs = List__.aget(2).to_int();

        if (fh.eof) {
            return PlCx.UNDEF;
        }
        StringBuilder buf = fh.readlineBuffer;
        // read from filehandle until \"len\"
        int pos = buf.length();
        while (pos < leng && !fh.eof) {
            // read more
            int len = 1000;
            char[] c = new char[len];
            int num_chars = 0;
            try {
                num_chars = fh.reader.read(c, 0, len);
                if (num_chars > 0) {
                    // TODO - use: new String(bytes,\"UTF-8\")
                    String s = new String(c, 0, num_chars);
                    buf.append(s);
                }
            }
            catch(IOException e) {
                PlV.sset(\"main::!\", new PlString(e.getMessage()));
                return PlCx.UNDEF;
            }
            if (num_chars > 0) {
                pos = buf.length();
            }
            else {
                // eof
                fh.eof = true;
            }
        }
        String s;
        if (fh.eof || pos < leng) {
            s = buf.toString();
            fh.readlineBuffer = new StringBuilder();
            fh.eof = true;
            if (s.length() == 0) {
                return PlCx.UNDEF;
            }
        }
        else {
            s = buf.substring(0, leng);
            fh.readlineBuffer = new StringBuilder(buf.substring(leng));
        }

        leng = s.length();
        if (ofs == 0) {
            List__.aset(0, s);
        }
        else {
            die(\"TODO: sysread with OFFSET\");
        }
        return new PlInt(leng);
", "seek", "        int position = List__.aget(0).to_int();
        int whence   = List__.aget(1).to_int();
        try {

            // TODO - random access files, more tests
            // See: http://stackoverflow.com/questions/262618/java-bufferedreader-back-to-the-top-of-a-text-file

            // position = 0
            if (fh.reader == null) {
                PlV.sset(\"main::!\", new PlString(\"File is not open\"));
                return PlCx.UNDEF;
            }
            fh.reader.reset();
            fh.readlineBuffer = new StringBuilder();
            fh.eof = false;

            if (position > 0) {
                PlCORE.read(PlCx.VOID, fh, new PlArray(PlCx.UNDEF, new PlInt(position)));
            }

        }
        catch(IOException e) {
            PlV.sset(\"main::!\", new PlString(e.getMessage()));
            return PlCx.UNDEF;
        }
        return PlCx.INT1;
");
    sub Perlito5::Java::CORE::emit_java {;
        return "
class PlCORE {
" . join('', map {;
            "    public static final PlObject " . $_ . "(int want, PlFileHandle fh, PlArray List__) {
" . $FileFunc{$_} . "    }
"
        } sort {;
            $a cmp $b
        } keys(%FileFunc)) . "    public static final PlObject say(String s) {
        // say() shortcut for internal use
        return PlCORE.say(PlCx.VOID, PlCx.STDOUT, new PlArray(new PlString(s)));
    }
    public static final PlObject mkdir(int want, PlArray List__) {
        try {
            Path path = PlV.path.resolve(List__.aget(0).toString()).toRealPath();
            int mask = List__.aget(1).to_int();
            Set<PosixFilePermission> perms = PerlOp.MaskToPermissions(mask);
            FileAttribute<Set<PosixFilePermission>> attr = PosixFilePermissions.asFileAttribute(perms);
            Files.createDirectory(path, attr);
            return PlCx.INT1;
        }
        catch(IOException e) {
            PlV.sset(\"main::!\", new PlString(e.getMessage()));
        }
        return PlCx.UNDEF;
    }
    public static final PlObject require(int want, PlObject file, boolean is_bareword) {
        // TODO - require-version
        if (is_bareword) {
            file = PlV.apply(\"Perlito5::Grammar::Use::modulename_to_filename\", PlCx.SCALAR, new PlArray(file));
        }
        return PlV.apply(\"Perlito5::Grammar::Use::require\", want, new PlArray(file));
    }
    public static final PlObject rmdir(int want, PlArray List__) {
        try {
            Path path = PlV.path.resolve(List__.aget(0).toString()).toRealPath();
            Files.delete(path);
            return PlCx.INT1;
        }
        catch(NoSuchFileException e) {
            PlV.sset(\"main::!\", new PlString(\"No such file or directory\"));
        }
        catch(DirectoryNotEmptyException e) {
            PlV.sset(\"main::!\", new PlString(\"Directory not empty\"));
        }
        catch(IOException e) {
            PlV.sset(\"main::!\", new PlString(e.getMessage()));
        }
        return PlCx.UNDEF;
    }
    public static final PlObject chdir(int want, PlArray List__) {
        try {
            Path path = PlV.path.resolve(List__.aget(0).toString()).toRealPath();
            PlV.path = path;
            // TODO - test that the destination is a directory
            return PlCx.INT1;
        }
        catch(NoSuchFileException e) {
            PlV.sset(\"main::!\", new PlString(\"No such file or directory\"));
        }
        catch(DirectoryNotEmptyException e) {
            PlV.sset(\"main::!\", new PlString(\"Directory not empty\"));
        }
        catch(IOException e) {
            PlV.sset(\"main::!\", new PlString(e.getMessage()));
        }
        return PlCx.UNDEF;
    }
    public static final PlObject unlink(int want, PlArray List__) {
        try {
            for (int i = 0; i < List__.to_int(); i++) {
                Path path = PlV.path.resolve(List__.aget(i).toString()).toRealPath();
                Files.delete(path);
            }
            return PlCx.INT1;
        }
        catch(NoSuchFileException e) {
            PlV.sset(\"main::!\", new PlString(\"No such file or directory\"));
        }
        catch(DirectoryNotEmptyException e) {
            PlV.sset(\"main::!\", new PlString(\"Directory not empty\"));
        }
        catch(IOException e) {
            PlV.sset(\"main::!\", new PlString(e.getMessage()));
        }
        return PlCx.UNDEF;
    }
    public static final PlObject select(int want, PlArray List__) {
        return PlCORE.die(\"select() not implemented\");
    }
    public static final PlObject exit(int want, PlArray List__) {
        int arg = List__.aget(0).to_int();
        System.exit(arg);
        return PlCx.UNDEF;
    }
    public static final PlObject warn(int want, PlArray List__) {
        int arg_count = List__.length_of_array_int();
        if (arg_count == 0) {
            List__.push(\"Warning: something's wrong\");
        }
        if (arg_count != 1 || !List__.aget(0).is_ref()) {
            String s = List__.toString();
            int s_length = s.length();
            if (s_length > 0 && (s.charAt(s_length-1) == '\\n' || s.charAt(s_length-1) == '\\r')) {
                // don't add file+line
            }
            else {
                // TODO - add module name, line number
                s = s + \" at \" + PlV.sget(\"main::0\") + \"\\n\";
            }
            List__.set(new PlArray(new PlString(s)));
        }
        if (PlV.hash_get(\"main::SIG\").hget(\"__WARN__\").is_coderef()) {
            // execute \$SIG{__WARN__}
            // localize \$SIG{__WARN__} during the call
            int tmp = PerlOp.local_length();
            PlObject c = PlV.hash_get(\"main::SIG\").hget(\"__WARN__\");
            PlV.hash_get(\"main::SIG\").hget_lvalue_local(\"__WARN__\");
            c.apply(want, List__);
            PerlOp.cleanup_local(tmp, PlCx.UNDEF);
        }
        else {
            String s = List__.toString();
            PlCx.STDERR.outputStream.println(s);
        }
        return PlCx.INT1;
    }
    public static final PlObject die(int want, PlArray List__) {
        int arg_count = List__.length_of_array_int();
        if (arg_count == 0) {
            List__.push(\"Died\");
        }
        if (arg_count != 1 || !List__.aget(0).is_ref()) {
            String s = List__.toString();
            int s_length = s.length();
            if (s_length > 0 && (s.charAt(s_length-1) == '\\n' || s.charAt(s_length-1) == '\\r')) {
                // don't add file+line
            }
            else {
                // TODO - add module name, line number
                s = s + \" at \" + PlV.sget(\"main::0\") + \"\\n\";
                // Java stack trace
                s = s + Arrays.toString(new Throwable().getStackTrace());
            }
            List__.set(new PlArray(new PlString(s)));
        }
        if (PlV.hash_get(\"main::SIG\").hget(\"__DIE__\").is_coderef()) {
            // execute \$SIG{__DIE__}
            // localize \$SIG{__DIE__} during the call
            int tmp = PerlOp.local_length();
            PlObject c = PlV.hash_get(\"main::SIG\").hget(\"__DIE__\");
            PlV.hash_get(\"main::SIG\").hget_lvalue_local(\"__DIE__\");
            c.apply(want, List__);
            PerlOp.cleanup_local(tmp, PlCx.UNDEF);
        }
        PlObject arg = List__.aget(0);
        throw new PlDieException(arg);
    }
    public static final PlObject die(String s) {
        // die() shortcut
        return PlCORE.die(PlCx.VOID, new PlArray(new PlString(s)));
    }
    public static final PlString ref(int want, PlArray List__) {
        return List__.aget(0).ref();
    }
    public static final PlObject values(int want, PlObject List__) {
        return want == PlCx.LIST ? List__.values() : List__.values().scalar();
    }
    public static final PlObject keys(int want, PlObject List__) {
        return want == PlCx.LIST ? List__.keys() : List__.keys().scalar();
    }
    public static final PlObject each(int want, PlObject List__) {
        return want == PlCx.LIST ? List__.each() : List__.each().aget(0);
    }
    public static final PlObject chomp(int want, PlObject Object__) {
        String sep = PlV.sget(\"main::/\").toString();
        int sepSize = sep.length();
        int result = 0;
        String toChomp = Object__.toString();
        if(toChomp.substring(toChomp.length() - sepSize, toChomp.length()).equals(sep)) {
            toChomp = toChomp.substring(0, toChomp.length() - sepSize);
            result += sepSize;
        }

        Object__.set(new PlString(toChomp));
            
        return new PlInt(result);
    }
    public static final PlObject chomp(int want, PlArray List__) {
        int result = 0;
        for(int i = 0; i < List__.to_int(); ++i) {
            PlObject item = List__.aget_lvalue(i);
            result += chomp(want, item).to_int();
        }

        return new PlInt(result);
    }
    public static final PlString chop(int want, PlObject Object__) {
        String str = Object__.toString();
        String returnValue = \"\";
        if (str.length() > 0) {
            returnValue = str.substring(str.length() -1);
            Object__.set(new PlString(str.substring(0, str.length()-1)));
        }

        return new PlString(returnValue);
    }
    public static final PlObject chop(int want, PlArray List__) {
        PlString result = PlCx.EMPTY;
        for(int i = 0; i < List__.to_int(); ++i) {
            PlObject item = List__.aget_lvalue(i);
            result = chop(want, item);
        }

        return result;
    }
    public static final PlObject scalar(int want, PlArray List__) {
        if (List__.to_int() == 0) {
            return PlCx.UNDEF;
        }
        return List__.aget(-1).scalar();
    }
    public static final PlObject splice(int want, PlArray List__) {
        PlArray res = new PlArray(List__);
        List__.a.clear();
        if (want == PlCx.LIST) {
            return res;
        }
        if (res.to_int() == 0) {
            return PlCx.UNDEF;
        }
        return res.aget(-1);
    }
    public static final PlObject split(int want, PlObject plReg, PlObject plArg, PlObject plCount) {
        if (want == PlCx.SCALAR) {
            return PlCORE.split(PlCx.LIST, plReg, plArg, plCount).length_of_array();
        }
        int limit = plCount.to_int();
        PlArray res = new PlArray();
        if (limit == 0) {
            // strip trailing empty strings and undef
            res = (PlArray)PlCORE.split(PlCx.LIST, plReg, plArg, PlCx.MIN1);
            while (res.to_int() > 0) {
                PlObject item = res.aget(-1);
                if (item.is_undef() || item.toString().length() == 0) {
                    res.pop();
                }
                else {
                    return res;
                }
            }
            return res;
        }
        String arg = plArg.toString();
        if (arg.length() == 0) {
            return res;
        }
        // make sure pattern is a RegExp
        if (plReg.is_lvalue()) {
            plReg = plReg.get();
        }

        // --- TODO ---

        if (!plReg.is_regex()) {
            String regs = plReg.toString();
            if (regs.equals(\" \")) {

                // ltrim
                int i = 0;
                while (i < arg.length() && Character.isWhitespace(arg.charAt(i))) {
                    i++;
                }
                if (i > 0) {
                    arg = arg.substring(i);
                }

                plReg = PlCx.SPLIT_SPACE;
            }
            else {
                plReg = new PlRegex(regs, Pattern.MULTILINE, false);
            }
        }

        Pattern pat = ((PlRegex)plReg).p;

        //      // make sure pattern is a RegExp
        //      if (typeof pattern === \"object\" && (pattern instanceof RegExp)) {
        //          pattern = pattern.source;
        //      }
        //      else {
        //          pattern = p5str(pattern);
        //          if (pattern == \" \") {
        //              // single space string is special
        //              pattern = \"(?: |\\t|\\n)+\";
        //              s = s.replace(/^(?: |\\t|\\n)+/, \"\");
        //          }
        //      }
        //      // add \"g\", \"m\" modifiers
        //      var flags = \"g\";
        //      if (pattern.substr(0, 1) == \"^\" || pattern.substr(-1,1) == \"\$\") {
        //          flags = flags + \"m\";
        //      }
        // --- /TODO ---

        int pos = 0;
        int next = pos;
        int count = 1;
        String cap;
        Matcher matcher = pat.matcher(arg).useTransparentBounds(true);
        while (pos < arg.length() && !(limit > 0 && count >= limit) && matcher.find(next)) {
            boolean matched = true;
            if (matcher.end() == pos) {
                // pointer didn't move
                next++;
                matched = matcher.find(next);
            }
            if (matched) {
                cap = arg.substring(pos, matcher.start());
                res.push(cap);
                pos = matcher.end();
                next = pos;
                // PlCORE.say(\"match: match [\" + cap + \"] next pos \" + pos);
                count++;
                for (int i = 1; i <= matcher.groupCount(); i++) {
                    cap = matcher.group(i);
                    if (cap == null) {
                        res.push(PlCx.UNDEF);
                    }
                    else {
                        res.push(cap);
                    }
                }
            }
        }
        if ( pos >= arg.length()) {
            cap = \"\";
        }
        else {
            cap = arg.substring(pos);
        }
        res.push(cap);
        return res;
    }
    public static final PlObject splice(int want, PlArray List__, PlObject offset) {
        int size = List__.to_int();
        int pos  = offset.to_int();
        if (pos < 0) {
            pos = List__.a.size() + pos;
        }
        if (pos < 0 || pos > List__.a.size()) {
            return PlCx.UNDEF;
        }
        PlArray res = new PlArray();
        for (int i = pos; i < size; i++) {
            res.unshift(List__.pop());
        }
        if (want == PlCx.LIST) {
            return res;
        }
        if (res.to_int() == 0) {
            return PlCx.UNDEF;
        }
        return res.aget(-1);
    }
    public static final PlObject splice(int want, PlArray List__, PlObject offset, PlObject length) {
        int size = List__.to_int();
        int pos  = offset.to_int();
        if (pos < 0) {
            pos = List__.a.size() + pos;
        }
        if (pos < 0 || pos > List__.a.size()) {
            return PlCx.UNDEF;
        }

        int last = length.to_int();
        if (last < 0) {
            last = List__.a.size() + last;
        }
        else {
            last = pos + last;
        }
        if (last < 0) {
            return PlCx.UNDEF;
        }
        if (last > size) {
            last = size;
        }

        int diff = last - pos;
        PlArray res = new PlArray();
        for (int i = pos; i < last; i++) {
            res.push(List__.a.get(i));
        }
        for (int i = pos; i < (size - diff); i++) {
            List__.a.set(i, List__.a.get(i+diff));
        }
        for (int i = 0; i < diff; i++) {
            List__.pop();
        }
        if (want == PlCx.LIST) {
            return res;
        }
        if (res.to_int() == 0) {
            return PlCx.UNDEF;
        }
        return res.aget(-1);
    }
    public static final PlObject splice(int want, PlArray List__, PlObject offset, PlObject length, PlArray list) {
        int size = List__.to_int();
        int pos  = offset.to_int();
        if (pos < 0) {
            pos = List__.a.size() + pos;
        }
        if (pos < 0 || pos > List__.a.size()) {
            return PlCx.UNDEF;
        }

        int last = length.to_int();
        if (last < 0) {
            last = List__.a.size() + last;
        }
        else {
            last = pos + last;
        }
        if (last < 0) {
            return PlCx.UNDEF;
        }
        if (last > size) {
            last = size;
        }

        int diff = last - pos;
        PlArray res = new PlArray();

        for (int i = pos; i < last; i++) {
            res.push(List__.a.get(i));
        }
        for (int i = pos; i < (size - diff); i++) {
            List__.a.set(i, List__.a.get(i+diff));
        }
        for (int i = 0; i < diff; i++) {
            List__.pop();
        }

        List__.a.addAll(pos, list.a);
        if (want == PlCx.LIST) {
            return res;
        }
        if (res.to_int() == 0) {
            return PlCx.UNDEF;
        }
        return res.aget(-1);
    }

    public static final PlObject hex(int want, PlObject List__) {
        String s = List__.toString();

        final int length = s.length();
        int c;

        for (int i = 0; i < length; i++ ) {
            c = s.codePointAt(i);
            if (c > 254) {
                PlCORE.die(\"Wide character in hex\");
            }
        }

        if (s.startsWith(\"0x\") || s.startsWith(\"0X\")) {
            s = s.substring(2);
        }
        else if (s.startsWith(\"x\") || s.startsWith(\"X\")) {
            s = s.substring(1);
        }
        s = s.replace(\"_\",\"\");
        try {
            return new PlInt(Long.parseLong(s, 16));
        } catch (java.lang.NumberFormatException e) {
            // result = e.getMessage();
        }
        return new PlInt(0);
    }
    public static final PlObject oct(int want, PlObject List__) {
        String s = List__.toString();
        return new PlInt(PerlOp.oct(s));
    }
    public static final PlObject sprintf(int want, PlObject List__) {
        String format = List__.aget(0).toString();
        // \"%3s\"
        int length = format.length();
        int offset = 0;
        int args_max = List__.to_int();
        int args_index = 0;
        Object args[] = new Object[args_max];
        for ( ; offset < length; ) {
            int c = format.codePointAt(offset);
            switch (c) {
                case '%':
                    offset++;
                    boolean scanning = true;
                    for ( ; offset < length && scanning ; ) {
                        c = format.codePointAt(offset);
                        switch (c) {
                            case '%':
                                scanning = false;
                                offset++;
                                break;
                            case 'c': case 's': case 'd': case 'u': case 'o':
                            case 'x': case 'e': case 'f': case 'g':
                            case 'X': case 'E': case 'G': case 'b':
                            case 'B': case 'p': case 'n':
                            case 'i': case 'D': case 'U': case 'O': case 'F':
                                scanning = false;
                                switch (c) {
                                    case 's':
                                        args[args_index] = List__.aget(args_index+1).toString();
                                        break;
                                    case 'd': case 'o': case 'x': case 'X':
                                    case 'u': case 'b': case 'B': case 'p':
                                    case 'c':
                                        args[args_index] = List__.aget(args_index+1).to_int();
                                        break;
                                    case 'f': case 'e': case 'g':
                                    case 'E': case 'G':
                                        args[args_index] = List__.aget(args_index+1).to_double();
                                        break;
                                    default:
                                        break;
                                }
                                args_index++;
                                if (args_index > args_max) {
                                    // panic
                                    offset = length;
                                }
                                offset++;
                                break;
                            default:
                                offset++;
                                break;
                        }
                    }
                    break;
                default:
                    offset++;
                    break;
            }
        }
        return new PlString(String.format(format, args));
    }
    public static final PlObject crypt(int want, PlArray List__) {
        if(List__.to_int() < 2) {
            die(\"Not enough arguments for crypt\");
        }
        if(List__.to_int() > 2) {
            die(\"Too many arguments for crypt\");
        }
        String plainText = List__.shift().toString();
        String salt = List__.shift().toString();

        while(salt.length() < 2) {
            salt = salt.concat(\".\");
        }
        
        return new PlString(PlCrypt.crypt(salt, plainText));
    }
    public static final PlObject join(int want, PlArray List__) {
        String s = List__.shift().toString();
        StringBuilder sb = new StringBuilder();
        boolean first = true;
        for (int i = 0; i < List__.to_int(); i++) {
            String item = List__.aget(i).toString();
            if (first)
                first = false;
            else
                sb.append(s);
            sb.append(item);
        }
        return new PlString(sb.toString());
    }
    public static final PlObject reverse(int want, PlArray List__) {
        if (want == PlCx.LIST) {
            PlArray ret = new PlArray(List__);
            Collections.reverse(ret.a);
            return ret;
        }
        StringBuilder sb = new StringBuilder();
        if (List__.to_int() == 0) {
            sb.append( PlV.sget(\"main::_\") );
        }
        else {
            for (int i = 0; i < List__.to_int(); i++) {
                sb.append( List__.aget(i).toString() );
            }
        }
        return new PlString(sb.reverse().toString());
    }
    public static final PlObject fc(int want,  PlObject Object__) {
        return new PlString(Object__.toString().toLowerCase());
    }
    public static final PlObject pack(int want, PlArray List__) {
        String template = List__.aget(0).toString();
        StringBuilder result = new StringBuilder();
        int index = 1;
        for(int i = 0; i < template.length(); ++i) {
            switch(template.charAt(i)) {
            case 'a':
            {
                int size = pack_size(template, i);
                result.append(pack_a(List__.aget(index).toString(), size));
                ++index;
                break;
            }
            case 'A':
            {    
                int size = pack_size(template, i);
                result.append(pack_A(List__.aget(index).toString(), size));
                ++index;
                break;
            }
            case 'Z':
            {
                int size = pack_size(template, i);
                result.append(pack_Z(List__.aget(index).toString(), size));
                ++index;
                break;
            }
            case 'b':
            {
                int size = pack_size(template, i);
                result.append(pack_b(List__.aget(index).toString(), size));
                ++index;
                break;
            }
            case 'B':
            {
                int size = pack_size(template, i);
                result.append(pack_B(List__.aget(index).toString(), size));
                ++index;
                break;
            }
            case 'h':
            {
                int size = pack_size(template, i);
                result.append(pack_h(List__.aget(index).toString(), size));
                ++index;
                break;
            }
            case 'H':
            {
                int size = pack_size(template, i);
                result.append(pack_H(List__.aget(index).toString(), size));
                ++index;
                break;        
            }
            case 'c':
            {
                result.append(pack_c(List__.aget(index).toString()));
                ++index;
                break;        
            }
            case 'C':
            {
                result.append(pack_C(List__.aget(index).toString()));
                ++index;
                break;        
            }
            case 'W':
            {
                result.append(pack_W(List__.aget(index).toString()));
                ++index;
                break;        
            }
            case 's':
            {
                result.append(pack_s(List__.aget(index).toString()));
                ++index;
                break;        
            }
            case 'S':
            {
                result.append(pack_S(List__.aget(index).toString()));
                ++index;
                break;        
            }
            case 'l':
            {
                result.append(pack_l(List__.aget(index).toString()));
                ++index;
                break;        
            }
            case 'L':
            {
                result.append(pack_L(List__.aget(index).toString()));
                ++index;
                break;        
            }
            case 'q':
            {
                result.append(pack_q(List__.aget(index).toString()));
                ++index;
                break;        
            }
            case 'Q':
            {
                result.append(pack_Q(List__.aget(index).toString()));
                ++index;
                break;        
            }
            case 'i':
            {
                result.append(pack_i(List__.aget(index).toString()));
                ++index;
                break;        
            }
            case 'I':
            {
                result.append(pack_I(List__.aget(index).toString()));
                ++index;
                break;        
            }
            case 'n':
            {
                result.append(pack_n(List__.aget(index).toString()));
                ++index;
                break;        
            }
            case 'N':
            {
                result.append(pack_N(List__.aget(index).toString()));
                ++index;
                break;        
            }
            case 'v':   
            {
                result.append(pack_v(List__.aget(index).toString()));
                ++index;
                break;        
            }
            case 'V':   
            {
                result.append(pack_V(List__.aget(index).toString()));
                ++index;
                break;        
            }
            case 'j':   
            {
                result.append(pack_j(List__.aget(index).toString()));
                ++index;
                break;        
            }
            case 'J':   
            {
                result.append(pack_J(List__.aget(index).toString()));
                ++index;
                break;        
            }
            case 'f':
            {
                result.append(pack_f(List__.aget(index).to_double()));
                ++index;
                break;        
            }
            case 'd':
            case 'F':
            {
                result.append(pack_d(List__.aget(index).to_double()));
                ++index;
                break;        
            }
            case 'p':
            {
                int size = pack_size(template, i);
                for(int k = 0; k < size; ++k) {
                    if(List__.aget(index + k).is_undef()) {
                        result.append(pack_q(\"0\"));
                    
                    } else {
                        result.append(pack_p(List__.aget(index + k).toString()));
                    }
                }
                index += i;
            }
            case 'u':
            {
                result.append(pack_u(List__.aget(index).toString()));
                ++index;
                break;
            }
            case 'w':
            {
                int size = pack_size(template, i);
                String[] input = new String[size];
                for(int j = 0; j < size; ++j) {
                    input[j] = List__.aget(index + j).toString();
                }
                result.append(pack_w(input, size));
                index += size;
                break;        
            }
            case 'x':
            {
                int size = pack_size(template, i);
                result.append(pack_x(size));
                ++index;                
                break;        
            }
            case 'X':
            {
                int size = pack_size(template, i);
                int length = result.length();
                result.delete(Math.max(0,length - size), length);
                ++index;                
                break;        
            }
            case '\@':
            {
                int size = pack_size(template, i);
                int length = result.length();
                if(size > length) {
                    result.append(new char[size - length]);
                }
                ++index;                
                break;        
            }
            case '.':
            {
               int size = List__.aget(index).to_int();
                int length = result.length();
                if(size > length) {
                    result.append(new char[size - length]);
                }
                ++index;                
                break;        
            }
            default:
            }
        }

        return new PlString(result.toString());
    }
    public static final PlObject unpack(int want, PlArray List__) {
        String template = List__.aget(0).toString();
        StringBuilder result = new StringBuilder();
        int index = 1;
        for(int i = 0; i < template.length(); ++i) {
            switch(template.charAt(i)) {
            case 'a':
            {
                int size = pack_size(template, i);
                result.append(unpack_a(List__.aget(index).toString(), size));
                ++index;
                break;
            }
            case 'A':
            {
                int size = pack_size(template, i);
                result.append(unpack_A(List__.aget(index).toString(), size));
                ++index;
                break;
            }
            case 'Z':
            {
                int size = pack_size(template, i);
                result.append(unpack_Z(List__.aget(index).toString(), size));
                ++index;
                break;
            }
            case 'b':
            {
                int size = pack_size(template, i);
                result.append(unpack_b(List__.aget(index).toString(), size));
                ++index;
                break;
            }
            default:
            }
        }
        return new PlString(result.toString());
    }
    private static final int pack_size(String s, int pos) {
        int howMany = 0;
        while(s.length() > (pos + 1 + howMany) && java.lang.Character.isDigit(s.charAt(pos + 1 + howMany))) {
            ++howMany;
        }
        if(howMany != 0) {
            return java.lang.Integer.parseInt(s.substring(pos + 1, pos + 1 + howMany));
        }
        return 1;
    }
    private static final String pack_a(String s, int size) {
        if(s.length() >= size) {
            return s.substring(0,size);
        }
        String padding = new String(new char[size - s.length()]);
        return s + padding;    
    }
    private static final String unpack_a(String s, int size) {
        if(s.length() >= size) {
            return s.substring(0,size);
        }
        return s; 
    }
    private static final String pack_A(String s, int size) {
        if(s.length() >= size) {
            return s.substring(0,size);
        }
        String padding = new String(new char[size - s.length()]).replace('\\0', ' ');
        return s + padding;    
    }
    private static final String unpack_A(String s, int size) {
        if(s.length() >= size) {
            return s.substring(0,size);
        }
        return s; 
    }
    private static final String pack_Z(String s, int size) {
        s = s.substring(0, java.lang.Math.min(size - 1, s.length()));
        return s +  new String(new char[size - s.length()]);
    }
    private static final String unpack_Z(String s, int size) {
        if(s.length() >= size) {
            return s.substring(0,size);
        }
        return s; 
    }
    private static final String pack_b(String s, int size) {
        s = s.substring(0, Math.min(size, s.length()));
        int wanted8strings = (size + 7) / 8;
        s += new String(new char[(wanted8strings * 8) - s.length()]).replace('\\0', '0');
        StringBuilder input = new StringBuilder();
        for(int i = 0; i < s.length(); ++i) {
            if(s.codePointAt(i) % 2 == 1) {
                input.append(\"1\");
            }
            else {
                input.append(\"0\");
            }
        }
        StringBuilder result = new StringBuilder();
        s = input.toString();
        for(int i = 0; i < wanted8strings; ++i) {
            String part = s.substring(i * 8, i * 8 + 8);
            int first = java.lang.Integer.parseInt(new StringBuilder(part.substring(0,4)).reverse().toString(), 2);
            int second = java.lang.Integer.parseInt(new StringBuilder(part.substring(4,8)).reverse().toString(), 2);
            result.append(Character.toString((char)(first + second * 16)));
        }
        return result.toString();
    }
    private static final String unpack_b(String s, int size) {
        byte[] bytes = s.getBytes();
        StringBuilder result = new StringBuilder();
        byte mask = (byte)128;
        for(int i = 0; i < size; ++i) {
            byte b = bytes[i / 8];
            if((b & mask) > 0) {
                result.append(\"1\");
            } else {
                result.append(\"0\");
            }
            if(mask == 1) {
                mask = (byte)128;
            } else {
                mask /= 2;
            }
        }
        return result.toString();
    }
    private static final String pack_B(String s, int size) {
        s = s.substring(0, Math.min(size, s.length()));
        int wanted8strings = (size + 7) / 8;
        s += new String(new char[(wanted8strings * 8) - s.length()]).replace('\\0', '0');
        StringBuilder input = new StringBuilder();
        for(int i = 0; i < s.length(); ++i) {
            if(s.codePointAt(i) % 2 == 1) {
                input.append(\"1\");
            }
            else {
                input.append(\"0\");
            }
        }
        StringBuilder result = new StringBuilder();
        s = input.toString();
        for(int i = 0; i < wanted8strings; ++i) {
            String part = s.substring(i * 8, i * 8 + 8);
            int ascii = java.lang.Integer.parseInt(part, 2);
            result.append(Character.toString((char)ascii));
        }
        return result.toString();
    }
    private static final String pack_h(String s, int size) {
        int index  = 0;
        if(s.length() < size * 2) {
            s += new String(new char[size * 2 - s.length()]).replace('\\0', '0');
        }
        StringBuilder result = new StringBuilder();
        while(index < size) {
            String part = s.substring(index + 1, index + 2) + s.substring(index, index + 1);
            int ascii = java.lang.Integer.parseInt(part, 16);
            result.append(Character.toString((char)ascii));
            index += 2;
        }
        return result.toString();
    }
    private static final String pack_H(String s, int size) {
        int index  = 0;
        if(s.length() < size * 2) {
            s += new String(new char[size * 2 - s.length()]).replace('\\0', '0');
        }
        StringBuilder result = new StringBuilder();
        while(index < size) {
            String part = s.substring(index, index + 2);
            int ascii = java.lang.Integer.parseInt(part, 16);
            result.append(Character.toString((char)ascii));
            index += 2;
        }
        return result.toString();
    }
    private static String pack_c(String s) {
        try {
            int ascii = java.lang.Integer.parseInt(s) % 128;
            return Character.toString((char)ascii);
        } catch(Exception e) {
            return \"\";
        }
    }
    private static String pack_C(String s) {
        try {
            int ascii = (java.lang.Integer.parseInt(s) + 256) % 256;
            return Character.toString((char)ascii);
        } catch(Exception e) {
            return \"\";
        }
    }
    private static String pack_W(String s) {
        for(int i = 0; i < s.length(); ++i) {
            if(!java.lang.Character.isDigit(s.charAt(i))) {
                s = s.substring(0, i);
                break;
            }
        }
        int value = java.lang.Integer.parseInt(s);
        StringBuilder sb = new StringBuilder();
        sb.appendCodePoint(value);
        return sb.toString();
    }
    private static String pack_number_2_string(String s, int size, boolean signed) {
        for(int i = 0; i < s.length(); ++i) {
            if(!java.lang.Character.isDigit(s.charAt(i)) && !(s.charAt(i) == '-')) {
                s = s.substring(0, i);
                break;
            }
        }
        long value = java.lang.Long.parseLong(s);
        StringBuilder result = new StringBuilder();
        for(int i = 0; i < size; ++i) {
            result.append((char)((value / (int)Math.pow(2,8*i)) % 256));
        }
        return result.toString();        
    }
    private static String pack_s(String s) {
        return pack_number_2_string(s, 2, true);
    }
    private static String pack_S(String s) {
        return pack_number_2_string(s, 2, false);
    }
    public static final String pack_l(String s) {
        return pack_number_2_string(s, 4, true);
    }
    public static final String pack_L(String s) {
        return pack_number_2_string(s, 4, false);
    }
    public static final String pack_q(String s) {
        return pack_number_2_string(s, 8, true);
    }
    public static final String pack_Q(String s) {
        return pack_number_2_string(s, 8, false);
    }
    public static final String pack_i(String s) {
        return pack_number_2_string(s, 4, true);
    }
    public static final String pack_I(String s) {
        return pack_number_2_string(s, 4, false);
    }
    public static final String pack_n(String s) {
        return new StringBuilder(pack_number_2_string(s, 2, false)).reverse().toString();
    }
    public static final String pack_N(String s) {
        return new StringBuilder(pack_number_2_string(s, 4, false)).reverse().toString();
    }
    public static final String pack_v(String s) {
        return pack_number_2_string(s, 2, false);
    }
    public static final String pack_V(String s) {
        return pack_number_2_string(s, 4, false);
    }
    public static final String pack_j(String s) {
        return pack_number_2_string(s, 8, true);
    }
    public static final String pack_J(String s) {
        return pack_number_2_string(s, 8, false);
    }
    public static final String pack_f(double d) {
        float f = (float)d;
        int intBits = java.lang.Float.floatToRawIntBits(f); 
        char one = (char)(intBits / (int)Math.pow(2, 24));
        char two = (char)((intBits / (int)Math.pow(2, 16)) % 256);
        char three = (char)((intBits / (int)Math.pow(2, 8)) % 256);
        char four = (char)(intBits % 256);
        StringBuilder result = new StringBuilder();
        result.append(Character.toString(four));
        result.append(Character.toString(three));
        result.append(Character.toString(two));
        result.append(Character.toString(one));
        return result.toString();        
    }
    public static final String pack_d(double d) {
        long intBits = java.lang.Double.doubleToRawLongBits(d);
        char one =  (char)(intBits / (long)Math.pow(2, 56));
        char two = (char)((intBits / (long)Math.pow(2, 48)) % 256);
        char three = (char)((intBits / (long)Math.pow(2, 40)) % 256);
        char four = (char)((intBits / (long)Math.pow(2, 32)) % 256);
        char five = (char)((intBits / (long)Math.pow(2, 24)) % 256);
        char six = (char)((intBits / (long)Math.pow(2, 16)) % 256);
        char seven = (char)((intBits / (long)Math.pow(2, 8)) % 256);
        char eight = (char)(intBits % 256);
        StringBuilder result = new StringBuilder();
        result.append(eight);
        result.append(seven);
        result.append(six);
        result.append(five);
        result.append(four);
        result.append(three);
        result.append(two);
        result.append(one);
        return result.toString();        
    }
    private static StringBuilder pack_pointers = new StringBuilder();
    private static Map<Long, Integer> pack_pointers_size = new HashMap<Long, Integer>();
    private static final long pack_pointers_magic_value = 654321;
    public static final String pack_p(String s) {
        long pointer = pack_pointers.length() + pack_pointers_magic_value;
        pack_pointers.append(s);

        pack_pointers_size.put(pointer, s.length());
        return pack_q(((Long)(pointer)).toString());
    }
    public static final String pack_u(String s) {
        int index = 0;
        StringBuilder result = new StringBuilder();
        StringBuilder line = new StringBuilder();
        int tooMany = 0;
        while(s.length() > index * 3) {
            String cur = s.substring(index * 3, Math.min(index * 3 + 3, s.length()));
            while(cur.length() < 3) {
                ++tooMany;
                cur += '\\0';
            }
            byte[] bytes = cur.getBytes();
            char value1 = (char)((bytes[0] >> 2) + 32);
            char value2 = (char)(((bytes[0] & 3) << 4) + (bytes[1] >> 4) + 32);
            char value3 = (char)(((bytes[1] & 15) << 2) + (bytes[2] >> 6) + 32);
            char value4 = (char)((bytes[2] & 63) + 32);

            line.append(value1);
            line.append(value2);
            line.append(value3);
            line.append(value4);
            
            if(line.length() == 60 && index != 0) {
                line.insert(0, (char)(32 + (45 - tooMany)));
                line.append(\"\\n\");
                result.append(line.toString());
                line = new StringBuilder();
            }
            ++index;
        }
        if(line.length() > 0) {
            line.insert(0, (char)(32 + ((index * 3 - tooMany) % 45)));
            line.append(\"\\n\");
            result.append(line);
        }

        return result.toString().replaceAll(\" \", \"`\");
    }
    public static final String pack_w(String[] s, int size) {
        java.math.BigInteger max_byte = new java.math.BigInteger(\"128\");
        StringBuilder result = new StringBuilder();
        for(int i = 0; i < size; ++i) {
            java.math.BigInteger current = new java.math.BigInteger(s[i]);
            if(current.signum() < 0) {
                throw new PlDieException(new PlString(\"Cannot compress negative numbers in pack\"));
            }
            while(current.compareTo(max_byte) > 0) {
                int part = current.mod(max_byte).intValue();
                result.append((char) (part + 128));
                current = current.divide(max_byte);
            }
            result.append((char)current.intValue());
        }

        return result.toString();
    }
    public static final String pack_x(int size) {
        return new String(new char[size]);
    }
    public static final PlObject time(int want, PlArray List__) {
        return new PlInt( (long)Math.floor(System.currentTimeMillis() * 0.001 + 0.5));
    }
    public static final PlObject sleep(int want, PlArray List__) {
        long s = ((Double)(List__.shift().to_double() * 1000)).longValue();
        try {
            TimeUnit.MILLISECONDS.sleep(s);
        } catch (InterruptedException e) {
            //Handle exception
            PlCORE.die(\"interrupted\");
        }
        return new PlDouble(s / 1000.0);
    }
    public static final PlObject system(int want, PlArray List__) {
        // TODO - see perldoc -f system
        try {
            Process p;
            if (List__.to_int() > 1) {
                String[] args = new String[List__.to_int()];
                int i = 0;
                for (PlObject s : List__.a) {
                    args[i++] = s.toString();
                }
                p = Runtime.getRuntime().exec(args);
            }
            else {
                p = Runtime.getRuntime().exec(List__.aget(0).toString());
            }
            // String s = null;
            // BufferedReader stdInput = new BufferedReader(new InputStreamReader(p.getInputStream()));
            // BufferedReader stdError = new BufferedReader(new InputStreamReader(p.getErrorStream()));
            // System.out.println(\"STDOUT\\n\");
            // while ((s = stdInput.readLine()) != null) {
            //     System.out.println(\"  \" + s);
            // }
            // System.out.println(\"STDERR\\n\");
            // while ((s = stdError.readLine()) != null) {
            //     System.out.println(\"  \" + s);
            // }
            int ret = p.waitFor() * 256;
            PlV.sset(\"main::?\", new PlInt(ret));
            return new PlInt(ret);
        } catch (InterruptedException e) {
            //Handle exception
            return PlCORE.die(\"interrupted\");
        }
        catch (IOException e) {
            // System.out.println(\"IOexception: \");
            // e.printStackTrace();
            PlV.sset(\"main::!\", new PlString(e.getMessage()));
            return PlCx.MIN1;
        }
    }
    public static final PlObject qx(int want, PlArray List__) {
        // TODO - see perldoc -f qx
        try {
            String[] args = new String[List__.to_int()];
            int i = 0;
            for (PlObject s : List__.a) {
                args[i++] = s.toString();
            }
            PlArray res = new PlArray();
            String s = null;
            Process p = Runtime.getRuntime().exec(args);
            // ??? set PlCx.UTF8
            BufferedReader stdInput = new BufferedReader(new InputStreamReader(p.getInputStream()));
            // System.out.println(\"STDOUT\\n\");
            while ((s = stdInput.readLine()) != null) {
                // System.out.println(\"  \" + s);
                res.push(s + \"\\n\");
            }
            // BufferedReader stdError = new BufferedReader(new InputStreamReader(p.getErrorStream()));
            // System.out.println(\"STDERR\\n\");
            // while ((s = stdError.readLine()) != null) {
            //     System.out.println(\"  \" + s);
            // }
            if (want == PlCx.LIST) {
                return res;
            }
            res.unshift(PlCx.EMPTY);
            return join(want, res);
        }
        catch (IOException e) {
            // System.out.println(\"IOexception: \");
            // e.printStackTrace();
            return PlCx.UNDEF;
        }
    }
}

"
    }
    1
}
{
    package main;
    package Perlito5::Java::Crypt;
    sub Perlito5::Java::Crypt::emit_java {;
        return "
/****************************************************************************
 * Java-based implementation of the unix crypt(3) command
 *
 * Based upon C source code written by Eric Young, eay\@psych.uq.oz.au
 * Java conversion by John F. Dumas, jdumas\@zgs.com
 *
 * Found at http://locutus.kingwoodcable.com/jfd/crypt.html
 * Found at http://cseweb.ucsd.edu/classes/sp12/cse130-a/static/pa5/Crypt.java
 * Minor optimizations by Wes Biggs, wes\@cacas.org
 *
 * Eric's original code is licensed under the BSD license.  As this is
 * derivative, the same license applies.
 *
 * Note: Crypt.class is much smaller when compiled with javac -O
 ****************************************************************************/

class PlCrypt {
  private PlCrypt() {} // defined so class can't be instantiated.

  private static final int ITERATIONS = 16;

  private static final boolean shifts2[] = {
    false, false, true, true, true, true, true, true,
    false, true,  true, true, true, true, true, false
  };

  private static final int skb[][] = {
    {
      /* for C bits (numbered as per FIPS 46) 1 2 3 4 5 6 */
      0x00000000, 0x00000010, 0x20000000, 0x20000010, 
      0x00010000, 0x00010010, 0x20010000, 0x20010010, 
      0x00000800, 0x00000810, 0x20000800, 0x20000810, 
      0x00010800, 0x00010810, 0x20010800, 0x20010810, 
      0x00000020, 0x00000030, 0x20000020, 0x20000030, 
      0x00010020, 0x00010030, 0x20010020, 0x20010030, 
      0x00000820, 0x00000830, 0x20000820, 0x20000830, 
      0x00010820, 0x00010830, 0x20010820, 0x20010830, 
      0x00080000, 0x00080010, 0x20080000, 0x20080010, 
      0x00090000, 0x00090010, 0x20090000, 0x20090010, 
      0x00080800, 0x00080810, 0x20080800, 0x20080810, 
      0x00090800, 0x00090810, 0x20090800, 0x20090810, 
      0x00080020, 0x00080030, 0x20080020, 0x20080030, 
      0x00090020, 0x00090030, 0x20090020, 0x20090030, 
      0x00080820, 0x00080830, 0x20080820, 0x20080830, 
      0x00090820, 0x00090830, 0x20090820, 0x20090830, 
    },
    {
      /* for C bits (numbered as per FIPS 46) 7 8 10 11 12 13 */
      0x00000000, 0x02000000, 0x00002000, 0x02002000, 
      0x00200000, 0x02200000, 0x00202000, 0x02202000, 
      0x00000004, 0x02000004, 0x00002004, 0x02002004, 
      0x00200004, 0x02200004, 0x00202004, 0x02202004, 
      0x00000400, 0x02000400, 0x00002400, 0x02002400, 
      0x00200400, 0x02200400, 0x00202400, 0x02202400, 
      0x00000404, 0x02000404, 0x00002404, 0x02002404, 
      0x00200404, 0x02200404, 0x00202404, 0x02202404, 
      0x10000000, 0x12000000, 0x10002000, 0x12002000, 
      0x10200000, 0x12200000, 0x10202000, 0x12202000, 
      0x10000004, 0x12000004, 0x10002004, 0x12002004, 
      0x10200004, 0x12200004, 0x10202004, 0x12202004, 
      0x10000400, 0x12000400, 0x10002400, 0x12002400, 
      0x10200400, 0x12200400, 0x10202400, 0x12202400, 
      0x10000404, 0x12000404, 0x10002404, 0x12002404, 
      0x10200404, 0x12200404, 0x10202404, 0x12202404, 
    },
    {
      /* for C bits (numbered as per FIPS 46) 14 15 16 17 19 20 */
      0x00000000, 0x00000001, 0x00040000, 0x00040001, 
      0x01000000, 0x01000001, 0x01040000, 0x01040001, 
      0x00000002, 0x00000003, 0x00040002, 0x00040003, 
      0x01000002, 0x01000003, 0x01040002, 0x01040003, 
      0x00000200, 0x00000201, 0x00040200, 0x00040201, 
      0x01000200, 0x01000201, 0x01040200, 0x01040201, 
      0x00000202, 0x00000203, 0x00040202, 0x00040203, 
      0x01000202, 0x01000203, 0x01040202, 0x01040203, 
      0x08000000, 0x08000001, 0x08040000, 0x08040001, 
      0x09000000, 0x09000001, 0x09040000, 0x09040001, 
      0x08000002, 0x08000003, 0x08040002, 0x08040003, 
      0x09000002, 0x09000003, 0x09040002, 0x09040003, 
      0x08000200, 0x08000201, 0x08040200, 0x08040201, 
      0x09000200, 0x09000201, 0x09040200, 0x09040201, 
      0x08000202, 0x08000203, 0x08040202, 0x08040203, 
      0x09000202, 0x09000203, 0x09040202, 0x09040203, 
    },
    {
      /* for C bits (numbered as per FIPS 46) 21 23 24 26 27 28 */
      0x00000000, 0x00100000, 0x00000100, 0x00100100, 
      0x00000008, 0x00100008, 0x00000108, 0x00100108, 
      0x00001000, 0x00101000, 0x00001100, 0x00101100, 
      0x00001008, 0x00101008, 0x00001108, 0x00101108, 
      0x04000000, 0x04100000, 0x04000100, 0x04100100, 
      0x04000008, 0x04100008, 0x04000108, 0x04100108, 
      0x04001000, 0x04101000, 0x04001100, 0x04101100, 
      0x04001008, 0x04101008, 0x04001108, 0x04101108, 
      0x00020000, 0x00120000, 0x00020100, 0x00120100, 
      0x00020008, 0x00120008, 0x00020108, 0x00120108, 
      0x00021000, 0x00121000, 0x00021100, 0x00121100, 
      0x00021008, 0x00121008, 0x00021108, 0x00121108, 
      0x04020000, 0x04120000, 0x04020100, 0x04120100, 
      0x04020008, 0x04120008, 0x04020108, 0x04120108, 
      0x04021000, 0x04121000, 0x04021100, 0x04121100, 
      0x04021008, 0x04121008, 0x04021108, 0x04121108, 
    },
    {
      /* for D bits (numbered as per FIPS 46) 1 2 3 4 5 6 */
      0x00000000, 0x10000000, 0x00010000, 0x10010000, 
      0x00000004, 0x10000004, 0x00010004, 0x10010004, 
      0x20000000, 0x30000000, 0x20010000, 0x30010000, 
      0x20000004, 0x30000004, 0x20010004, 0x30010004, 
      0x00100000, 0x10100000, 0x00110000, 0x10110000, 
      0x00100004, 0x10100004, 0x00110004, 0x10110004, 
      0x20100000, 0x30100000, 0x20110000, 0x30110000, 
      0x20100004, 0x30100004, 0x20110004, 0x30110004, 
      0x00001000, 0x10001000, 0x00011000, 0x10011000, 
      0x00001004, 0x10001004, 0x00011004, 0x10011004, 
      0x20001000, 0x30001000, 0x20011000, 0x30011000, 
      0x20001004, 0x30001004, 0x20011004, 0x30011004, 
      0x00101000, 0x10101000, 0x00111000, 0x10111000, 
      0x00101004, 0x10101004, 0x00111004, 0x10111004, 
      0x20101000, 0x30101000, 0x20111000, 0x30111000, 
      0x20101004, 0x30101004, 0x20111004, 0x30111004, 
    },
    {
      /* for D bits (numbered as per FIPS 46) 8 9 11 12 13 14 */
      0x00000000, 0x08000000, 0x00000008, 0x08000008, 
      0x00000400, 0x08000400, 0x00000408, 0x08000408, 
      0x00020000, 0x08020000, 0x00020008, 0x08020008, 
      0x00020400, 0x08020400, 0x00020408, 0x08020408, 
      0x00000001, 0x08000001, 0x00000009, 0x08000009, 
      0x00000401, 0x08000401, 0x00000409, 0x08000409, 
      0x00020001, 0x08020001, 0x00020009, 0x08020009, 
      0x00020401, 0x08020401, 0x00020409, 0x08020409, 
      0x02000000, 0x0A000000, 0x02000008, 0x0A000008, 
      0x02000400, 0x0A000400, 0x02000408, 0x0A000408, 
      0x02020000, 0x0A020000, 0x02020008, 0x0A020008, 
      0x02020400, 0x0A020400, 0x02020408, 0x0A020408, 
      0x02000001, 0x0A000001, 0x02000009, 0x0A000009, 
      0x02000401, 0x0A000401, 0x02000409, 0x0A000409, 
      0x02020001, 0x0A020001, 0x02020009, 0x0A020009, 
      0x02020401, 0x0A020401, 0x02020409, 0x0A020409, 
    },
    {
      /* for D bits (numbered as per FIPS 46) 16 17 18 19 20 21 */
      0x00000000, 0x00000100, 0x00080000, 0x00080100, 
      0x01000000, 0x01000100, 0x01080000, 0x01080100, 
      0x00000010, 0x00000110, 0x00080010, 0x00080110, 
      0x01000010, 0x01000110, 0x01080010, 0x01080110, 
      0x00200000, 0x00200100, 0x00280000, 0x00280100, 
      0x01200000, 0x01200100, 0x01280000, 0x01280100, 
      0x00200010, 0x00200110, 0x00280010, 0x00280110, 
      0x01200010, 0x01200110, 0x01280010, 0x01280110, 
      0x00000200, 0x00000300, 0x00080200, 0x00080300, 
      0x01000200, 0x01000300, 0x01080200, 0x01080300, 
      0x00000210, 0x00000310, 0x00080210, 0x00080310, 
      0x01000210, 0x01000310, 0x01080210, 0x01080310, 
      0x00200200, 0x00200300, 0x00280200, 0x00280300, 
      0x01200200, 0x01200300, 0x01280200, 0x01280300, 
      0x00200210, 0x00200310, 0x00280210, 0x00280310, 
      0x01200210, 0x01200310, 0x01280210, 0x01280310, 
    },
    {
      /* for D bits (numbered as per FIPS 46) 22 23 24 25 27 28 */
      0x00000000, 0x04000000, 0x00040000, 0x04040000, 
      0x00000002, 0x04000002, 0x00040002, 0x04040002, 
      0x00002000, 0x04002000, 0x00042000, 0x04042000, 
      0x00002002, 0x04002002, 0x00042002, 0x04042002, 
      0x00000020, 0x04000020, 0x00040020, 0x04040020, 
      0x00000022, 0x04000022, 0x00040022, 0x04040022, 
      0x00002020, 0x04002020, 0x00042020, 0x04042020, 
      0x00002022, 0x04002022, 0x00042022, 0x04042022, 
      0x00000800, 0x04000800, 0x00040800, 0x04040800, 
      0x00000802, 0x04000802, 0x00040802, 0x04040802, 
      0x00002800, 0x04002800, 0x00042800, 0x04042800, 
      0x00002802, 0x04002802, 0x00042802, 0x04042802, 
      0x00000820, 0x04000820, 0x00040820, 0x04040820, 
      0x00000822, 0x04000822, 0x00040822, 0x04040822, 
      0x00002820, 0x04002820, 0x00042820, 0x04042820, 
      0x00002822, 0x04002822, 0x00042822, 0x04042822, 
    }
  };
  
  private static final int SPtrans[][] = {
    {
      /* nibble 0 */
      0x00820200, 0x00020000, 0x80800000, 0x80820200,
      0x00800000, 0x80020200, 0x80020000, 0x80800000,
      0x80020200, 0x00820200, 0x00820000, 0x80000200,
      0x80800200, 0x00800000, 0x00000000, 0x80020000,
      0x00020000, 0x80000000, 0x00800200, 0x00020200,
      0x80820200, 0x00820000, 0x80000200, 0x00800200,
      0x80000000, 0x00000200, 0x00020200, 0x80820000,
      0x00000200, 0x80800200, 0x80820000, 0x00000000,
      0x00000000, 0x80820200, 0x00800200, 0x80020000,
      0x00820200, 0x00020000, 0x80000200, 0x00800200,
      0x80820000, 0x00000200, 0x00020200, 0x80800000,
      0x80020200, 0x80000000, 0x80800000, 0x00820000,
      0x80820200, 0x00020200, 0x00820000, 0x80800200,
      0x00800000, 0x80000200, 0x80020000, 0x00000000,
      0x00020000, 0x00800000, 0x80800200, 0x00820200,
      0x80000000, 0x80820000, 0x00000200, 0x80020200,
    },
    {
      /* nibble 1 */
      0x10042004, 0x00000000, 0x00042000, 0x10040000,
      0x10000004, 0x00002004, 0x10002000, 0x00042000,
      0x00002000, 0x10040004, 0x00000004, 0x10002000,
      0x00040004, 0x10042000, 0x10040000, 0x00000004,
      0x00040000, 0x10002004, 0x10040004, 0x00002000,
      0x00042004, 0x10000000, 0x00000000, 0x00040004,
      0x10002004, 0x00042004, 0x10042000, 0x10000004,
      0x10000000, 0x00040000, 0x00002004, 0x10042004,
      0x00040004, 0x10042000, 0x10002000, 0x00042004,
      0x10042004, 0x00040004, 0x10000004, 0x00000000,
      0x10000000, 0x00002004, 0x00040000, 0x10040004,
      0x00002000, 0x10000000, 0x00042004, 0x10002004,
      0x10042000, 0x00002000, 0x00000000, 0x10000004,
      0x00000004, 0x10042004, 0x00042000, 0x10040000,
      0x10040004, 0x00040000, 0x00002004, 0x10002000,
      0x10002004, 0x00000004, 0x10040000, 0x00042000,
    },
    {
      /* nibble 2 */
      0x41000000, 0x01010040, 0x00000040, 0x41000040,
      0x40010000, 0x01000000, 0x41000040, 0x00010040,
      0x01000040, 0x00010000, 0x01010000, 0x40000000,
      0x41010040, 0x40000040, 0x40000000, 0x41010000,
      0x00000000, 0x40010000, 0x01010040, 0x00000040,
      0x40000040, 0x41010040, 0x00010000, 0x41000000,
      0x41010000, 0x01000040, 0x40010040, 0x01010000,
      0x00010040, 0x00000000, 0x01000000, 0x40010040,
      0x01010040, 0x00000040, 0x40000000, 0x00010000,
      0x40000040, 0x40010000, 0x01010000, 0x41000040,
      0x00000000, 0x01010040, 0x00010040, 0x41010000,
      0x40010000, 0x01000000, 0x41010040, 0x40000000,
      0x40010040, 0x41000000, 0x01000000, 0x41010040,
      0x00010000, 0x01000040, 0x41000040, 0x00010040,
      0x01000040, 0x00000000, 0x41010000, 0x40000040,
      0x41000000, 0x40010040, 0x00000040, 0x01010000,
    },
    {
      /* nibble 3 */
      0x00100402, 0x04000400, 0x00000002, 0x04100402,
      0x00000000, 0x04100000, 0x04000402, 0x00100002,
      0x04100400, 0x04000002, 0x04000000, 0x00000402,
      0x04000002, 0x00100402, 0x00100000, 0x04000000,
      0x04100002, 0x00100400, 0x00000400, 0x00000002,
      0x00100400, 0x04000402, 0x04100000, 0x00000400,
      0x00000402, 0x00000000, 0x00100002, 0x04100400,
      0x04000400, 0x04100002, 0x04100402, 0x00100000,
      0x04100002, 0x00000402, 0x00100000, 0x04000002,
      0x00100400, 0x04000400, 0x00000002, 0x04100000,
      0x04000402, 0x00000000, 0x00000400, 0x00100002,
      0x00000000, 0x04100002, 0x04100400, 0x00000400,
      0x04000000, 0x04100402, 0x00100402, 0x00100000,
      0x04100402, 0x00000002, 0x04000400, 0x00100402,
      0x00100002, 0x00100400, 0x04100000, 0x04000402,
      0x00000402, 0x04000000, 0x04000002, 0x04100400,
    },
    {
      /* nibble 4 */
      0x02000000, 0x00004000, 0x00000100, 0x02004108,
      0x02004008, 0x02000100, 0x00004108, 0x02004000,
      0x00004000, 0x00000008, 0x02000008, 0x00004100,
      0x02000108, 0x02004008, 0x02004100, 0x00000000,
      0x00004100, 0x02000000, 0x00004008, 0x00000108,
      0x02000100, 0x00004108, 0x00000000, 0x02000008,
      0x00000008, 0x02000108, 0x02004108, 0x00004008,
      0x02004000, 0x00000100, 0x00000108, 0x02004100,
      0x02004100, 0x02000108, 0x00004008, 0x02004000,
      0x00004000, 0x00000008, 0x02000008, 0x02000100,
      0x02000000, 0x00004100, 0x02004108, 0x00000000,
      0x00004108, 0x02000000, 0x00000100, 0x00004008,
      0x02000108, 0x00000100, 0x00000000, 0x02004108,
      0x02004008, 0x02004100, 0x00000108, 0x00004000,
      0x00004100, 0x02004008, 0x02000100, 0x00000108,
      0x00000008, 0x00004108, 0x02004000, 0x02000008,
    },
    {
      /* nibble 5 */
      0x20000010, 0x00080010, 0x00000000, 0x20080800,
      0x00080010, 0x00000800, 0x20000810, 0x00080000,
      0x00000810, 0x20080810, 0x00080800, 0x20000000,
      0x20000800, 0x20000010, 0x20080000, 0x00080810,
      0x00080000, 0x20000810, 0x20080010, 0x00000000,
      0x00000800, 0x00000010, 0x20080800, 0x20080010,
      0x20080810, 0x20080000, 0x20000000, 0x00000810,
      0x00000010, 0x00080800, 0x00080810, 0x20000800,
      0x00000810, 0x20000000, 0x20000800, 0x00080810,
      0x20080800, 0x00080010, 0x00000000, 0x20000800,
      0x20000000, 0x00000800, 0x20080010, 0x00080000,
      0x00080010, 0x20080810, 0x00080800, 0x00000010,
      0x20080810, 0x00080800, 0x00080000, 0x20000810,
      0x20000010, 0x20080000, 0x00080810, 0x00000000,
      0x00000800, 0x20000010, 0x20000810, 0x20080800,
      0x20080000, 0x00000810, 0x00000010, 0x20080010,
    },
    {
      /* nibble 6 */
      0x00001000, 0x00000080, 0x00400080, 0x00400001,
      0x00401081, 0x00001001, 0x00001080, 0x00000000,
      0x00400000, 0x00400081, 0x00000081, 0x00401000,
      0x00000001, 0x00401080, 0x00401000, 0x00000081,
      0x00400081, 0x00001000, 0x00001001, 0x00401081,
      0x00000000, 0x00400080, 0x00400001, 0x00001080,
      0x00401001, 0x00001081, 0x00401080, 0x00000001,
      0x00001081, 0x00401001, 0x00000080, 0x00400000,
      0x00001081, 0x00401000, 0x00401001, 0x00000081,
      0x00001000, 0x00000080, 0x00400000, 0x00401001,
      0x00400081, 0x00001081, 0x00001080, 0x00000000,
      0x00000080, 0x00400001, 0x00000001, 0x00400080,
      0x00000000, 0x00400081, 0x00400080, 0x00001080,
      0x00000081, 0x00001000, 0x00401081, 0x00400000,
      0x00401080, 0x00000001, 0x00001001, 0x00401081,
      0x00400001, 0x00401080, 0x00401000, 0x00001001,
    },
    {
      /* nibble 7 */
      0x08200020, 0x08208000, 0x00008020, 0x00000000,
      0x08008000, 0x00200020, 0x08200000, 0x08208020,
      0x00000020, 0x08000000, 0x00208000, 0x00008020,
      0x00208020, 0x08008020, 0x08000020, 0x08200000,
      0x00008000, 0x00208020, 0x00200020, 0x08008000,
      0x08208020, 0x08000020, 0x00000000, 0x00208000,
      0x08000000, 0x00200000, 0x08008020, 0x08200020,
      0x00200000, 0x00008000, 0x08208000, 0x00000020,
      0x00200000, 0x00008000, 0x08000020, 0x08208020,
      0x00008020, 0x08000000, 0x00000000, 0x00208000,
      0x08200020, 0x08008020, 0x08008000, 0x00200020,
      0x08208000, 0x00000020, 0x00200020, 0x08008000,
      0x08208020, 0x00200000, 0x08200000, 0x08000020,
      0x00208000, 0x00008020, 0x08008020, 0x08200000,
      0x00000020, 0x08208000, 0x00208020, 0x00000000,
      0x08000000, 0x08200020, 0x00008000, 0x00208020
    }
  };
  
  private static final int byteToUnsigned(byte b) {
    int value = (int) b;
    return (value >= 0) ? value : value + 256;
  }

  private static int fourBytesToInt(byte b[], int offset) {
    return byteToUnsigned(b[offset++]) 
      | (byteToUnsigned(b[offset++]) <<  8) 
      | (byteToUnsigned(b[offset++]) << 16) 
      | (byteToUnsigned(b[offset]) << 24);
  }

  private static final void intToFourBytes(int iValue, byte b[], int offset) {
    b[offset++] = (byte)((iValue)        & 0xff);
    b[offset++] = (byte)((iValue >>> 8 ) & 0xff);
    b[offset++] = (byte)((iValue >>> 16) & 0xff);
    b[offset] = (byte)((iValue >>> 24) & 0xff);
  }
  
  private static final void PERM_OP(int a, int b, int n, int m, int results[]) {
    int t;

    t = ((a >>> n) ^ b) & m;
    a ^= t << n;
    b ^= t;

    results[0] = a;
    results[1] = b;
  }

  private static final int HPERM_OP(int a, int n, int m) {
    int t;
    
    t = ((a << (16 - n)) ^ a) & m;
    a = a ^ t ^ (t >>> (16 - n));
    
    return a;
  }

  private static int [] des_set_key(byte key[]) {
    int schedule[] = new int [ITERATIONS * 2];
    
    int c = fourBytesToInt(key, 0);
    int d = fourBytesToInt(key, 4);
    
    int results[] = new int[2];

    PERM_OP(d, c, 4, 0x0f0f0f0f, results);
    d = results[0]; c = results[1];
    
    c = HPERM_OP(c, -2, 0xcccc0000);
    d = HPERM_OP(d, -2, 0xcccc0000);
    
    PERM_OP(d, c, 1, 0x55555555, results);
    d = results[0]; c = results[1];
    
    PERM_OP(c, d, 8, 0x00ff00ff, results);
    c = results[0]; d = results[1];
    
    PERM_OP(d, c, 1, 0x55555555, results);
    d = results[0]; c = results[1];
    
    d = (((d & 0x000000ff) <<  16) |  (d & 0x0000ff00)     |
     ((d & 0x00ff0000) >>> 16) | ((c & 0xf0000000) >>> 4));
    c &= 0x0fffffff;
    
    int s, t;
    int j = 0;
    
    for(int i = 0; i < ITERATIONS; i ++) {
      if(shifts2[i]) {
    c = (c >>> 2) | (c << 26);
    d = (d >>> 2) | (d << 26);
      } else {
    c = (c >>> 1) | (c << 27);
    d = (d >>> 1) | (d << 27);
      }
      
      c &= 0x0fffffff;
      d &= 0x0fffffff;
      
      s = skb[0][ (c       ) & 0x3f                       ]|
    skb[1][((c >>>  6) & 0x03) | ((c >>>  7) & 0x3c)]|
    skb[2][((c >>> 13) & 0x0f) | ((c >>> 14) & 0x30)]|
    skb[3][((c >>> 20) & 0x01) | ((c >>> 21) & 0x06) |
                   ((c >>> 22) & 0x38)];

      t = skb[4][ (d     )  & 0x3f                       ]|
    skb[5][((d >>> 7) & 0x03) | ((d >>>  8) & 0x3c)]|
    skb[6][ (d >>>15) & 0x3f                       ]|
    skb[7][((d >>>21) & 0x0f) | ((d >>> 22) & 0x30)];
      
      schedule[j++] = ((t <<  16) | (s & 0x0000ffff)) & 0xffffffff;
      s             = ((s >>> 16) | (t & 0xffff0000));
      
      s             = (s << 4) | (s >>> 28);
      schedule[j++] = s & 0xffffffff;
    }
    return schedule;
  }

  private static final int D_ENCRYPT(int L, int R, int S, int E0, int E1, int s[]) {
    int t, u, v;
    
    v = R ^ (R >>> 16);
    u = v & E0;
    v = v & E1;
    u = (u ^ (u << 16)) ^ R ^ s[S];
    t = (v ^ (v << 16)) ^ R ^ s[S + 1];
    t = (t >>> 4) | (t << 28);
    
    L ^= SPtrans[1][(t       ) & 0x3f] |
      SPtrans[3][(t >>>  8) & 0x3f] |
      SPtrans[5][(t >>> 16) & 0x3f] |
      SPtrans[7][(t >>> 24) & 0x3f] |
      SPtrans[0][(u       ) & 0x3f] |
      SPtrans[2][(u >>>  8) & 0x3f] |
      SPtrans[4][(u >>> 16) & 0x3f] |
      SPtrans[6][(u >>> 24) & 0x3f];

    return L;
  }
  
  private static final int [] body(int schedule[], int Eswap0, int Eswap1) {
    int left = 0;
    int right = 0;
    int t     = 0;

    for (int j = 0; j < 25; j ++) {
      for (int i = 0; i < ITERATIONS * 2; i += 4) {
    left  = D_ENCRYPT(left,  right, i,     Eswap0, Eswap1, schedule);
    right = D_ENCRYPT(right, left,  i + 2, Eswap0, Eswap1, schedule);
      }
      t     = left; 
      left  = right; 
      right = t;
    }
    
    t = right;

    right = (left >>> 1) | (left << 31);
    left  = (t    >>> 1) | (t    << 31);
    
    left  &= 0xffffffff;
    right &= 0xffffffff;

    int results[] = new int[2];

    PERM_OP(right, left, 1, 0x55555555, results); 
    right = results[0]; left = results[1];
    
    PERM_OP(left, right, 8, 0x00ff00ff, results); 
    left = results[0]; right = results[1];

    PERM_OP(right, left, 2, 0x33333333, results); 
    right = results[0]; left = results[1];
    
    PERM_OP(left, right, 16, 0x0000ffff, results);
    left = results[0]; right = results[1];
    
    PERM_OP(right, left, 4, 0x0f0f0f0f, results);
    right = results[0]; left = results[1];
    
    int out[] = new int[2];
    
    out[0] = left; 
    out[1] = right;
    
    return out;
  }

  public static final String alphabet = \"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";

  public static final String crypt(String salt, String original) {
    // wwb -- Should do some sanity checks: salt needs to be 2 chars, in alpha.
    while(salt.length() < 2)
      salt += \"A\";

    char[] buffer = new char [13];

    char charZero = salt.charAt(0);
    char charOne  = salt.charAt(1);
    
    buffer[0] = charZero;
    buffer[1] = charOne;

    int Eswap0 = alphabet.indexOf(charZero);
    int Eswap1 = alphabet.indexOf(charOne) << 4;
    byte key[] = new byte[8];
    
    for(int i = 0; i < key.length; i ++)
      key[i] = (byte)0;
    
    for(int i = 0; i < key.length && i < original.length(); i ++)
      key[i] = (byte) (((int) original.charAt(i)) << 1);

    int schedule[] = des_set_key(key);
    int out[]      = body(schedule, Eswap0, Eswap1);
    
    byte b[] = new byte[9];
    
    intToFourBytes(out[0], b, 0);
    intToFourBytes(out[1], b, 4);
    b[8] = 0;

    for(int i = 2, y = 0, u = 0x80; i < 13; i ++) {
      for(int j = 0, c = 0; j < 6; j ++) {
        c <<= 1;

        if(((int)b[y] & u) != 0)
          c |= 1;

        u >>>= 1;
        
        if (u == 0) {
          y++;
          u = 0x80;
        }
        buffer[i] = alphabet.charAt(c);
      }
    }
    return new String(buffer);
  }
}
"
    }
    1
}
{
    package main;
    package Perlito5::Java::JavaCompiler;
    sub Perlito5::Java::JavaCompiler::emit_java_imports {;
        return "import java.io.ByteArrayOutputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.net.URI;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import javax.tools.FileObject;
import javax.tools.ForwardingJavaFileManager;
import javax.tools.JavaCompiler;
import javax.tools.JavaFileManager;
import javax.tools.JavaFileObject;
import javax.tools.SimpleJavaFileObject;
import javax.tools.ToolProvider;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import org.perlito.Perlito5.*;

"
    }
    sub Perlito5::Java::JavaCompiler::emit_java {;
        return "
/****************************************************************************/
// Credits for the PlJavaCompiler idea:
//
// http://udn.yyuap.com/doc/jdk6-api-zh/javax/tools/JavaCompiler.html         
//  * idea to reuse the same file manager to allow caching of jar files
// https://github.com/turpid-monkey/InMemoryJavaCompiler
// https://github.com/trung/InMemoryJavaCompiler
//  * provided a working example
//  * Apache License, Version 2.0 - http://www.apache.org/licenses/LICENSE-2.0.txt
// http://stackoverflow.com/questions/1563909/how-to-set-classpath-when-i-use-javax-tools-javacompiler-compile-the-source
//  * set classpath
/****************************************************************************/

class PlJavaCompiler {
    private PlJavaCompiler() {} // defined so class can't be instantiated.

    static ArrayList<SourceCode> compilationUnits;
    static ExtendedStandardJavaFileManager fileManager;
    static DynamicClassLoader classLoader;
    static JavaCompiler javac;
    static Boolean initDone;
    static int invocationCount = 0;

    public static void init() throws Exception
    {
        // System.out.println(\"initializing Perlito5.LibPerl\");
        // try {
        //     LibPerl.main( new String[]{} );
        // }
        // catch(Exception e) {
        //     System.out.println(\"Errors in main()\");
        // }

        javac = ToolProvider.getSystemJavaCompiler();
        classLoader = new DynamicClassLoader(ClassLoader.getSystemClassLoader());
        compilationUnits = new ArrayList<SourceCode>();
    }

    public static PlObject eval_java_string(PlArray List__)
    {

        String source    = List__.shift().toString();
        String constants = List__.shift().toString();

        if (source.equals(\"\")) {
            return PlCx.UNDEF;
        }

        try {
            if (initDone == null) {
                PlJavaCompiler.init();
                // System.out.println(\"eval_string: init\");
                initDone = true;
            }

            // TODO - test local(); initialize local() stack if needed
            String className = \"PlEval\" + invocationCount;
            invocationCount++;

            StringBuilder source5 = new StringBuilder();
            source5.append(\"import org.perlito.Perlito5.*;\\n\");
            source5.append(\"import java.util.regex.Pattern;\\n\");
            source5.append(\"public class \" + className + \" {\\n\");
            source5.append(constants);
            source5.append(\"    public \" + className + \"() {\\n\");
            source5.append(\"    }\\n\");
            source5.append(\"    public static PlObject runEval(int want, PlArray List__) {\\n\");
            source5.append(\"        try {\\n\");
            source5.append(\"        \" + source + \"\\n\");
            source5.append(\"        }\\n\");
            source5.append(\"        catch(PlReturnException e) {\\n\");
            source5.append(\"            return e.ret;\\n\");
            source5.append(\"        }\\n\");
            source5.append(\"        catch(PlNextException e) {\\n\");
            source5.append(\"            throw(e);\\n\");
            source5.append(\"        }\\n\");
            source5.append(\"        catch(PlLastException e) {\\n\");
            source5.append(\"            throw(e);\\n\");
            source5.append(\"        }\\n\");
            source5.append(\"        catch(PlRedoException e) {\\n\");
            source5.append(\"            throw(e);\\n\");
            source5.append(\"        }\\n\");
            source5.append(\"        catch(Exception e) {\\n\");
            // source5.append(\"            e.printStackTrace();\\n\");
            source5.append(\"            String message = e.getMessage();\\n\");
            source5.append(\"            PlV.sset(\\\"main::\@\\\", new PlString(\\\"\\\" + message));\\n\");
            source5.append(\"            return PerlOp.context(want);\\n\");
            source5.append(\"        }\\n\");
            source5.append(\"    }\\n\");
            source5.append(\"}\\n\");
            String cls5 = source5.toString();
            // System.out.println(\"\\neval_ast:\\n\" + cls5 + \"\\n\");

            // TODO - retrieve errors in Java->bytecode
            Class<?> class5 = compileClassInMemory(
                className,
                cls5
            );
            Method method5 = class5.getMethod(\"runEval\", new Class[]{int.class, PlArray.class});
            PlObject out = (org.perlito.Perlito5.PlObject)method5.invoke(null, PlCx.VOID, List__);
            // System.out.println(\"eval_string result: \" + out.toString());
            return out;
        }
        catch(PlReturnException e) {
            return e.ret;
        }
        catch(PlNextException e) {
            throw(e);
        }
        catch(PlLastException e) {
            throw(e);
        }
        catch(PlRedoException e) {
            throw(e);
        }
        catch(Exception e) {
            // e.printStackTrace();
            String message = e.getMessage();
            // System.out.println(\"Exception in eval_string: \" + message);
            PlV.sset(\"main::\@\", new PlString(\"\" + message));
        }
        return PlCx.UNDEF;
    }

    public static PlObject eval_perl_string(
        String      source, 
        String      namespace, 
        String      wantarray, 
        PlInt       scalar_hints,   // \$^H
        PlHashRef   hash_hints,     // \\%^H
        PlObject    scope,          // \"my\" declarations
        String[]    scalar_name,    // new String[]{\"x_100\"};   capture name
        PlLvalue[]  scalar_val,     // new PlLvalue[]{x_100};   capture value
        String[]    array_name,     // new String[]{\"xx_101\"};
        PlArray[]   array_val,      // new PlArray[]{xx_101};
        String[]    hash_name,      // new String[]{};
        PlHash[]    hash_val,       // new PlHash[]{}         
        int         want,
        PlArray     List__
    )
    {
        // System.out.println(\"eval_string: enter\");
        // (new Throwable()).printStackTrace();

        String outJava;
        String constants;
        PlObject tmp_scalar_hints = PlV.sget(\"main::\" + (char)8).get();   // save \$^H
        PlHash   tmp_hash_hints   = new PlHash(PlV.hash_get(\"main::\" + (char)8));  // save %^H
        try {

            PlV.sset(\"main::\" + (char)8, scalar_hints);                   // \$^H
            PlV.hash_set(\"main::\" + (char)8, hash_hints.hash_deref());    // %^H
            // Perlito5::Java::JavaCompiler::perl5_to_java(\$source, \$namespace, \$want, \$scope_java)
            PlObject code[] = org.perlito.Perlito5.LibPerl.apply(
                \"Perlito5::Java::Runtime::perl5_to_java\",
                new PlString(source),
                new PlString(namespace),
                new PlString(wantarray),
                scope
            );
            outJava = code[0].toString();
            constants = code[1].toString();
            // System.out.println(\"eval_string: from Perlito5::Java::JavaCompiler::perl5_to_java \\n[[[ \" + outJava + \" ]]\");
            // System.out.println(\"eval_string: constants \\n[[[ \" + constants + \" ]]\");
        }
        catch(Exception e) {
            // e.printStackTrace();
            String message = e.getMessage();
            // System.out.println(\"Exception in eval_string: \" + message);
            PlV.sset(\"main::\@\", new PlString(\"\" + message));
            PlV.sset(\"main::\" + (char)8, tmp_scalar_hints);     // restore \$^H
            PlV.hash_set(\"main::\" + (char)8, tmp_hash_hints);   // restore %^H
            return PlCx.UNDEF;
        }
        PlV.sset(\"main::\" + (char)8, tmp_scalar_hints);     // restore \$^H
        PlV.hash_set(\"main::\" + (char)8, tmp_hash_hints);   // restore %^H

        // return eval_java_string(outJava.toString());

        if (source.equals(\"\")) {
            return PlCx.UNDEF;
        }

        try {
            if (initDone == null) {
                PlJavaCompiler.init();
                // System.out.println(\"eval_string: init\");
                initDone = true;
            }

            // TODO - test local(); initialize local() stack if needed
            String className = \"PlEval\" + invocationCount;
            invocationCount++;

            StringBuilder source5 = new StringBuilder();
            source5.append(\"import org.perlito.Perlito5.*;\\n\");
            source5.append(\"import java.util.regex.Pattern;\\n\");
            source5.append(\"public class \" + className + \" {\\n\");

            source5.append(constants);

            source5.append(\"    public \" + className + \"() {\\n\");
            source5.append(\"    }\\n\");
            source5.append(\"    public static PlObject runEval(int want, Object scalar_val, Object array_val, Object hash_val, PlArray List__) {\\n\");
            for (int i = 0; i < scalar_name.length; i++) {
            source5.append(\"        PlLvalue \" + scalar_name[i] + \" = ((PlLvalue[])(scalar_val))[\" + i + \"];\\n\");
            }
            for (int i = 0; i < array_name.length; i++) {
            source5.append(\"        PlArray \" + array_name[i] + \" = ((PlArray[])(array_val))[\" + i + \"];\\n\");
            }
            for (int i = 0; i < hash_name.length; i++) {
            source5.append(\"        PlHash \" + hash_name[i] + \" = ((PlHash[])(hash_val))[\" + i + \"];\\n\");
            }
            source5.append(\"        try {\\n\");
            source5.append(\"            return \" + outJava + \";\\n\");
            source5.append(\"        }\\n\");
            source5.append(\"        catch(PlReturnException e) {\\n\");
            source5.append(\"            return e.ret;\\n\");
            source5.append(\"        }\\n\");
            source5.append(\"        catch(PlNextException e) {\\n\");
            source5.append(\"            throw(e);\\n\");
            source5.append(\"        }\\n\");
            source5.append(\"        catch(PlLastException e) {\\n\");
            source5.append(\"            throw(e);\\n\");
            source5.append(\"        }\\n\");
            source5.append(\"        catch(PlRedoException e) {\\n\");
            source5.append(\"            throw(e);\\n\");
            source5.append(\"        }\\n\");
            source5.append(\"        catch(Exception e) {\\n\");
            // source5.append(\"            e.printStackTrace();\\n\");
            source5.append(\"            String message = e.getMessage();\\n\");
            source5.append(\"            PlV.sset(\\\"main::\@\\\", new PlString(\\\"\\\" + message));\\n\");
            source5.append(\"            return PerlOp.context(want);\\n\");
            source5.append(\"        }\\n\");
            source5.append(\"    }\\n\");
            source5.append(\"}\\n\");
            String cls5 = source5.toString();
            // System.out.println(\"\\neval_perl_string:\\n\" + cls5 + \"\\n\");

            // TODO - retrieve errors in Java->bytecode
            Class<?> class5 = compileClassInMemory(
                className,
                cls5
            );
            Method method5 = class5.getMethod(\"runEval\", new Class[]{int.class, Object.class, Object.class, Object.class, PlArray.class});
            PlObject out = (org.perlito.Perlito5.PlObject)method5.invoke(null, want, scalar_val, array_val, hash_val, List__);
            // System.out.println(\"eval_string result: \" + out.toString());
            return out;
        }
        catch(PlReturnException e) {
            return e.ret;
        }
        catch(PlNextException e) {
            throw(e);
        }
        catch(PlLastException e) {
            throw(e);
        }
        catch(PlRedoException e) {
            throw(e);
        }
        catch(Exception e) {
            // e.printStackTrace();
            String message = e.getMessage();
            // System.out.println(\"Exception in eval_string: \" + message);
            PlV.sset(\"main::\@\", new PlString(\"\" + message));
        }
        return PlCx.UNDEF;
    }

    static Class<?> compileClassInMemory(String className, String classSourceCode) throws Exception
    {
        SourceCode sourceCodeObj = new SourceCode(className, classSourceCode);
        // System.out.println(\"PlJavaCompiler.compileClassInMemory: name=\" + className);
        classLoader.customCompiledCode.put(className, new CompiledCode(className));
        if (fileManager == null) {
            // initializing the file manager
            compilationUnits.add(sourceCodeObj);
            fileManager = new ExtendedStandardJavaFileManager(
                    javac.getStandardFileManager(null, null, null), classLoader);
        }
        else {
            // reusing the file manager; replace the source code
            compilationUnits.set(0, sourceCodeObj);
        }

        List<String> optionList = new ArrayList<String>();
        // set compiler's classpath to be same as the runtime's
        optionList.addAll(Arrays.asList(\"-classpath\", System.getProperty(\"java.class.path\")));
        optionList.addAll(Arrays.asList(\"-source\",    \"7\"));

        // run the compiler
        JavaCompiler.CompilationTask task = javac.getTask(null, fileManager,
                null, optionList, null, compilationUnits);
        boolean result = task.call();
        if (!result)
            throw new RuntimeException(\"Unknown error during compilation.\");
        return classLoader.loadClass(className);
    }

}

class ExtendedStandardJavaFileManager extends ForwardingJavaFileManager<JavaFileManager> {
    private DynamicClassLoader cl;

    protected ExtendedStandardJavaFileManager(JavaFileManager fileManager, DynamicClassLoader cl) {
        super(fileManager);
        this.cl = cl;
    }

    \@Override
    public JavaFileObject getJavaFileForOutput(JavaFileManager.Location location, String className, JavaFileObject.Kind kind, FileObject sibling) throws IOException {
        // System.out.println(\"ExtendedStandardJavaFileManager.getJavaFileForOutput: name=\" + className);
        CompiledCode cc = cl.customCompiledCode.get(className);
        if (cc != null) {
            return cc;
        }
        // source file not found for this output class: this is ok, because we can have a class like 'PlEval\$1'
        // System.out.println(\"ExtendedStandardJavaFileManager.getJavaFileForOutput: create name=\" + className);
        try {
            cc = new CompiledCode(className);
        }
        catch(Exception e) {
            throw new FileNotFoundException(\"Error creating output file for class \" + className );
        }
        cl.customCompiledCode.put(className, cc);
        return cc;
    }

    \@Override
    public ClassLoader getClassLoader(JavaFileManager.Location location) {
        return cl;
    }
}

class CompiledCode extends SimpleJavaFileObject {
    private ByteArrayOutputStream baos = new ByteArrayOutputStream();
    private String className;

    public CompiledCode(String className) throws Exception {
        super(new URI(className), Kind.CLASS);
        this.className = className;
    }
    
    public String getClassName() {
        // System.out.println(\"CompiledCode.getClassName: name=\" + className);
        return className;
    }

    \@Override
    public OutputStream openOutputStream() throws IOException {
        // System.out.println(\"CompiledCode.openOutputStream()\");
        return baos;
    }

    public byte[] getByteCode() {
        return baos.toByteArray();
    }
}

class DynamicClassLoader extends ClassLoader {
    public Map<String, CompiledCode> customCompiledCode = new HashMap<String, CompiledCode>();

    public DynamicClassLoader(ClassLoader parent) {
        super(parent);
    }

    public void addCode(CompiledCode cc) {
        // System.out.println(\"DynamicClassLoader.addCode: name=\" + cc.getName());
        customCompiledCode.put(cc.getName(), cc);
    }

    \@Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        // System.out.println(\"DynamicClassLoader.findClass: name=\" + name);
        CompiledCode cc = customCompiledCode.get(name);
        if (cc == null) {
            return super.findClass(name);
        }
        byte[] byteCode = cc.getByteCode();
        return defineClass(name, byteCode, 0, byteCode.length);
    }
}

class SourceCode extends SimpleJavaFileObject {
    private String contents = null;
    private String className;

    public SourceCode(String className, String contents) throws Exception {
        super(URI.create(\"string:///\" + className.replace('.', '/') + Kind.SOURCE.extension), Kind.SOURCE);
        this.contents = contents;
        this.className = className;
    }

    public String getClassName() {
        return className;
    }

    public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {
        return contents;
    }
}

"
    }
    1
}
{
    package main;
    package Perlito5::Java::Runtime;
    sub Perlito5::Java::Runtime::perl5_to_java {
        (my($source), my($namespace), my($want), my($scope_java)) = @_;
        local $_;
        local ${^GLOBAL_PHASE};
        local $Perlito5::BASE_SCOPE = $scope_java;
        local @Perlito5::SCOPE_STMT;
        local $Perlito5::CLOSURE_SCOPE = $Perlito5::BASE_SCOPE;
        local $Perlito5::SCOPE = $Perlito5::BASE_SCOPE;
        local $Perlito5::SCOPE_DEPTH = 0;
        local $Perlito5::PKG_NAME = $namespace;
        local @Perlito5::UNITCHECK_BLOCK;
        local @Perlito5::Java::Java_constants;
        ${"\@"} = '';
        my $match = Perlito5::Grammar::exp_stmts($source, 0);
        if (!$match || $match->{"to"} != length($source)) {;
            die("Syntax error in eval near pos ", $match->{"to"})
        }
        my $ast = Perlito5::AST::Apply::->new("code", "do", "arguments", [Perlito5::AST::Block::->new("stmts", $match->{"capture"})]);
        $ast = $ast->emit_begin_scratchpad();
        my $java_code = $ast->emit_java(0, $want);
        my $constants = '';
        for my $s (@Perlito5::Java::Java_constants) {;
            $constants .= "    " . $s . ";
"
        }
        Perlito5::set_global_phase("UNITCHECK");
        $_->()
            while $_ = shift(@Perlito5::UNITCHECK_BLOCK);
        return ($java_code, $constants)
    }
    sub Perlito5::Java::Runtime::eval_ast {
        (my($ast)) = @_;
        my $want = 0;
        my $java_code = $ast->emit_java(0, $want);
        Perlito5::set_global_phase("UNITCHECK");
        $_->()
            while $_ = shift(@Perlito5::UNITCHECK_BLOCK);
        my $constants = '';
        for my $s (@Perlito5::Java::Java_constants) {;
            $constants .= "    " . $s . ";
"
        }
        @_ = ($java_code, $constants);
        return Java::inline("PlJavaCompiler.eval_java_string(List__)")
    }
    sub Perlito5::Java::Runtime::emit_java_extends {
        (my($class), my($java_classes)) = @_;
        my @out;
        my $java_decl = $class->{"decl"} // [];
        if ($class->{"extends"}) {;
            push(@out, join(${"\""}, @{$java_decl}) . " class " . $class->{"java_type"} . " extends " . $class->{"extends_java_type"} . " {")
        }
        else {;
            push(@out, join(${"\""}, @{$java_decl}) . " class " . $class->{"java_type"} . " implements " . $class->{"implements_java_type"} . " {")
        }
        $class->{"Java::inline"} && push(@out, $class->{"Java::inline"});
        while (@{$class->{"variables"}}) {
            my $method = shift(@{$class->{"variables"}});
            my $data = shift(@{$class->{"variables"}})
        }
        while (@{$class->{"methods"}}) {
            my $method = shift(@{$class->{"methods"}});
            my $data = shift(@{$class->{"methods"}});
            my $decl = $data->{"decl"};
            my $code = $data->{"code"} or die("Java extends: missing 'code' argument in method '" . $method . "'");
            my $return = $data->{"return"} or die("Java extends: missing 'return' argument in method '" . $method . "'");
            my @args;
            my $var = 0;
            for my $arg (@{$data->{"args"}}) {
                my $type = $java_classes->{$arg};
                push(@args, $type->{"java_type"} . " param" . $var);
                $var++
            }
            my @java_decl = @{$decl};
            my $return_type = $return;
            if ($return ne "void") {
                my $type = $java_classes->{$return};
                $return_type = $type->{"java_type"}
            }
            my $throws = '';
            if ($data->{"throws"}) {;
                $throws = "throws " . join(${"\""}, @{$data->{"throws"}})
            }
            push(@out, "    " . join(${"\""}, @java_decl) . " " . $return_type . " " . $method . "(" . join(", ", @args) . ") " . $throws . " {");
            @args = ();
            if (grep {;
                $_ eq "static"
            } @{$decl}) {;
                push(@args, "new PlString(\"" . $class->{"perl_package"} . "\")")
            }
            else {;
                push(@args, "new " . $class->{"java_native_to_perl"} . "(this)")
            }
            $var = 0;
            for my $arg (@{$data->{"args"}}) {
                my $type = $java_classes->{$arg};
                push(@args, "new " . $type->{"java_native_to_perl"} . "(param" . $var . ")");
                $var++
            }
            push(@out, "        PlObject[] res = Main.apply(\"" . $code . "\", " . join(", ", @args) . ");");
            if ($return eq "void") {;
                push(@out, "        return;")
            }
            else {
                my $type = $java_classes->{$return} or die("Java class '" . $return . "' is not imported");
                push(@out, "        return res[0]." . $type->{"perl_to_java"} . "();")
            }
            push(@out, "    }")
        }
        push(@out, "}
");
        return join("
", @out)
    }
    sub Perlito5::Java::Runtime::emit_java {
        (my($self), my(%args)) = @_;
        if ($Perlito5::JAVA_EVAL) {;
            return ("
// use perlito5-lib.jar
import org.perlito.Perlito5.*;
import java.util.regex.Pattern;

")
        }
        my %java_classes = %{$args{"java_classes"} // {}};
        my @number_unary = ("op_int", "neg", "complement", "abs", "sqrt", "cos", "sin", "exp", "log");
        my @boolean_unary = ("is_int", "is_num", "is_string", "is_bool", "is_undef", "is_regex", "is_filehandle", "is_ref", "is_arrayref", "is_coderef", "is_hashref", "is_scalarref", "is_typeglobref");
        my %number_binop = ("add", {"op", "+", "returns", "PlInt", "num_returns", "PlDouble"}, "sub", {"op", "-", "returns", "PlInt", "num_returns", "PlDouble"}, "mul", {"op", "*", "returns", "PlInt", "num_returns", "PlDouble"}, "div", {"op", "/", "returns", "PlDouble", "num_returns", "PlDouble"}, "num_eq", {"op", "==", "returns", "PlBool", "num_returns", "PlBool"}, "num_ne", {"op", "!=", "returns", "PlBool", "num_returns", "PlBool"}, "num_lt", {"op", "<", "returns", "PlBool", "num_returns", "PlBool"}, "num_le", {"op", "<=", "returns", "PlBool", "num_returns", "PlBool"}, "num_gt", {"op", ">", "returns", "PlBool", "num_returns", "PlBool"}, "num_ge", {"op", ">=", "returns", "PlBool", "num_returns", "PlBool"}, "int_and", {"op", "&", "returns", "PlInt", "num_returns", "PlInt"}, "int_or", {"op", "|", "returns", "PlInt", "num_returns", "PlInt"}, "int_xor", {"op", "^", "returns", "PlInt", "num_returns", "PlInt"}, "int_shr", {"op", ">>>", "returns", "PlInt", "num_returns", "PlInt"}, "int_shl", {"op", "<<", "returns", "PlInt", "num_returns", "PlInt"});
        my %string_binop = ("str_eq", {"op", "==", "str_op", "eq", "returns", "PlBool"}, "str_ne", {"op", "!=", "str_op", "ne", "returns", "PlBool"}, "str_lt", {"op", "<", "str_op", "lt", "returns", "PlBool"}, "str_le", {"op", "<=", "str_op", "le", "returns", "PlBool"}, "str_gt", {"op", ">", "str_op", "gt", "returns", "PlBool"}, "str_ge", {"op", ">=", "str_op", "ge", "returns", "PlBool"});
        my %native_to_perl = ("long", "PlInt", "double", "PlDouble", "boolean", "PlBool", "String", "PlString");
        for $_ (values(%java_classes)) {;
            if ($_->{"import"} || $_->{"extends"} || $_->{"implements"}) {;
                $native_to_perl{$_->{"java_type"}} = $_->{"java_native_to_perl"}
            }
        }
        return ("// start Perl-Java runtime
// this is generated code - see: lib/Perlito5/Java/Runtime.pm

import java.lang.Math;
import java.lang.System;
import java.util.*;
import java.io.*;
import java.nio.file.*;
import java.nio.file.attribute.*;
import java.nio.charset.*;
import java.nio.ByteBuffer;
import static java.nio.file.attribute.PosixFilePermission.*;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.concurrent.TimeUnit;
", ($Perlito5::BOOTSTRAP_JAVA_EVAL ? Perlito5::Java::JavaCompiler::->emit_java_imports() : ()), ((map {
            my $class = $java_classes{$_};
            $class->{"import"} ? "import " . $class->{"import"} . ";
" : ()
        } sort {;
            $a cmp $b
        } keys(%java_classes))), ((map {
            my $class = $java_classes{$_};
            $class->{"extends"} || $class->{"implements"} ? emit_java_extends($class, \%java_classes) : ()
        } sort {;
            $a cmp $b
        } keys(%java_classes))), Perlito5::Java::CORE::->emit_java(), "class PlControlException extends RuntimeException {
}
class PlNextException    extends PlControlException {
    public int label_id;

    public PlNextException(int i) {
        this.label_id = i;
    }
}
class PlLastException    extends PlControlException {
    public int label_id;

    public PlLastException(int i) {
        this.label_id = i;
    }
}
class PlRedoException    extends PlControlException {
    public int label_id;

    public PlRedoException(int i) {
        this.label_id = i;
    }
}
class PlReturnException  extends PlControlException {
    public PlObject ret;

    public PlReturnException(PlObject ret) {
        this.ret = ret;
    }
}
class PlDieException  extends PlControlException {
    public PlObject ret;

    public PlDieException(PlObject ret) {
        this.ret = ret;
    }
    public String getMessage() {
        return this.ret.toString();
    }
}
class PlCx {
    public static final int     VOID   = 0;
    public static final int     SCALAR = 1;
    public static final int     LIST   = 2;
    public static final PlUndef  UNDEF  = new PlUndef();
    public static final PlBool   TRUE   = new PlBool(true);
    public static final PlBool   FALSE  = new PlBool(false);
    public static final PlFileHandle STDIN  = new PlFileHandle();
    public static final PlFileHandle STDOUT = new PlFileHandle();
    public static final PlFileHandle STDERR = new PlFileHandle();
    public static final Charset UTF8        = Charset.forName(\"UTF-8\");
    public static final PlString EMPTY  = new PlString(\"\");
    public static final PlNextException NEXT = new PlNextException(0);
    public static final PlLastException LAST = new PlLastException(0);
    public static final String OVERLOAD_STRING   = \"(\\\"\\\"\";  // (\"\"
    public static final String OVERLOAD_NUM      = \"(0+\";
    public static final String OVERLOAD_BOOL     = \"(bool\";
    public static final PlRegex SPLIT_SPACE      = new PlRegex(\"\\\\s+\", Pattern.MULTILINE, false);
", "    " . join("
    ", map {;
            "public static final PlInt " . ($_ < 0 ? "MIN" : "INT") . abs($_) . " = new PlInt(" . $_ . ");"
        } (-2 .. 2)) . "
", "    " . join("
    ", @{$args{"java_constants"} // []}) . "
", "}
", Perlito5::Java::Crypt::->emit_java(), ($Perlito5::BOOTSTRAP_JAVA_EVAL ? Perlito5::Java::JavaCompiler::->emit_java() : ()), "class PerlCompare implements Comparator<PlObject> {
    public PlClosure sorter;
    public PlLvalue v_a;
    public PlLvalue v_b;
    public PlArray  list__;
    public PerlCompare (PlClosure sorter, PlLvalue a, PlLvalue b, PlArray list__) {
        this.sorter = sorter;
        this.v_a = a;
        this.v_b = b;
        this.list__ = list__;
    }
    public int compare (PlObject a, PlObject b) {
        v_a.set(a);
        v_b.set(b);
        return this.sorter.apply( PlCx.SCALAR, list__ ).to_int();
    }
}
class PerlRangeString implements Iterator<PlObject> {
    public PlString v_start;
    public String   v_end;
    public PerlRangeString(PlString v_start, String v_end) {
        this.v_start = v_start;
        this.v_end = v_end;
    }
    public PlObject next() {
        PlString ret = v_start;
        PlObject incr = v_start._incr();
        if (incr.is_string()) {
            v_start = (PlString)incr;
        }
        else {
            v_start = new PlString(incr.toString());
        }
        return new PlLvalue(ret);
    }
    public boolean hasNext() {
        return (  (v_start.int_length() < v_end.length())
               || (v_start.int_length() == v_end.length() && v_start.boolean_str_le(v_end)) );
    }
}
class PerlRangeInt implements Iterator<PlObject> {
    public long     v_start;
    public long     v_end;
    public PerlRangeInt(long v_start, long v_end) {
        this.v_start = v_start;
        this.v_end = v_end;
    }
    public PlObject next() {
        PlInt ret = new PlInt(v_start);
        v_start++;
        return new PlLvalue(ret);
    }
    public boolean hasNext() {
        return v_start <= v_end;
    }
}
class PerlRangeString1 implements Iterator<PlObject> {
    public PlString v_start;
    public PerlRangeString1(PlString v_start) {
        this.v_start = v_start;
    }
    public PlObject next() {
        PlString ret = v_start;
        v_start = null;
        return new PlLvalue(ret);
    }
    public boolean hasNext() {
        return (v_start != null);
    }
}
class PerlRange0 implements Iterator<PlObject> {
    public PerlRange0() {
    }
    public PlObject next() {
        return new PlObject();
    }
    public boolean hasNext() {
        return false;
    }
}
class PerlRange implements Iterable<PlObject> {
    public PlObject v_start;
    public PlObject v_end;
    private static HashMap<String, Integer> flip_flop = new HashMap<String, Integer>();
    public PerlRange(PlObject v_start, PlObject v_end) {
        this.v_start = v_start;
        this.v_end = v_end;
    }
    public final Iterator<PlObject> iterator() {
        if (this.v_start.is_string() && this.v_end.is_string()) {
            String s = v_start.toString();
            final int length = s.length();
            if (length > 0) {
                boolean is_num_start = PerlOp.looks_like_number(s);
                boolean is_num_end = PerlOp.looks_like_number(this.v_end.toString());
                if (is_num_start && is_num_end && s.codePointAt(0) != '0') {
                    if (!this.v_start.is_integer_range() || !this.v_end.is_integer_range()) {
                        PlCORE.die(\"Range iterator outside integer range\");
                    }
                    return new PerlRangeInt(this.v_start.to_long(), this.v_end.to_long());
                }
                // If the initial value specified isn't part of a magical increment sequence
                // (that is, a non-empty string matching /^[a-zA-Z]*[0-9]*\\z/ ),
                // only the initial value will be returned.
                boolean is_incrementable = true;
                for (int offset = 0; offset < length; offset++) {
                    int c = s.codePointAt(offset);
                    if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {
                        // good
                    }
                    else {
                        for ( ; offset < length; offset++) {
                            c = s.codePointAt(offset);
                            if (c >= '0' && c <= '9') {
                                // good
                            }
                            else {
                                is_incrementable = false;
                                offset = length;  // exit loop
                            }
                        }
                    }
                }
                if (is_incrementable) {
                    return new PerlRangeString(new PlString(s), this.v_end.toString());
                }
            }
            if (length > this.v_end.toString().length()) {
                return new PerlRange0();
            }
            return new PerlRangeString1(new PlString(s));
        }

        if (!this.v_start.is_integer_range() || !this.v_end.is_integer_range()) {
            PlCORE.die(\"Range iterator outside integer range\");
        }
        return new PerlRangeInt(this.v_start.to_long(), this.v_end.to_long());
    }
    public final PlObject range(int want, String id, int three_dots) {
        if (want == PlCx.LIST) {
            PlArray ret = new PlArray();
            for (PlObject i : this) {
                ret.a.add(i);
            }
            return ret;
        }
        // http://perldoc.perl.org/perlop.html#Range-Operators
        Integer v = flip_flop.get(id);
        if (v != null && v != 0) {
            v++;
            if (v_end.to_boolean()) {
                flip_flop.put(id, 0);
                return new PlString(\"\" + v + \"E0\");
            }
            else {
                flip_flop.put(id, v);
                return new PlInt(v);
            }
        }
        else {
            if (v_start.to_boolean()) {
                v = 1;
            }
            else {
                v = 0;
            }
            if (v != 0 && three_dots == 0 && v_end.to_boolean()) {
                flip_flop.put(id, 0);
                return new PlString(\"\" + v + \"E0\");
            }
            else {
                flip_flop.put(id, v);
                if (v == 0) {
                    return PlCx.EMPTY;
                }
                return new PlInt(v);
            }
        }
    }
}
class PerlOp {
    // PerlOp implements operators: && ||
    //      and auxiliary functions
    //
    // note: '+' add() and '-' sub() are PlObject methods, not implemented here.
    //
    // TODO - see Perlito5/JavaScript2/Runtime.pm for more operator implementations
    // TODO - 'boolean_stack' should be reset when an exception happens

    private static PlArrayList boolean_stack = new PlArrayList();
    private static PlArray local_stack = new PlArray();
    private static Random random = new Random();

    // filehandles
    public static final PlFileHandle get_filehandle(PlObject fh, String nameSpace) {
        if (fh.is_lvalue()) {
            if (fh.is_undef()) {
                // \$fh autovivification to filehandle
                fh.set(new PlFileHandle());
            }
            fh = fh.get();
        }
        if (fh.is_filehandle()) {
            return (PlFileHandle)fh;
        }
        return get_filehandle(fh.toString(), nameSpace);    // get \"GLOB\" by name
    }
    public static final PlFileHandle get_filehandle(String s, String nameSpace) {
        if (s.indexOf(\"::\") == -1) {
            if (s.equals(\"STDOUT\")) {
                s = \"main::STDOUT\";
            }
            else if (s.equals(\"STDERR\")) {
                s = \"main::STDERR\";
            }
            else if (s.equals(\"STDIN\")) {
                s = \"main::STDIN\";
            }
            else if (s.equals(\"ARGV\")) {
                s = \"main::ARGV\";
            }
            else {
                s = nameSpace + \"::\" + s;
            }
        }
        PlObject fh = PlV.fget(s);    // get \"GLOB\" by name
        return (PlFileHandle)(fh.get());
    }
    public static final Set<PosixFilePermission> MaskToPermissions(int mask) {
        final Set<PosixFilePermission> perm = new HashSet<PosixFilePermission>();
        // TODO - provide a workaround
        // if ((mask & 04000)==0) PlCORE.die(\"setuid bit not implemented\");
        // if ((mask & 02000)==0) PlCORE.die(\"setgid bit not implemented\");
        // if ((mask & 01000)==0) PlCORE.die(\"sticky bit not implemented\");
        if ((mask & 00400)==0) perm.add(OWNER_READ);
        if ((mask & 00200)==0) perm.add(OWNER_WRITE);
        if ((mask & 00100)==0) perm.add(OWNER_EXECUTE);
        if ((mask & 00040)==0) perm.add(GROUP_READ);
        if ((mask & 00020)==0) perm.add(GROUP_WRITE);
        if ((mask & 00010)==0) perm.add(GROUP_EXECUTE);
        if ((mask & 00004)==0) perm.add(OTHERS_READ);
        if ((mask & 00002)==0) perm.add(OTHERS_WRITE);
        if ((mask & 00001)==0) perm.add(OTHERS_EXECUTE);
        return perm;
    }

    // objects
    // coderef methods can be called on ANY invocant
    //  \$m = sub {...};
    //  \$a->\$m
    public static final PlObject call( PlObject invocant, PlObject method, PlArray args, int context ) {
        if ( method.is_coderef() ) {
            args.unshift(invocant);
            return method.apply(context, args);
        }
        else if ( method.is_lvalue() ) {
            return call( invocant, method.get(), args, context );
        }
        else {
            return call( invocant, method.toString(), args, context );
        }
    }
    public static final PlObject call( String invocant, PlObject method, PlArray args, int context ) {
        if ( method.is_coderef() ) {
            args.unshift( new PlString(invocant) );
            return method.apply(context, args);
        }
        else if ( method.is_lvalue() ) {
            return call( invocant, method.get(), args, context );
        }
        else {
            return call( invocant, method.toString(), args, context );
        }
    }
    // Intermediate calls, which have to be dispatched properly
    public static final PlObject call( PlObject invocant, String method, PlArray args, int context ) {
        if ( invocant.is_undef() ) {
            PlCORE.die( \"Can't call method \\\"\" + method
                + \"\\\" on an undefined value\" );
            return PlCx.UNDEF;
        }

        if ( invocant.is_lvalue() ) {
            invocant = invocant.get();
        }

        PlClass pClass = invocant.blessed_class();

        if ( pClass == null ) {
            if (!invocant.is_ref()) {
                // invocant can be a package name
                return call( invocant.toString(), method, args, context );
            }

            if (invocant.is_filehandle()) {
                // \$fh->print() is allowed, even if \$fh is unblessed
                if (method.equals(\"print\")) {
                    return PlCORE.print(context, (PlFileHandle)invocant, args);
                }
            }

            PlCORE.die( \"Can't call method \\\"\" + method
                + \"\\\" on unblessed reference\" );
            return PlCx.UNDEF;
        }

        PlObject methodCode = pClass.method_lookup(method, 0);

        if (methodCode.is_undef()) {
            String className = pClass.className();
            PlCORE.die( \"Can't locate object method \\\"\" + method
                + \"\\\" via package \\\"\" + className
                + \"\\\" (perhaps you forgot to load \\\"\" + className + \"\\\"?\" );
            return PlCx.UNDEF;
        }

        args.unshift( invocant );
        return methodCode.apply(context, args);
    }
    public static final PlObject call( String invocant, String method, PlArray args, int context ) {
        if ( invocant.equals(\"\") ) {
            PlCORE.die( \"Can't call method \\\"\" + method
                + \"\\\" on an undefined value\" );
            return PlCx.UNDEF;
        }

        PlObject methodCode = PlClass.getInstance(invocant).method_lookup(method, 0);

        if (methodCode.is_undef()) {
            PlCORE.die( \"Can't locate object method \\\"\" + method
                + \"\\\" via package \\\"\" + invocant
                + \"\\\" (perhaps you forgot to load \\\"\" + invocant + \"\\\"?\" );
            return PlCx.UNDEF;
        }

        args.unshift( new PlString(invocant) );
        return methodCode.apply(context, args);
    }

    // local()
    public static final PlObject push_local(PlHash container, String index) {
        local_stack.a.add(container);
        local_stack.a.add(new PlString(index));
        PlLvalue empty = new PlLvalue();
        local_stack.a.add(container.hget_lvalue(index));
        container.hset_alias(index, empty);
        return empty;
    }
    public static final PlObject push_local(PlArray container, int index) {
        local_stack.a.add(container);
        local_stack.a.add(new PlInt(index));
        PlLvalue empty = new PlLvalue();
        local_stack.a.add(container.aget_lvalue(index));
        container.aset_alias(index, empty);
        return empty;
    }
    public static final void push_local_regex_result() {
        PlRegexResult match = PlV.regex_result;
        local_stack.a.add(match);
        PlRegexResult new_match = new PlRegexResult();
        new_match.matcher = match.matcher;
        new_match.regex_string = match.regex_string;
        PlV.regex_result = new_match;
    }

    public static final int local_length() {
        return local_stack.to_int();
    }
    public static final PlObject cleanup_local(int pos, PlObject ret) {
        while (local_stack.to_int() > pos) {
            PlObject v = local_stack.pop();
            if (v.is_regex_result()) {
                PlV.regex_result = (PlRegexResult)v;
            }
            else {
                PlLvalue lvalue    = (PlLvalue)v;
                PlObject index     = local_stack.pop();
                PlObject container = local_stack.pop();
                if (container.is_array()) {
                    ((PlArray)container).aset_alias(index.to_int(), lvalue);
                }
                else {
                    ((PlHash)container).hset_alias(index.toString(), lvalue);
                }
            }
        }
        return ret;
    }

    // context()
    //      - handles run-time scalar/list/void context in expression results
    public static final PlObject context(int want, PlObject arg) {
        if (want == PlCx.LIST) {
            return arg;
        }
        return arg.scalar();
    }
    public static final PlObject context(int want) {
        if (want == PlCx.LIST) {
            return new PlArray();
        }
        return PlCx.UNDEF;
    }
    public static final PlObject context(int want, PlObject... args) {
        if (want == PlCx.LIST) {
            return new PlArray(args);
        }
        return args[args.length-1].scalar();
    }
    public static final PlObject context(int want, String arg) {
        if (want == PlCx.LIST) {
            return new PlArray(new PlString(arg));
        }
        return new PlString(arg);
    }

    // process id
    public static PlObject getPID() {
      String processName =
        java.lang.management.ManagementFactory.getRuntimeMXBean().getName();
      return new PlString(processName.split(\"\@\")[0]);
    }

    // statement()
    //      - workaround for \"Error: not a statement\"
    //      - this is the compile-time version of context(null, arg)
    public static final void statement(PlObject... args) { }
    public static final void statement() { }

    // control-flow exceptions
    public static final PlObject next() {
        throw PlCx.NEXT;
    }
    public static final PlObject next(int label_id) {
        throw new PlNextException(label_id);
    }
    public static final PlObject last() {
        throw PlCx.LAST;
    }
    public static final PlObject last(int label_id) {
        throw new PlLastException(label_id);
    }
    public static final PlObject redo(int label_id) {
        throw new PlRedoException(label_id);
    }
    public static final PlObject ret(PlObject ret) {
        throw new PlReturnException(ret);
    }

    public static final PlObject gotoOp(int ctx, PlObject s, PlArray List__) {
        if (s.is_coderef()) {
            // goto &subr;
            throw new PlReturnException(s.apply(ctx, List__));
        }
        return PlCORE.die(\"goto() not implemented\");
    }

    public static final PlObject caller(int ctx, PlArray List__) {
        int item = List__.aget(0).to_int();

        PlArray caller = PlV.array_get(\"Perlito5::CALLER\");
        if (caller.length_of_array().to_boolean()) {
            if (ctx == 2) {
                return caller.aget(item).array_deref();
            }
            return caller.aget(item).aget(0);
        };

        // PlCORE.die(\"caller() not implemented\");

        // TODO - this code works, needs some tweaks
        // StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();
        // for (StackTraceElement elem : stackTraceElements) {
        //     PlCORE.say(elem.getMethodName());
        // }

        // The last element of the array represents the bottom of the stack,
        // which is the least recent method invocation in the sequence.
        // A StackTraceElement has getClassName(), getFileName(), getLineNumber() and getMethodName().

        return context(ctx);
    }

    public static final PlObject mod(PlInt aa, PlObject bb) {
        long a = aa.to_long();
        long b = bb.to_long();
        long res = Math.abs(a) % Math.abs(b);
        // PlCORE.say(\"mod \" + a + \" % \" + b + \" = \" + res);
        if (a < 0 && b > 0) {
            return new PlInt(b - res);
        }
        if (a > 0 && b < 0) {
            return new PlInt(b + res);
        }
        if (a < 0 && b < 0) {
            return new PlInt(- res);
        }
        return new PlInt(res);
    }
    public static final PlObject mod(PlDouble aa, PlObject bb) {
        double a = aa.to_double();
        double b = bb.to_double();
        double res = Math.abs(a) % Math.abs(b);
        // PlCORE.say(\"mod \" + a + \" % \" + b + \" = \" + res);
        if (a < 0.0 && b > 0.0) {
            return new PlDouble(b - res);
        }
        if (a > 0.0 && b < 0.0) {
            return new PlDouble(b + res);
        }
        if (a < 0.0 && b < 0.0) {
            return new PlDouble(- res);
        }
        return new PlDouble(res);
    }

    public static final PlObject srand() {
        random = new Random();
        return PlCx.UNDEF;
    }
    public static final PlObject srand(PlObject o) {
        if (!o.is_integer_range()) {
            PlCORE.warn(PlCx.VOID, new PlArray(new PlString(\"Integer overflow in srand\")));
        }
        long s = o.to_long();
        random = new Random(s);
        if (s == 0) {
            return new PlString(\"0E0\");
        }
        return new PlInt(s);
    }

    public static final PlObject rand(double s) {
        if (s == 0.0) {
            s = 1.0;
        }
        return new PlDouble(s * random.nextDouble());
    }

    public static final PlObject smartmatch_scalar(PlObject arg0, PlObject arg1) {
        if (arg1.is_undef()) {
            return arg0.is_undef() ? PlCx.TRUE : PlCx.FALSE;
        }
        if (arg1.is_string()) {
            return arg0.str_eq(arg1);
        }
        if (arg1.is_num() || arg1.is_int()) {
            return arg0.num_eq(arg1);
        }
        return PlCORE.die(PlCx.VOID, new PlArray(new PlString(\"Not implemented: smartmatch operator with argument type '\"), PlCORE.ref(PlCx.SCALAR, new PlArray(arg1)), new PlString(\"'\")));
    }

    // and1(x) ? y : and3()
    public static final boolean and1(PlObject arg1) {
        if (arg1.to_boolean()) {
            return true;
        }
        else {
            boolean_stack.add(0, arg1);
            return false;
        }
    }
    public static final PlObject and3() {
        return boolean_stack.remove(0);
    }

    // or1(x) ? or2() : y
    public static final boolean or1(PlObject arg1) {
        if (arg1.to_boolean()) {
            boolean_stack.add(0, arg1);
            return true;
        }
        else {
            return false;
        }
    }
    public static final PlObject or2() {
        return boolean_stack.remove(0);
    }

    // defined_or1(x) ? defined_or2() : y
    public static final boolean defined_or1(PlObject arg1) {
        if (!arg1.is_undef()) {
            boolean_stack.add(0, arg1);
            return true;
        }
        else {
            return false;
        }
    }
    public static final PlObject defined_or2() {
        return boolean_stack.remove(0);
    }

    public static final PlInt ord(PlObject s) {
        String item = s.toString();
        return new PlInt(item.length() > 0 ? Character.codePointAt(item, 0) : 0);
    }

    //    'prefix:<-A>' => 'PerlOp.p5atime',
    //    'prefix:<-C>' => 'PerlOp.p5ctime',
    //    'prefix:<-M>' => 'PerlOp.p5mtime',
    //    'prefix:<-d>' => 'PerlOp.p5is_directory',
    //    'prefix:<-e>' => 'PerlOp.p5file_exists',
    //    'prefix:<-f>' => 'PerlOp.p5is_file',
    //    'prefix:<-s>' => 'PerlOp.p5size',

    public static final Path resolve_file(PlObject s) throws IOException {
        return PlV.path.resolve(s.toString()).toRealPath();
    }

    public static final PlObject p5atime(PlObject s) {
        return PlCORE.die(\"-A not implemented\");
    }
    public static final PlObject p5ctime(PlObject s) {
        return PlCORE.die(\"-C not implemented\");
    }
    public static final PlObject p5mtime(PlObject s) {
        try {
            // TODO - \"Script start time minus file modification time, in days\"
            return new PlDouble(new File(resolve_file(s).toString()).lastModified() / 86400.0);
        }
        catch(IOException e) {
            PlV.sset(\"main::!\", new PlString(e.getMessage()));
            return PlCx.UNDEF;
        }
        catch(RuntimeException e) {
            PlV.sset(\"main::!\", new PlString(e.getMessage()));
            return PlCx.UNDEF;
        }
    }
    public static final PlObject p5is_directory(PlObject s) {
        try {
            return new PlBool(new File(resolve_file(s).toString()).isDirectory());
        }
        catch(IOException e) {
            PlV.sset(\"main::!\", new PlString(e.getMessage()));
            return PlCx.UNDEF;
        }
        catch(RuntimeException e) {
            PlV.sset(\"main::!\", new PlString(e.getMessage()));
            return PlCx.UNDEF;
        }
    }
    public static final PlObject p5file_exists(PlObject s) {
        return PlCORE.die(\"-e not implemented\");
    }
    public static final PlObject p5is_file(PlObject s) {
        try {
            return new PlBool(new File(resolve_file(s).toString()).isFile());
        }
        catch(IOException e) {
            PlV.sset(\"main::!\", new PlString(e.getMessage()));
            return PlCx.UNDEF;
        }
        catch(RuntimeException e) {
            PlV.sset(\"main::!\", new PlString(e.getMessage()));
            return PlCx.UNDEF;
        }
    }
    public static final PlObject p5size(PlObject s) {
        try {
            return new PlInt(new File(resolve_file(s).toString()).length());
        }
        catch(IOException e) {
            PlV.sset(\"main::!\", new PlString(e.getMessage()));
            return PlCx.UNDEF;
        }
        catch(RuntimeException e) {
            PlV.sset(\"main::!\", new PlString(e.getMessage()));
            return PlCx.UNDEF;
        }
    }

    public static final PlString string_replicate(PlObject s, PlObject c) {
        int count = c.to_int();
        if ( count < 1 ) {
            return new PlString(\"\");
        }
        else {
            String raw_s = s.toString();
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < count; i++) {
                sb.append(raw_s);
            }
            return new PlString(sb.toString());
        }
    }
    public static final PlObject list_replicate(PlArray o, PlObject c, int wantarray) {
        int count = c.to_int();
        PlArray a = new PlArray();
        if (count > 0) {
            for (int i = 0; i < count; i++) {
                a.push( o );
            }
        }
        return (wantarray == PlCx.LIST ) ? a : a.length_of_array();
    }
    public static final PlObject grep(PlClosure c, PlArray a, PlArray list__, int wantarray) {
        PlArray ret = new PlArray();
        int size = a.to_int();
        PlLvalue v__ref = (PlLvalue)PlV.sget(\"main::_\");
        PlObject v__val = v__ref.get();
        for (int i = 0; i < size; i++) {
            boolean result;
            PlObject temp = a.aget(i);
            v__ref.set(temp);
            result = c.apply(PlCx.SCALAR, list__).to_boolean();
            if (result) {
                ret.push(temp);
            }
        }
        v__ref.set(v__val);
        return (wantarray == PlCx.LIST ) ? ret : ret.length_of_array();
    }
    public static final PlObject map(PlClosure c, PlArray a, PlArray list__, int wantarray) {
        if (wantarray == PlCx.LIST ) {
            PlArray ret = new PlArray();
            int size = a.to_int();
            PlLvalue v__ref = (PlLvalue)PlV.sget(\"main::_\");
            PlObject v__val = v__ref.get();
            for (int i = 0; i < size; i++) {
                v__ref.set(a.aget(i));
                ret.push(c.apply(PlCx.LIST, list__));
            }
            v__ref.set(v__val);
            return ret;
        }
        else {
            int ret = 0;
            int size = a.to_int();
            PlLvalue v__ref = (PlLvalue)PlV.sget(\"main::_\");
            PlObject v__val = v__ref.get();
            for (int i = 0; i < size; i++) {
                v__ref.set(a.aget(i));
                ret += c.apply(PlCx.LIST, new PlArray()).length_of_array_int();
            }
            v__ref.set(v__val);
            return new PlInt(ret);
        }
    }
    public static final PlObject sort(PlClosure c, PlArray a, PlArray list__, int wantarray) {
        String pkg = c.pkg_name;
        PlArray ret = new PlArray(a);
        PlLvalue v_a_ref = (PlLvalue)PlV.sget(pkg + \"::a\");
        PlLvalue v_b_ref = (PlLvalue)PlV.sget(pkg + \"::b\");
        PerlCompare comp = new PerlCompare(c, v_a_ref, v_b_ref, list__);
        PlObject v_a_val = v_a_ref.get();
        PlObject v_b_val = v_b_ref.get();
        Collections.sort(ret.a, comp);
        v_a_ref.set(v_a_val);
        v_b_ref.set(v_b_val);
        return (wantarray == PlCx.LIST ) ? ret : ret.length_of_array();
    }

    public static PlObject prototype(PlObject arg, String packageName) {
        if (arg.is_coderef()) {
            if (arg.is_lvalue()) {
                arg = arg.get();
            }
            return ((PlClosure)arg).prototype();
        }
        String method = arg.toString();
        PlObject methodCode;
        if (method.indexOf(\"::\") == -1) {
            methodCode = PlV.cget(packageName + \"::\" + method);
        }
        else {
            // fully qualified name
            methodCode = PlV.cget(method);
        }
        if (methodCode.is_coderef()) {
            return prototype(methodCode, packageName); 
        }
        return PlCx.UNDEF;
    }

    private static int _regex_character_class_escape(int offset, String s, StringBuilder sb, int length, boolean flag_xx) {
        // [ ... ]
        for ( ; offset < length; ) {
            final int c3 = s.codePointAt(offset);
            switch (c3) {
                case ']':
                    sb.append(Character.toChars(c3));
                    return offset;
                case '\\\\':
                    sb.append(Character.toChars(c3));
                    if (offset < length) {
                        offset++;
                        int c2 = s.codePointAt(offset);
                        sb.append(Character.toChars(c2));
                    }
                    break;
                case ' ':
                    if (flag_xx) {
                        sb.append(Character.toChars(c3));
                    }
                    else {
                        sb.append(\"\\\\ \");   // make this space a \"token\", even inside /x
                    }
                    break;
                default:
                    sb.append(Character.toChars(c3));
                    break;
            }
            offset++;
        }
        return offset;
    }
    private static int _regex_skip_comment(int offset, String s, int length) {
        // [ ... ]
        int offset3 = offset;
        for ( ; offset3 < length; ) {
            final int c3 = s.codePointAt(offset3);
            switch (c3) {
                case ')':
                    return offset3;
                case '\\\\':
                    offset3++;
                    break;
                default:
                    break;
            }
            offset3++;
        }
        return offset;  // possible error - end of comment not found
    }

    // regex escape rules:
    //
    // \\[       as-is
    // [xx xx]  becomes: [xx\\ xx] - this will make sure space is a token, even when /x modifier is set
    // \\120     becomes: \\0120 - Java requires octal sequences to start with zero
    // \\0       becomes: \\00 - Java requires the extra zero
    // (?#...)  inline comment is removed
    //
    public static String regex_escape(String s, boolean flag_xx) {
        // escape spaces in character classes
        final int length = s.length();
        StringBuilder sb = new StringBuilder();
        for (int offset = 0; offset < length; ) {
            final int c = s.codePointAt(offset);
            switch (c) {
                case '\\\\':  // escape - \\[ \\120
                            sb.append(Character.toChars(c));
                            if (offset < length) {
                                offset++;
                                int c2 = s.codePointAt(offset);
                                if (c2 >= '1' && c2 <= '3') {
                                    if (offset < length+1) {
                                        int off = offset;
                                        int c3 = s.codePointAt(off++);
                                        int c4 = s.codePointAt(off++);
                                        if ((c3 >= '0' && c3 <= '7') && (c4 >= '0' && c4 <= '7')) {
                                            // a \\000 octal sequence
                                            sb.append('0');
                                        }
                                    }
                                }
                                else if (c2 == '0') {
                                    // rewrite \\0 to \\00
                                    sb.append('0');
                                }
                                sb.append(Character.toChars(c2));
                            }
                            break;
                case '[':   // character class
                            sb.append(Character.toChars(c));
                            offset++;
                            offset = _regex_character_class_escape(offset, s, sb, length, flag_xx);
                            break;
                case '(':   // comment (?# ... )
                            if (offset < length - 2) {
                                int c2 = s.codePointAt(offset+1);
                                int c3 = s.codePointAt(offset+2);
                                if (c2 == '?' && c3 == '#') {
                                    offset = _regex_skip_comment(offset, s, length);
                                }
                                else {
                                    sb.append(Character.toChars(c));
                                }
                            }
                            else {
                                sb.append(Character.toChars(c));
                            }
                            break;
                default:    // normal char
                            sb.append(Character.toChars(c));
                            break;
            }
            offset++;
        }
        return sb.toString();
    }

    // tr() escape rules:
    //
    // \\[       as-is
    // [xx xx]  becomes: [xx\\ xx] - this will make sure space is a token, even when /x modifier is set
    // \\120     becomes: \\0120 - Java requires octal sequences to start with zero
    // \\0       becomes: \\00 - Java requires the extra zero
    //
    public static String tr_escape(String s) {
        // escape spaces in character classes
        final int length = s.length();
        StringBuilder sb = new StringBuilder();
        for (int offset = 0; offset < length; ) {
            final int c = s.codePointAt(offset);
            switch (c) {
                case '\\\\':  // escape - \\[ \\120
                            if (offset < length) {
                                offset++;
                                int c2 = s.codePointAt(offset);
                                if (c2 >= '0' && c2 <= '3') {
                                    if (offset < length+1) {
                                        int c3 = s.codePointAt(offset+1);
                                        int c4 = s.codePointAt(offset+2);
                                        if ((c3 >= '0' && c3 <= '7') && (c4 >= '0' && c4 <= '7')) {
                                            // a \\000 octal sequence
                                            try {
                                                String oct = s.substring(offset, offset+3);
                                                sb.append(  (char) Integer.parseInt(oct, 8)  );
                                                offset = offset + 2;
                                                break;
                                            }
                                            catch (NumberFormatException e) {
                                            }
                                        }
                                    }
                                }
                                if (c2 == '0') {
                                    // \\0
                                    sb.append(  (char)0  );
                                    break;
                                }
                                sb.append(Character.toChars(c2));
                                break;
                            }
                            sb.append(Character.toChars(c));
                            break;
                case '[':   // character class
                            // TODO - character class in tr()
                            sb.append(Character.toChars(c));
                            offset++;
                            offset = _regex_character_class_escape(offset, s, sb, length, false);
                            break;
                default:    // normal char
                            sb.append(Character.toChars(c));
                            break;
            }
            offset++;
        }
        return sb.toString();
    }


    // ****** pos()
    // TODO - optimize: we are adding \"pos\" (Integer) to all PlLvalue objects

    public static final PlObject pos(PlObject vv) {
        if (!vv.is_lvalue()) {
            return PlCx.UNDEF;
        }
        PlLvalue var = (PlLvalue)vv;
        Integer pos = var.pos;
        if (pos == null) {
            return PlCx.UNDEF;
        }
        return new PlInt(pos);
    }
    public static final PlObject set_pos(PlObject vv, PlObject value) {
        PlLvalue var = (PlLvalue)vv;
        var.regex_zero_length_flag = false;
        if (value.is_undef()) {
            var.pos = null;
        }
        else {
            var.pos = value.to_int();
        }
        return value;
    }
    public static final PlObject set_pos(PlObject vv, PlObject value, PlRegexResult matcher, String str) {
        if (!vv.is_lvalue()) {
            return value;
        }
        PlLvalue var = (PlLvalue)vv;

        if (value.is_undef()) {
            var.pos = null;
            var.regex_zero_length_flag = false;
            return value;
        }

        int pos = value.to_int();

        // check for zero-length match
        int old_pos = pos(var).to_int();

        if (old_pos == pos) {
            // PlCORE.say(\"zero length match\");
            if (var.regex_zero_length_flag) {
                if (matcher.matcher.find()) {
                    matcher.regex_string = str;
                    pos = matcher.matcher.end();

                    // TODO - \$&
                    // String cap1 = str.substring(old_pos, pos);
                    // String cap = str.substring(matcher.start(), matcher.end());
                    // PlCORE.say(\"zero length match [true]: [\" + cap + \"] [\"+ cap1+\"] pos=\" + pos + \" start=\"+matcher.start() + \" end=\"+matcher.end());

                    var.regex_zero_length_flag = false;
                }
                else {
                    reset_match();
                    var.pos = null;
                    return PlCx.UNDEF;
                }
            }
            else {
                var.regex_zero_length_flag = true;
            }
        }

        // TODO - test that pos < string length
        value = new PlInt(pos);
        var.pos = pos;
        return value;
    }

    // ****** regex variables
    // class PlRegexResult extends PlObject {
    //     public Matcher matcher;      // regex captures
    //     public String  regex_string; // last string used in a regex

    public static final PlRegexResult set_match(Matcher m, String s) {
        PlRegexResult match = PlV.regex_result;
        match.matcher = m;
        match.regex_string = s;
        return match;
    }
    public static final void reset_match() {
        PlRegexResult match = PlV.regex_result;
        match.matcher = null;
        match.regex_string = null;
    }
    public static final PlObject regex_var(int var_number) {
        if (var_number == 0) {
            return PlV.sget(\"main::0\");
        }
        Matcher matcher = PlV.regex_result.matcher;
        if (matcher == null || var_number > matcher.groupCount() || var_number < 1) {
            return PlCx.UNDEF;
        }
        String cap = matcher.group(var_number);
        if (cap == null) {
            return PlCx.UNDEF;
        }
        return new PlString(cap);
    }
    public static final PlObject regex_var(String var_name) {
        PlRegexResult match = PlV.regex_result;
        Matcher matcher = match.matcher;
        String str = match.regex_string;
        if (matcher == null || str == null) {
            return PlCx.UNDEF;
        }
        if (var_name.equals(\"&\")) {    // \$&
            return new PlString( str.substring(matcher.start(), matcher.end()) );
        }
        if (var_name.equals(\"`\")) {    // \$`
            return new PlString( str.substring(0, matcher.start()) );
        }
        if (var_name.equals(\"'\")) {    // \$'
            return new PlString( str.substring(matcher.end()) );
        }
        return PlCx.UNDEF;
    }

    // ****** end regex variables

    public static final PlObject match(PlObject input, PlRegex pat, int want, boolean global, boolean c_flag) {
        // 'want'    context (PlCx.LIST, PlCx.SCALAR, PlCx.VOID)
        // 'global'  g  - globally match the pattern repeatedly in the string
        // 'c_flag'  c  - keep the current position during repeated matching

        String str = input.toString();
        if (want != PlCx.LIST) {
            Matcher matcher = pat.p.matcher(str);
            if (global) {
                // scalar context, global match
                PlObject pos = pos(input);
                boolean find;
                if (pos.is_undef()) {
                    find = matcher.find();
                }
                else {
                    find = matcher.find(pos.to_int());
                }
                if (find) {
                    PlRegexResult match = set_match(matcher, str);
                    set_pos(input, new PlInt(matcher.end()), match, str);
                    return PlCx.TRUE;
                }
                else {
                    // reset_match();
                    if (!c_flag) {
                        set_pos(input, PlCx.UNDEF, null, null);
                    }
                    return PlCx.FALSE;
                }
            }
            else {
                // scalar context, non-global match
                if (matcher.find()) {
                    set_match(matcher, str);
                    return PlCx.TRUE;
                }
                else {
                    // reset_match();
                    return PlCx.FALSE;
                }
            }
        }
        // list context
        Matcher matcher = pat.p.matcher(str);
        PlArray ret = new PlArray();
        if (global) {
            // list context, global match
            // Note: if there are no captures, then return the matched substrings
            boolean found = false;
            while (matcher.find()) {
                found = true;
                int count = matcher.groupCount();
                if (count > 0) {
                    for (int i = 1; i <= count; i++) {
                        String cap = matcher.group(i);
                        if (cap == null) {
                            ret.push(PlCx.UNDEF);
                        }
                        else {
                            ret.push(cap);
                        }
                    }
                }
                else {
                    String cap = matcher.group();
                    if (cap == null) {
                        ret.push(PlCx.UNDEF);
                    }
                    else {
                        ret.push(cap);
                    }
                }
            }
            if (found) {
                set_match(matcher, str);
            }
            else {
                // reset_match();
            }
            set_pos(input, PlCx.UNDEF, null, null);
            return ret;
        }
        else {
            // list context, non-global match
            if (matcher.find()) {
                set_match(matcher, str);
                for (int i = 1; i <= matcher.groupCount(); i++) {
                    String cap = matcher.group(i);
                    if (cap == null) {
                        ret.push(PlCx.UNDEF);
                    }
                    else {
                        ret.push(cap);
                    }
                }
            }
            else {
                // reset_match();
            }
            return ret;
        }
    }
    public static final PlObject match(PlObject s, PlLvalue pat, int want, boolean global, boolean c_flag) {
        return match(s, pat.get(), want, global, c_flag);
    }
    public static final PlObject match(PlObject s, PlObject pat, int want, boolean global, boolean c_flag) {
        // TODO - cache the compiled pattern
        return match(s, new PlRegex(pat, 0, false), want, global, c_flag);
    }

    public static final PlObject replace(PlLvalue s, PlRegex pat, PlClosure rep, int want, boolean global) {
        String str = s.toString();
        int count = 0;
        Matcher matcher = pat.p.matcher(str);
        if (global) {
            final StringBuilder buf = new StringBuilder(str.length() + 256);
            int pos = 0;
            while (matcher.find()) {
                count++;
                set_match(matcher, str);
                int start = matcher.start();
                int end   = matcher.end();
                String replace = rep.apply(PlCx.SCALAR, new PlArray()).toString();
                if (start > pos) {
                    buf.append( str.substring(pos, start) );
                }
                if (replace.length() > 0) {
                    buf.append( replace );
                }
                pos = end;
            }
            if (count > 0) {
                if (pos <= str.length()) {
                    buf.append( str.substring(pos) );
                }
                s.set(new PlString(buf.toString()));
            }
        }
        else {
            if (matcher.find()) {
                count++;
                set_match(matcher, str);
                int start = matcher.start();
                int end   = matcher.end();
                String replace = rep.apply(PlCx.SCALAR, new PlArray()).toString();
                final StringBuilder buf = new StringBuilder(str.length() + replace.length());
                if (start > 0) {
                    buf.append( str.substring(0, start) );
                }
                if (replace.length() > 0) {
                    buf.append( replace );
                }
                if (end <= str.length()) {
                    buf.append( str.substring(end) );
                }
                s.set(new PlString(buf.toString()));
            }
        }
        if (count == 0) {
            // no match
            return PlCx.FALSE;
        }
        return new PlInt(count);
    }
    public static final PlObject replace(PlLvalue s, PlRegex pat, String replace, int want, boolean global) {
        String str = s.toString();
        int count = 0;
        Matcher matcher = pat.p.matcher(str);
        if (global) {
            final StringBuilder buf = new StringBuilder(str.length() + 256);
            int pos = 0;
            while (matcher.find()) {
                count++;
                set_match(matcher, str);
                int start = matcher.start();
                int end   = matcher.end();
                if (start > pos) {
                    buf.append( str.substring(pos, start) );
                }
                if (replace.length() > 0) {
                    buf.append( replace );
                }
                pos = end;
            }
            if (count > 0) {
                if (pos <= str.length()) {
                    buf.append( str.substring(pos) );
                }
                s.set(new PlString(buf.toString()));
            }
        }
        else {
            if (matcher.find()) {
                count++;
                set_match(matcher, str);
                int start = matcher.start();
                int end   = matcher.end();
                final StringBuilder buf = new StringBuilder(str.length() + replace.length());
                if (start > 0) {
                    buf.append( str.substring(0, start) );
                }
                if (replace.length() > 0) {
                    buf.append( replace );
                }
                if (end <= str.length()) {
                    buf.append( str.substring(end) );
                }
                s.set(new PlString(buf.toString()));
            }
        }
        if (count == 0) {
            // no match
            return PlCx.FALSE;
        }
        return new PlInt(count);
    }

    public static final PlObject replace(PlLvalue s, PlRegex pat, PlObject rep, int want, boolean global) {
        if (rep.is_coderef()) {
            return replace(s, pat, (PlClosure)rep, want, global);
        }
        return replace(s, pat, rep.toString(), want, global);
    }
    public static final PlObject replace(PlObject s, PlObject pat, PlObject rep, int want, boolean global) {
        if (!s.is_lvalue()) {
            PlCORE.die(\"Can't modify constant item in substitution (s///)\");
        }
        // TODO - cache the compiled pattern
        return replace((PlLvalue)s, new PlRegex(pat, 0, false), rep, want, global);
    }
    public static final PlObject replace(PlObject s, PlObject pat, String rep, int want, boolean global) {
        if (!s.is_lvalue()) {
            PlCORE.die(\"Can't modify constant item in substitution (s///)\");
        }
        // TODO - cache the compiled pattern
        return replace((PlLvalue)s, new PlRegex(pat, 0, false), rep, want, global);
    }

    // \$v =~ tr/xyz/abc/i
    // PerlOp.tr(v_v_100, new PlString(\"xyz\"), new PlString(\"abc\"), \"\", PlCx.VOID)
    public static final PlObject tr(PlObject pstr, PlObject psearchChars, PlObject preplaceChars, String modifier, int want) {
        String str          = pstr.toString();
        String searchChars  = tr_escape(psearchChars.toString());
        String replaceChars = tr_escape(preplaceChars.toString());
        int modified = 0;
        final int replaceCharsLength = replaceChars.length();
        final int strLength = str.length();
        final StringBuilder buf = new StringBuilder(strLength);
        for (int i = 0; i < strLength; i++) {
            final char ch = str.charAt(i);
            final int index = searchChars.indexOf(ch);
            if (index >= 0) {
                modified++;
                if (index < replaceCharsLength) {
                    buf.append(replaceChars.charAt(index));
                }
            } else {
                buf.append(ch);
            }
        }
        if (modified > 0) {
            pstr.set(new PlString(buf.toString()));
        }
        return new PlInt(modified);
    }


    // looks_like_number
    private static int _parse_space(String s, int length, int offset) {
        for ( ; offset < length; offset++ ) {
            final int c3 = s.codePointAt(offset);
            switch (c3) {
                case ' ': case '\\t': case '\\n': case '\\r':
                    break;
                default:
                    return offset;
            }
        }
        return offset;
    }
    private static boolean _parse_space_to_end(String s, int length, int offset) {
        for ( ; offset < length; offset++ ) {
            final int c3 = s.codePointAt(offset);
            switch (c3) {
                case ' ': case '\\t': case '\\n': case '\\r':
                    break;
                default:
                    return false;
            }
        }
        return true;
    }
    private static boolean _parse_exp(String s, int length, int offset) {
        // 123.45E^^^
        final int c = s.codePointAt(offset);
        if (c == '+' || c == '-') {
            offset++;
            if (offset >= length) {
                return false;
            }
        }
        for ( ; offset < length; offset++ ) {
            final int c3 = s.codePointAt(offset);
            switch (c3) {
                case '0': case '1': case '2': case '3': case '4':
                case '5': case '6': case '7': case '8': case '9':
                    break;
                default:
                    return _parse_space_to_end(s, length, offset);
            }
        }
        return true;
    }
    private static boolean _parse_dot(String s, int length, int offset) {
        // 123.^^^
        for ( ; offset < length; offset++ ) {
            final int c3 = s.codePointAt(offset);
            switch (c3) {
                case '0': case '1': case '2': case '3': case '4':
                case '5': case '6': case '7': case '8': case '9':
                    break;
                case 'E': case 'e':
                    return _parse_exp(s, length, offset+1);
                default:
                    return _parse_space_to_end(s, length, offset);
            }
        }
        return true;
    }
    private static boolean _parse_int(String s, int length, int offset) {
        // 123
        for ( ; offset < length; offset++ ) {
            final int c3 = s.codePointAt(offset);
            switch (c3) {
                case '0': case '1': case '2': case '3': case '4':
                case '5': case '6': case '7': case '8': case '9':
                    break;
                case '.':
                    return _parse_dot(s, length, offset+1);
                case 'E': case 'e':
                    return _parse_exp(s, length, offset+1);
                default:
                    return _parse_space_to_end(s, length, offset);
            }
        }
        return true;
    }
    public static boolean looks_like_number(String s) {
        final int length = s.length();
        int offset = _parse_space(s, length, 0);
        if (offset >= length) {
            return false;
        }
        int c = s.codePointAt(offset);
        if (c == '+' || c == '-') {
            offset++;
            if (offset >= length) {
                return false;
            }
            c = s.codePointAt(offset);
        }
        switch (c) {
            case 'i': case 'I':
                        return s.substring(offset, offset+3).equalsIgnoreCase(\"inf\");
            case 'n': case 'N':
                        return s.substring(offset, offset+3).equalsIgnoreCase(\"nan\");
            case '.':
                        offset++;
                        if (offset >= length) {
                            return false;
                        }
                        final int c3 = s.codePointAt(offset);
                        switch (c3) {
                            case '0': case '1': case '2': case '3': case '4':
                            case '5': case '6': case '7': case '8': case '9':
                                return _parse_dot(s, length, offset+1);
                        }
            case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':
                        return _parse_int(s, length, offset+1);
        }
        return false;
    }
    public static boolean looks_like_number(PlObject arg) {
        if (arg.is_num() || arg.is_int()) {
            return true;
        }
        return looks_like_number(arg.toString());
    }
    public static long _parse_oct(String s, int base) {
        try {
            s = s.replace(\"_\",\"\");
            return Long.parseLong(s, base);
        } catch (NumberFormatException n) {
        } catch (Exception e) {
        }
        return 0;
    }
    public static long oct(String s) {
        final int length = s.length();
        int c;

        for (int i = 0; i < length; i++ ) {
            c = s.codePointAt(i);
            if (c > 254) {
                PlCORE.die(\"Wide character in oct\");
            }
        }

        int offset = _parse_space(s, length, 0);
        if (offset >= length) {
            return 0;
        }
        int start = offset;
        c = s.codePointAt(offset);
        if (c == '0') {
            start++;
            offset++;
            if (offset >= length) {
                return 0;
            }
            c = s.codePointAt(offset);
        }
        boolean ul = false;
        switch (c) {
            case 'x': case 'X':
                    start++;
                    offset++;
                    for ( ; offset < length; offset++ ) {
                        c = s.codePointAt(offset);
                        if (c == '_') {
                            if (ul) {
                                return _parse_oct(s.substring(start, offset), 16);
                            }
                            ul = true;
                        }
                        else if ((c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f') || (c >= '0' && c <= '9')) {
                            ul = false;
                        }
                        else {
                            return _parse_oct(s.substring(start, offset), 16);
                        }
                    }
                    return _parse_oct(s.substring(start, offset), 16);
            case 'b': case 'B':
                    start++;
                    offset++;
                    for ( ; offset < length; offset++ ) {
                        c = s.codePointAt(offset);
                        switch (c) {
                            case '_':
                                if (ul) {
                                    return _parse_oct(s.substring(start, offset), 2);
                                }
                                ul = true;
                                break;
                            case '0': case '1':
                                ul = false;
                                break;
                            default:
                                return _parse_oct(s.substring(start, offset), 2);
                        }
                    }
                    return _parse_oct(s.substring(start, offset), 2);
            case '0': case '1': case '2': case '3': case '4':
            case '5': case '6': case '7': case '_':
                    for ( ; offset < length; offset++ ) {
                        c = s.codePointAt(offset);
                        switch (c) {
                            case '_':
                                if (ul) {
                                    return _parse_oct(s.substring(start, offset), 8);
                                }
                                ul = true;
                                break;
                            case '0': case '1': case '2': case '3': case '4':
                            case '5': case '6': case '7':
                                ul = false;
                                break;
                            default:
                                return _parse_oct(s.substring(start, offset), 8);
                        }
                    }
                    return _parse_oct(s.substring(start, offset), 8);
        }
        return 0;
    }

}

", "
class PlV {
    // PlV implements namespaces and global variables
    //
    // TODO - import CORE subroutines in new namespaces, if needed
    // TODO - cache lookups in lexical variables (see PlClosure implementation)

    public static final PlHash svar = new PlHash(); // scalar
    public static final PlHash cvar = new PlHash(); // code
    public static final PlHash avar = new PlHash(); // array
    public static final PlHash hvar = new PlHash(); // hash
    public static final PlHash fvar = new PlHash(); // file

    public static PlRegexResult regex_result = new PlRegexResult();
    public static Path path;

    public static final void init(String[] args) {
        PlV.array_set(\"main::ARGV\", new PlArray(args));               // args is String[]
        PlV.hash_set(\"main::ENV\",   new PlArray(System.getenv()));    // env  is Map<String, String>
        PlV.sset(\"main::\" + (char)34, new PlString(\" \"));         // \$\" = \" \"
        PlV.sset(\"main::/\", new PlString(\"\\n\"));                  // \$/ = \"\\n\"

        PlCx.STDIN.inputStream   = System.in;
        PlCx.STDIN.reader        = new BufferedReader(new InputStreamReader(System.in));
        PlCx.STDIN.eof           = false;
        PlCx.STDIN.typeglob_name = \"main::STDIN\";

        PlCx.STDOUT.outputStream = System.out;
        PlCx.STDOUT.typeglob_name = \"main::STDOUT\";

        PlCx.STDERR.outputStream = System.err;
        PlCx.STDERR.typeglob_name = \"main::STDERR\";

        try {
            PlV.path = Paths.get(\".\").toRealPath();
        }
        catch (IOException e) {
            // don't know what to do
        }

        PlV.fset(\"main::STDIN\",  PlCx.STDIN);                             // \"GLOB\"
        PlV.fset(\"main::STDOUT\", PlCx.STDOUT);
        PlV.fset(\"main::STDERR\", PlCx.STDERR);

        PlV.cset(\"UNIVERSAL::can\", new PlClosure(PlCx.UNDEF, new PlObject[]{  }, \"UNIVERSAL\") {
            public PlObject apply(int want, PlArray List__) {
                PlObject self = List__.shift();
                String method_name = List__.shift().toString();
                PlClass bless = self.blessed_class();
                if ( bless != null ) {
                    PlObject methodCode = bless.method_lookup(method_name, 0);
                    if (methodCode.is_coderef()) {
                        return methodCode;
                    }
                    return PlCx.UNDEF;
                }

                // calling can() as a class method
                PlObject methodCode = PlClass.getInstance(self).method_lookup(method_name, 0);
                if (methodCode.is_coderef()) {
                    return methodCode;
                }

                return PlCx.UNDEF;
            }
        });
        PlV.cset(\"UNIVERSAL::isa\", new PlClosure(PlCx.UNDEF, new PlObject[]{  }, \"UNIVERSAL\") {
            public PlObject apply(int want, PlArray List__) {
                PlObject self = List__.shift();
                String class_name = List__.shift().toString();
                PlClass bless = self.blessed_class();
                if ( bless != null ) {
                    return bless.isa(class_name, 0);
                }

                // reftype == \"ARRAY\"
                if (self.reftype().toString().equals(class_name)) {
                    return PlCx.INT1;
                }

                // calling isa() as a class method
                bless = PlClass.getInstance(self);
                if ( bless != null ) {
                    return bless.isa(class_name, 0);
                }

                return PlCx.UNDEF;
            }
        });
        PerlOp.reset_match();
    }

    // scalar
    public static final PlLvalue sget(String name) {
        return (PlLvalue)svar.hget_lvalue(name);
    }
    public static final PlLvalue sget_local(String name) {
        return (PlLvalue)svar.hget_lvalue_local(name);
    }
    public static final PlObject sset(String name, PlObject v) {
        return svar.hset(name, v);
    }
    public static final PlObject sset_local(String name, PlObject v) {
        return svar.hget_lvalue_local(name).set(v);
    }
    public static final void sset_alias(String name, PlLvalue v) {
        svar.hset_alias(name, v);
    }

    // code
    public static final PlObject apply(String name, int want, PlArray List__) {
        PlObject code = cvar.hget(name);
        if ( code.is_coderef() ) {
            return code.apply(want, List__);
        }
        int pos = name.lastIndexOf(\"::\");
        if (pos != -1) {
            String namespace = name.substring(0, pos);
            PlLvalue autoload = PlV.cget_no_autoload(namespace + \"::AUTOLOAD\");
            if ( autoload.is_coderef() ) {
                PlV.sset(namespace + \"::AUTOLOAD\", new PlString(name));
                return autoload.apply(want, List__);
            }
        }
        return PlCORE.die(\"Undefined subroutine &\" + name + \" called\");
    }

    public static final PlObject apply_maybe_core(String name, int want, PlArray List__) {
        // time() is a CORE function that can be redefined
        PlObject code = cvar.hget(name);
        if ( code.is_coderef() ) {
            return code.apply(want, List__);
        }
        int pos = name.lastIndexOf(\"::\");
        if (pos != -1) {
            String shortname = name.substring(pos + 2);
            if ( shortname.equals(\"time\") ) {
                return PlCORE.time(want, List__);
            }
        }
        return PlCORE.die(\"Undefined subroutine &\" + name + \" called\");
    }

    public static final PlLvalue cget(String name) {
        // this implements \" \\&name \"
        PlLvalue code = (PlLvalue)cvar.hget_lvalue(name);
        if ( code.is_coderef() ) {
            return code;
        }
        int pos = name.lastIndexOf(\"::\");
        if (pos == -1) {
            return code;
        }
        String namespace = name.substring(0, pos);
        PlLvalue autoload = PlV.cget_no_autoload(namespace + \"::AUTOLOAD\");
        if ( autoload.is_coderef() ) {
            PlV.sset(namespace + \"::AUTOLOAD\", new PlString(name));
            return autoload;
        }
        return code;
    }
    public static final PlLvalue cget_local(String name) {
        return (PlLvalue)cvar.hget_lvalue_local(name);
    }
    public static final PlLvalue cget_no_autoload(String name) {
        return (PlLvalue)cvar.hget_lvalue(name);
    }
    public static final PlObject cset(String name, PlObject v) {
        return cvar.hset(name, v);
    }
    public static final PlObject cset_local(String name, PlObject v) {
        return cvar.hget_lvalue_local(name).set(v);
    }
    public static final void cset_alias(String name, PlLvalue v) {
        cvar.hset_alias(name, v);
    }

    // hash
    public static final PlHash hash_get(String name) {
        return (PlHash)hvar.hget_hashref(name).hash_deref();
    }
    public static final PlHash hash_get_local(String name) {
        PlLvalue o = (PlLvalue)hvar.hget_lvalue_local(name);
        PlHashRef hr = new PlHashRef();
        o.set(hr);
        return hr.hash_deref();
    }
    public static final PlObject hash_set(String name, PlObject v) {
        return hvar.hget_hashref(name).hash_deref_set(v);
    }
    public static final PlObject hash_set_local(String name, PlObject v) {
        return hvar.hget_lvalue_local(name).get_hashref().hash_deref_set(v);
    }
    public static final PlLvalue hget(String name) {
        return (PlLvalue)hvar.hget_lvalue(name);
    }
    public static final PlLvalue hget_local(String name) {
        return (PlLvalue)hvar.hget_lvalue_local(name);
    }
    public static final PlObject hset(String name, PlObject v) {
        return hvar.hset(name, v);
    }
    public static final PlObject hset_local(String name, PlObject v) {
        return hvar.hget_lvalue_local(name).set(v);
    }
    public static final void hset_alias(String name, PlHash v) {
        hvar.hset_alias(name, v);
    }

    // array
    public static final PlArray array_get(String name) {
        return (PlArray)avar.hget_arrayref(name).array_deref();
    }
    public static final PlArray array_get_local(String name) {
        PlLvalue o = (PlLvalue)avar.hget_lvalue_local(name);
        PlArrayRef ar = new PlArrayRef();
        o.set(ar);
        return ar.array_deref();
    }
    public static final PlObject array_set(String name, PlObject v) {
        return avar.hget_arrayref(name).array_deref_set(v);
    }
    public static final PlObject array_set_local(String name, PlObject v) {
        return avar.hget_lvalue_local(name).get_arrayref().array_deref_set(v);
    }
    public static final PlLvalue aget(String name) {
        return (PlLvalue)avar.hget_lvalue(name);
    }
    public static final PlLvalue aget_local(String name) {
        return (PlLvalue)avar.hget_lvalue_local(name);
    }
    public static final PlObject aset(String name, PlObject v) {
        return avar.hset(name, v);
    }
    public static final PlObject aset_local(String name, PlObject v) {
        return avar.hget_lvalue_local(name).set(v);
    }
    public static final void aset_alias(String name, PlArray v) {
        avar.hset_alias(name, v);
    }

    // filehandle
    public static final PlLvalue fget(String name) {
        PlLvalue v = (PlLvalue)fvar.hget_lvalue(name);
        if (v.is_undef()) {
            // autovivification to filehandle
            PlFileHandle f = new PlFileHandle();
            if (name.equals(\"main::ARGV\")) {
                f.is_argv = true;
            }
            f.typeglob_name = name;
            v.set(f);
        }
        return v;
    }
    public static final PlLvalue fget_local(String name) {
        PlLvalue v = (PlLvalue)fvar.hget_lvalue_local(name);
        if (v.is_undef()) {
            // autovivification to filehandle
            PlFileHandle f = new PlFileHandle();
            if (name.equals(\"main::ARGV\")) {
                f.is_argv = true;
            }
            f.typeglob_name = name;
            v.set(f);
        }
        return v;
    }
    public static final PlObject fset(String name, PlObject v) {
        return fvar.hset(name, v);
    }
    public static final PlObject fset_local(String name, PlObject v) {
        return fvar.hget_lvalue_local(name).set(v);
    }

    // code
    public static final PlObject code_lookup_by_name(String nameSpace, PlObject name) {
        if (name.is_coderef()) {
            return name;
        }
        String s = name.toString();
        if (s.indexOf(\"::\") == -1) {
            s = nameSpace + \"::\" + s;
        }
        return PlV.cget(s);
    }
    public static final PlObject code_lookup_by_name_no_autoload(String nameSpace, PlObject name) {
        if (name.is_coderef()) {
            return name;
        }
        String s = name.toString();
        if (s.indexOf(\"::\") == -1) {
            s = nameSpace + \"::\" + s;
        }
        return PlV.cget_no_autoload(s);
    }

    // glob
    public static final PlObject glob_set(PlObject name, PlObject value, String nameSpace) {
        return glob_set(name.toString(), value, nameSpace);
    }
    public static final PlObject glob_set(String name, PlObject value, String nameSpace) {
        if (value.is_lvalue()) {
            value = value.get();
        }
        if (value.is_coderef()) {
            PlV.cset(name, value);
        }
        else if (value.is_hashref()) {
            PlV.hset(name, value);
        }
        else if (value.is_arrayref()) {
            PlV.aset(name, value);
        }
        else if (value.is_scalarref()) {
            PlV.sset(name, value.scalar_deref(nameSpace));
        }
        else if (value.is_typeglobref()) {
            // *x = \\*y
            PlGlobRef gl = (PlGlobRef)value;
            return glob_set(name, gl.filehandle, nameSpace);
        }
        else if (value.is_filehandle()) {
            // *x = *y
            PlFileHandle fh = (PlFileHandle)value;
            String typeglob_name = fh.typeglob_name;
            if (typeglob_name == null) {
                PlCORE.die(\"not implemented assign anonymous typeglob to typeglob\");
            }
            return glob_set(name, new PlString(typeglob_name), nameSpace);
        }
        else if (!value.is_ref()) {
            String typeglob_name = value.toString();
            if (typeglob_name.indexOf(\"::\") == -1) {
                typeglob_name = nameSpace + \"::\" + typeglob_name;
            }
            // TODO - share lvalue containers (alias)
            PlV.fset(name, PlV.fget(typeglob_name));
            PlV.cset_alias(name, PlV.cget(typeglob_name));
            PlV.sset_alias(name, PlV.sget(typeglob_name));
            PlV.aset(name, PlV.aget(typeglob_name));
            PlV.hset(name, PlV.hget(typeglob_name));
        }
        else {
            PlCORE.die(\"not implemented assign \" + value.ref() + \" to typeglob\");
        }
        return value;
    }
    public static final PlObject glob_set_local(PlString name, PlObject value, String nameSpace) {
        return glob_set_local(name.toString(), value, nameSpace);
    }
    public static final PlObject glob_set_local(String name, PlObject value, String nameSpace) {
        if (value.is_coderef()) {
            PlV.cset_local(name, value);
        }
        else if (value.is_hashref()) {
            PlV.hset_local(name, value);
        }
        else if (value.is_arrayref()) {
            PlV.aset_local(name, value);
        }
        else if (value.is_scalarref()) {
            PlV.sset_local(name, value);
        }
        else if (value.is_typeglobref()) {
            // local *x = \\*y
            PlGlobRef gl = (PlGlobRef)value;
            return glob_set_local(name, gl.filehandle, nameSpace);
        }
        else if (value.is_filehandle()) {
            // local *x = *y
            PlFileHandle fh = (PlFileHandle)value;
            String typeglob_name = fh.typeglob_name;
            if (typeglob_name == null) {
                PlCORE.die(\"not implemented assign anonymous typeglob to typeglob\");
            }
            return glob_set_local(name, new PlString(typeglob_name), nameSpace);
        }
        else if (!value.is_ref()) {
            String typeglob_name = value.toString();
            if (typeglob_name.indexOf(\"::\") == -1) {
                typeglob_name = nameSpace + \"::\" + typeglob_name;
            }
            // TODO - share lvalue containers (alias)
            PlV.fset_local(name, PlV.fget(typeglob_name));
            PlV.cset_local(name, PlCx.UNDEF);
            PlV.cset_alias(name, PlV.cget(typeglob_name));
            PlV.sset_local(name, PlCx.UNDEF);
            PlV.sset_alias(name, PlV.sget(typeglob_name));
            PlV.aset_local(name, PlV.aget(typeglob_name));
            PlV.hset_local(name, PlV.hget(typeglob_name));
        }
        else {
            PlCORE.die(\"not implemented assign \" + value.ref() + \" to typeglob\");
        }
        return value;
    }

}
class PlObject {
    public static final PlString REF = new PlString(\"\");

    public PlObject() {
    }
", ((map {
            my $class = $java_classes{$_};
            my $java_class_name = $class->{"java_type"};
            my $perl_to_java = $class->{"perl_to_java"};
            $class->{"import"} || $class->{"extends"} || $class->{"implements"} ? "    public " . $java_class_name . " " . $perl_to_java . "() {
" . "        PlCORE.die(\"error ." . $perl_to_java . "!\");
" . "        return null;
" . "    }
" : ()
        } sort {;
            $a cmp $b
        } keys(%java_classes))), "    // public String toString() {
    //     return this.toString();
    // }
    public int to_int() {
        long v = this.to_long();
        if (v > Integer.MAX_VALUE || v < Integer.MIN_VALUE) {
            PlCORE.die(\"numeric overflow converting to int\");
        }
        return (int)v;
    }
    public byte to_byte() {
        long v = this.to_long();
        if (v > Byte.MAX_VALUE || v < Byte.MIN_VALUE) {
            PlCORE.die(\"numeric overflow converting to byte\");
        }
        return (byte)v;
    }
    public short to_short() {
        long v = this.to_long();
        if (v > Short.MAX_VALUE || v < Short.MIN_VALUE) {
            PlCORE.die(\"numeric overflow converting to short\");
        }
        return (short)v;
    }
    public float to_float() {
        double v = this.to_double();
        if (v > Float.MAX_VALUE || v < Float.MIN_VALUE) {
            PlCORE.die(\"numeric overflow converting to float\");
        }
        return (float)v;
    }
    public long to_long() {
        return 0;
    }
    public double to_double() {
        return 0.0;
    }
    public boolean to_boolean() {
        return false;
    }
    public PlObject to_num() {
        return PlCx.INT0;
    }
    public char to_char() {
        return (char)(this.to_int());
    }
    public PlObject end_of_array_index() {
        return PlCORE.die(\"Not an ARRAY reference\");
    }
    public PlObject set_end_of_array_index(PlObject o) {
        return PlCORE.die(\"Not an ARRAY reference\");
    }
    public PlObject apply(int want, PlArray List__) {
        // \$ perl -e ' \$a = 5; \$a->() '
        // Undefined subroutine &main::5 called
        PlCORE.die(\"subroutine call error\");
        return this;
    }

    public PlObject length() {
        return new PlInt(this.toString().length());
    }
    public PlObject get_arrayref() {
        return PlCORE.die(\"Not an ARRAY reference\");
    }

    public PlObject shift() {
        return PlCORE.die(\"Not an ARRAY reference\");
    }

    public PlObject get_hashref() {
        return PlCORE.die(\"Not a HASH reference\");
    }

    public PlObject hget_scalarref(PlObject i) {
        return this.hget_scalarref(i.toString());
    }
    public PlObject hget_scalarref(String i) {
        PlCORE.die(\"Not a SCALAR reference\");
        return this;
    }
    public PlObject scalar_deref_lvalue(String namespace) {
        return PlCORE.die(\"Not a SCALAR reference\");
    }
    public PlObject scalar_deref(String namespace) {
        return PlCORE.die(\"Not a SCALAR reference\");
    }
    public PlObject scalar_deref_strict() {
        return PlCORE.die(\"Not a SCALAR reference\");
    }
    public PlObject scalar_deref_set(String namespace, PlObject v) {
        return PlCORE.die(\"Not a SCALAR reference\");
    }
    public PlObject aget_list_of_aliases(int want, PlArray a) {
        if (this.is_array()) {
            return ((PlArray)this).aget_list_of_aliases(want, a);
        }
        return PlCORE.die(\"Not an ARRAY\");
    }
    public PlObject aget_lvalue(PlObject i) {
        return this.aget_lvalue(i.to_int());
    }
    public PlObject aget_lvalue(int i) {
        return PlCORE.die(\"Not an ARRAY reference\");
    }
    public PlObject aget_scalarref(PlObject i) {
        return this.aget_scalarref(i.to_int());
    }
    public PlObject aget_scalarref(int i) {
        PlCORE.die(\"Not a SCALAR reference\");
        return this;
    }

    public PlArray array_deref_lvalue() {
        PlCORE.die(\"Not an ARRAY reference\");
        return (PlArray)this;
    }
    public PlArray array_deref() {
        PlCORE.die(\"Not an ARRAY reference\");
        return (PlArray)this;
    }
    public PlArray array_deref_strict() {
        PlCORE.die(\"Not an ARRAY reference\");
        return (PlArray)this;
    }
    public PlObject array_deref_set(PlObject i) {
        PlCORE.die(\"Not an ARRAY reference\");
        return this;
    }

    public PlObject hget_arrayref(PlObject i) {
        return this.hget_arrayref(i.toString());
    }
    public PlObject hget_arrayref(String i) {
        PlCORE.die(\"Not a HASH reference\");
        return this;
    }
    public PlObject hget_hashref(PlObject i) {
        return this.hget_hashref(i.toString());
    }
    public PlObject hget_hashref(String i) {
        PlCORE.die(\"Not a HASH reference\");
        return this;
    }

    public PlObject aget_arrayref(PlObject i) {
        return this.aget_arrayref(i.to_int());
    }
    public PlObject aget_arrayref(int i) {
        PlCORE.die(\"Not an ARRAY reference\");
        return this;
    }
    public PlObject aget_hashref(PlObject i) {
        return this.aget_hashref(i.to_int());
    }
    public PlObject aget_hashref(int i) {
        PlCORE.die(\"Not an ARRAY reference\");
        return this;
    }

    public PlObject hash_deref() {
        PlCORE.die(\"Not a HASH reference\");
        return this;
    }
    public PlObject hash_deref_strict() {
        PlCORE.die(\"Not a HASH reference\");
        return this;
    }
    public PlObject hash_deref_set(PlObject i) {
        PlCORE.die(\"Not a HASH reference\");
        return this;
    }

    public PlObject hget(PlObject i) {
        PlCORE.die(\"Not a HASH reference\");
        return this;
    }
    public PlObject hget(String i) {
        PlCORE.die(\"Not a HASH reference\");
        return this;
    }
    public PlObject hget_lvalue(PlObject i) {
        return this.hget_lvalue(i.toString());
    }
    public PlObject hget_lvalue(String i) {
        PlCORE.die(\"Not a HASH reference\");
        return this;
    }
    public PlObject hget_lvalue_local(PlObject i) {
        return this.hget_lvalue_local(i.toString());
    }
    public PlObject hget_lvalue_local(String i) {
        PlCORE.die(\"Not a HASH reference\");
        return this;
    }

    public PlObject hset(PlObject s, PlObject v) {
        return this.hset(s.toString(), v);
    }
    public PlObject hset(String s, PlObject v) {
        PlCORE.die(\"Not a HASH reference\");
        return this;
    }

    public PlObject aget(PlObject i) {
        return this.aget(i.to_int());
    }
    public PlObject aget(int i) {
        PlCORE.die(\"Not an ARRAY reference\");
        return this;
    }
    public PlObject aset(int i, PlObject v) {
        PlCORE.die(\"Not an ARRAY reference\");
        return this;
    }
    public PlObject aset(PlObject i, PlObject v) {
        return this.aset(i.to_int(), v);
    }
    public PlObject to_array() {
        PlCORE.die(\"Not an ARRAY reference\");
        return this;
    }
    public PlObject length_of_array() {
        PlCORE.die(\"Not an ARRAY reference\");
        return this;
    }
    public int length_of_array_int() {
        return 1;
    }
    public PlObject values() {
        PlCORE.die(\"Type of argument to values on reference must be unblessed hashref or arrayref\");
        return this;
    }
    public PlObject keys() {
        PlCORE.die(\"Type of argument to keys on reference must be unblessed hashref or arrayref\");
        return this;
    }
    public PlObject each() {
        PlCORE.die(\"Type of argument to each on reference must be unblessed hashref or arrayref\");
        return this;
    }
    public PlObject exists(PlObject i) {
        PlCORE.die(\"exists argument is not a HASH or ARRAY element or a subroutine\");
        return this;
    }
    public PlObject delete(PlObject i) {
        PlCORE.die(\"delete argument is not a HASH or ARRAY element or slice\");
        return this;
    }
    public PlObject set(PlObject o) {
        PlCORE.die(\"Modification of a read-only value attempted\");
        return this;
    }
    public PlObject get() {
        return PlCORE.die(\"error .get!\");
    }
    public PlObject mod(PlObject o) {
        return this.to_num().mod(o);
    }

", ((map {
            my $op = $_;
            "    public boolean " . $op . "() {
        return false;
    }
"
        } sort {;
            $a cmp $b
        } @boolean_unary)), "
    public boolean is_hash() {
        return false;
    }
    public boolean is_slice() {
        return false;
    }
    public boolean is_array() {
        return false;
    }
    public boolean is_lvalue() {
        return false;
    }
    public boolean is_tiedScalar() {
        return false;
    }
    public boolean is_regex_result() {
        return false;
    }
    public boolean is_integer_range() {
        return new PlDouble(this.to_double()).is_integer_range();
    }
    public PlObject tie(PlArray args) {
        if (this.is_lvalue()) {
            return ((PlLvalue)this).tie(args);
        }
        return PlCORE.die(\"Can't modify constant item in tie\");
    }
    public PlString ref() {
        return REF;
    }
    public PlObject refaddr() {
        // Scalar::Util::refaddr()
        return PlCx.UNDEF;
    }
    public PlObject reftype() {
        // Scalar::Util::reftype()
        return PlCx.UNDEF;
    }
    public PlObject refstring() {
        if (this.is_ref()) {
            StringBuilder sb = new StringBuilder();
            PlClass bless = this.blessed_class();
            if ( bless != null ) {
                sb.append(this.ref().toString());
                sb.append(\"=\");
            }
            sb.append(this.reftype().toString());
            sb.append(\"(0x\");
            sb.append(Integer.toHexString(this.refaddr().to_int()));
            sb.append(\")\");
            return new PlString(sb.toString());
        }
        return PlCx.EMPTY;
    }
    public PlObject blessed() {
        // Scalar::Util::blessed()
        return PlCx.UNDEF;
    }
    public PlObject tied() {
        return PlCx.UNDEF;
    }
    public PlObject _decr() {
        // --\$x
        return PlCx.MIN1;
    }
    public PlObject _incr() {
        // ++\$x
        return PlCx.INT1;
    }

    public PlObject op_int() {
        return new PlInt(this.to_long());
    }
    public PlObject neg() {
        return new PlInt(-this.to_long());
    }
    public PlObject complement() {
        long v = this.to_long();
        return new PlInt(v < 0 ? ~v : 4294967295L - v);
    }
    public PlObject abs() {
        long c = this.to_long();
        return new PlInt(c < 0 ? -c : c);
    }

    public PlObject sqrt() { return new PlDouble(Math.sqrt(this.to_double())); }
    public PlObject cos()  { return new PlDouble(Math.cos(this.to_double())); }
    public PlObject sin()  { return new PlDouble(Math.sin(this.to_double())); }
    public PlObject exp()  { return new PlDouble(Math.exp(this.to_double())); }
    public PlObject log()  { return new PlDouble(Math.log(this.to_double())); }
    public PlObject pow(PlObject arg)    { return new PlDouble(Math.pow(this.to_double(), arg.to_double()));   }
    public PlObject atan2(PlObject arg)  { return new PlDouble(Math.atan2(this.to_double(), arg.to_double())); }

    public PlObject pre_decr() {
        // --\$x
        PlCORE.die(\"Can't modify constant item in predecrement (--)\");
        return this;
    }
    public PlObject post_decr() {
        // \$x--
        PlCORE.die(\"Can't modify constant item in postdecrement (--)\");
        return this;
    }
    public PlObject pre_incr() {
        // ++\$x
        PlCORE.die(\"Can't modify constant item in preincrement (++)\");
        return this;
    }
    public PlObject post_incr() {
        // \$x++
        PlCORE.die(\"Can't modify constant item in postincrement (++)\");
        return this;
    }

    public PlObject lcfirst() {
        String s = this.toString();
        int len = s.length();
        if (len == 0) {
            return new PlString(s);
        }
        if (len == 1) {
            return new PlString(s.toLowerCase());
        }
        return new PlString( s.substring(0,1).toLowerCase() + s.substring(1) );
    }
    public PlObject ucfirst() {
        String s = this.toString();
        int len = s.length();
        if (len == 0) {
            return new PlString(s);
        }
        if (len == 1) {
            return new PlString(s.toUpperCase());
        }
        return new PlString( s.substring(0,1).toUpperCase() + s.substring(1) );
    }
    public PlObject quotemeta() {
        String s = this.toString();
        final int length = s.length();
        StringBuilder sb = new StringBuilder();
        for (int offset = 0; offset < length; offset++) {
            final int c = s.codePointAt(offset);
            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9')) {
                // good
            }
            else {
                sb.append(\"\\\\\");
            }
            sb.append(Character.toChars(c));
        }
        return new PlString(sb.toString());
    }
    public PlInt index(PlObject substr) {
        String s = this.toString();
        String s1 = substr.toString();
        return new PlInt(s.indexOf(s1));
    }
    public PlInt index(PlObject substr, PlObject position) {
        String s = this.toString();
        String s1 = substr.toString();
        int i = position.to_int();
        if (i < 0) {
            i = 0;
        }
        return new PlInt(s.indexOf(s1, i));
    }
    public PlInt rindex(PlObject substr) {
        String s = this.toString();
        String s1 = substr.toString();
        return new PlInt(s.lastIndexOf(s1));
    }
    public PlInt rindex(PlObject substr, PlObject position) {
        String s = this.toString();
        String s1 = substr.toString();
        int i = position.to_int();
        if (i < 0) {
            if (s1.length() == 0) {
                return PlCx.INT0;
            }
            return PlCx.MIN1;
        }
        return new PlInt(s.lastIndexOf(s1, i));
    }
    public PlObject substr(PlObject offset) {
        // substr EXPR,OFFSET
        String s = this.toString();
        int ofs = offset.to_int();
        if (ofs < 0) {
            ofs = s.length() + ofs;
        }
        if (ofs < 0) {
            ofs = 0;
        }
        if (ofs >= s.length()) {
            return PlCx.UNDEF;
        }
        return new PlString(s.substring(ofs));
    }
    public PlObject substr(PlObject offset, PlObject length) {
        // substr EXPR,OFFSET,LENGTH
        String s = this.toString();
        int ofs = offset.to_int();
        int len = length.to_int();
        if (ofs < 0) {
            ofs = s.length() + ofs;
        }
        if (ofs >= s.length()) {
            return PlCx.UNDEF;
        }

        if (len < 0) {
            len = s.length() + len;
        }
        else {
            len = ofs + len;
        }

        if (len >= s.length()) {
            len = s.length();
        }
        if (len <= 0) {
            return PlCx.UNDEF;
        }
        if (ofs < 0) {
            ofs = 0;
        }
        return new PlString(s.substring(ofs, len));
    }
    public PlObject substr(PlObject offset, PlObject length, PlObject replacement) {
        // substr EXPR,OFFSET,LENGTH,REPLACEMENT
        PlCORE.die(\"TODO substr EXPR,OFFSET,LENGTH,REPLACEMENT\");
        return this;
    }
    public PlObject bless(String className) {
        PlCORE.die(\"Can't bless non-reference value\");
        return this;
    }
    public PlClass blessed_class() {
        return null;
    }
    public PlObject scalar() {
        return this;
    }
    public PlObject str_cmp(PlObject b) {
        int c = this.toString().compareTo(b.toString());
        return (c == 0 ? PlCx.INT0 : c < 0 ? PlCx.MIN1 : PlCx.INT1);
    }
    public PlObject num_cmp(PlObject b) {
        return b.num_cmp2(this);
    }
    public PlObject num_cmp2(PlObject b) {
        Long blong = b.to_long();
        int c = blong.compareTo(this.to_long());
        return (c == 0 ? PlCx.INT0 : c < 0 ? PlCx.MIN1 : PlCx.INT1);
    }
", ((map {
            my $perl = $_;
            my $native = $number_binop{$perl}->{"op"};
            my $returns = $number_binop{$perl}->{"returns"};
            "    public PlObject " . $perl . "(PlObject s) {
        return s." . $perl . "2(this);
    }
" . ($returns eq "PlDouble" ? "    public PlObject " . $perl . "2(PlObject s) {
        return new " . $returns . "( s.to_double() " . $native . " this.to_double() );
    }
" : "    public PlObject " . $perl . "2(PlObject s) {
        return new " . $returns . "( s.to_long() " . $native . " this.to_long() );
    }
")
        } sort {;
            $a cmp $b
        } keys(%number_binop))), ((map {
            my $perl = $_;
            my $native = $string_binop{$perl}->{"op"};
            my $returns = $string_binop{$perl}->{"returns"};
            "    public PlObject " . $perl . "(PlObject b) {
        return new " . $returns . "(this.toString().compareTo(b.toString()) " . $native . " 0);
    }
"
        } sort {;
            $a cmp $b
        } keys(%string_binop))), "}
class PlReference extends PlObject {
    public static final PlString REF = new PlString(\"REF\");
    public PlClass bless;

    public boolean is_ref() {
        return true;
    }
    public PlReference bless(String className) {
        this.bless = PlClass.getInstance(className);
        return this;
    }
    public PlClass blessed_class() {
        return this.bless;
    }

    public PlString ref() {
        if ( this.bless == null ) {
            return this.REF;
        }
        else {
            return this.bless.plClassName();
        }
    }

    public PlInt refaddr() {
        // Scalar::Util::refaddr()
        return new PlInt(this.hashCode());
    }
    public PlObject blessed() {
        // Scalar::Util::blessed()
        if ( this.bless == null ) {
            return PlCx.UNDEF;
        }
        else {
            return this.bless.plClassName();
        }
    }
    public PlObject reftype() {
        // Scalar::Util::reftype()
        return REF;
    }

    // overload
    public String toString() {
        return PlClass.overload_to_string(this).toString();
    }
    public boolean to_boolean() {
        return PlClass.overload_to_boolean(this).to_boolean();
    }
    public PlObject to_num() {
        return PlClass.overload_to_number(this);
    }
    public long to_long() {
        return PlClass.overload_to_number(this).to_long();
    }
", ((map {
            my $perl = $_;
            "    public PlObject " . $perl . "2(PlObject s) {
        return PlClass.overload_" . $perl . "(this, s, PlCx.INT1);
    }
"
        } sort {;
            $a cmp $b
        } ("num_cmp", keys(%number_binop)))), ((map {
            my $op = $_;
            "    public PlObject " . $op . "() {
        return PlClass.overload_" . $op . "(this);
    }
"
        } sort {;
            $a cmp $b
        } @number_unary)), ((map {
            my $perl = $_;
            "    public PlObject " . $perl . "(PlObject s) {
        return PlClass.overload_" . $perl . "(this, s, PlCx.UNDEF);
    }
"
        } sort {;
            $a cmp $b
        } ("str_cmp", "pow", "atan2", "mod", "num_cmp", keys(%string_binop), keys(%number_binop)))), "}
class PlGlobRef extends PlReference {
    public static final PlString REF = new PlString(\"GLOB\");
    public PlFileHandle filehandle;

    public PlGlobRef(PlFileHandle filehandle) {
        this.filehandle = filehandle;
    }
    public PlGlobRef(PlLvalue v) {
        PlObject o = v.get();
        this.filehandle = (PlFileHandle)o;
    }
    public PlGlobRef(PlObject o) {
        this.filehandle = (PlFileHandle)o;
    }
    public boolean is_typeglobref() {
        return true;
    }
}

class PlStringReader extends Reader{
    // read from string
    String s;
    int pos;
    int mark;

    PlStringReader(PlObject o) {
        this.s = o.toString();
        this.pos = 0;
        this.mark = 0;
    }
    public int read(char[] cbuf, int off, int len) {
        if (pos >= s.length()) {
            return -1;
        }
        len = Math.min(len, s.length() - pos);
        int count = 0;
        while (count < len) {
            cbuf[off++] = s.charAt(pos++);
            count++;
        }
        return count;
    }

    public boolean markSupported() {
        return true;
    }
    public void mark(int readlimit) {
        mark = pos;
        return;
    }
    public void reset() {
        pos = mark;
    }
    public void close() {
        return;
    }
}

class PlFileHandle extends PlReference {
    public static final PlString REF = new PlString(\"GLOB\");
    public String typeglob_name;
    public PrintStream outputStream;    // System.out, System.err
    public InputStream inputStream;     // System.in
    public Iterator<Path> directoryIterator;
    public DirectoryStream<Path> directoryStream;
    public Reader reader;       // Console.reader
    public StringBuilder readlineBuffer;
    public boolean eof;
    public boolean is_argv;

    public PlFileHandle() {
        this.readlineBuffer = new StringBuilder();
        this.eof = true;
        this.is_argv = false;
    }

    public boolean is_filehandle() {
        return true;
    }

    public PlObject hget(String i) {
        // *{ \$name }{CODE}->()

        if (i.equals(\"CODE\")) {
            return PlV.cget(typeglob_name);
        }
        return PlCx.UNDEF;
    }
    public PlObject hset(String s, PlObject v) {
        return PlCORE.die(\"Can't modify glob elem in scalar assignment\");
    }
}

", "
class PlRegex extends PlReference {
    public Pattern p;
    public String  original_string;
    // public Matcher m;
    public boolean flag_xx;
    public static final PlString REF = new PlString(\"Regexp\");

    public PlRegex(String p, int flags, boolean flag_xx) {
        this.flag_xx = flag_xx;
        this.p = Pattern.compile(PerlOp.regex_escape(p, flag_xx), flags);
    }
    public PlRegex(PlObject p, int flags, boolean flag_xx) {
        if (p.is_lvalue()) {
            p = p.get();
        }
        if (p.is_regex()) {
            this.p = ((PlRegex)p).p;    // reuse compiled regex; ignore any difference in flags
        }
        else {
            this.flag_xx = flag_xx;
            this.p = Pattern.compile(PerlOp.regex_escape(p.toString(), flag_xx), flags);
        }
    }
    public String toString() {
        if (original_string == null) {

            int flags = p.flags();
            StringBuilder sb = new StringBuilder();
            sb.append(\"(?\");

            if ((flags & Pattern.CASE_INSENSITIVE) != 0)
                sb.append(\"i\");
            if ((flags & Pattern.COMMENTS) != 0)
                sb.append(\"x\");
            if ((flags & Pattern.DOTALL) != 0)
                sb.append(\"s\");
            if ((flags & Pattern.MULTILINE) != 0)
                sb.append(\"m\");

            sb.append(\"-\");

            if ((flags & Pattern.CASE_INSENSITIVE) == 0)
                sb.append(\"i\");
            if ((flags & Pattern.COMMENTS) == 0)
                sb.append(\"x\");
            if (flag_xx) {
                sb.append(\"x\");
            }
            if ((flags & Pattern.DOTALL) == 0)
                sb.append(\"s\");
            if ((flags & Pattern.MULTILINE) == 0)
                sb.append(\"m\");

            sb.append(\":\");
            sb.append(p.toString());
            sb.append(\")\");
            original_string = sb.toString();
 
            // TODO - show flags
            // Pattern.CANON_EQ
            // Pattern.LITERAL
            // Pattern.UNICODE_CASE
            // Pattern.UNICODE_CHARACTER_CLASS
            // Pattern.UNIX_LINES
        }
        return this.original_string;
    }
    public boolean is_regex() {
        return true;
    }
}
class PlRegexResult extends PlObject {
    public Matcher matcher;      // regex captures
    public String  regex_string; // last string used in a regex

    public boolean is_regex_result() {
        return true;
    }
}
class PlClosure extends PlReference implements Runnable {
    public PlObject[] env;       // new PlObject[]{ v1, v2, v3 }
    public PlObject prototype;   // '\$\$\$'
    public String pkg_name;      // 'main'
    public static final PlString REF = new PlString(\"CODE\");
    public PlClosure currentSub;

    public PlClosure(PlObject prototype, PlObject[] env, String pkg_name) {
        this.prototype = prototype;
        this.env = env;
        this.pkg_name = pkg_name;
        this.currentSub = this;
    }
    public PlClosure(PlObject prototype, PlObject[] env, String pkg_name, PlClosure currentSub) {
        // this is the constructor for do-BLOCK; currentSub points to the \"sub\" outside
        this.prototype = prototype;
        this.env = env;
        this.pkg_name = pkg_name;
        this.currentSub = currentSub;
    }

    public PlClosure getCurrentSub() {
        return this.currentSub;
    }

    // Note: apply() is inherited from PlObject
    public PlObject apply(int want, PlArray List__) {
        PlCORE.die(\"it looks like you have a closure without a block\");
        return this;
    }
    public void run() {
        // run as a thread
        this.apply(PlCx.VOID, new PlArray());
    }
    public PlString ref() {
        if ( this.bless == null ) {
            return REF;
        }
        else {
            return this.bless.plClassName();
        }
    }
    public PlObject reftype() {
        return REF;
    }
    public boolean is_coderef() {
        return true;
    }
    public PlObject prototype() {
        return this.prototype;
    }
}
class PlLvalueRef extends PlReference {
    private PlObject o;
    public static final PlString REF = new PlString(\"SCALAR\");
    public static final PlString REF_REF = new PlString(\"REF\");

    public PlString ref() {
        if ( this.bless == null ) {
            if ( this.o.is_ref() ) {
                return REF_REF;
            }
            return REF;
        }
        else {
            return this.bless.plClassName();
        }
    }
    public PlInt refaddr() {
        // Scalar::Util::refaddr()
        int id = System.identityHashCode(this.o);
        return new PlInt(id);
    }
    public PlLvalueRef(PlLvalue o) {
        this.o = o;
    }
    public PlLvalueRef(PlObject o) {
        this.o = o;
    }
    public PlLvalueRef(String o) {
        this.o = new PlString(o);
    }
    public PlObject scalar_deref_lvalue(String namespace) {
        return this.o;
    }
    public PlObject scalar_deref(String namespace) {
        return this.o;
    }
    public PlObject scalar_deref_strict() {
        return this.o;
    }
    public PlObject scalar_deref_set(String namespace, PlObject v) {
        return this.o.set(v);
    }
    public boolean is_scalarref() {
        return true;
    }
}
class PlArrayRef extends PlReference {
    public static final PlString REF = new PlString(\"ARRAY\");
    public PlArray ar;

    public PlArrayRef() {
        this.ar = new PlArray();
    }
    public PlArrayRef(PlArray o) {
        this.ar = o;
    }
    public PlArrayRef(PlObject o) {
        this.ar = (PlArray)o;
    }
    public PlObject set(PlArray o) {
        this.ar = o;
        return o;
    }
    public PlArray array_deref_lvalue() {
        return this.ar;
    }
    public PlArray array_deref() {
        return this.ar;
    }
    public PlArray array_deref_strict() {
        return this.ar;
    }
    public PlObject array_deref_set(PlObject v) {
        this.ar.set(v);
        return v;
    }
    public boolean is_arrayref() {
        return true;
    }
    public PlString ref() {
        if ( this.bless == null ) {
            return REF;
        }
        else {
            return this.bless.plClassName();
        }
    }
    public PlObject reftype() {
        return REF;
    }

    public PlObject aget(int i) {
        return this.ar.aget(i);
    }
    public PlObject aget(PlObject i) {
        return this.ar.aget(i);
    }
    public PlObject aget_lvalue(int i) {
        return this.ar.aget_lvalue(i);
    }
    public PlObject aget_lvalue(PlObject i) {
        return this.ar.aget_lvalue(i);
    }
    public PlObject aget_scalarref(int i) {
        return this.ar.aget_scalarref(i);
    }
    public PlObject aget_hashref(int i) {
        return this.ar.aget_hashref(i);
    }
    public PlObject aget_arrayref(int i) {
        return this.ar.aget_arrayref(i);
    }
    public PlObject aset(int i, PlObject v) {
        return this.ar.aset(i, v);
    }
    public PlObject aset(PlObject i, PlObject v) {
        return this.ar.aset(i, v);
    }
 
    public PlObject exists(PlObject i) {
        return this.ar.exists(i);
    }
    public PlObject delete(int want, PlObject i) {
        return this.ar.delete(want, i);
    }
    public PlObject values() {
        return this.ar.values();
    }
    public PlObject keys() {
        return this.ar.keys();
    }
    public PlObject each() {
        return this.ar.each();
    }
}

class PlHashRef extends PlReference {
    public static final PlString REF = new PlString(\"HASH\");
    public PlHash ha;

    public PlHashRef() {
        this.ha = new PlHash();
    }
    public PlHashRef(PlHash o) {
        this.ha = o;
    }
    public PlHashRef(PlObject o) {
        this.ha = (PlHash)o;
    }
    public boolean is_hashref() {
        return true;
    }
    public PlString ref() {
        if ( this.bless == null ) {
            return REF;
        }
        else {
            return this.bless.plClassName();
        }
    }
    public PlObject reftype() {
        return REF;
    }

    public PlObject set(PlHash o) {
        this.ha = o;
        return o;
    }
    public PlHash hash_deref() {
        return this.ha;
    }
    public PlHash hash_deref_strict() {
        return this.ha;
    }
    public PlObject hash_deref_set(PlObject v) {
        this.ha.set(v);
        return v;
    }

    public PlObject hget(PlObject i) {
        return this.ha.hget(i);
    }
    public PlObject hget(String i) {
        return this.ha.hget(i);
    }

    public PlObject hget_lvalue(String i) {
        return this.ha.hget_lvalue(i);
    }
    public PlObject hget_lvalue_local(String i) {
        return this.ha.hget_lvalue_local(i);
    }

    public PlObject hget_scalarref(String i) {
        return this.ha.hget_scalarref(i);
    }

    public PlObject hget_arrayref(PlObject i) {
        return this.ha.hget_arrayref(i);
    }
    public PlObject hget_arrayref(String i) {
        return this.ha.hget_arrayref(i);
    }

    public PlObject hget_hashref(PlObject i) {
        return this.ha.hget_hashref(i);
    }
    public PlObject hget_hashref(String i) {
        return this.ha.hget_hashref(i);
    }

    public PlObject hset(PlObject i, PlObject v) {
        return this.ha.hset(i, v);
    }
    public PlObject hset(String i, PlObject v) {
        return this.ha.hset(i, v);
    }
    public PlObject hset(PlObject i, PlLvalue v) {
        return this.ha.hset(i, v);
    }
    public PlObject hset(String i, PlLvalue v) {
        return this.ha.hset(i, v);
    }
    public PlObject hset(int want, PlArray i, PlArray v) {
        return this.ha.hset(want, i, v);
    }
    public PlObject hset_alias(String i, PlObject v) {
        return this.ha.hset_alias(i, v);
    }
    public PlObject exists(PlObject i) {
        return this.ha.exists(i);
    }
    public PlObject delete(PlObject i) {
        return this.ha.delete(i);
    }
    public PlObject delete(int want, PlArray a) {
        return this.ha.delete(want, a);
    }
    public PlObject delete(int want, PlString a) {
        return this.ha.delete(want, a);
    }
    public PlObject delete(int want, PlLvalue a) {
        return this.ha.delete(want, a);
    }
    public PlObject values() {
        return this.ha.values();
    }
    public PlObject keys() {
        return this.ha.keys();
    }
    public PlObject each() {
        return this.ha.each();
    }
}
class PlClass {
    public static HashMap<String, PlClass> classes = new HashMap<String, PlClass>();
    public String className;
    public PlString plClassName;
    public Boolean overload_flag;
    public Boolean overload_fallback_flag;

    protected PlClass(String s) {
        this.className = s;
        this.plClassName = new PlString(s);
        this.overload_flag = null;
        this.overload_fallback_flag = null;
    }
    public static PlClass getInstance(PlObject s) {
        return PlClass.getInstance(s.toString());
    }
    public static PlClass getInstance(String s) {
        if (!classes.containsKey(s)) {
            PlClass c = new PlClass(s);
            classes.put(s, c);
            return c;
        }
        return classes.get(s);
    }
    public String className() {
        return this.className;
    }
    public PlString plClassName() {
        return this.plClassName;
    }
    public boolean is_undef() {
        return this.className == null;
    }
    public Boolean is_overloaded() {
        if (this.overload_flag == null) {
            PlObject methodCode1 = this.method_lookup(\"((\", 0);
            PlObject methodCode2 = this.method_lookup(\"()\", 0);
            this.overload_flag = methodCode1.is_coderef() || methodCode2.is_coderef();
        }
        return this.overload_flag;
    }
    public Boolean is_overload_fallback() {
        if (this.overload_fallback_flag == null) {
            PlObject methodCode = this.method_lookup(\"()\", 0);
            this.overload_fallback_flag = methodCode.is_coderef();
        }
        return this.overload_fallback_flag;
    }

    public PlObject method_lookup(String method, int level) {
        PlObject methodCode;
        if (method.indexOf(\"::\") != -1) {
            // fully qualified method name
            return PlV.cget(method);
        }
        methodCode = PlV.cget_no_autoload(className + \"::\" + method);
        if (methodCode.is_undef()) {
            // method not found

            // lookup in AUTOLOAD
            methodCode = PlV.cget_no_autoload(className + \"::AUTOLOAD\");
            if (!methodCode.is_undef()) {
                if (method.charAt(0) == '('     // \"overload\" methods
                 || method.equals(\"import\")
                 || method.equals(\"unimport\")
                 || method.equals(\"isa\")
                 || method.equals(\"can\")
                ) {
                    // overload method - TODO
                }
                else {
                    PlV.sset(className + \"::AUTOLOAD\", new PlString(className + \"::\" + method));
                    return methodCode;
                }
            }

            // lookup in \@ISA
            for (PlObject className : PlV.array_get(className + \"::ISA\")) {
                // prevent infinite loop
                if (level >= 100) {
                    PlCORE.die(\"Recursive inheritance detected in package '\" + className + \"'\");
                }
                methodCode = PlClass.getInstance(className).method_lookup(method, level+1);
                if (!methodCode.is_undef()) {
                    // found
                    return methodCode;
                }
            }

            // lookup in UNIVERSAL
            methodCode = PlV.cget_no_autoload(\"UNIVERSAL::\" + method);
        }
        return methodCode;
    }
    public PlObject isa(String s, int level) {
        if (className.equals(s)) {
            return PlCx.INT1;
        }

        // lookup in \@ISA
        for (PlObject isa_item : PlV.array_get(className + \"::ISA\")) {
            String className = isa_item.toString();
            // prevent infinite loop
            if (level >= 100) {
                PlCORE.die(\"Recursive inheritance detected in package '\" + className.toString() + \"'\");
            }
            PlObject is = PlClass.getInstance(className).isa(s, level+1);
            if (is.to_boolean()) {
                return is;
            }
        }

        // lookup in UNIVERSAL
        if (s.equals(\"UNIVERSAL\")) {
            return PlCx.INT1;
        }
        return PlCx.UNDEF;
    }
", "    public static PlObject overload_to_string(PlObject o) {
        PlClass bless = o.blessed_class();
        if ( bless != null && bless.is_overloaded() ) {
            for (String ovl : new String[] { PlCx.OVERLOAD_STRING, PlCx.OVERLOAD_NUM, PlCx.OVERLOAD_BOOL }) {
                PlObject methodCode = bless.method_lookup(ovl, 0);
                if (methodCode.is_coderef()) {
                    return methodCode.apply(PlCx.SCALAR, new PlArray(o));
                }
                if (!bless.is_overload_fallback()) {
                    break;
                }
            }
        }
        return o.refstring();
    }
    public static PlObject overload_to_number(PlObject o) {
        PlClass bless = o.blessed_class();
        if ( bless != null && bless.is_overloaded() ) {
            for (String ovl : new String[] { PlCx.OVERLOAD_NUM, PlCx.OVERLOAD_STRING, PlCx.OVERLOAD_BOOL }) {
                PlObject methodCode = bless.method_lookup(ovl, 0);
                if (methodCode.is_coderef()) {
                    return methodCode.apply(PlCx.SCALAR, new PlArray(o));
                }
                if (!bless.is_overload_fallback()) {
                    break;
                }
            }
        }
        return o.refaddr();
    }
    public static PlObject overload_to_boolean(PlObject o) {
        PlClass bless = o.blessed_class();
        if ( bless != null && bless.is_overloaded() ) {
            for (String ovl : new String[] { PlCx.OVERLOAD_BOOL, PlCx.OVERLOAD_NUM, PlCx.OVERLOAD_STRING }) {
                PlObject methodCode = bless.method_lookup(ovl, 0);
                if (methodCode.is_coderef()) {
                    return methodCode.apply(PlCx.SCALAR, new PlArray(o));
                }
                if (!bless.is_overload_fallback()) {
                    break;
                }
            }
        }
        return PlCx.TRUE;
    }
", ((map {
            my $perl = $_;
            my $native;
            exists($number_binop{$perl}) && ($native = $number_binop{$perl}->{"op"});
            $perl eq "num_cmp" && ($native = "<=>");
            $perl eq "pow" && ($native = "**");
            $perl eq "atan2" && ($native = "atan2");
            $perl eq "mod" && ($native = "%");
            $perl eq "int_shr" && ($native = ">>");
            "    public static PlObject overload_" . $perl . "(PlObject o, PlObject other, PlObject swap) {
        PlClass bless = o.blessed_class();
        if ( bless != null && bless.is_overloaded() ) {
            PlObject methodCode = bless.method_lookup(\"(" . $native . "\", 0);
            if (methodCode.is_coderef()) {
                return methodCode.apply(PlCx.SCALAR, new PlArray(o, other, swap));
            }
            if (bless.is_overload_fallback()) {
                o = PlClass.overload_to_number(o);
            }
            else {
                o = o.refaddr();
            }
        }
        else {
            o = o.refaddr();
        }
        if (swap.to_boolean()) {
            return other." . $perl . "(o);
        }
        return o." . $perl . "(other);
    }
"
        } sort {;
            $a cmp $b
        } ("num_cmp", "pow", "atan2", "mod", keys(%number_binop)))), ((map {
            my $perl = $_;
            $native = $perl;
            $perl eq "op_int" && ($native = "int");
            $perl eq "complement" && ($native = "~");
            "    public static PlObject overload_" . $perl . "(PlObject o) {
        PlClass bless = o.blessed_class();
        if ( bless != null && bless.is_overloaded() ) {
            PlObject methodCode = bless.method_lookup(\"(" . $native . "\", 0);
            if (methodCode.is_coderef()) {
                return methodCode.apply(PlCx.SCALAR, new PlArray(o));
            }
            if (bless.is_overload_fallback()) {
                o = PlClass.overload_to_number(o);
            }
            else {
                o = o.refaddr();
            }
        }
        else {
            o = o.refaddr();
        }
        return o." . $perl . "();
    }
"
        } sort {;
            $a cmp $b
        } @number_unary)), ((map {
            my $perl = $_;
            my $native;
            exists($string_binop{$perl}) && ($native = $string_binop{$perl}->{"str_op"});
            $perl eq "str_cmp" && ($native = "cmp");
            "    public static PlObject overload_" . $perl . "(PlObject o, PlObject other, PlObject swap) {
        PlClass bless = o.blessed_class();
        if ( bless != null && bless.is_overloaded() ) {
            PlObject methodCode = bless.method_lookup(\"(" . $native . "\", 0);
            if (methodCode.is_coderef()) {
                return methodCode.apply(PlCx.SCALAR, new PlArray(o, other, swap));
            }
            if (bless.is_overload_fallback()) {
                o = PlClass.overload_to_string(o);
            }
            else {
                o = o.refstring();
            }
        }
        else {
            o = o.refstring();
        }
        if (swap.to_boolean()) {
            return other." . $perl . "(o);
        }
        return o." . $perl . "(other);
    }
"
        } sort {;
            $a cmp $b
        } ("str_cmp", keys(%string_binop)))), "}
class PlLazyIndex extends PlLazyLvalue {
    private PlArray la;    // \@la
    private int i;         // \$la[\$i]

    public PlLazyIndex(PlArray la, int i) {
        this.la = la;
        this.i  = i;
    }

    // internal lazy api
    public PlLvalue create_scalar() {
        if (llv == null) {
            llv = la.create_scalar(i);
        }
        return llv;
    }

}
class PlLazyTiedLookup extends PlLazyLvalue {
    private PlHash la;    // %la
    private String i;     // \$la{\$i}

    public PlLazyTiedLookup(PlHash la, String i) {
        this.la = la;
        this.i  = i;
    }

    // internal lazy api
    public PlLvalue create_scalar() {
        if (llv == null) {
            llv = la.create_scalar(i);
        }
        return llv;
    }

    public PlObject get() {
        return la.hget(i);
    }

    public PlObject set(PlObject o) {
        la.hset(i, o);
        return this;
    }

    public PlObject pre_decr() {
        // --\$x
        PlObject o = this.get()._decr();
        return this.set(o);
    }
    public PlObject post_decr() {
        // \$x--
        PlObject o = this.get();
        this.set(o._decr());
        return o;
    }
    public PlObject pre_incr() {
        // ++\$x
        PlObject o = this.get()._incr();
        return this.set(o);
    }
    public PlObject post_incr() {
        // \$x++
        PlObject o = this.get();
        this.set(o._incr());
        return o;
    }


}
class PlLazyLookup extends PlLazyLvalue {
    private PlHash la;    // %la
    private String i;     // \$la{\$i}

    public PlLazyLookup(PlHash la, String i) {
        this.la = la;
        this.i  = i;
    }

    // internal lazy api
    public PlLvalue create_scalar() {
        if (llv == null) {
            llv = la.create_scalar(i);
        }
        return llv;
    }

}
class PlLazyScalarref extends PlLazyLvalue {
    private PlLvalue lv;    // \$lv

    public PlLazyScalarref(PlLvalue lv) {
        this.lv = lv;
    }

    // internal lazy api
    public PlLvalue create_scalar() {
        if (this.llv == null) {
            PlLvalue s = new PlLvalue();
            lv.create_scalar().set(new PlLvalueRef(s));
            this.llv = s;
        }
        return this.llv;
    }
}

class PlTieScalar extends PlObject {
    public PlObject tied;
    public PlObject old_var;

    public PlTieScalar() {
    }
    public boolean is_tiedScalar() {
        return true;
    }
    public PlObject tied() {
        return tied;
    }

    public PlObject get() {
        PlObject v = PerlOp.call(tied, \"FETCH\", new PlArray(), PlCx.VOID);
        old_var = v;
        return v;
    }

    public PlObject set(PlObject o) {
        PerlOp.call(tied, \"STORE\", new PlArray(o), PlCx.VOID);
        return this;
    }
    public PlObject set(PlString o) {
        PerlOp.call(tied, \"STORE\", new PlArray(o), PlCx.VOID);
        return this;
    }
    public PlObject set(PlInt o) {
        PerlOp.call(tied, \"STORE\", new PlArray(o), PlCx.VOID);
        return this;
    }
}
class PlLazyLvalue extends PlLvalue {
    public  PlLvalue llv;   // \$\$lv

    public PlLazyLvalue() {
    }

    public PlLvalue create_scalar() {
        return (PlLvalue)PlCORE.die(\"internal error: called PlLazyLvalue.create_scalar()\");
    }

    public PlObject get() {
        if (llv == null) {
            return PlCx.UNDEF;
        }
        return llv.get();
    }

    // Note: several versions of set()
    public PlObject set(PlObject o) {
        if (llv == null) {
            create_scalar();
        }
        return llv.set(o);
    }
    public PlObject set(PlString o) {
        if (llv == null) {
            create_scalar();
        }
        return llv.set(o);
    }
    public PlObject set(PlInt o) {
        if (llv == null) {
            create_scalar();
        }
        return llv.set(o);
    }
}
class PlLvalue extends PlObject {
    public PlObject o;
    public Integer pos;
    public boolean regex_zero_length_flag;

    // Note: several versions of PlLvalue()
    public PlLvalue() {
        this.o = PlCx.UNDEF;
    }
    public PlLvalue(PlObject o) {
        this.o = o;
    }
    public PlLvalue(PlLvalue o) {
        this.o = o.get();
    }
    public PlLvalue(PlArray o) {
        // \$a = \@x
        this.o = o.scalar();
    }
    public PlLvalue(PlHash o) {
        // \$a = %x
        this.o = o.scalar();
    }

    // tie scalar
    public PlObject tie(PlArray args) {
        if (this.o.is_tiedScalar()) {
            this.untie();
        }
        PlTieScalar v = new PlTieScalar();
        PlObject class_name = args.shift();
        PlObject self = PerlOp.call(class_name.toString(), \"TIESCALAR\", args, PlCx.VOID);
        v.tied = self;
        v.old_var = this.o;
        this.o = v;
        return self;
    }

    public PlObject untie() {
        if (this.o.is_tiedScalar()) {
            PlObject tied = this.o.tied();
            PlObject untie = PerlOp.call(tied, \"can\", new PlArray(new PlString(\"UNTIE\")), PlCx.SCALAR);
            if (untie.to_boolean()) {
                untie.apply(PlCx.VOID, new PlArray(tied));
            };
            this.o = ((PlTieScalar)o).old_var;
            return tied;
        }
        return this;
    }
    public PlObject tied() {
        if (this.o.is_tiedScalar()) {
            return o.tied();
        }
        return PlCx.UNDEF;
    }
 
    // internal lazy api
    public PlLvalue create_scalar() {
        if (this.o.is_undef()) {
            PlLvalue llv = new PlLvalue();
            this.set(new PlLvalueRef(llv));
            return llv;
        }
        else if (this.o.is_scalarref()) {
            return (PlLvalue)this.o.scalar_deref(\"main\");
        }
        return (PlLvalue)PlCORE.die(\"Not a SCALAR reference\");
    }

    public PlObject get() {
        if (this.o.is_tiedScalar()) {
            return this.o.get();
        }
        return this.o;
    }
    public PlObject get_scalarref() {
        PlObject o = this.get();
        if (o.is_undef()) {
            PlLvalueRef ar = new PlLvalueRef(new PlLvalue());
            this.set(ar);
            return ar;
        }
        else if (o.is_scalarref()) {
            return o;
        }
        // Modification of a read-only value attempted
        return o;
    }
    public PlObject get_arrayref() {
        PlObject o = this.get();
        if (o.is_undef()) {
            PlArrayRef ar = new PlArrayRef();
            this.set(ar);
            return ar;
        }
        else if (o.is_arrayref()) {
            return o;
        }
        return PlCORE.die(\"Not an ARRAY reference\");
    }
    public PlObject get_hashref() {
        PlObject o = this.get();
        if (o.is_undef()) {
            PlHashRef hr = new PlHashRef();
            this.set(hr);
            return hr;
        }
        else if (o.is_hashref()) {
            return o;
        }
        return PlCORE.die(\"Not a HASH reference\");
    }
    public PlObject aget(PlObject i) {
        PlObject o = this.get();
        if (o.is_undef()) {
            o = this.set(new PlArrayRef());
        }
        return o.aget(i);
    }
    public PlObject aget(int i) {
        PlObject o = this.get();
        if (o.is_undef()) {
            o = this.set(new PlArrayRef());
        }
        return o.aget(i);
    }

    public PlObject aget_scalarref(int i) {
        PlObject o = this.get();
        if (o.is_undef()) {
            o = this.set(new PlArrayRef());
        }
        return o.aget_scalarref(i);
    }
    public PlObject aget_arrayref(int i) {
        PlObject o = this.get();
        if (o.is_undef()) {
            o = this.set(new PlArrayRef());
        }
        return o.aget_arrayref(i);
    }
    public PlObject aget_lvalue(int pos) {
        PlObject o = this.get();
        if (o.is_undef()) {
            o = this.set(new PlArrayRef());
        }
        return o.aget_lvalue(pos);
    }
    public PlObject aget_hashref(int i) {
        PlObject o = this.get();
        if (o.is_undef()) {
            o = this.set(new PlArrayRef());
        }
        return o.aget_hashref(i);
    }

    public PlObject aset(int i, PlObject v) {
        PlObject o = this.get();
        if (o.is_undef()) {
            o = this.set(new PlArrayRef());
        }
        return o.aset(i, v);
    }
    public PlObject aset(PlObject i, PlObject v) {
        PlObject o = this.get();
        if (o.is_undef()) {
            o = this.set(new PlArrayRef());
        }
        return o.aset(i, v);
    }
    public PlObject hget(PlObject i) {
        PlObject o = this.get();
        if (o.is_undef()) {
            o = this.set(new PlHashRef());
        }
        return o.hget(i);
    }
    public PlObject hget(String i) {
        PlObject o = this.get();
        if (o.is_undef()) {
            o = this.set(new PlHashRef());
        }
        return o.hget(i);
    }
    public PlObject hget_lvalue(String i) {
        PlObject o = this.get();
        if (o.is_undef()) {
            o = this.set(new PlHashRef());
        }
        return o.hget_lvalue(i);
    }

    public PlObject hget_scalarref(String i) {
        PlObject o = this.get();
        if (o.is_undef()) {
            o = this.set(new PlHashRef());
        }
        return o.hget_scalarref(i);
    }
    public PlObject hget_arrayref(String i) {
        PlObject o = this.get();
        if (o.is_undef()) {
            o = this.set(new PlHashRef());
        }
        return o.hget_arrayref(i);
    }
    public PlObject hget_arrayref(PlObject i) {
        PlObject o = this.get();
        if (o.is_undef()) {
            o = this.set(new PlHashRef());
        }
        return o.hget_arrayref(i);
    }
    public PlObject hget_hashref(String i) {
        PlObject o = this.get();
        if (o.is_undef()) {
            o = this.set(new PlHashRef());
        }
        return o.hget_hashref(i);
    }
    public PlObject hget_hashref(PlObject i) {
        PlObject o = this.get();
        if (o.is_undef()) {
            o = this.set(new PlHashRef());
        }
        return o.hget_hashref(i);
    }

    public PlObject hset(PlObject s, PlObject v) {
        PlObject o = this.get();
        if (o.is_undef()) {
            o = this.set(new PlHashRef());
        }
        return o.hset(s, v);
    }
    public PlObject hset(String s, PlObject v) {
        PlObject o = this.get();
        if (o.is_undef()) {
            o = this.set(new PlHashRef());
        }
        return o.hset(s, v);
    }

    public PlObject scalar_deref(String namespace) {
        PlObject o = this.get();
        if (o.is_undef()) {
            return new PlLazyScalarref(this);
        }
        return o.scalar_deref(namespace);
    }
    public PlObject scalar_deref_strict() {
        PlObject o = this.get();
        return o.scalar_deref_strict();
    }
    public PlObject scalar_deref_lvalue(String namespace) {
        PlObject o = this.get();
        if (o.is_undef()) {
            PlLvalue lv = new PlLvalue();
            this.set(new PlLvalueRef(lv));
            return lv;
        }
        return o.scalar_deref_lvalue(namespace);
    }
    public PlObject scalar_deref_set(String namespace, PlObject v) {
        PlObject o = this.get();
        if (o.is_undef()) {
            PlLvalueRef ar = new PlLvalueRef(new PlLvalue());
            this.set(ar);
        }
        return o.scalar_deref_set(namespace, v);
    }

    public PlArray array_deref() {
        // \@\$x doesn't autovivify
        PlObject o = this.get();
        if (o.is_undef()) {
            return new PlArray();
        }
        else if (o.is_arrayref()) {
            return (PlArray)(o.array_deref());
        }
        return o.array_deref();
    }
    public PlArray array_deref_strict() {
        // \@\$x doesn't autovivify
        PlObject o = this.get();
        return (PlArray)(o.array_deref_strict());
    }
    public PlArray array_deref_lvalue() {
        PlObject o = this.get();
        if (o.is_undef()) {
            PlArrayRef ar = new PlArrayRef();
            this.set(ar);
            return (PlArray)(ar.array_deref_lvalue());
        }
        else if (o.is_arrayref()) {
            return (PlArray)(o.array_deref_lvalue());
        }
        return o.array_deref();
    }
    public PlObject array_deref_set(PlObject v) {
        // \@\$x = ...
        PlObject o = this.get();
        if (o.is_undef()) {
            this.set(new PlArrayRef());
            return o.array_deref_set(v);
        }
        else if (o.is_arrayref()) {
            return o.array_deref_set(v);
        }
        return o.array_deref_set(v);
    }

    public PlObject hash_deref() {
        // %\$x doesn't autovivify
        PlObject o = this.get();
        if (o.is_undef()) {
            return new PlHash();
        }
        else if (o.is_hashref()) {
            return o.hash_deref();
        }
        return o.hash_deref();
    }
    public PlObject hash_deref_strict() {
        // %\$x doesn't autovivify
        PlObject o = this.get();
        return o.hash_deref_strict();
    }
    public PlObject hash_deref_set(PlObject v) {
        // %\$x = ...
        PlObject o = this.get();
        if (o.is_undef()) {
            this.set(new PlHashRef());
            return o.hash_deref_set(v);
        }
        else if (o.is_hashref()) {
            return o.hash_deref_set(v);
        }
        return o.hash_deref_set(v);
    }

    // Note: several versions of set()
    public PlObject set(PlObject o) {
        if (o == null) {
            o = PlCx.UNDEF;
        }
        if (o.is_lvalue()) {
            o = o.get();
        }
        if (this.o.is_tiedScalar()) {
            ((PlTieScalar)this.o).set(o);
            return this;
        }
        this.o = o;
        return this;
    }
    public PlObject set(PlString o) {
        if (this.o.is_tiedScalar()) {
            ((PlTieScalar)this.o).set(o);
            return this;
        }
        this.o = o;
        return this;
    }
    public PlObject set(PlInt o) {
        if (this.o.is_tiedScalar()) {
            ((PlTieScalar)this.o).set(o);
            return this;
        }
        this.o = o;
        return this;
    }

    public PlObject set(PlLvalue o) {
        return this.set(o.get());
    }
    public PlObject set(PlArray o) {
        // \$a = \@x
        return this.set(o.scalar());
    }
    public PlObject set(PlHash o) {
        // \$a = %x
        return this.set(o.scalar());
    }
", ((map {
            my $native = $_;
            my $perl = $native_to_perl{$native};
            $native && $perl ? "    public PlObject set(" . $native . " s) {
        this.set(new " . $perl . "(s));
        return this;
    }
" : ()
        } sort {;
            $a cmp $b
        } keys(%native_to_perl))), "    public PlObject apply(int want, PlArray List__) {
        return this.get().apply(want, List__);
    }
    public PlObject exists(PlObject a) {
        // exists \$v->{\$a}
        return this.get().exists(a);
    }
    public PlObject delete(PlObject a) {
        // delete \$v->{\$a}
        return this.get().delete(a);
    }
    public boolean is_lvalue() {
        return true;
    }

    public PlObject pre_decr() {
        // --\$x
        PlObject res = this.get();
        if (res.is_ref()) {
            // TODO - check if overload \"--\"
        }
        return this.set(res._decr());
    }
    public PlObject post_decr() {
        // \$x--
        PlObject res = this.get();
        if (res.is_ref()) {
            // TODO - check if overload \"--\"
        }
        this.set(res._decr());
        return res;
    }
    public PlObject pre_incr() {
        // ++\$x
        PlObject res = this.get();
        if (res.is_ref()) {
            // TODO - check if overload \"++\"
        }
        return this.set(res._incr());
    }
    public PlObject post_incr() {
        // \$x++
        PlObject res = this.get();
        if (res.is_ref()) {
            // TODO - check if overload \"++\"
        }
        if (res.is_undef()) {
            res = PlCx.INT0;
        }
        this.set(res._incr());
        return res;
    }
    public PlObject bless(String className) {
        return this.get().bless(className);
    }

    // accessors
    public PlObject pow(PlObject arg)    { return this.get().pow(arg); }
    public PlObject atan2(PlObject arg)  { return this.get().atan2(arg); }

    public PlObject scalar() {
        return this.get();
    }
", ((map {
            my $perl = $_;
            "    public PlObject " . $perl . "(PlObject s) {
        return this.get()." . $perl . "(s);
    }
    public PlObject " . $perl . "2(PlObject s) {
        return s." . $perl . "(this.get());
    }
"
        } sort {;
            $a cmp $b
        } ("num_cmp", "mod", keys(%number_binop)))), ((map {
            my($op, $type) = @{$_};
            "    public " . $type . " " . $op . "() {
        return this.get()." . $op . "();
    }
"
        } map([$_, "PlObject"], (@number_unary, "blessed", "refaddr", "reftype", "to_num")), map([$_, "boolean"], (@boolean_unary, "is_integer_range")), ["toString", "String"], ["to_long", "long"], ["to_double", "double"], ["to_boolean", "boolean"], ["blessed_class", "PlClass"], ["ref", "PlString"], (map {
            my $class = $java_classes{$_};
            $class->{"import"} || $class->{"extends"} || $class->{"implements"} ? [$class->{"perl_to_java"}, $class->{"java_type"}] : ()
        } sort {;
            $a cmp $b
        } keys(%java_classes)))), "}

", "
class PlROvalue extends PlLvalue {

    // Note: several versions of PlROvalue()
    public PlROvalue() {
        this.o = PlCx.UNDEF;
    }
    public PlROvalue(PlObject o) {
        this.o = o;
    }
    public PlROvalue(PlLvalue o) {
        this.o = o.get();
    }
    public PlROvalue(PlArray o) {
        // \$a = \@x
        this.o = o.scalar();
    }
    public PlROvalue(PlHash o) {
        // \$a = %x
        this.o = o.scalar();
    }

    public PlObject set(Object o) {
        PlCORE.die(\"Modification of a read-only value attempted\");
        return this;
    }
    public PlObject set(PlString o) {
        return PlCORE.die(\"Modification of a read-only value attempted\");
    }
    public PlObject set(PlInt o) {
        return PlCORE.die(\"Modification of a read-only value attempted\");
    }

    public PlObject pre_decr() {
        return PlCORE.die(\"Modification of a read-only value attempted\");
    }
    public PlObject post_decr() {
        return PlCORE.die(\"Modification of a read-only value attempted\");
    }
    public PlObject pre_incr() {
        return PlCORE.die(\"Modification of a read-only value attempted\");
    }
    public PlObject post_incr() {
        return PlCORE.die(\"Modification of a read-only value attempted\");
    }

}
class PlSlice extends PlArray {
    public boolean is_slice() {
        return true;
    }
}

class PlTieArrayIterator implements Iterator<PlObject> {
    public PlObject tied;
    private int key;

    public PlTieArrayIterator(PlObject tied) {
        this.tied = tied;
    }
    public PlObject next() {
        return PerlOp.call(this.tied, \"FETCH\", new PlArray(new PlInt(this.key)), PlCx.SCALAR);
    }
    public boolean hasNext() {
        return this.key < PerlOp.call(tied, \"FETCHSIZE\", new PlArray(), PlCx.SCALAR).to_int();
    }
}
class PlTieArrayList extends PlArrayList {
    public PlObject tied;
    public PlArrayList old_var;

    public PlTieArrayList() {
    }
    // add(PlObject)
    // add(pos, PlObject)
    // get(pos)
    // remove(pos)
    // set(pos, PlObject)
    // size()
    // clear()
    // iterator()

    public boolean add(PlObject v) {
        PerlOp.call(tied, \"PUSH\", new PlArray(v), PlCx.SCALAR);
        return true;
    }
    public void add(int i, PlObject v) {
        if (i == 0) {
            PerlOp.call(tied, \"UNSHIFT\", new PlArray(v), PlCx.SCALAR);
        }
        else {
            PerlOp.call(tied, \"PUSH\", new PlArray(v), PlCx.SCALAR);
        }
    }
    public PlObject get(int i) {
        return PerlOp.call(tied, \"FETCH\", new PlArray(new PlInt(i)), PlCx.SCALAR);
    }
    public PlObject remove(int i) {
        if (i == 0) {
            return PerlOp.call(tied, \"SHIFT\", new PlArray(), PlCx.SCALAR);
        }
        return PerlOp.call(tied, \"POP\", new PlArray(), PlCx.SCALAR);
    }
    public PlObject set(int i, PlObject v) {
        return PerlOp.call(tied, \"STORE\", new PlArray(new PlInt(i), v), PlCx.SCALAR);
    }
    public int size() {
        return PerlOp.call(tied, \"FETCHSIZE\", new PlArray(), PlCx.SCALAR).to_int();
    }
    public void clear() {
        PerlOp.call(tied, \"STORESIZE\", new PlArray(PlCx.INT0), PlCx.SCALAR);
    }
    public Iterator<PlObject> iterator() {
        return new PlTieArrayIterator(this.tied);
    }

    // Perl API
    // add == PUSH
    // add(0, v) == UNSHIFT

    public PlObject exists(PlObject i) {
        return PerlOp.call(tied, \"EXISTS\", new PlArray(i), PlCx.SCALAR);
    }
    public PlObject delete(int want, PlObject i) {
        return PerlOp.call(tied, \"DELETE\", new PlArray(i), want);
    }

    public PlObject set_end_of_array_index(int i) {
        return PerlOp.call(tied, \"STORESIZE\", new PlArray(), PlCx.SCALAR);
    }
    public PlObject aset(int i, PlObject v) {
        this.set(i, v);
        return v;
    }
    public PlObject aget(int i) {
        return this.get(i);
    }
    public PlObject shift() {
        return PerlOp.call(tied, \"SHIFT\", new PlArray(), PlCx.SCALAR);
    }
    public PlObject pop() {
        return PerlOp.call(tied, \"POP\", new PlArray(), PlCx.SCALAR);
    }

    public PlObject scalar() {
        return PerlOp.call(this.tied, \"SCALAR\", new PlArray(), PlCx.SCALAR);
    }
    public boolean is_tiedArray() {
        return true;
    }
    public PlObject tied() {
        return this.tied;
    }
} // PlTieArrayList
class PlArrayList extends ArrayList<PlObject> implements Iterable<PlObject> {
    public PlArrayList() {
    }
    // add(PlObject)
    // add(pos, PlObject)
    // get(pos)
    // remove(pos)
    // set(pos, PlObject)
    // size()
    // clear()
    // iterator()

    // Perl API

    public PlObject exists(PlObject i) {
        int pos  = i.to_int();
        if (pos < 0) {
            pos = this.size() + pos;
        }
        if (pos < 0 || pos >= this.size()) {
            return PlCx.FALSE;
        }
        return PlCx.TRUE;
    }
    public PlObject delete(int want, PlObject i) {
        int pos  = i.to_int();
        if (pos < 0) {
            pos = this.size() + pos;
        }
        if ((pos+1) == this.size()) {
            return this.pop();
        }
        if (pos < 0 || pos >= this.size()) {
            return PlCx.FALSE;
        }
        PlObject res = this.aget(pos);
        this.aset(pos, PlCx.UNDEF);
        return res;
    }

    public PlObject set_end_of_array_index(int i) {
        int size = i + 1;
        while (this.size() < size) {
            this.add(PlCx.UNDEF);
        }
        if (size < this.size() && this.size() > 0) {
            this.removeRange(size, this.size() - 1);
        }
        return new PlInt(this.size());
    }
    public PlObject aset(int i, PlObject v) {
        int size = this.size();
        int pos  = i;
        if (pos < 0) {
            pos = size + pos;
        }
        if (size <= pos) {
            while (size < pos) {
                this.add( PlCx.UNDEF );
                size++;
            }
            this.add(v.scalar());
            return v;
        }
        PlObject old = this.get(pos);
        if (old.is_lvalue()) {
            old.set(v.scalar());
        }
        else {
            this.set(pos, v.scalar());
        }
        return v;
    }
    public PlObject aget(int i) {
        int pos  = i;
        if (pos < 0) {
            pos = this.size() + pos;
        }
        if (pos < 0 || pos >= this.size()) {
            return PlCx.UNDEF;
        }
        return this.get(pos);
    }
    public PlObject shift() {
        int size = this.size();
        if (size > 0) {
            return this.remove(0);
        }
        else {
            return PlCx.UNDEF;
        }
    }
    public PlObject pop() {
        int size = this.size() - 1;
        if (size >= 0) {
            return this.remove(size);
        }
        else {
            return PlCx.UNDEF;
        }
    }

    public PlObject scalar() {
        return new PlInt(this.hashCode());
    }
    public boolean is_tiedArray() {
        return false;
    }
    public PlObject tied() {
        return PlCx.UNDEF;
    }
}
class PlArray extends PlObject implements Iterable<PlObject> {
    public PlArrayList a;
    public int each_iterator;

    public final Iterator<PlObject> iterator() {
        return this.a.iterator(); 
    }

    public PlArray( PlArrayList a ) {
        this.each_iterator = 0;
        this.a = a;
    }
    public PlArray() {
        this.each_iterator = 0;
        this.a = new PlArrayList();
    }
    public PlArray(PlObject... args) {
        PlArrayList aa = new PlArrayList();
        for (PlObject s : args) {
            if (s.is_hash()) {
                // \@x = %x;
                s = s.to_array();
            }
            if (s.is_array()) {
                // \@x = ( \@x, \@y );
                for (int i = 0; i < s.to_long(); i++) {
                    PlObject v = s.aget(i);
                    if (v.is_lvalue()) {
                        v = v.get();
                    }
                    aa.add(v);
                }
            }
            else if (s.is_lvalue()) {
                aa.add(s.get());
            }
            else {
                aa.add(s);
            }
        }
        this.each_iterator = 0;
        this.a = aa;
    }

    // tie hash
    public PlObject tie(PlArray args) {
        if (this.a.is_tiedArray()) {
            this.untie();
        }
        PlTieArrayList v = new PlTieArrayList();
        PlObject class_name = args.shift();
        PlObject self = PerlOp.call(class_name.toString(), \"TIEARRAY\", args, PlCx.VOID);
        v.tied = self;
        v.old_var = this.a;
        this.a = v;
        return self;
    }

    public PlObject untie() {
        if (this.a.is_tiedArray()) {
            PlObject tied = this.a.tied();
            PlObject untie = PerlOp.call(tied, \"can\", new PlArray(new PlString(\"UNTIE\")), PlCx.SCALAR);
            if (untie.to_boolean()) {
                untie.apply(PlCx.VOID, new PlArray(tied));
            };
            this.a = ((PlTieArrayList)a).old_var;
            return tied;
        }
        return this;
    }
    public PlObject tied() {
        return a.tied();
    }

    // internal lazy api
    public PlLvalue create_scalar(int i) {
        int size = this.a.size();
        int pos  = i;
        if (pos < 0) {
            return (PlLvalue)PlCORE.die(\"internal error: negative index on PlArray.create_scalar()\");
        }
        if (size <= pos) {
            while (size < pos) {
                this.a.add( PlCx.UNDEF );
                size++;
            }
            PlLvalue v = new PlLvalue();
            this.a.add(v);
            return v;
        }
        PlObject old = this.a.get(pos);
        if (old.is_lvalue()) {
            return (PlLvalue)old;
        }
        if (old.is_undef()) {
            PlLvalue v = new PlLvalue();
            this.a.set(pos, v);
            return v;
        }
        return (PlLvalue)PlCORE.die(\"Not a SCALAR reference\");
    }

    public static PlArray construct_list_of_aliases(PlObject... args) {
        PlArrayList aa = new PlArrayList();
        for (PlObject s : args) {
            if (s.is_hash()) {
                // ( %x );
                s = ((PlHash)s).to_list_of_aliases();
                for (int i = 0; i < s.to_long(); i++) {
                    aa.add(s.aget_lvalue(i));
                }
            }
            else if (s.is_array()) {
                // ( \@x, \@y );
                for (int i = 0; i < s.to_long(); i++) {
                    aa.add(s.aget_lvalue(i));
                }
            }
            else if (s.is_lvalue()) {
                aa.add(s);  // store lvalue as-is
            }
            else {
                aa.add(new PlROvalue(s));  // store \"read only\"
            }
        }
        PlArray result = new PlArray();
        result.a = aa;
        return result;
    }
    public static PlArray construct_list_of_references(PlObject... args) {
        PlArray aa = PlArray.construct_list_of_aliases(args);
        PlArray result = new PlArray();
        for (PlObject s : aa) {
            result.push(new PlLvalueRef(s));
        }
        return result;
    }
    public static PlObject static_list_set(int want, PlObject src, PlObject... args) {
        src = new PlArray(src);
        int size = src.to_int();
        for (PlObject s : args) {
            if (s.is_hash()) {
                // ( %x );
                s.set(src);
                src = new PlArray();
            }
            else if (s.is_slice()) {
                // ( \@x[3,4] ); - \"slice\" is not \"slurpy\"
                int s_size = s.to_int();
                for (int i = 0; i < s_size; i++) {
                    s.aset(i, src.shift());
                }
            }
            else if (s.is_array()) {
                // ( \@x ); - \"array\" is \"slurpy\"
                s.set(src);
                src = new PlArray();
            }
            else if (s.is_lvalue()) {
                PlObject o = src.shift();
                s.set(o);
            }
            else if (s.is_undef()) {
                src.shift();   // skip
            }
            else {
                PlCORE.die(\"Can't modify constant item in list assignment\");
            }
        }
        if (want == PlCx.LIST) {
            return PlArray.construct_list_of_aliases(args);
        }
        return new PlInt(size);
    }
    public PlObject list_set(int want, PlArray s) {
        // \@x[3,4] = ( \@x, \@y );
        for (int i = 0; i < this.to_long(); i++) {
            this.aset(i, s.aget(i));
        }
        this.each_iterator = 0;
        if (want == PlCx.LIST) {
            return this;
        }
        return this.pop();
    }

    public PlObject set(PlObject s) {
        this.a.clear();
        PlObject tmp;
        if (s.is_hash()) {
            // \@x = %x;
            s = s.to_array();
        }
        if (s.is_array()) {
            // \@x = ( \@x, \@y );
            for (int i = 0; i < s.to_long(); i++) {
                tmp = s.aget(i);
                if (tmp.is_lvalue()) {
                    this.a.add(tmp.get());
                }
                else {
                    this.a.add(tmp);
                }
            }
        }
        else {
            this.a.add(s);
        }
        this.each_iterator = 0;
        return this;
    }

    public PlObject set(Map<String, String> env) {
        this.a.clear();
        for (String envName : env.keySet()) {
            this.a.add(new PlString(envName));
            this.a.add(new PlString(env.get(envName)));
        }
        this.each_iterator = 0;
        return this;
    }
    public PlArray(Map<String, String> strings) {
        PlArray arr = new PlArray();
        arr.set(strings);
        this.each_iterator = arr.each_iterator;
        this.a = arr.a;
    }

", ((map {
            my $native = $_;
            my $perl = $native_to_perl{$native};
            $native && $perl ? "    public PlObject set(" . $native . "[] stuffs) {
        this.a.clear();
        // \@x = " . $native . "[] native;
        for(" . $native . " i : stuffs){
            this.a.add(new " . $perl . "(i));
        }
        this.each_iterator = 0;
        return this;
    }
    public PlArray(" . $native . "[] stuffs) {
        PlArray aa = new PlArray();
        aa.set(stuffs);
        this.each_iterator = aa.each_iterator;
        this.a = aa.a;
    }
" : ()
        } sort {;
            $a cmp $b
        } keys(%native_to_perl))), "    public PlObject aget(PlObject i) {
        return this.a.aget(i.to_int());
    }
    public PlObject aget(int i) {
        return this.a.aget(i);
    }
    public PlObject aget_lvalue(int pos) {
        int size = this.a.size();
        if (pos < 0) {
            pos = size + pos;
        }
        if (size <= pos) {
            return new PlLazyIndex(this, pos);
        }
        PlObject o = this.a.get(pos);
        if (o == null) {
            return new PlLazyIndex(this, pos);
        }
        if (o.is_lvalue()) {
            return o;
        }
        PlLvalue a = new PlLvalue(o);
        this.a.set(pos, a);
        return a;
    }
    public PlObject aget_lvalue(PlObject i) {
        return this.aget_lvalue(i.to_int());
    }
    public PlObject aget_lvalue_local(PlObject i) {
        return this.aget_lvalue_local(i.to_int());
    }
    public PlObject aget_lvalue_local(int i) {
        PlObject o = this.a.get(i);
        if (o == null) {
            this.a.set(i, PlCx.UNDEF);
        }
        return PerlOp.push_local(this, i);
    }

    public PlObject aget_list_of_aliases(int want, PlArray a) {
        // \@a[LIST]
        PlArrayList aa = new PlArrayList();
        for (PlObject i : a) {
            aa.add( this.aget_lvalue(i) );
        }
        PlSlice result = new PlSlice();
        result.a = aa;
        if (want == PlCx.LIST) {
            return result;
        }
        return result.pop();
    }
    public PlObject aget_hash_list_of_aliases(int want, PlArray a) {
        // %a[LIST]
        PlArrayList aa = new PlArrayList();
        for (PlObject i : a) {
            aa.add( i );
            aa.add( this.aget_lvalue(i) );
        }
        PlSlice result = new PlSlice();
        result.a = aa;
        if (want == PlCx.LIST) {
            return result;
        }
        return result.pop();
    }

    public PlObject get_scalar(PlObject i) {
        // \$\$x
        PlObject o = this.aget(i);
        if (o.is_undef()) {
            PlLvalue a = new PlLvalue();
            this.aset(i, new PlLvalueRef(a));
            return a;
        }
        else if (o.is_scalarref()) {
            return o.get();
        }
        // Modification of a read-only value attempted
        // return PlCORE.die(\"Not an SCALAR reference\");
        return o;
    }
    public PlObject aget_scalarref(int i) {
        PlObject o = this.aget(i);
        if (o.is_undef()) {
            return new PlLvalueRef(new PlLazyScalarref(new PlLazyIndex(this, i)));
        }
        else if (o.is_scalarref()) {
            return o;
        }
        return PlCORE.die(\"Not a SCALAR reference\");
    }

    public PlObject aget_arrayref(int i) {
        PlObject o = this.aget(i);
        if (o.is_undef()) {
            PlArrayRef ar = new PlArrayRef();
            this.aset(i, ar);
            return ar;
        }
        else if (o.is_arrayref()) {
            return o;
        }
        return PlCORE.die(\"Not an ARRAY reference\");
    }

    public PlObject aget_hashref(int i) {
        PlObject o = this.aget(i);
        if (o.is_undef()) {
            PlHashRef hr = new PlHashRef();
            this.aset(i, hr);
            return hr;
        }
        else if (o.is_hashref()) {
            return o;
        }
        return PlCORE.die(\"Not a HASH reference\");
    }

    public PlObject get_hash(int i) {
        PlObject o = this.aget(i);
        if (o.is_undef()) {
            PlHashRef hr = new PlHashRef();
            this.aset(i, hr);
            return hr;
        }
        else if (o.is_hashref()) {
            return o;
        }
        return PlCORE.die(\"Not a HASH reference\");
    }

    // Note: multiple versions of set()
    public PlObject aset(PlObject i, PlObject v) {
        return this.a.aset(i.to_int(), v);
    }
    public PlObject aset(int i, PlObject v) {
        return this.a.aset(i, v);
    }
    public PlObject aset(PlObject i, PlLvalue v) {
        return this.a.aset(i.to_int(), v.get());
    }
    public PlObject aset(int i, PlLvalue v) {
        return this.a.aset(i, v.get());
    }
", ((map {
            my $native = $_;
            my $perl = $native_to_perl{$native};
            $native && $perl ? "    public PlObject aset(PlObject i, " . $native . " s) {
        return this.aset(i, new " . $perl . "(s));
    }
    public PlObject aset(int i, " . $native . " s) {
        return this.aset(i, new " . $perl . "(s));
    }
    public PlObject push(" . $native . " s) {
        return this.push(new " . $perl . "(s));
    }
    public PlObject unshift(" . $native . " s) {
        return this.unshift(new " . $perl . "(s));
    }
" : ()
        } sort {;
            $a cmp $b
        } keys(%native_to_perl))), "    public PlObject aset_alias(int i, PlLvalue lvalue) {
        return this.a.set(i, lvalue);
    }

    // Note: multiple versions of push()
    public PlObject push(PlObject v) {
        if (v.is_array()) {
            return this.push( (PlArray)v );
        }
        this.a.add(v.scalar());
        return this.length_of_array();
    }
    public PlObject push(PlLvalue v) {
        this.a.add(v.get());
        return this.length_of_array();
    }
    public PlObject push(PlArray args) {
        int size = args.a.size();
        for (int i = 0; i < size; i++) {
            PlObject s = args.aget(i);
            if (s.is_hash()) {
                // \@x = %x;
                s = s.to_array();
            }
            if (s.is_array()) {
                this.push(s);
            }
            else {
                this.a.add(s);
            }
        }
        return this.length_of_array();
    }

    // Note: multiple versions of unshift()
    public PlObject unshift(PlObject v) {
        if (v.is_array()) {
            return this.unshift( (PlArray)v );
        }
        this.a.add(0, v.scalar());
        return this.length_of_array();
    }
    public PlObject unshift(PlLvalue v) {
        this.a.add(0, v.get());
        return this.length_of_array();
    }
    public PlObject unshift(PlArray args) {
        args = new PlArray(args);   // allow \"unshift \@x, \@x\" - TODO: optimize
        int size = args.a.size();
        for (int i = size - 1; i >= 0; i--) {
            PlObject s = args.aget(i);
            if (s.is_hash()) {
                // \@x = %x;
                s = s.to_array();
            }
            if (s.is_array()) {
                this.unshift(s);
            }
            else {
                this.a.add(0, s);
            }
        }
        return this.length_of_array();
    }

    public PlObject pop() {
        return this.a.pop();
    }
    public PlObject shift() {
        return this.a.shift();
    }
    public PlObject exists(PlObject i) {
        return this.a.exists(i);
    }
    public PlObject delete(int want, PlObject i) {
        return this.a.delete(want, i);
    }
    public PlObject values() {
        // return a copy
        return new PlArray(this);
    }
    public PlObject keys() {
        PlArray aa = new PlArray();
        int size = this.to_int();
        for (int i = 0; i < size; i++) {
            aa.push(new PlInt(i));
        }
        return aa;
    }
    public PlObject each() {
        PlArray aa = new PlArray();
        int size = this.to_int();
        if (this.each_iterator < size) {
            aa.push(new PlInt(this.each_iterator));
            aa.push(this.aget(this.each_iterator));
            this.each_iterator++;
        }
        else {
            // return empty list
            this.each_iterator = 0;
        }
        return aa;
    }
    public String toString() {
        StringBuilder sb = new StringBuilder();
        int size = this.to_int();
        for (int i = 0; i < size; i++) {
            String item = this.aget(i).toString();
            sb.append(item);
        }
        return sb.toString();
    }
    public long to_long() {
        return this.a.size();
    }
    public int to_int() {
        return this.a.size();
    }
    public PlObject length_of_array() {
        return new PlInt(this.a.size());
    }
    public int length_of_array_int() {
        return this.a.size();
    }
    public PlObject end_of_array_index() {
        return new PlInt(this.a.size() - 1);
    }
    public PlObject set_end_of_array_index(PlObject o) {
        return this.a.set_end_of_array_index(o.to_int());
    }
    public double to_double() {
        return 0.0 + this.to_long();
    }
    public boolean to_boolean() {
        return (this.a.size() > 0);
    }
    public PlObject to_num() {
        return this.scalar();
    }
    public boolean is_array() {
        return true;
    }
    public PlObject scalar() {
        return this.length_of_array();
    }
}


class PlTieHashIterator implements Iterator<Map.Entry<String, PlObject>> {
    public PlObject tied;
    private PlObject key;

    public PlTieHashIterator(PlObject tied) {
        this.tied = tied;
    }
    public Map.Entry<String, PlObject> next() {
        return new AbstractMap.SimpleEntry<String, PlObject>(
                    this.key.toString(),
                    PerlOp.call(this.tied, \"FETCH\", new PlArray(this.key), PlCx.SCALAR)
               );
    }
    public boolean hasNext() {
        if (this.key == null) {
            this.key = PerlOp.call(this.tied, \"FIRSTKEY\", new PlArray(), PlCx.SCALAR);
        }
        else {
            this.key = PerlOp.call(this.tied, \"NEXTKEY\", new PlArray(), PlCx.SCALAR);
        }
        return !this.key.is_undef();
    }
}
class PlTieHashMap extends PlHashMap {
    public PlObject tied;
    public PlHashMap old_var;

    public PlTieHashMap() {
    }
    // get(String)
    // put(String, PlObject)
    // containsKey(String)
    // remove(String)
    // clear()
    // entrySet().iterator() == iterator()

    public PlObject get(Object i) {
        return PerlOp.call(this.tied, \"FETCH\", new PlArray(new PlString((String)i)), PlCx.SCALAR);
    }
    public PlObject put(String i, PlObject v) {
        return PerlOp.call(this.tied, \"STORE\", new PlArray(new PlString(i), v), PlCx.SCALAR);
    }
    public boolean containsKey(Object i) {
        return PerlOp.call(this.tied, \"EXISTS\", new PlArray(new PlString((String)i)), PlCx.SCALAR).to_boolean();
    }
    public PlObject remove(Object i) {
        return PerlOp.call(this.tied, \"DELETE\", new PlArray(new PlString((String)i)), PlCx.SCALAR);
    }
    public void clear() {
        PerlOp.call(this.tied, \"CLEAR\", new PlArray(), PlCx.SCALAR);
    }
    public Iterator<Map.Entry<String, PlObject>> iterator() {
        return new PlTieHashIterator(this.tied);
    }
    public PlObject scalar() {
        return PerlOp.call(this.tied, \"SCALAR\", new PlArray(), PlCx.SCALAR);
    }
    public boolean is_tiedHash() {
        return true;
    }
    public PlObject tied() {
        return this.tied;
    }

} // PlTieHashMap

class PlHashIterator {
    public Iterator<Map.Entry<String, PlObject>> iterator;

    public PlHashIterator() {
    }
    public void reset() {
        iterator = null;
    }
}
class PlHashMap extends HashMap<String, PlObject> implements Iterable<Map.Entry<String, PlObject>> {
    public PlHashMap() {
    }
    // get(String)
    // put(String, PlObject)
    // containsKey(String)
    // remove(String)
    // clear()
    // entrySet().iterator() == iterator()

    public Iterator<Map.Entry<String, PlObject>> iterator() {
        return this.entrySet().iterator();
    }
    public PlObject scalar() {
        return new PlInt(this.hashCode());
    }
    public boolean is_tiedHash() {
        return false;
    }
    public PlObject tied() {
        return PlCx.UNDEF;
    }
}
class PlHash extends PlObject {
    public PlHashMap h;
    public PlHashIterator each_iterator;

    public PlHash() {
        this.each_iterator = new PlHashIterator();
        this.h = new PlHashMap();
        this.each_iterator.reset();
    }
    public PlHash(PlObject... args) {
        PlHash hh = new PlHash();
        int args_size = args.length;
        for (int i = 0; i < args_size; i++) {
            PlObject s = args[i];
            if (s.is_hash()) {
                // \@x = %x;
                s = s.to_array();
            }
            if (s.is_array()) {
                // %x = ( \@x, \@y );
                int array_size = s.to_int();
                for (int j = 0; j < array_size; j++) {
                    PlObject key = s.aget(j);
                    j++;
                    PlObject value;
                    if ( j >= array_size ) {
                        // TODO - emit warning about odd number of arguments
                        value = PlCx.UNDEF;
                    }
                    else {
                        value = s.aget(j);
                    }
                    hh.hset(key, value);
                }
            }
            else {
                i++;
                PlObject value;
                if ( i >= args_size ) {
                    // TODO - emit warning about odd number of arguments
                    value = PlCx.UNDEF;
                }
                else {
                    value = args[i];
                }
                hh.hset(s, value);
            }
        }
        this.h = hh.h;
        this.each_iterator = hh.each_iterator;
        this.each_iterator.reset();
    }


    // tie hash
    public PlObject tie(PlArray args) {
        if (this.h.is_tiedHash()) {
            this.untie();
        }
        PlTieHashMap v = new PlTieHashMap();
        PlObject class_name = args.shift();
        PlObject self = PerlOp.call(class_name.toString(), \"TIEHASH\", args, PlCx.VOID);
        v.tied = self;
        v.old_var = this.h;
        this.h = v;
        return self;
    }

    public PlObject untie() {
        if (this.h.is_tiedHash()) {
            PlObject tied = this.h.tied();
            PlObject untie = PerlOp.call(tied, \"can\", new PlArray(new PlString(\"UNTIE\")), PlCx.SCALAR);
            if (untie.to_boolean()) {
                untie.apply(PlCx.VOID, new PlArray(tied));
            };
            this.h = ((PlTieHashMap)h).old_var;
            return tied;
        }
        return this;
    }
    public PlObject tied() {
        return h.tied();
    }


    // internal lazy api
    public PlLvalue create_scalar(String i) {
        PlObject o = this.h.get(i);
        if (o == null) {
            PlLvalue a = new PlLvalue();
            this.h.put(i, a);
            return a;
        }
        if (o.is_lvalue()) {
            return (PlLvalue)o;
        }
        if (o.is_undef()) {
            PlLvalue a = new PlLvalue();
            this.h.put(i, a);
            return a;
        }
        return (PlLvalue)PlCORE.die(\"Not a SCALAR reference\");
    }

    public PlObject set(PlObject s) {
        this.h.clear();
        if (s.is_hash()) {
            // \@x = %x;
            s = s.to_array();
        }
        if (s.is_array()) {
            // %x = ( \@x, \@y );
            int array_size = s.to_int();
            for (int j = 0; j < array_size; j++) {
                PlObject key = s.aget(j);
                j++;
                PlObject value;
                if ( j >= array_size ) {
                    // TODO - emit warning about odd number of arguments
                    value = PlCx.UNDEF;
                }
                else {
                    value = s.aget(j);
                }
                this.hset(key, value);
            }
        }
        else {
            // TODO - emit warning about odd number of arguments
            this.hset(s, PlCx.UNDEF);
        }
        this.each_iterator.reset();
        return this;
    }

    public PlObject to_array() {
        PlArray aa = new PlArray();
        for (Map.Entry<String, PlObject> entry : this.h) {
            String key = entry.getKey();
            PlObject value = entry.getValue();
            aa.push(new PlString(key));
            aa.push(value);
        }
        return aa;
    }

    public PlArray to_list_of_aliases() {
        PlArrayList aa = new PlArrayList();
        for (Map.Entry<String, PlObject> entry : this.h) {
            String key = entry.getKey();
            aa.add(new PlString(key));
            PlObject value = this.hget_lvalue(key);
            aa.add(value);
        }
        PlSlice result = new PlSlice();
        result.a = aa;
        return result;
    }

    public PlObject hget(PlObject i) {
        PlObject o = this.h.get(i.toString());
        if (o == null) {
            return PlCx.UNDEF;
        }
        return o;
    }
    public PlObject hget(String i) {
        PlObject o = this.h.get(i);
        if (o == null) {
            return PlCx.UNDEF;
        }
        return o;
    }
    public PlObject hget_list_of_aliases(int want, PlArray a) {
        // \@a{LIST}
        PlArrayList aa = new PlArrayList();
        for (int i = 0; i < a.to_int(); i++) {
            String key = a.aget(i).toString();
            PlObject value = this.hget_lvalue(key);
            aa.add(value);
        }
        PlSlice result = new PlSlice();
        result.a = aa;
        if (want == PlCx.LIST) {
            return result;
        }
        return result.pop();
    }
    public PlObject hget_hash_list_of_aliases(int want, PlArray a) {
        // %a{LIST}
        PlArrayList aa = new PlArrayList();
        for (int i = 0; i < a.to_int(); i++) {
            String key = a.aget(i).toString();
            aa.add(new PlString(key));
            PlObject value = this.hget_lvalue(key);
            aa.add(value);
        }
        PlArray result = new PlArray();
        result.a = aa;
        if (want == PlCx.LIST) {
            return result;
        }
        return result.pop();
    }

    public PlObject hget_lvalue(String i) {
        PlObject o = this.h.get(i);
        if (o == null) {
            return new PlLazyLookup(this, i);
        }
        else if (o.is_lvalue()) {
            return o;
        }

        if (this.h.is_tiedHash()) {
            return new PlLazyTiedLookup(this, i);
        }

        PlLvalue a = new PlLvalue(o);
        this.h.put(i, a);
        return a;
    }
    public PlObject hget_lvalue_local(String i) {
        PlObject o = this.h.get(i);
        if (o == null) {
            this.h.put(i, PlCx.UNDEF);
        }

        if (this.h.is_tiedHash()) {
            PerlOp.push_local(this, i);
            return new PlLazyTiedLookup(this, i);
        }

        return PerlOp.push_local(this, i);
    }

    public PlObject get_scalar(PlObject i) {
        // \$\$x
        PlObject o = this.hget(i);
        if (o.is_undef()) {
            PlLvalue a = new PlLvalue();
            this.hset(i, new PlLvalueRef(a));
            return a;
        }
        else if (o.is_scalarref()) {
            return o.get();
        }
        // Modification of a read-only value attempted
        // return PlCORE.die(\"Not an SCALAR reference\");
        return o;
    }

    public PlObject hget_scalarref(String i) {
        PlObject o = this.hget(i);
        if (o.is_undef()) {
            return new PlLvalueRef(new PlLazyScalarref(new PlLazyLookup(this, i)));
        }
        else if (o.is_scalarref()) {
            return o;
        }
        // Modification of a read-only value attempted
        return o;
    }

    public PlObject hget_arrayref(PlObject i) {
        PlObject o = this.hget(i);
        if (o.is_undef()) {
            PlArrayRef ar = new PlArrayRef();
            this.hset(i, ar);
            return ar;
        }
        else if (o.is_arrayref()) {
            return o;
        }
        return PlCORE.die(\"Not an ARRAY reference\");
    }
    public PlObject hget_arrayref(String i) {
        PlObject o = this.hget(i);
        if (o.is_undef()) {
            PlArrayRef ar = new PlArrayRef();
            this.hset(i, ar);
            return ar;
        }
        else if (o.is_arrayref()) {
            return o;
        }
        return PlCORE.die(\"Not an ARRAY reference\");
    }

    public PlObject hget_hashref(PlObject i) {
        PlObject o = this.hget(i);
        if (o.is_undef()) {
            PlHashRef hr = new PlHashRef();
            this.hset(i, hr);
            return hr;
        }
        else if (o.is_hashref()) {
            return o;
        }
        return PlCORE.die(\"Not a HASH reference\");
    }
    public PlObject hget_hashref(String i) {
        PlObject o = this.hget(i);
        if (o.is_undef()) {
            PlHashRef hr = new PlHashRef();
            this.hset(i, hr);
            return hr;
        }
        else if (o.is_hashref()) {
            return o;
        }
        return PlCORE.die(\"Not a HASH reference\");
    }

    // Note: multiple versions of set()
    public PlObject hset(PlObject s, PlObject v) {
        String key = s.toString();
        PlObject value = v.scalar();
        PlObject o = this.h.get(key);
        if (o != null && o.is_lvalue()) {
            o.set(value);
        }
        else {
            this.h.put(key, value);
        }
        return v;
    }
    public PlObject hset(String key, PlObject v) {
        PlObject value = v.scalar();
        PlObject o = this.h.get(key);
        if (o != null && o.is_lvalue()) {
            o.set(value);
        }
        else {
            this.h.put(key, value);
        }
        return v;
    }
    public PlObject hset(PlObject s, PlLvalue v) {
        return this.hset(s, v.get());
    }
    public PlObject hset(String s, PlLvalue v) {
        return this.hset(s, v.get());
    }
    public PlObject hset(int want, PlArray s, PlArray v) {
        PlArray aa = new PlArray();

        for (int i = 0; i < v.to_int(); i++){
            aa.push(this.hset(v.aget(i), s.aget(i)));
        };
        if (want == PlCx.LIST) {
            return aa;
        }
        return aa.pop();
    }
    public PlObject hset_alias(String s, PlObject lvalue) {
        return this.h.put(s, lvalue);
    }
    public PlObject exists(PlObject i) {
        return this.h.containsKey(i.toString()) ? PlCx.TRUE : PlCx.FALSE;
    }
    public PlObject delete(PlObject i) {
        PlObject r = this.h.remove(i.toString());
        if (r == null) {
            return PlCx.UNDEF;
        }
        return r;
    }
    public PlObject delete(int want, PlArray a) {
        PlArray aa = new PlArray();

        for (int i = 0; i < a.to_int(); i++) {
            PlObject r = this.delete(a.aget(i));
            aa.push(r);
        }
        if (want == PlCx.LIST) {
            return aa;
        }
        return aa.pop();
    }
    public PlObject delete(int want, PlString a) {
        PlArray aa = new PlArray();
        aa.push(a);
        return delete(want, aa);
    }
    public PlObject delete(int want, PlLvalue a) {
        PlArray aa = new PlArray();
        aa.push(a);
        return delete(want, aa);
    }
    public PlObject values() {
        PlArray aa = new PlArray();
        for (Map.Entry<String, PlObject> entry : this.h) {
            PlObject value = entry.getValue();
            aa.push(value);
        }
        return aa;
    }
    public PlObject keys() {
        PlArray aa = new PlArray();
        for (Map.Entry<String, PlObject> entry : this.h) {
            String key = entry.getKey();
            aa.push(new PlString(key));
        }
        return aa;
    }
    public PlObject each() {
        PlArray aa = new PlArray();
        if (this.each_iterator.iterator == null) {
            this.each_iterator.iterator = this.h.iterator();
        }
        if (this.each_iterator.iterator.hasNext()) {
            Map.Entry<String, PlObject> entry = this.each_iterator.iterator.next();
            String key = entry.getKey();
            aa.push(new PlString(key));
            PlObject value = entry.getValue();
            aa.push(value);
        }
        else {
            // return empty list
            this.each_iterator.reset();
        }
        return aa;
    }
", ((map {
            my $native = $_;
            my $perl = $native_to_perl{$native};
            $native && $perl ? "    public PlObject hset(PlObject s, " . $native . " v) {
        return this.hset(s, new " . $perl . "(v));
    }
    public PlObject hset(String s, " . $native . " v) {
        return this.hset(s, new " . $perl . "(v));
    }
" : ()
        } sort {;
            $a cmp $b
        } keys(%native_to_perl))), "
    public String toString() {
        // TODO
        return \"\" + this.hashCode();
    }
    public long to_long() {
        // TODO
        return this.hashCode();
    }
    public double to_double() {
        return 0.0 + this.to_long();
    }
    public boolean to_boolean() {
        for (Map.Entry<String, PlObject> entry : this.h) {
            return true;
        }
        return false;
    }
    public PlObject to_num() {
        return this.scalar();
    }
    public boolean is_hash() {
        return true;
    }
    public PlObject scalar() {
        return this.h.scalar();
    }
}
class PlUndef extends PlObject {
    public PlUndef() {
    }
    public PlObject apply(int want, PlArray List__) {
        // \$a->()
        PlCORE.die(\"Can't use an undefined value as a subroutine reference\");
        return this;
    }
    public PlObject length() {
        return PlCx.UNDEF;
    }
    public long to_long() {
        return 0;
    }
    public double to_double() {
        return 0.0;
    }
    public String toString() {
        return \"\";
    }
    public boolean to_boolean() {
        return false;
    }
    public PlObject to_num() {
        return PlCx.INT0;
    }
    public boolean is_undef() {
        return true;
    }

    public PlObject scalar_deref_strict() {
        return PlCORE.die(\"Can't use an undefined value as a SCALAR reference\");
    }
    public PlArray array_deref_strict() {
        return (PlArray)PlCORE.die(\"Can't use an undefined value as an ARRAY reference\");
    }
    public PlObject hash_deref_strict() {
        return PlCORE.die(\"Can't use an undefined value as a HASH reference\");
    }

}
class PlBool extends PlObject {
    private boolean i;
    public PlBool(boolean i) {
        this.i = i;
    }
    public long to_long() {
        if (this.i) {
            return 1;
        }
        else {
            return 0;
        }
    }
    public double to_double() {
        if (this.i) {
            return 1.0;
        }
        else {
            return 0.0;
        }
    }
    public String toString() {
        if (this.i) {
            return \"1\";
        }
        else {
            return \"\";
        }
    }
    public boolean to_boolean() {
        return this.i;
    }
    public PlObject to_num() {
        if (i) {
            return PlCx.INT1;
        }
        else {
            return PlCx.INT0;
        }
    }
    public boolean is_bool() {
        return true;
    }
    public PlObject _decr() {
        // --\$x
        if (i) {
            return PlCx.INT0;
        }
        else {
            return PlCx.MIN1;
        }
    }
    public PlObject _incr() {
        // ++\$x
        if (i) {
            return PlCx.INT2;
        }
        else {
            return PlCx.INT1;
        }
    }
    public PlObject neg() {
        if (i) {
            return PlCx.MIN1;
        }
        else {
            return PlCx.INT0;
        }
    }
}
class PlInt extends PlObject {
    private long i;
    public PlInt(long i) {
        this.i = i;
    }
    public PlInt(int i) {
        this.i = (long)i;
    }
    public long to_long() {
        return this.i;
    }
    public double to_double() {
        return (double)(this.i);
    }
    public String toString() {
        return \"\" + this.i;
    }
    public boolean to_boolean() {
        return this.i != 0;
    }
    public PlObject to_num() {
        return this;
    }
    public PlObject mod(PlObject o) {
        return PerlOp.mod(this, o);
    }
    public boolean is_int() {
        return true;
    }
    public boolean is_integer_range() {
        return true;
    }
    public PlObject _decr() {
        // --\$x
        return new PlInt(i-1);
    }
    public PlObject _incr() {
        // ++\$x
        return new PlInt(i+1);
    }
    public PlObject neg() {
        return new PlInt(-i);
    }
    public PlObject mul2(PlObject s) {
        long v = s.to_long();
        // 3037000000 is sqrt(Long.MAX_VALUE)
        if (i > 3037000000L || i < -3037000000L || v > 3037000000L || v < -3037000000L) {
            return new PlDouble(this.to_double()).mul2(s);
        }
        return new PlInt(v * i);
    }
}
class PlDouble extends PlObject {
    private double i;
    public PlDouble(double i) {
        this.i = i;
    }
    public long to_long() {
        return (long)(this.i);
    }
    public double to_double() {
        return this.i;
    }
    public String toString() {
        double v = this.i;
        String s;
        if (   v < 0.0001 && v > -0.0001
            || v < -1E14
            || v >  1E14 )
        {
            // use scientific notation
            s = String.format(\"%20.20e\", v);
            s = s.replaceAll(\"\\\\.?0*e\", \"e\");
            if (s.equals(\"0e+00\")) {
                s = \"0\";
            }
        }
        else {
            s = String.format(\"%20.20f\", v);
            s = s.replaceAll(\"\\\\.?0*\$\", \"\");
        }
        return s;
    }
    public boolean to_boolean() {
        return this.i != 0.0;
    }
    public PlObject to_num() {
        return this;
    }
    public PlObject _decr() {
        // --\$x
        return new PlDouble(i-1);
    }
    public PlObject _incr() {
        // ++\$x
        return new PlDouble(i+1);
    }
    public PlObject neg() {
        return new PlDouble(-i);
    }
    public PlObject abs() {
        return new PlDouble(i < 0.0 ? -i : i);
    }
    public PlObject num_cmp(PlObject b) {
        int c = ((Double)this.i).compareTo(b.to_double());
        return (c == 0 ? PlCx.INT0 : c < 0 ? PlCx.MIN1 : PlCx.INT1);
    }
    public PlObject num_cmp2(PlObject b) {
        int c = ((Double)b.to_double()).compareTo(this.i);
        return (c == 0 ? PlCx.INT0 : c < 0 ? PlCx.MIN1 : PlCx.INT1);
    }
", ((map {
            my $perl = $_;
            my $native = $number_binop{$perl}->{"op"};
            my $returns = $number_binop{$perl}->{"num_returns"};
            if ($returns eq "PlInt") {;
                "    public PlObject " . $perl . "(PlObject s) {
        // num - int, num - num
        return new " . $returns . "( this.to_long() " . $native . " s.to_long() );
    }
    public PlObject " . $perl . "2(PlObject s) {
        // int - num
        return new " . $returns . "( s.to_long() " . $native . " this.to_long() );
    }
"
            }
            else {;
                "    public PlObject " . $perl . "(PlObject s) {
        // num - int, num - num
        return new " . $returns . "( this.i " . $native . " s.to_double() );
    }
    public PlObject " . $perl . "2(PlObject s) {
        // int - num
        return new " . $returns . "( s.to_double() " . $native . " this.i );
    }
"
            }
        } sort {;
            $a cmp $b
        } keys(%number_binop))), "    public PlObject mod(PlObject o) {
        return PerlOp.mod(this, o);
    }
    public boolean is_num() {
        return true;
    }
    public boolean is_integer_range() {
        return !Double.isNaN(i) && i <= Long.MAX_VALUE && i >= Long.MIN_VALUE;
    }
}
class PlString extends PlObject {
    private java.lang.String s;
    private PlObject numericValue;

    public PlString(String s) {
        // if (s == null) {
        //     s = \"\";
        // }
        this.s = s;
    }
    public PlString(char s) {
        this.s = \"\" + s;
    }
    public PlObject scalar_deref_lvalue(String namespace) {
        return this.scalar_deref(namespace);
    }
    public PlObject scalar_deref(String namespace) {
        if (s.length() == 1) {
            if (this._looks_like_non_negative_integer()) {
                return PerlOp.regex_var(this.to_int());
            }
            if (s.equals(\"&\") || s.equals(\"`\") || s.equals(\"'\")) {
                return PerlOp.regex_var(s);
            }
            if (s.equals(\"\$\")) {
                return PerlOp.getPID();
            }
        }
        if (s.indexOf(\"::\") == -1) {
            s = namespace + \"::\" + s;
        }
        return PlV.sget(s);
    }
    public PlObject scalar_deref_strict() {
        return PlCORE.die(\"Can't use string (\\\"\" + this.s + \"\\\") as a SCALAR ref while \\\"strict refs\\\" in use\");
    }
    public PlObject scalar_deref_set(String namespace, PlObject v) {
        if (s.indexOf(\"::\") == -1) {
            s = namespace + \"::\" + s;
        }
        return PlV.sset(s, v);
    }
    public PlArray array_deref_lvalue() {
        // TODO - concatenate current namespace if needed
        return PlV.array_get(s);
    }
    public PlArray array_deref_strict() {
        // TODO - concatenate current namespace if needed
        PlCORE.die(\"Can't use string (\\\"\" + this.s + \"\\\") as an ARRAY ref while \\\"strict refs\\\" in use\");
        return PlV.array_get(s);
    }
    public PlArray array_deref() {
        // TODO - concatenate current namespace if needed
        return PlV.array_get(s);
    }
    public PlObject array_deref_set(PlObject v) {
        // TODO - concatenate current namespace if needed
        return PlV.aset(s, v);
    }
    public PlObject hash_deref() {
        // TODO - concatenate current namespace if needed
        return PlV.hash_get(s);
    }
    public PlObject hash_deref_strict() {
        // TODO - concatenate current namespace if needed
        PlCORE.die(\"Can't use string (\\\"\" + this.s + \"\\\") as a HASH ref while \\\"strict refs\\\" in use\");
        return PlV.hash_get(s);
    }
    public PlObject hash_deref_set(PlObject v) {
        // TODO - concatenate current namespace if needed
        return PlV.hash_set(s, v);
    }

    public PlObject parse() {
        if (numericValue == null) {
            numericValue = this._parse();
        }
        return numericValue;
    }
    private boolean _looks_like_non_negative_integer() {
        final int length = s.length();
        for (int offset = 0; offset < length; ) {
            final int c = s.codePointAt(offset);
            switch (c) {
                case '0': case '1': case '2': case '3': case '4':
                case '5': case '6': case '7': case '8': case '9':
                    break;
                default:
                    return false;
            }
        }
        return true;
    }
    private PlObject _parse_exp(int length, int signal, int offset, int next) {
        // 123.45E^^^
        int offset_orig = next;
        int offset3 = next;
        if (offset3 >= length) {
            return new PlDouble(Double.parseDouble(this.s.substring(0, offset_orig - 1)));
        }
        final int sig = s.codePointAt(offset3);
        if (sig == '+' || sig == '-') {
            offset3++;
            if (offset3 >= length) {
                return new PlDouble(Double.parseDouble(this.s.substring(0, offset_orig - 1)));
            }
        }
        final int num = s.codePointAt(offset3);
        if (num < '0' || num > '9') {
            // illegal exp
            return new PlDouble(Double.parseDouble(this.s.substring(0, offset_orig - 1)));
        }
        for ( ; offset3 < length; ) {
            final int c3 = s.codePointAt(offset3);
            switch (c3) {
                case '0': case '1': case '2': case '3': case '4':
                case '5': case '6': case '7': case '8': case '9':
                    break;
                default:    // invalid
                    return new PlDouble(Double.parseDouble(this.s.substring(0, offset3)));
            }
            offset3++;
        }
        return new PlDouble(Double.parseDouble(this.s.substring(0, offset3)));
    }
    private PlObject _parse_dot(int length, int signal, int offset, int next) {
        // 123.^^^
        int offset3 = next;
        for ( ; offset3 < length; ) {
            final int c3 = s.codePointAt(offset3);
            switch (c3) {
                case '0': case '1': case '2': case '3': case '4':
                case '5': case '6': case '7': case '8': case '9':
                    break;
                case 'E': case 'e':
                    // start exponential part
                    return _parse_exp(length, signal, offset, offset3+1);
                default:    // invalid
                    try {
                        return new PlDouble(Double.parseDouble(this.s.substring(0, offset3)));
                    }
                    catch (NumberFormatException e) {
                        // string is \".\"
                        return PlCx.INT0;   // string is \".\"
                    }
            }
            offset3++;
        }
        if (offset3 == 1) {
            return PlCx.INT0;   // string is \".\"
        }
        return new PlDouble(Double.parseDouble(this.s.substring(0, offset3)));
    }
    private PlObject _parse() {
        final int length = s.length();
        int signal = 0;
        for (int offset = 0; offset < length; ) {
            final int c = s.codePointAt(offset);
            switch (c) {
                case 'i': case 'I':
                            if (length > 2 && this.s.substring(offset, offset+3).equalsIgnoreCase(\"inf\")) {
                                if (signal < 0) {
                                    return new PlDouble(Double.NEGATIVE_INFINITY);
                                }
                                else {
                                    return new PlDouble(Double.POSITIVE_INFINITY);
                                }
                            }
                            return PlCx.INT0;
                case 'n': case 'N':
                            if (length > 2 && this.s.substring(offset, offset+3).equalsIgnoreCase(\"nan\")) {
                                return new PlDouble(Double.NaN);
                            }
                            return PlCx.INT0;
                case '.':   // starts with dot
                            if (signal != 0) {
                                signal = 1;
                            }
                            return _parse_dot(length, signal, offset, offset+1);
                case '0': case '1': case '2': case '3': case '4':
                case '5': case '6': case '7': case '8': case '9':
                            // starts with number
                            if (signal == 0) {
                                signal = 1;
                            }
                            int offset2 = offset+1;
                            for ( ; offset2 < length; ) {
                                final int c2 = s.codePointAt(offset2);
                                switch (c2) {
                                    case '0': case '1': case '2': case '3': case '4':
                                    case '5': case '6': case '7': case '8': case '9':
                                        // more numbers
                                        break;
                                    case '.':
                                        // start decimal part
                                        return _parse_dot(length, signal, offset, offset2+1);
                                    case 'E': case 'e':
                                        // start exponential part
                                        return _parse_exp(length, signal, offset, offset2+1);
                                    default:
                                        // return integer
                                        try {
                                            if (signal < 0) {
                                                return new PlInt(-Long.parseLong(this.s.substring(offset, offset2)));
                                            }
                                            else {
                                                return new PlInt(Long.parseLong(this.s.substring(offset, offset2)));
                                            }
                                        }
                                        catch (NumberFormatException e) {
                                            return new PlDouble(Double.parseDouble(this.s.substring(offset, offset2)));
                                        }
                                }
                                offset2++;
                            }
                            // integer
                            try {
                                if (signal < 0) {
                                    return new PlInt(-Long.parseLong(this.s.substring(offset, offset2)));
                                }
                                else {
                                    return new PlInt(Long.parseLong(this.s.substring(offset, offset2)));
                                }
                            }
                            catch (NumberFormatException e) {
                                return new PlDouble(Double.parseDouble(this.s.substring(offset, offset2)));
                            }
                case '+':   // starts with +
                            if (signal != 0) {
                                // invalid
                                return PlCx.INT0;
                            }
                            signal = 1;
                            break;
                case '-':   // starts with -
                            if (signal != 0) {
                                // invalid
                                return PlCx.INT0;
                            }
                            signal = -1;
                            break;
                case ' ': case '\\t': case '\\n': case '\\r':
                            // starts with space
                            if (signal != 0) {
                                // invalid
                                return PlCx.INT0;
                            }
                            break;
                default:    // invalid
                            return PlCx.INT0;
            }
            offset++;
        }
        return PlCx.INT0;
    }
    public long to_long() {
        return this.parse().to_long();
    }
    public double to_double() {
        return this.parse().to_double();
    }
    public String toString() {
        return this.s;
    }
    public boolean to_boolean() {
        return !( this.s.equals(\"\") || this.s.equals(\"0\") );
    }
    public PlObject to_num() {
        return this.parse();
    }
    public char to_char() {
        if (this.s.length() == 0) {
            return '\\u0000';
        }
        return this.s.charAt(0);
    }
    public boolean is_string() {
        return true;
    }
    public boolean boolean_str_le(String b) {
        return this.s.compareTo(b) <= 0;
    }
    public int int_length() {
        return this.s.length();
    }
    public PlObject length() {
        return new PlInt(this.s.length());
    }
    public PlObject _decr() {
        // --\$x
        return this.add(PlCx.MIN1);
    }

    // \$x++ when \$x is PlString
    private static final String _string_increment(String s) {
        if (s.length() < 2) {
            final int c = s.codePointAt(0);
            if ((c >= '0' && c <= '8') || (c >= 'A' && c <= 'Y') || (c >= 'a' && c <= 'y')) {
                return \"\" + (char)(c + 1);
            }
            if (c == '9') {
                return \"10\";
            }
            if (c == 'Z') {
                return \"AA\";
            }
            if (c == 'z') {
                return \"aa\";
            }
            return \"1\";
        }
        String c = _string_increment(s.substring(s.length()-1, s.length()));
        if (c.length() == 1) {
            return s.substring(0, s.length()-1) + c;
        }
        return _string_increment(s.substring(0, s.length()-1)) + c.substring(c.length()-1, c.length());
    }
    public PlObject _incr() {
        // ++\$x
        final int length = s.length();
        if (length == 0) {
            return PlCx.INT1;
        }
        int c = this.s.codePointAt(0);
        switch (c) {
            case ' ': case '\\t': case '\\n': case '\\r':
            case '+': case '-': case '.':
            case '0': case '1': case '2': case '3': case '4':
            case '5': case '6': case '7': case '8': case '9':
                return this.add(PlCx.INT1);
        }
        c = s.codePointAt(length - 1);
        if ((c >= '0' && c <= '8') || (c >= 'A' && c <= 'Y') || (c >= 'a' && c <= 'y')) {
            return new PlString(s.substring(0, length-1) + (char)(c + 1));
        }
        return new PlString(_string_increment(this.s));
    }
    public PlObject neg() {
        final int length = s.length();
        if (length == 0) {
            return PlCx.INT0;
        }
        final int c = this.s.codePointAt(0);
        switch (c) {
            case '+': case '-':
                if (c == '+') {
                    return new PlString( '-' + s.substring(1) );
                }
                if (c == '-') {
                    return new PlString( '+' + s.substring(1) );
                }
            case '.':
            case ' ': case '\\t': case '\\n': case '\\r':
            case '0': case '1': case '2': case '3': case '4':
            case '5': case '6': case '7': case '8': case '9':
                return this.parse().neg();
        }
        if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {
            return new PlString( '-' + s );
        }
        return PlCx.INT0;
    }
    public PlObject abs() {
        return this.parse().abs();
    }
    public PlObject num_cmp(PlObject b) {
        return this.parse().num_cmp(b);
    }
    public PlObject num_cmp2(PlObject b) {
        return b.num_cmp2(this.parse());
    }
    public boolean is_integer_range() {
        return this.parse().is_integer_range();
    }
", ((map {
            my $perl = $_;
            my $native = $number_binop{$perl}->{"op"};
            my $returns = $number_binop{$perl}->{"returns"};
            my $num_returns = $number_binop{$perl}->{"num_returns"};
            if ($returns eq "PlDouble") {;
                "    public PlObject " . $perl . "(PlObject b) {
        // 'num' - int, 'num' - num
        return this.parse()." . $perl . "(b);
    }
    public PlObject " . $perl . "2(PlObject b) {
        // int - 'num'
        return b." . $perl . "(this.parse());
    }
"
            }
            else {;
                "    public PlObject " . $perl . "(PlObject b) {
        // 'num' - int, 'num' - num
        return this.parse()." . $perl . "(b);
    }
    public PlObject " . $perl . "2(PlObject b) {
        // int - 'num'
        return b." . $perl . "(this.parse());
    }
"
            }
        } sort {;
            $a cmp $b
        } keys(%number_binop))), "}
", ((map {
            my $class = $java_classes{$_};
            my $java_class_name = $class->{"java_type"};
            my $perl_to_java = $class->{"perl_to_java"};
            my $perl_package = $class->{"perl_package"};
            my $java_native_to_perl = $class->{"java_native_to_perl"};
            $class->{"import"} || $class->{"extends"} || $class->{"implements"} ? "class " . $java_native_to_perl . " extends PlReference {
    public static final PlString REF = new PlString(\"" . $perl_package . "\");
    private " . $java_class_name . " stuff;

    public " . $java_native_to_perl . "(" . $java_class_name . " stuff) {
        this.stuff = stuff;
    }
    public " . $java_class_name . " " . $perl_to_java . "() {
        return this.stuff;
    }
    public PlString ref() {
        return REF;
    }
    public boolean is_undef() {
        return stuff == null;
    }
}
" : ()
        } sort {;
            $a cmp $b
        } keys(%java_classes))), "// end Perl-Java runtime
")
    }
    1
}
{
    package main;
    package Perlito5::Java::Lib;
    sub Perlito5::Java::Lib::init {
        Perlito5::Grammar::Use::register_internal_module("MIME::Base64", "Perlito5X::Java::MIME::Base64");
        Perlito5::Grammar::Use::register_internal_module("Scalar::Util", "Perlito5X::Java::Scalar::Util");
        Perlito5::Grammar::Use::register_internal_module("List::Util", "Perlito5X::Java::List::Util");
        Perlito5::Grammar::Use::register_internal_module("Digest::MD5", "Perlito5X::Java::Digest::MD5");
        Perlito5::Grammar::Use::register_internal_module("Digest::SHA1", "Perlito5X::Java::Digest::SHA1");
        Perlito5::Grammar::Use::register_internal_module("Encode", "Perlito5X::Java::Encode");
        Perlito5::Grammar::Use::register_internal_module("Time::HiRes", "Perlito5X::Java::Time::HiRes")
    }
    1
}
{
    package main;
    package Perlito5;
    my $_V5_COMPILER_NAME = Perlito5::Compiler::compiler_name();
    my $_V5_COMPILER_VERSION = $Perlito5::VERSION;
    my $source = '';
    my $backend = ${^O};
    my $compile_only = 0;
    my $execute = 1;
    my $verbose = 0;
    my $expand_use = 1;
    my $boilerplate = 1;
    my $bootstrapping = 0;
    my $wrapper_begin = '';
    my $wrapper_end = '';
    my $wrapper_priority = 0;
    my @Use;
    my $i_switch = 0;
    my $i_switch_extension = '';
    my @e_switch;
    $Perlito5::BOOTSTRAP_JAVA_EVAL = 0;
    $Perlito5::JAVA_EVAL = 0;
    $Perlito5::FILE_NAME = '';
    if ($verbose) {
        warn("// Perlito5 compiler");
        warn("// ARGV: " . join(${"\""}, @ARGV))
    }
    my $help_message = "
perlito5 [switches] [programfile]
  switches:
    -c              check syntax only (runs BEGIN and CHECK blocks)
    -e program      one line of program (omit programfile)
    -E program      like -e, but enables all optional features
    -h --help
    -Idirectory     specify \@INC/include directory (several -I's allowed)
    -[mM][-]module  execute \"use/no module...\" before executing program
    -n              assume \"while (<>) { ... }\" loop around program
    -p              assume loop like -n but print line also, like sed
    -V --version
    -v
    --verbose
    -Ctarget        target backend: js, perl5, perl6, java
    -Cast-perl5     emits a dump of the abstract syntax tree as a Perl dump
    -Cast-json      emits a dump of the abstract syntax tree in JSON format
    --expand_use --noexpand_use
                    expand 'use' statements at compile time
    --boilerplate --noboilerplate
                    emits or not boilerplate code
    --bootstrapping set this when compiling the compiler,
                    otherwise the new subroutine definitions will overwrite the current compiler
    --java_eval     enable java eval, using perlito5-lib.jar
    --nojava_eval   disable java eval, creates a standalone file that doesn't depend on perlito5-lib.jar
";
    my $copyright_message = "This is Perlito5 " . $_V5_COMPILER_VERSION . ", an implementation of the Perl language.

The Perl language is Copyright 1987-2017, Larry Wall
The Perlito5 implementation is Copyright 2011-2017 by Flavio Soibelmann Glock and others.

Perl may be copied only under the terms of either the Artistic License or the
GNU General Public License, which may be found in the Perl 5 source kit.

Complete documentation for Perl, including FAQ lists, should be found on
this system using \"man perl\" or \"perldoc perl\".  If you have access to the
Internet, point your browser at http://www.perl.org/, the Perl Home Page.
";
    sub Perlito5::chomp_switch {
        my $s = substr($ARGV[0], 2);
        if ($s) {;
            $ARGV[0] = "-" . $s
        }
        else {;
            shift(@ARGV)
        }
    }
    sub Perlito5::get_text_from_switch {
        my $s = substr($ARGV[0], 2);
        if (!$s) {
            shift(@ARGV);
            $s = $ARGV[0]
        }
        if ($s) {
            my $c = substr($s, 0, 1);
            if ($c eq "\"" || $c eq "'") {;
                if (substr($s, -1, 1) eq $c) {;
                    $s = substr($s, 1, -1)
                }
            }
        }
        return $s
    }
    my $use_warnings = '';
    push(@Use, "no strict");
    ARG_LOOP:
    while (@ARGV && substr($ARGV[0], 0, 1) eq "-") {
        if ($ARGV[0] eq "--verbose") {
            $verbose = 1;
            shift(@ARGV)
        }
        elsif (substr($ARGV[0], 0, 2) eq "-I") {
            my $lib = get_text_from_switch();
            unshift(@INC, $lib);
            shift(@ARGV)
        }
        elsif (substr($ARGV[0], 0, 2) eq "-e" || substr($ARGV[0], 0, 2) eq "-E") {
            my $source = get_text_from_switch();
            push(@e_switch, $source);
            $Perlito5::FILE_NAME = "-e";
            if ($verbose) {;
                warn("// source from command line: " . $source)
            }
            shift(@ARGV)
        }
        elsif (substr($ARGV[0], 0, 2) eq "-c") {
            $compile_only = 1;
            $execute = 0;
            $backend = "perl5";
            chomp_switch()
        }
        elsif (substr($ARGV[0], 0, 2) eq "-C") {
            $backend = get_text_from_switch();
            $execute = 0;
            shift(@ARGV)
        }
        elsif (substr($ARGV[0], 0, 2) eq "-i") {
            $i_switch = 1;
            $ARGV[0] ne "-i" && ($i_switch_extension = get_text_from_switch());
            die("switch -i " . $i_switch_extension . " not yet implemented.
");
            shift(@ARGV)
        }
        elsif ($ARGV[0] eq "-MO=Deparse") {
            $backend = "perl5";
            $execute = 0;
            $expand_use = 0;
            shift(@ARGV)
        }
        elsif (uc(substr($ARGV[0], 0, 2)) eq "-M") {
            my $s = $ARGV[0];
            my $import = '';
            if (substr($s, 1, 1) eq "m") {;
                $import = "()"
            }
            $s = substr($s, 2);
            my $use = "use";
            if (substr($s, 0, 1) eq "-") {
                $use = "no";
                $s = substr($s, 1)
            }
            if (index($s, "=") > -1) {
                ($s, $import) = split("=", $s);
                $import = "split(/,/,q{" . $import . "})"
            }
            push(@Use, $use . " " . $s . " " . $import);
            shift(@ARGV)
        }
        elsif (substr($ARGV[0], 0, 2) eq "-w") {
            $use_warnings = "w";
            chomp_switch()
        }
        elsif (substr($ARGV[0], 0, 2) eq "-W") {
            $use_warnings = "W";
            chomp_switch()
        }
        elsif (substr($ARGV[0], 0, 2) eq "-X") {
            $use_warnings = '';
            chomp_switch()
        }
        elsif (substr($ARGV[0], 0, 2) eq "-n") {
            if ($wrapper_priority < 1) {
                $wrapper_begin = " LINE: while (<>) { ";
                $wrapper_end = " } ";
                $wrapper_priority = 1
            }
            chomp_switch()
        }
        elsif (substr($ARGV[0], 0, 2) eq "-p") {
            if ($wrapper_priority < 2) {
                $wrapper_begin = " LINE: while (<>) { ";
                $wrapper_end = " } continue { " . " print or die \"-p destination: \$!\\n\"; " . " } ";
                $wrapper_priority = 2
            }
            chomp_switch()
        }
        elsif ($ARGV[0] eq "-V") {
            $backend = '';
            say($_V5_COMPILER_NAME, " ", $_V5_COMPILER_VERSION);
            if ($ENV{"PERL5LIB"}) {
                say("  %ENV:");
                say("    PERL5LIB=\"" . $ENV{"PERL5LIB"} . "\"")
            }
            say("  \@INC:");
            say("    " . $_)
                for @INC;
            shift(@ARGV)
        }
        elsif ($ARGV[0] eq "-v" || $ARGV[0] eq "--version") {
            $backend = '';
            say($copyright_message);
            shift(@ARGV)
        }
        elsif ($ARGV[0] eq "-h" || $ARGV[0] eq "--help" || !@ARGV) {
            $backend = '';
            say($_V5_COMPILER_NAME, " ", $_V5_COMPILER_VERSION, $help_message);
            shift(@ARGV)
        }
        elsif ($ARGV[0] eq "--expand_use") {
            $expand_use = 1;
            shift(@ARGV)
        }
        elsif ($ARGV[0] eq "--noexpand_use") {
            $expand_use = 0;
            shift(@ARGV)
        }
        elsif ($ARGV[0] eq "--boilerplate") {
            $boilerplate = 1;
            shift(@ARGV)
        }
        elsif ($ARGV[0] eq "--noboilerplate") {
            $boilerplate = 0;
            shift(@ARGV)
        }
        elsif ($ARGV[0] eq "--bootstrapping") {
            $bootstrapping = 1;
            shift(@ARGV)
        }
        elsif ($ARGV[0] eq "--bootstrap_java_eval") {
            $Perlito5::BOOTSTRAP_JAVA_EVAL = 1;
            shift(@ARGV)
        }
        elsif ($ARGV[0] eq "--java_eval") {
            $Perlito5::JAVA_EVAL = 1;
            shift(@ARGV)
        }
        elsif ($ARGV[0] eq "--nojava_eval") {
            $Perlito5::JAVA_EVAL = 0;
            shift(@ARGV)
        }
        elsif ($ARGV[0] eq "-") {
            shift(@ARGV);
            last(ARG_LOOP)
        }
        else {;
            die("Unrecognized switch: " . $ARGV[0] . "  (-h will show valid options).
")
        }
    }
    if (!$expand_use) {;
        $Perlito5::EMIT_USE = 1
    }
    if ($backend) {
        local $Perlito5::LINE_NUMBER = 1;
        if (@e_switch) {;
            $source = join(${"\""}, @e_switch)
        }
        else {
            $Perlito5::FILE_NAME = $ARGV[0];
            if ($verbose) {;
                warn("// source from file: ", $ARGV[0])
            }
            my $source_filename = shift(@ARGV);
            if ($source_filename eq '') {
                local $/ = undef;
                $source = <STDIN>
            }
            else {
                open(FILE, "<:encoding(UTF-8)", $source_filename) or die("Cannot read " . $source_filename . ": " . ${"!"} . "
");
                local $/ = undef;
                $source = <FILE>;
                close(FILE)
            }
        }
        $0 = $Perlito5::FILE_NAME;
        if ($verbose) {
            warn("// backend: ", $backend);
            warn("now parsing")
        }
        $Perlito5::PKG_NAME = "main";
        $Perlito5::PROTO = {};
        Perlito5::set_global_phase("BEGIN");
        if ($source =~ m/^#![^\n]+-(w|W)/) {;
            $use_warnings = $1
        }
        $source = "
# line 1
" . $source;
        if ($wrapper_begin) {;
            $source = " " . $wrapper_begin . ";
                    " . $source . ";
                    " . $wrapper_end . "
                  "
        }
        if ($verbose) {;
            warn("// source [[[ " . $source . " ]]]
")
        }
        $backend eq "java" && Perlito5::Java::Lib::init();
        ($backend eq "js" || ${^O} eq "node.js") && Perlito5::JavaScript2::Lib::init();
        $backend eq "java" && ($Perlito5::CODE_TOO_LARGE = 1);
        $Perlito5::EXPAND_USE = 1;
        $bootstrapping && ($Perlito5::EXPAND_USE = 0);
        if ($execute) {
            local ${"\@"};
            my $init = join("; ", @Use);
            my $warnings = '';
            $use_warnings && ($warnings = "use warnings");
            eval("
            " . $warnings . ";
            Perlito5::set_global_phase(\"CHECK\");
            \$_->() for \@Perlito5::CHECK_BLOCK;
            package main;
            " . $init . ";
            Perlito5::set_global_phase(\"INIT\");
            eval {
                \$_->() for \@Perlito5::INIT_BLOCK;
                1;
            }
            or die \"\$\@
INIT failed--call queue aborted.
\";
            Perlito5::set_global_phase(\"RUN\");
            " . $source . ";
            \$\@ = undef
        ");
            my $error = ${"\@"};
            $error && warn($error);
            Perlito5::set_global_phase("END");
            $_->()
                for @Perlito5::END_BLOCK;
            if ($error) {;
                exit(255)
            }
        }
        else {;
            eval {
                %INC = ();
                @Perlito5::COMP_UNIT = ();
                $use_warnings && ($source = "use warnings;
" . $source);
                my $m;
                my $ok;
                eval {
                    $m = Perlito5::Grammar::exp_stmts($source, 0);
                    $ok = 1
                };
                if (!$ok || $m->{"to"} < length($source)) {
                    my $error = ${"\@"} || ($m->{"to"} < length($source) && "Syntax Error near " . $m->{"to"}) || "Unknown error";
                    warn($error);
                    exit(255)
                }
                else {
                    if ($expand_use) {
                        my $ok;
                        eval {
                            push(@Perlito5::COMP_UNIT, Perlito5::AST::CompUnit::->new("name", "main", "body", Perlito5::Match::flat($m)));
                            $ok = 1
                        };
                        if (!$ok) {
                            my $error = ${"\@"} || "Unknown error loading a module";
                            warn($error);
                            exit(255)
                        }
                    }
                    else {;
                        push(@Perlito5::COMP_UNIT, Perlito5::AST::CompUnit::->new("name", "main", "body", Perlito5::Match::flat($m)))
                    }
                    for $_ (0 .. $#Perlito5::COMP_UNIT) {;
                        $Perlito5::COMP_UNIT[$_] = $Perlito5::COMP_UNIT[$_]->emit_begin_scratchpad()
                    }
                    {
                        local ${^GLOBAL_PHASE};
                        Perlito5::set_global_phase("CHECK");
                        $_->()
                            for @Perlito5::CHECK_BLOCK
                    }
                    if (!$bootstrapping) {
                        ${^H} = 0;
                        %{^H} = ();
                        my @units;
                        push(@units, Perlito5::AST::Block::->new("stmts", Perlito5::CompileTime::Dumper::emit_globals_after_BEGIN($Perlito5::GLOBAL)));
                        if (@Perlito5::INIT_BLOCK || keys(%Perlito5::DATA_SECTION)) {
                            $s = "{ ";
                            if (keys(%Perlito5::DATA_SECTION)) {;
                                for my $pkg (keys(%Perlito5::DATA_SECTION)) {
                                    $s .= "open " . $pkg . "::DATA, '<', \\\$Perlito5::DATA_SECTION{" . $pkg . "}{data}; ";
                                    $s .= "seek(" . $pkg . "::DATA, \$Perlito5::DATA_SECTION{" . $pkg . "}{pos}, 0); "
                                }
                            }
                            $s .= "local \$\@; " . "local \${^GLOBAL_PHASE}; " . "eval { \${^GLOBAL_PHASE} = \"INIT\" }; " . "eval { " . "\$_->() for \@Perlito5::INIT_BLOCK; " . "1; " . "} " . "or die \"\$\@\\nINIT failed--call queue aborted.\\n\"; " . "} ";
                            my $m = Perlito5::Grammar::exp_stmts($s, 0);
                            push(@units, @{Perlito5::Match::flat($m)})
                        }
                        unshift(@Perlito5::COMP_UNIT, @units)
                    }
                    my $comp_units = [@Perlito5::COMP_UNIT];
                    if ($compile_only) {;
                        say($Perlito5::FILE_NAME . " syntax OK")
                    }
                    elsif ($backend eq "perl5") {
                        if ($expand_use) {;
                            print(Perlito5::Perl5::Runtime::->emit_perl5())
                        }
                        else {;
                            $Perlito5::EMIT_USE = 1
                        }
                        my @data = Perlito5::AST::CompUnit::emit_perl5_program($comp_units);
                        my $out = [];
                        Perlito5::Perl5::PrettyPrinter::pretty_print(\@data, 0, $out);
                        print(join('', @{$out}), ";1
")
                    }
                    elsif ($backend eq "perl6") {
                        if ($boilerplate) {;
                            say("use v6;")
                        }
                        if (!$boilerplate) {;
                            if (ref($comp_units) eq "ARRAY" && (@{$comp_units} == 1) && ref($comp_units->[0]) eq "Perlito5::AST::CompUnit") {;
                                $comp_units = $comp_units->[0]->{"body"}
                            }
                        }
                        my @data = Perlito5::AST::CompUnit::emit_perl6_program($comp_units);
                        my $out = [];
                        Perlito5::Perl6::PrettyPrinter::pretty_print(\@data, 0, $out);
                        print(join('', @{$out}));
                        $boilerplate && print("
")
                    }
                    elsif ($backend eq "js") {;
                        print(Perlito5::AST::CompUnit::emit_javascript2_program($comp_units, "expand_use", $expand_use))
                    }
                    elsif ($backend eq "java") {;
                        print(Perlito5::AST::CompUnit::emit_java_program($comp_units, "expand_use", $expand_use))
                    }
                    elsif ($backend eq "ast-perl5" || $backend eq "ast") {;
                        say(Perlito5::Dumper::ast_dumper($comp_units))
                    }
                    elsif ($backend eq "ast-json") {;
                        say(Perlito5::JSON::ast_dumper($comp_units))
                    }
                    elsif ($backend eq "ast-pretty") {
                        eval("use Data::Printer {colored=>1,class=>{expand=>\"all\",show_methods=>\"none\"}};p(\$comp_units);1");
                        print(${"\@"})
                    }
                    elsif ($backend eq "_comp") {;
                        say(Perlito5::Dumper::ast_dumper($Perlito5::SCOPE))
                    }
                    else {;
                        die("don't know what to do with backend '" . $backend . "'")
                    }
                }
                ${"\@"} = undef
            }
        }
        if (${"\@"}) {
            my $error = ${"\@"};
            warn($error);
            exit(255)
        }
    }
}
;1
