;; Do not edit this file - Generated by MiniPerl6 3.0
(defpackage mp-Rul
  (:use common-lisp mp-Main))
(defpackage mp-Rul-Quantifier
  (:use common-lisp mp-Main))
(defpackage mp-Rul-Or
  (:use common-lisp mp-Main))
(defpackage mp-Rul-Concat
  (:use common-lisp mp-Main))
(defpackage mp-Rul-Subrule
  (:use common-lisp mp-Main))
(defpackage mp-Rul-SubruleNoCapture
  (:use common-lisp mp-Main))
(defpackage mp-Rul-Var
  (:use common-lisp mp-Main))
(defpackage mp-Rul-Constant
  (:use common-lisp mp-Main))
(defpackage mp-Rul-Dot
  (:use common-lisp mp-Main))
(defpackage mp-Rul-SpecialChar
  (:use common-lisp mp-Main))
(defpackage mp-Rul-Block
  (:use common-lisp mp-Main))
(defpackage mp-Rul-InterpolateVar
  (:use common-lisp mp-Main))
(defpackage mp-Rul-NamedCapture
  (:use common-lisp mp-Main))
(defpackage mp-Rul-Before
  (:use common-lisp mp-Main))
(defpackage mp-Rul-NotBefore
  (:use common-lisp mp-Main))
(defpackage mp-Rul-NegateCharClass
  (:use common-lisp mp-Main))
(defpackage mp-Rul-CharClass
  (:use common-lisp mp-Main))
(defpackage mp-Rul-Capture
  (:use common-lisp mp-Main))
(defpackage mp-Rul-CaptureResult
  (:use common-lisp mp-Main))
(defpackage mp-Rul-After
  (:use common-lisp mp-Main))
;; class Rul
(if (not (ignore-errors (find-class 'mp-Rul)))
  (defclass mp-Rul () ()))

(let (x) 
  (setq x (make-instance 'mp-Rul))
  (defun proto-mp-Rul () x))
(defun mp-Rul-sv-constant (&optional sv-str )
  (block mp6-function (let ((sv-len (sv-undef))) (setf sv-len (length sv-str))(if (sv-bool (sv-eq sv-str "\\")) (progn (setf sv-str "\\\\")) nil)(if (sv-bool (sv-eq sv-str "'")) (progn (setf sv-str "\\'")) nil)(if (sv-bool sv-len) (progn (concatenate 'string (sv-string "( ( '") (sv-string (concatenate 'string (sv-string sv-str) (sv-string (concatenate 'string (sv-string "' eq substr( $str, $MATCH.to, ") (sv-string (concatenate 'string (sv-string sv-len) (sv-string (concatenate 'string (sv-string ")) ") (sv-string (concatenate 'string (sv-string "  ?? (1 + ( $MATCH.to := ") (sv-string (concatenate 'string (sv-string sv-len) (sv-string (concatenate 'string (sv-string " + $MATCH.to ))") (sv-string (concatenate 'string (sv-string "  !! false ") (sv-string ")"))))))))))))))))))) (progn (return-from mp6-function "1"))))))
(in-package mp-Rul)
  (defun sv-constant (&optional sv-str )
    (mp-Main::mp-Rul-sv-constant sv-str ))
(in-package mp-Main)
(defmethod sv-perl ((self mp-Rul))
  (mp-Main::sv-lisp_dump_object "::Rul" (list )))




;; class Rul::Quantifier
(if (not (ignore-errors (find-class 'mp-Rul-Quantifier)))
  (defclass mp-Rul-Quantifier () ()))

(let (x) 
  (setq x (make-instance 'mp-Rul-Quantifier))
  (defun proto-mp-Rul-Quantifier () x))
;; has $.term
(let ((new-slots (list (list :name 'sv-term
  :readers '(sv-term)
  :writers '((setf sv-term))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-Quantifier)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-Quantifier :direct-slots new-slots))

;; has $.quant
(let ((new-slots (list (list :name 'sv-quant
  :readers '(sv-quant)
  :writers '((setf sv-quant))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-Quantifier)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-Quantifier :direct-slots new-slots))

;; has $.greedy
(let ((new-slots (list (list :name 'sv-greedy
  :readers '(sv-greedy)
  :writers '((setf sv-greedy))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-Quantifier)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-Quantifier :direct-slots new-slots))

;; has $.ws1
(let ((new-slots (list (list :name 'sv-ws1
  :readers '(sv-ws1)
  :writers '((setf sv-ws1))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-Quantifier)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-Quantifier :direct-slots new-slots))

;; has $.ws2
(let ((new-slots (list (list :name 'sv-ws2
  :readers '(sv-ws2)
  :writers '((setf sv-ws2))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-Quantifier)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-Quantifier :direct-slots new-slots))

;; has $.ws3
(let ((new-slots (list (list :name 'sv-ws3
  :readers '(sv-ws3)
  :writers '((setf sv-ws3))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-Quantifier)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-Quantifier :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Rul-Quantifier))
  (block mp6-function
    (progn (sv-emit (sv-term sv-self) ))))

(defmethod sv-perl ((self mp-Rul-Quantifier))
  (mp-Main::sv-lisp_dump_object "::Rul::Quantifier" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "term") (setf (sv-value m) (sv-term self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "quant") (setf (sv-value m) (sv-quant self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "greedy") (setf (sv-value m) (sv-greedy self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "ws1") (setf (sv-value m) (sv-ws1 self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "ws2") (setf (sv-value m) (sv-ws2 self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "ws3") (setf (sv-value m) (sv-ws3 self)) m) )))




;; class Rul::Or
(if (not (ignore-errors (find-class 'mp-Rul-Or)))
  (defclass mp-Rul-Or () ()))

(let (x) 
  (setq x (make-instance 'mp-Rul-Or))
  (defun proto-mp-Rul-Or () x))
;; has $.or_list
(let ((new-slots (list (list :name 'sv-or_list
  :readers '(sv-or_list)
  :writers '((setf sv-or_list))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-Or)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-Or :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Rul-Or))
  (block mp6-function
    (progn (concatenate 'string (sv-string "do { ") (sv-string (concatenate 'string (sv-string "my $pos1 := $MATCH.to; do{ ") (sv-string (concatenate 'string (sv-string (sv-join (map 'vector #'(lambda (c) (sv-emit  c)) (sv-or_list sv-self)) "} || do { $MATCH.to := $pos1; ")) (sv-string "} }")))))))))

(defmethod sv-perl ((self mp-Rul-Or))
  (mp-Main::sv-lisp_dump_object "::Rul::Or" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "or_list") (setf (sv-value m) (sv-or_list self)) m) )))




;; class Rul::Concat
(if (not (ignore-errors (find-class 'mp-Rul-Concat)))
  (defclass mp-Rul-Concat () ()))

(let (x) 
  (setq x (make-instance 'mp-Rul-Concat))
  (defun proto-mp-Rul-Concat () x))
;; has $.concat
(let ((new-slots (list (list :name 'sv-concat
  :readers '(sv-concat)
  :writers '((setf sv-concat))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-Concat)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-Concat :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Rul-Concat))
  (block mp6-function
    (progn (concatenate 'string (sv-string "(") (sv-string (concatenate 'string (sv-string (sv-join (map 'vector #'(lambda (c) (sv-emit  c)) (sv-concat sv-self)) " && ")) (sv-string ")")))))))

(defmethod sv-perl ((self mp-Rul-Concat))
  (mp-Main::sv-lisp_dump_object "::Rul::Concat" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "concat") (setf (sv-value m) (sv-concat self)) m) )))




;; class Rul::Subrule
(if (not (ignore-errors (find-class 'mp-Rul-Subrule)))
  (defclass mp-Rul-Subrule () ()))

(let (x) 
  (setq x (make-instance 'mp-Rul-Subrule))
  (defun proto-mp-Rul-Subrule () x))
;; has $.metasyntax
(let ((new-slots (list (list :name 'sv-metasyntax
  :readers '(sv-metasyntax)
  :writers '((setf sv-metasyntax))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-Subrule)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-Subrule :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Rul-Subrule))
  (block mp6-function
    (let ((sv-meth (sv-undef))) (setf sv-meth (if (sv-bool (sv-add 1 (sv-index (sv-metasyntax sv-self) "."))) (sv-metasyntax sv-self) (concatenate 'string (sv-string "$grammar.") (sv-string (sv-metasyntax sv-self)))))(concatenate 'string (sv-string "do { ") (sv-string (concatenate 'string (sv-string "my $m2 := ") (sv-string (concatenate 'string (sv-string sv-meth) (sv-string (concatenate 'string (sv-string "($str, $MATCH.to); ") (sv-string (concatenate 'string (sv-string "if $m2 { $MATCH.to := $m2.to; $MATCH{'") (sv-string (concatenate 'string (sv-string (sv-metasyntax sv-self)) (sv-string (concatenate 'string (sv-string "'} := $m2; 1 } else { false } ") (sv-string "}")))))))))))))))))

(defmethod sv-perl ((self mp-Rul-Subrule))
  (mp-Main::sv-lisp_dump_object "::Rul::Subrule" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "metasyntax") (setf (sv-value m) (sv-metasyntax self)) m) )))




;; class Rul::SubruleNoCapture
(if (not (ignore-errors (find-class 'mp-Rul-SubruleNoCapture)))
  (defclass mp-Rul-SubruleNoCapture () ()))

(let (x) 
  (setq x (make-instance 'mp-Rul-SubruleNoCapture))
  (defun proto-mp-Rul-SubruleNoCapture () x))
;; has $.metasyntax
(let ((new-slots (list (list :name 'sv-metasyntax
  :readers '(sv-metasyntax)
  :writers '((setf sv-metasyntax))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-SubruleNoCapture)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-SubruleNoCapture :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Rul-SubruleNoCapture))
  (block mp6-function
    (let ((sv-meth (sv-undef))) (setf sv-meth (if (sv-bool (sv-add 1 (sv-index (sv-metasyntax sv-self) "."))) (sv-metasyntax sv-self) (concatenate 'string (sv-string "$grammar.") (sv-string (sv-metasyntax sv-self)))))(concatenate 'string (sv-string "do { ") (sv-string (concatenate 'string (sv-string "my $m2 := ") (sv-string (concatenate 'string (sv-string sv-meth) (sv-string (concatenate 'string (sv-string "($str, $MATCH.to); ") (sv-string (concatenate 'string (sv-string "if $m2 { $MATCH.to := $m2.to; 1 } else { false } ") (sv-string "}")))))))))))))

(defmethod sv-perl ((self mp-Rul-SubruleNoCapture))
  (mp-Main::sv-lisp_dump_object "::Rul::SubruleNoCapture" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "metasyntax") (setf (sv-value m) (sv-metasyntax self)) m) )))




;; class Rul::Var
(if (not (ignore-errors (find-class 'mp-Rul-Var)))
  (defclass mp-Rul-Var () ()))

(let (x) 
  (setq x (make-instance 'mp-Rul-Var))
  (defun proto-mp-Rul-Var () x))
;; has $.sigil
(let ((new-slots (list (list :name 'sv-sigil
  :readers '(sv-sigil)
  :writers '((setf sv-sigil))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-Var)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-Var :direct-slots new-slots))

;; has $.twigil
(let ((new-slots (list (list :name 'sv-twigil
  :readers '(sv-twigil)
  :writers '((setf sv-twigil))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-Var)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-Var :direct-slots new-slots))

;; has $.name
(let ((new-slots (list (list :name 'sv-name
  :readers '(sv-name)
  :writers '((setf sv-name))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-Var)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-Var :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Rul-Var))
  (block mp6-function
    (let ((sv-table (sv-undef))) (setf sv-table (let ((h (make-hash-table :test 'equal))) (setf (mp-Main::sv-hash-lookup "$" h) "$")(setf (mp-Main::sv-hash-lookup "@" h) "$List_")(setf (mp-Main::sv-hash-lookup "%" h) "$Hash_")(setf (mp-Main::sv-hash-lookup "&" h) "$Code_") h))(concatenate 'string (sv-string (mp-Main::sv-hash-lookup (sv-sigil sv-self) sv-table)) (sv-string (sv-name sv-self))))))

(defmethod sv-perl ((self mp-Rul-Var))
  (mp-Main::sv-lisp_dump_object "::Rul::Var" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "sigil") (setf (sv-value m) (sv-sigil self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "twigil") (setf (sv-value m) (sv-twigil self)) m) (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "name") (setf (sv-value m) (sv-name self)) m) )))




;; class Rul::Constant
(if (not (ignore-errors (find-class 'mp-Rul-Constant)))
  (defclass mp-Rul-Constant () ()))

(let (x) 
  (setq x (make-instance 'mp-Rul-Constant))
  (defun proto-mp-Rul-Constant () x))
;; has $.constant
(let ((new-slots (list (list :name 'sv-constant
  :readers '(sv-constant)
  :writers '((setf sv-constant))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-Constant)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-Constant :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Rul-Constant))
  (block mp6-function
    (let ((sv-str (sv-undef))) (setf sv-str (sv-constant sv-self))(mp-Rul::sv-constant sv-str))))

(defmethod sv-perl ((self mp-Rul-Constant))
  (mp-Main::sv-lisp_dump_object "::Rul::Constant" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "constant") (setf (sv-value m) (sv-constant self)) m) )))




;; class Rul::Dot
(if (not (ignore-errors (find-class 'mp-Rul-Dot)))
  (defclass mp-Rul-Dot () ()))

(let (x) 
  (setq x (make-instance 'mp-Rul-Dot))
  (defun proto-mp-Rul-Dot () x))
;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Rul-Dot))
  (block mp6-function
    (progn (concatenate 'string (sv-string "( ('' ne substr( $str, $MATCH.to, 1 )) ") (sv-string (concatenate 'string (sv-string "  ?? (1 + ($MATCH.to := 1 + $MATCH.to ))") (sv-string (concatenate 'string (sv-string "  !! false ") (sv-string ")")))))))))

(defmethod sv-perl ((self mp-Rul-Dot))
  (mp-Main::sv-lisp_dump_object "::Rul::Dot" (list )))




;; class Rul::SpecialChar
(if (not (ignore-errors (find-class 'mp-Rul-SpecialChar)))
  (defclass mp-Rul-SpecialChar () ()))

(let (x) 
  (setq x (make-instance 'mp-Rul-SpecialChar))
  (defun proto-mp-Rul-SpecialChar () x))
;; has $.char
(let ((new-slots (list (list :name 'sv-char
  :readers '(sv-char)
  :writers '((setf sv-char))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-SpecialChar)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-SpecialChar :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Rul-SpecialChar))
  (block mp6-function
    (let ((sv-char (sv-undef))) (setf sv-char (sv-char sv-self))(if (sv-bool (sv-eq sv-char "n")) (let ((sv-rul (sv-undef))) (setf sv-rul (let ((m (make-instance 'mp-Rul-SubruleNoCapture))) (setf (sv-metasyntax m) "is_newline") m))(setf sv-rul (sv-emit sv-rul ))(return-from mp6-function sv-rul)) nil)(if (sv-bool (sv-eq sv-char "N")) (let ((sv-rul (sv-undef))) (setf sv-rul (let ((m (make-instance 'mp-Rul-SubruleNoCapture))) (setf (sv-metasyntax m) "not_newline") m))(setf sv-rul (sv-emit sv-rul ))(return-from mp6-function sv-rul)) nil)(if (sv-bool (sv-eq sv-char "d")) (let ((sv-rul (sv-undef))) (setf sv-rul (let ((m (make-instance 'mp-Rul-SubruleNoCapture))) (setf (sv-metasyntax m) "digit") m))(setf sv-rul (sv-emit sv-rul ))(return-from mp6-function sv-rul)) nil)(if (sv-bool (sv-eq sv-char "s")) (let ((sv-rul (sv-undef))) (setf sv-rul (let ((m (make-instance 'mp-Rul-SubruleNoCapture))) (setf (sv-metasyntax m) "space") m))(setf sv-rul (sv-emit sv-rul ))(return-from mp6-function sv-rul)) nil)(return-from mp6-function (mp-Rul::sv-constant sv-char)))))

(defmethod sv-perl ((self mp-Rul-SpecialChar))
  (mp-Main::sv-lisp_dump_object "::Rul::SpecialChar" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "char") (setf (sv-value m) (sv-char self)) m) )))




;; class Rul::Block
(if (not (ignore-errors (find-class 'mp-Rul-Block)))
  (defclass mp-Rul-Block () ()))

(let (x) 
  (setq x (make-instance 'mp-Rul-Block))
  (defun proto-mp-Rul-Block () x))
;; has $.closure
(let ((new-slots (list (list :name 'sv-closure
  :readers '(sv-closure)
  :writers '((setf sv-closure))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-Block)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-Block :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Rul-Block))
  (block mp6-function
    (progn (concatenate 'string (sv-string "(do { ") (sv-string (concatenate 'string (sv-string (sv-closure sv-self)) (sv-string " } || 1)")))))))

(defmethod sv-perl ((self mp-Rul-Block))
  (mp-Main::sv-lisp_dump_object "::Rul::Block" (list (let ((m (make-instance 'mp-Pair))) (setf (sv-key m) "closure") (setf (sv-value m) (sv-closure self)) m) )))




;; class Rul::InterpolateVar
(if (not (ignore-errors (find-class 'mp-Rul-InterpolateVar)))
  (defclass mp-Rul-InterpolateVar () ()))

(let (x) 
  (setq x (make-instance 'mp-Rul-InterpolateVar))
  (defun proto-mp-Rul-InterpolateVar () x))
;; has $.var
(let ((new-slots (list (list :name 'sv-var
  :readers '(sv-var)
  :writers '((setf sv-var))
  :initform '(sv-undef)
  :initfunction (constantly (sv-undef))))))
(dolist (slot-defn (sb-mop:class-direct-slots (find-class 'mp-Rul-InterpolateVar)))
(push (list :name (sb-mop:slot-definition-name slot-defn)
  :readers (sb-mop:slot-definition-readers slot-defn)
  :writers (sb-mop:slot-definition-writers slot-defn)
  :initform (sb-mop:slot-definition-initform slot-defn)
  :initfunction (sb-mop:slot-definition-initfunction slot-defn))
new-slots))
(sb-mop:ensure-class 'mp-Rul-InterpolateVar :direct-slots new-slots))

;; method emit
(if (not (ignore-errors (find-method 'sv-emit () ())))
  (defgeneric sv-emit (sv-self)
      (:documentation "a method")))
(defmethod sv-emit ((sv-self mp-Rul-InterpolateVar))
  (block mp6-function
    (progn (mp-Main::sv-say (list (concatenate 'string (sv-string "# TODO: interpolate var ") (sv-string (concatenate 'string (sv-string (sv-emit (sv-var sv-self) )) (sv-string ""))))))(progn (write-line (format nil "狺扉篝┅弪蝻颦秕麴豸筲屮艉聃轸┅┅ㄤ彐礤翳镤篥疱蜢è箦戽眇阴飙深翦蝠镬狒逯狎┅眇歪轭汉篥扉箴咪蹴疬镡赍泗⒑阂蹯汉深翦蝠镬狒逯狎扉篝戾è磲脲轭篝犷沐ы瓠嗅轵┅箦翩篥脲愆Ⅵ狎箦翩篥鲠祯愆篥鲠箦戽┅愆┅换沆狍阴旌何犴邃冕痿躜ㄩ铒ㄩ珙矧瀛弪蝻蝮ㄦ轭洵沆狍ы瓠阴飙吾礤涿狃趱蝈┅ㄤ彐沆狍眇阴飙吾礤涿狃趱蝈īī┅戾箦赳磲脲轭篝犷沐ы瓠阴飙吾礤涿狃趱蝈┅ㄤ彐躅痱雉锃眇阴飙吾礤涿狃趱蝈ī┅换栳ぎ蝓戾咤戾è铄鳝箪雉扉篝扉篝侯犴篥蝓戾咤候遽溴蝮Ж篥蝓戾咤皓瑚蜷翦蝮Ж箦翩篥蝓戾咤皓洪铋翩矧Ж篥躅溴姗洪铋翩躅泗轱ㄣ镱篝犷綮篥躅溴姗┅┅ㄤ镬轶箪雉溴骖筲盹鸷沆狍蟓溟蝈泗箪雉ㄦ轭洵沆狍ы瓠阴飙吾礤涿狃趱蝈┅瘐箬扉篝侯犴筲盹鸷箪雉溴骈铋糸镱钺礤箪雉溴骖候遽溴蝮筲盹鸷箪雉溴骈铋糸镱蝈徜弪箪雉溴骖瑚蜷翦蝮筲盹鸷箪雉溴骈铋糸镱黩轸弪箪雉溴骖洪铋翩矧筲盹鸷箪雉溴骈铋糸镱轭轸骘蝽箪雉溴骖洪铋翩躅泗轱筲盹鸷箪雉溴骈铋糸镱轭轸骢钽糸镱箪雉溴骖┅铄鳝箪雉螬筲盹鸷孱篚蝈沆狍ы瓠阴飙吾礤涿狃趱蝈轰轵邈舡箪雉铄鳝箪雉螬换栳ぎ汜痿躜暹殇孱戾è铄鳝箪雉扉篝扉篝侯犴篥汜痿躜暹殇孱候遽溴蝮Ж篥汜痿躜暹殇孱舂瑚蜷翦蝮Ж箦翩篥汜痿躜暹殇孱舂洪铋翩矧Ж篥躅溴姗洪铋翩躅泗轱ㄣ镱篝犷綮篥躅溴姗┅┅ㄤ镬轶箪雉溴骖筲盹鸷沆狍蟓溟蝈泗箪雉ㄦ轭洵沆狍ы瓠阴飙吾礤涿狃趱蝈┅瘐箬扉篝侯犴筲盹鸷箪雉溴骈铋糸镱钺礤箪雉溴骖候遽溴蝮筲盹鸷箪雉溴骈铋糸镱蝈徜弪箪雉溴骖瑚蜷翦蝮筲盹鸷箪雉溴骈铋糸镱黩轸弪箪雉溴骖洪铋翩矧筲盹鸷箪雉溴骈铋糸镱轭轸骘蝽箪雉溴骖洪铋翩躅泗轱筲盹鸷箪雉溴骈铋糸镱轭轸骢钽糸镱箪雉溴骖┅铄鳝箪雉螬筲盹鸷孱篚蝈沆狍ы瓠阴飙吾礤涿狃趱蝈轰轵邈舡箪雉铄鳝箪雉螬换礤翳镤屙轸ㄩ铒ㄩ珙矧瀛弪蝻蝮ㄦ轭洵礤翳镤篥屙轸īī┅ㄤ彐珏铄蜷篥屙轸篥箦戽ê滹沲礤铘狒轱⑨礤翳镤┅ㄤ彐礤翳镤篥屙轸è篥箦戽眇阴飙吾礤涿狃趱蝈┅ㄢ祜汶眇董骢钽糸镱痱镧眇歪轭汉篥筢扉篝ㄣ镱汜翦钺翦篝蜷铉篥篝蜷铉韵南钺礤汜痿躜篥篝蜷铉ㄣ镱汜翦钺翦篝蜷铉篥篝蜷铉篥汜痿躜暹殇孱篥箦戽┅篥篝蜷铉ㄣ镱汜翦钺翦篝蜷铉篥篝蜷铉航篥篝蜷铉ㄣ镱汜翦钺翦篝蜷铉篥篝蜷铉篥屙轸篥蝓戾咤篥箦戽┅篥篝蜷铉┅┅┅┅┅痱镧黩轸瀛扉铄ㄦ矧磲铋狺扉篝┅弪蝻颦秕麴豸筲屮艉聃轸┅┅ㄤ彐礤翳镤篥疱蜢è箦戽眇阴飙吾礤涿狃趱蝈┅眇歪轭汉篥扉箴咪蹴疬镡赍泗⒑阂蹯汉吾礤涿狃趱蝈扉篝戾è磲脲轭篝犷沐ы瓠嗅轵┅箦翩篥脲愆Ⅱ蹯暹屮稷箦翩篥鲠祯愆篥蝓戾咤箦戽┅愆戾è磲脲轭篝犷沐ы瓠嗅轵┅箦翩篥脲愆汜痿躜暹殇孱簪箦翩篥鲠祯愆篥汜痿躜暹殇孱箦戽┅愆┅换沆狍阴旌郝彐矧ㄩ铒ㄩ珙矧瀛弪蝻蝮ㄦ轭洵沆狍ы瓠阴飙洛骘蝈┅ㄤ彐沆狍眇阴飙洛骘蝈īī┅戾箦赳磲脲轭篝犷沐ы瓠阴飙洛骘蝈┅ㄤ彐躅痱雉锃眇阴飙洛骘蝈ī┅换栳ぎ蝓戾咤戾è铄鳝箪雉扉篝扉篝侯犴篥蝓戾咤候遽溴蝮Ж篥蝓戾咤皓瑚蜷翦蝮Ж箦翩篥蝓戾咤皓洪铋翩矧Ж篥躅溴姗洪铋翩躅泗轱ㄣ镱篝犷綮篥躅溴姗┅┅ㄤ镬轶箪雉溴骖筲盹鸷沆狍蟓溟蝈泗箪雉ㄦ轭洵沆狍ы瓠阴飙洛骘蝈┅瘐箬扉篝侯犴筲盹鸷箪雉溴骈铋糸镱钺礤箪雉溴骖候遽溴蝮筲盹鸷箪雉溴骈铋糸镱蝈徜弪箪雉溴骖瑚蜷翦蝮筲盹鸷箪雉溴骈铋糸镱黩轸弪箪雉溴骖洪铋翩矧筲盹鸷箪雉溴骈铋糸镱轭轸骘蝽箪雉溴骖洪铋翩躅泗轱筲盹鸷箪雉溴骈铋糸镱轭轸骢钽糸镱箪雉溴骖┅铄鳝箪雉螬筲盹鸷孱篚蝈沆狍ы瓠阴飙洛骘蝈轰轵邈舡箪雉铄鳝箪雉螬换礤翳镤屙轸ㄩ铒ㄩ珙矧瀛弪蝻蝮ㄦ轭洵礤翳镤篥屙轸īī┅ㄤ彐珏铄蜷篥屙轸篥箦戽ê滹沲礤铘狒轱⑨礤翳镤┅ㄤ彐礤翳镤篥屙轸è篥箦戽眇阴飙洛骘蝈┅ㄢ祜汶眇董骢钽糸镱痱镧ㄣ镱汜翦钺翦篝蜷铉篥篝蜷铉滹篥篝蜷铉ㄣ镱汜翦钺翦篝蜷铉篥篝蜷铉㈨繇航ね猎萌篥篝蜷铉ㄣ镱汜翦钺翦篝蜷铉篥篝蜷铉ね猎萌航烷铋绣蜢逗和狒汨铄鳕篝颛骄ん趄ф蝻恣骄繇甬麸麸骄繇甬麸р镲歆骄┗篥篝蜷铉ㄣ镱汜翦钺翦篝蜷铉篥篝蜷铉ね猎萌怙镬航篥篝蜷铉ㄣ镱汜翦钺翦篝蜷铉篥篝蜷铉篥屙轸篥蝓戾咤篥箦戽┅篥篝蜷铉ㄣ镱汜翦钺翦篝蜷铉篥篝蜷铉⒒篥篝蜷铉ㄣ镱汜翦钺翦篝蜷铉篥篝蜷铉繇甬怙镬航郡土悦然篥篝蜷铉ㄣ镱汜翦钺翦篝蜷铉篥篝蜷铉ね猎萌航繇鸹篥篝蜷铉ㄣ镱汜翦钺翦篝蜷铉篥篝蜷铉⒖ね猎萌篥篝蜷铉┅┅┅┅┅┅┅┅┅┅ㄤ彐礤翳镤篥疱蜢è箦戽眇阴飙洛骘蝈┅眇歪轭汉篥扉箴咪蹴疬镡赍泗⒑阂蹯汉洛骘蝈扉篝戾è磲脲轭篝犷沐ы瓠嗅轵┅箦翩篥脲愆Ⅱ蹯暹屮稷箦翩篥鲠祯愆篥蝓戾咤箦戽┅愆┅换沆狍阴旌何雉洛骘蝈ㄩ铒ㄩ珙矧瀛弪蝻蝮ㄦ轭洵沆狍ы瓠阴飙物袈彐矧濠┅ㄤ彐沆狍眇阴飙物袈彐矧īī┅戾箦赳磲脲轭篝犷沐ы瓠阴飙物袈彐矧濠ㄤ彐躅痱雉锃眇阴飙物袈彐矧ī┅换栳ぎ蝓戾咤戾è铄鳝箪雉扉篝扉篝侯犴篥蝓戾咤候遽溴蝮Ж篥蝓戾咤皓瑚蜷翦蝮Ж箦翩篥蝓戾咤皓洪铋翩矧Ж篥躅溴姗洪铋翩躅泗轱ㄣ镱篝犷綮篥躅溴姗┅┅ㄤ镬轶箪雉溴骖筲盹鸷沆狍蟓溟蝈泗箪雉ㄦ轭洵沆狍ы瓠阴飙物袈彐矧濠┅瘐箬扉篝侯犴筲盹鸷箪雉溴骈铋糸镱钺礤箪雉溴骖候遽溴蝮筲盹鸷箪雉溴骈铋糸镱蝈徜弪箪雉溴骖瑚蜷翦蝮筲盹鸷箪雉溴骈铋糸镱黩轸弪箪雉溴骖洪铋翩矧筲盹鸷箪雉溴骈铋糸镱轭轸骘蝽箪雉溴骖洪铋翩躅泗轱筲盹鸷箪雉溴骈铋糸镱轭轸骢钽糸镱箪雉溴骖┅铄鳝箪雉螬筲盹鸷孱篚蝈沆狍ы瓠阴飙物袈彐矧轰轵邈舡箪雉铄鳝箪雉螬换礤翳镤屙轸ㄩ铒ㄩ珙矧瀛弪蝻蝮ㄦ轭洵礤翳镤篥屙轸īī┅ㄤ彐珏铄蜷篥屙轸篥箦戽ê滹沲礤铘狒轱⑨礤翳镤┅ㄤ彐礤翳镤篥屙轸è篥箦戽眇阴飙物袈彐矧濠ㄢ祜汶眇董骢钽糸镱痱镧ㄣ镱汜翦钺翦篝蜷铉篥篝蜷铉滹篥篝蜷铉ㄣ镱汜翦钺翦篝蜷铉篥篝蜷铉㈨繇航ね猎萌篥篝蜷铉ㄣ镱汜翦钺翦篝蜷铉篥篝蜷铉ね猎萌航烷铋绣蜢逗和狒汨铄鳕篝颛骄ん趄ф蝻恣骄繇甬麸麸骄繇甬麸р镲歆骄┗篥篝蜷铉ㄣ镱汜翦钺翦篝蜷铉篥篝蜷铉ね猎萌怙镬航篥篝蜷铉ㄣ镱汜翦钺翦篝蜷铉篥篝蜷铉篥屙轸篥蝓戾咤篥箦戽┅篥篝蜷铉ㄣ镱汜翦钺翦篝蜷铉篥篝蜷铉⒒篥篝蜷铉ㄣ镱汜翦钺翦篝蜷铉篥篝蜷铉繇甬怙镬航・土悦然篥篝蜷铉ㄣ镱汜翦钺翦篝蜷铉篥篝蜷铉ね猎萌航繇鸹篥篝蜷铉ㄣ镱汜翦钺翦篝蜷铉篥篝蜷铉⒖ね猎萌篥篝蜷铉┅┅┅┅┅┅┅┅┅┅ㄤ彐礤翳镤篥疱蜢è箦戽眇阴飙物袈彐矧濠眇歪轭汉篥扉箴咪蹴疬镡赍泗⒑阂蹯汉物袈彐矧澧扉篝戾è磲脲轭篝犷沐ы瓠嗅轵┅箦翩篥脲愆Ⅱ蹯暹屮稷箦翩篥鲠祯愆篥蝓戾咤箦戽┅愆┅换沆狍阴旌何彗狒迕栳蛎灬篌ㄩ铒ㄩ珙矧瀛弪蝻蝮ㄦ轭洵沆狍ы瓠阴飙五玑翦描狎渺狍螬┅ㄤ彐沆狍眇阴飙五玑翦描狎渺狍īī┅戾箦赳磲脲轭篝犷沐ы瓠阴飙五玑翦描狎渺狍螬ㄤ彐躅痱雉锃眇阴飙五玑翦描狎渺狍ī┅换栳ぎ汨狎戾è铄鳝箪雉扉篝扉篝侯犴篥汨狎候遽溴蝮Ж篥汨狎螬瑚蜷翦蝮Ж箦翩篥汨狎螬洪铋翩矧Ж篥躅溴姗洪铋翩躅泗轱ㄣ镱篝犷綮篥躅溴姗┅┅ㄤ镬轶箪雉溴骖筲盹鸷沆狍蟓溟蝈泗箪雉ㄦ轭洵沆狍ы瓠阴飙五玑翦描狎渺狍螬┅瘐箬扉篝侯犴筲盹鸷箪雉溴骈铋糸镱钺礤箪雉溴骖候遽溴蝮筲盹鸷箪雉溴骈铋糸镱蝈徜弪箪雉溴骖瑚蜷翦蝮筲盹鸷箪雉溴骈铋糸镱黩轸弪箪雉溴骖洪铋翩矧筲盹鸷箪雉溴骈铋糸镱轭轸骘蝽箪雉溴骖洪铋翩躅泗轱筲盹鸷箪雉溴骈铋糸镱轭轸骢钽糸镱箪雉溴骖┅铄鳝箪雉螬筲盹鸷孱篚蝈沆狍ы瓠阴飙五玑翦描狎渺狍轰轵邈舡箪雉铄鳝箪雉螬换礤翳镤屙轸ㄩ铒ㄩ珙矧瀛弪蝻蝮ㄦ轭洵礤翳镤篥屙轸īī┅ㄤ彐珏铄蜷篥屙轸篥箦戽ê滹沲礤铘狒轱⑨礤翳镤┅ㄤ彐礤翳镤篥屙轸è篥箦戽眇阴飙五玑翦描狎渺狍螬ㄢ祜汶眇董骢钽糸镱痱镧眇歪轭汉篥筢扉篝⒃夏五玑翦描狎渺狍螈┅痱镧黩轸瀛扉铄ㄦ矧磲铋狺扉篝┅弪蝻颦秕麴豸筲屮艉聃轸┅┅ㄤ彐礤翳镤篥疱蜢è箦戽眇阴飙五玑翦描狎渺狍螬眇歪轭汉篥扉箴咪蹴疬镡赍泗⒑阂蹯汉五玑翦描狎渺狍螈扉篝戾è磲脲轭篝犷沐ы瓠嗅轵┅箦翩篥脲愆汨狎螈箦翩篥鲠祯愆篥汨狎箦戽┅愆┅换沆狍阴旌好栳蛎灬篌ㄩ铒ㄩ珙矧瀛弪蝻蝮ㄦ轭洵沆狍ы瓠阴飙描狎渺狍螬┅ㄤ彐沆狍眇阴飙描狎渺狍īī┅戾箦赳磲脲轭篝犷沐ы瓠阴飙描狎渺狍螬ㄤ彐躅痱雉锃眇阴飙描狎渺狍ī┅换栳ぎ汨狎戾è铄鳝箪雉扉篝扉篝侯犴篥汨狎候遽溴蝮Ж篥汨狎螬瑚蜷翦蝮Ж箦翩篥汨狎螬洪铋翩矧Ж篥躅溴姗洪铋翩躅泗轱ㄣ镱篝犷綮篥躅溴姗┅┅ㄤ镬轶箪雉溴骖筲盹鸷沆狍蟓溟蝈泗箪雉ㄦ轭洵沆狍ы瓠阴飙描狎渺狍螬┅瘐箬扉篝侯犴筲盹鸷箪雉溴骈铋糸镱钺礤箪雉溴骖候遽溴蝮筲盹鸷箪雉溴骈铋糸镱蝈徜弪箪雉溴骖瑚蜷翦蝮筲盹鸷箪雉溴骈铋糸镱黩轸弪箪雉溴骖洪铋翩矧筲盹鸷箪雉溴骈铋糸镱轭轸骘蝽箪雉溴骖洪铋翩躅泗轱筲盹鸷箪雉溴骈铋糸镱轭轸骢钽糸镱箪雉溴骖┅铄鳝箪雉螬筲盹鸷孱篚蝈沆狍ы瓠阴飙描狎渺狍轰轵邈舡箪雉铄鳝箪雉螬换礤翳镤屙轸ㄩ铒ㄩ珙矧瀛弪蝻蝮ㄦ轭洵礤翳镤篥屙轸īī┅ㄤ彐珏铄蜷篥屙轸篥箦戽ê滹沲礤铘狒轱⑨礤翳镤┅ㄤ彐礤翳镤篥屙轸è篥箦戽眇阴飙描狎渺狍螬ㄢ祜汶眇董骢钽糸镱痱镧眇歪轭汉篥筢扉篝⒃夏描狎渺狍螈┅痱镧黩轸瀛扉铄ㄦ矧磲铋狺扉篝┅弪蝻颦秕麴豸筲屮艉聃轸┅┅ㄤ彐礤翳镤篥疱蜢è箦戽眇阴飙描狎渺狍螬眇歪轭汉篥扉箴咪蹴疬镡赍泗⒑阂蹯汉描狎渺狍螈扉篝戾è磲脲轭篝犷沐ы瓠嗅轵┅箦翩篥脲愆汨狎螈箦翩篥鲠祯愆篥汨狎箦戽┅愆┅换沆狍阴旌好狃趱蝈ㄩ铒ㄩ珙矧瀛弪蝻蝮ㄦ轭洵沆狍ы瓠阴飙冕痿躜濠┅ㄤ彐沆狍眇阴飙冕痿躜īī┅戾箦赳磲脲轭篝犷沐ы瓠阴飙冕痿躜濠ㄤ彐躅痱雉锃眇阴飙冕痿躜ī┅换栳ぎ蝓戾咤戾è铄鳝箪雉扉篝扉篝侯犴篥蝓戾咤候遽溴蝮Ж篥蝓戾咤皓瑚蜷翦蝮Ж箦翩篥蝓戾咤皓洪铋翩矧Ж篥躅溴姗洪铋翩躅泗轱ㄣ镱篝犷綮篥躅溴姗┅┅ㄤ镬轶箪雉溴骖筲盹鸷沆狍蟓溟蝈泗箪雉ㄦ轭洵沆狍ы瓠阴飙冕痿躜濠┅瘐箬扉篝侯犴筲盹鸷箪雉溴骈铋糸镱钺礤箪雉溴骖候遽溴蝮筲盹鸷箪雉溴骈铋糸镱蝈徜弪箪雉溴骖瑚蜷翦蝮筲盹鸷箪雉溴骈铋糸镱黩轸弪箪雉溴骖洪铋翩矧筲盹鸷箪雉溴骈铋糸镱轭轸骘蝽箪雉溴骖洪铋翩躅泗轱筲盹鸷箪雉溴骈铋糸镱轭轸骢钽糸镱箪雉溴骖┅铄鳝箪雉螬筲盹鸷孱篚蝈沆狍ы瓠阴飙冕痿躜轰轵邈舡箪雉铄鳝箪雉螬换礤翳镤屙轸ㄩ铒ㄩ珙矧瀛弪蝻蝮ㄦ轭洵礤翳镤篥屙轸īī┅ㄤ彐珏铄蜷篥屙轸篥箦戽ê滹沲礤铘狒轱⑨礤翳镤┅ㄤ彐礤翳镤篥屙轸è篥箦戽眇阴飙冕痿躜濠ㄢ祜汶眇董骢钽糸镱痱镧眇歪轭汉篥筢扉篝⒃夏阴烀狃趱蝈┅痱镧黩轸瀛扉铄ㄦ矧磲铋狺扉篝┅弪蝻颦秕麴豸筲屮艉聃轸┅┅ㄤ彐礤翳镤篥疱蜢è箦戽眇阴飙冕痿躜濠眇歪轭汉篥扉箴咪蹴疬镡赍泗⒑阂蹯汉冕痿躜澧扉篝戾è磲脲轭篝犷沐ы瓠嗅轵┅箦翩篥脲愆Ⅱ蹯暹屮稷箦翩篥鲠祯愆篥蝓戾咤箦戽┅愆┅换沆狍阴旌好狃趱蝈义篚祠ㄩ铒ㄩ珙矧瀛弪蝻蝮ㄦ轭洵沆狍ы瓠阴飙冕痿躜逡弩蹯舂┅ㄤ彐沆狍眇阴飙冕痿躜逡弩蹯īī┅戾箦赳磲脲轭篝犷沐ы瓠阴飙冕痿躜逡弩蹯舂ㄤ彐躅痱雉锃眇阴飙冕痿躜逡弩蹯ī┅换栳ぎ蝓戾咤戾è铄鳝箪雉扉篝扉篝侯犴篥蝓戾咤候遽溴蝮Ж篥蝓戾咤皓瑚蜷翦蝮Ж箦翩篥蝓戾咤皓洪铋翩矧Ж篥躅溴姗洪铋翩躅泗轱ㄣ镱篝犷綮篥躅溴姗┅┅ㄤ镬轶箪雉溴骖筲盹鸷沆狍蟓溟蝈泗箪雉ㄦ轭洵沆狍ы瓠阴飙冕痿躜逡弩蹯舂┅瘐箬扉篝侯犴筲盹鸷箪雉溴骈铋糸镱钺礤箪雉溴骖候遽溴蝮筲盹鸷箪雉溴骈铋糸镱蝈徜弪箪雉溴骖瑚蜷翦蝮筲盹鸷箪雉溴骈铋糸镱黩轸弪箪雉溴骖洪铋翩矧筲盹鸷箪雉溴骈铋糸镱轭轸骘蝽箪雉溴骖洪铋翩躅泗轱筲盹鸷箪雉溴骈铋糸镱轭轸骢钽糸镱箪雉溴骖┅铄鳝箪雉螬筲盹鸷孱篚蝈沆狍ы瓠阴飙冕痿躜逡弩蹯轰轵邈舡箪雉铄鳝箪雉螬换礤翳镤屙轸ㄩ铒ㄩ珙矧瀛弪蝻蝮ㄦ轭洵礤翳镤篥屙轸īī┅ㄤ彐珏铄蜷篥屙轸篥箦戽ê滹沲礤铘狒轱⑨礤翳镤┅ㄤ彐礤翳镤篥屙轸è篥箦戽眇阴飙冕痿躜逡弩蹯舂ㄢ祜汶眇董骢钽糸镱痱镧眇歪轭汉篥筢扉篝⒃夏阴旌好狃趱蝈义篚祠┅痱镧黩轸瀛扉铄ㄦ矧磲铋狺扉篝┅弪蝻颦秕麴豸筲屮艉聃轸┅┅ㄤ彐礤翳镤篥疱蜢è箦戽眇阴飙冕痿躜逡弩蹯舂眇歪轭汉篥扉箴咪蹴疬镡赍泗⒑阂蹯汉冕痿躜逡弩蹯簪扉篝戾è磲脲轭篝犷沐ы瓠嗅轵┅箦翩篥脲愆Ⅱ蹯暹屮稷箦翩篥鲠祯愆篥蝓戾咤箦戽┅愆┅换沆狍阴旌毫骠弪ㄩ铒ㄩ珙矧瀛弪蝻蝮ㄦ轭洵沆狍ы瓠阴飙伶翦颟┅ㄤ彐沆狍眇阴飙伶翦īī┅戾箦赳磲脲轭篝犷沐ы瓠阴飙伶翦颟ㄤ彐躅痱雉锃眇阴飙伶翦ī┅换栳ぎ蝓戾咤戾è铄鳝箪雉扉篝扉篝侯犴篥蝓戾咤候遽溴蝮Ж篥蝓戾咤皓瑚蜷翦蝮Ж箦翩篥蝓戾咤皓洪铋翩矧Ж篥躅溴姗洪铋翩躅泗轱ㄣ镱篝犷綮篥躅溴姗┅┅ㄤ镬轶箪雉溴骖筲盹鸷沆狍蟓溟蝈泗箪雉ㄦ轭洵沆狍ы瓠阴飙伶翦颟┅瘐箬扉篝侯犴筲盹鸷箪雉溴骈铋糸镱钺礤箪雉溴骖候遽溴蝮筲盹鸷箪雉溴骈铋糸镱蝈徜弪箪雉溴骖瑚蜷翦蝮筲盹鸷箪雉溴骈铋糸镱黩轸弪箪雉溴骖洪铋翩矧筲盹鸷箪雉溴骈铋糸镱轭轸骘蝽箪雉溴骖洪铋翩躅泗轱筲盹鸷箪雉溴骈铋糸镱轭轸骢钽糸镱箪雉溴骖┅铄鳝箪雉螬筲盹鸷孱篚蝈沆狍ы瓠阴飙伶翦轰轵邈舡箪雉铄鳝箪雉螬换礤翳镤屙轸ㄩ铒ㄩ珙矧瀛弪蝻蝮ㄦ轭洵礤翳镤篥屙轸īī┅ㄤ彐珏铄蜷篥屙轸篥箦戽ê滹沲礤铘狒轱⑨礤翳镤┅ㄤ彐礤翳镤篥屙轸è篥箦戽眇阴飙伶翦颟ㄢ祜汶眇董骢钽糸镱痱镧眇歪轭汉篥筢扉篝⒃夏阴旌毫骠弪┅痱镧黩轸瀛扉铄ㄦ矧磲铋狺扉篝┅弪蝻颦秕麴豸筲屮艉聃轸┅┅ㄤ彐礤翳镤篥疱蜢è箦戽眇阴飙伶翦颟眇歪轭汉篥扉箴咪蹴疬镡赍泗⒑阂蹯汉伶翦颌扉篝戾è磲脲轭篝犷沐ы瓠嗅轵┅箦翩篥脲愆Ⅱ蹯暹屮稷箦翩篥鲠祯愆篥蝓戾咤箦戽┅愆┅